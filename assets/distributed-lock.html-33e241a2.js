const e=JSON.parse('{"key":"v-dff0fe32","path":"/distributed-system/distributed-lock.html","title":"分布式锁详解","lang":"zh-CN","frontmatter":{"title":"分布式锁详解","category":"分布式","icon":"lock","description":"网上有很多分布式锁相关的文章，写了一个相对简洁易懂的版本，针对面试和工作应该够用了。 分布式锁介绍 对于单机多线程来说，在 Java 中，我们通常使用 ReetrantLock 类、synchronized 关键字这类 JDK 自带的 本地锁 来控制一个 JVM 进程内的多个线程对本地共享资源的访问。 下面是我对本地锁画的一张示意图。 从图中可以看出，这些线程访问共享资源是互斥的，同一时刻只有一个线程可以获取到本地锁访问共享资源。","head":[["meta",{"property":"og:url","content":"https://javaguide.cn/distributed-system/distributed-lock.html"}],["meta",{"property":"og:site_name","content":"知识库"}],["meta",{"property":"og:title","content":"分布式锁详解"}],["meta",{"property":"og:description","content":"网上有很多分布式锁相关的文章，写了一个相对简洁易懂的版本，针对面试和工作应该够用了。 分布式锁介绍 对于单机多线程来说，在 Java 中，我们通常使用 ReetrantLock 类、synchronized 关键字这类 JDK 自带的 本地锁 来控制一个 JVM 进程内的多个线程对本地共享资源的访问。 下面是我对本地锁画的一张示意图。 从图中可以看出，这些线程访问共享资源是互斥的，同一时刻只有一个线程可以获取到本地锁访问共享资源。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://javaguide.cn/"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-03-04T12:00:03.000Z"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:alt","content":"分布式锁详解"}],["meta",{"property":"article:modified_time","content":"2023-03-04T12:00:03.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"分布式锁详解\\",\\"image\\":[\\"https://javaguide.cn/\\"],\\"dateModified\\":\\"2023-03-04T12:00:03.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"分布式锁介绍","slug":"分布式锁介绍","link":"#分布式锁介绍","children":[]},{"level":2,"title":"基于 Redis 实现分布式锁","slug":"基于-redis-实现分布式锁","link":"#基于-redis-实现分布式锁","children":[{"level":3,"title":"如何基于 Redis 实现一个最简易的分布式锁？","slug":"如何基于-redis-实现一个最简易的分布式锁","link":"#如何基于-redis-实现一个最简易的分布式锁","children":[]},{"level":3,"title":"为什么要给锁设置一个过期时间？","slug":"为什么要给锁设置一个过期时间","link":"#为什么要给锁设置一个过期时间","children":[]},{"level":3,"title":"如何实现锁的优雅续期？","slug":"如何实现锁的优雅续期","link":"#如何实现锁的优雅续期","children":[]},{"level":3,"title":"如何实现可重入锁？","slug":"如何实现可重入锁","link":"#如何实现可重入锁","children":[]},{"level":3,"title":"Redis 如何解决集群情况下分布式锁的可靠性？","slug":"redis-如何解决集群情况下分布式锁的可靠性","link":"#redis-如何解决集群情况下分布式锁的可靠性","children":[]}]},{"level":2,"title":"基于 ZooKeeper 实现分布式锁","slug":"基于-zookeeper-实现分布式锁","link":"#基于-zookeeper-实现分布式锁","children":[{"level":3,"title":"如何基于 ZooKeeper 实现分布式锁？","slug":"如何基于-zookeeper-实现分布式锁","link":"#如何基于-zookeeper-实现分布式锁","children":[]},{"level":3,"title":"为什么要用临时顺序节点？","slug":"为什么要用临时顺序节点","link":"#为什么要用临时顺序节点","children":[]},{"level":3,"title":"为什么要设置对前一个节点的监听？","slug":"为什么要设置对前一个节点的监听","link":"#为什么要设置对前一个节点的监听","children":[]},{"level":3,"title":"如何实现可重入锁？","slug":"如何实现可重入锁-1","link":"#如何实现可重入锁-1","children":[]}]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]}],"git":{"createdTime":1661252001000,"updatedTime":1677931203000,"contributors":[{"name":"guide","email":"koushuangbwcx@163.com","commits":10},{"name":"Guide","email":"koushuangbwcx@163.com","commits":3},{"name":"Freeze","email":"42697182+zbzbzzz@users.noreply.github.com","commits":1}]},"readingTime":{"minutes":17.11,"words":5134},"filePathRelative":"distributed-system/distributed-lock.md","localizedDate":"2022年8月23日","excerpt":"<p>网上有很多分布式锁相关的文章，写了一个相对简洁易懂的版本，针对面试和工作应该够用了。</p>\\n<h2> 分布式锁介绍</h2>\\n<p>对于单机多线程来说，在 Java 中，我们通常使用 <code>ReetrantLock</code> 类、<code>synchronized</code> 关键字这类 JDK 自带的 <strong>本地锁</strong> 来控制一个 JVM 进程内的多个线程对本地共享资源的访问。</p>\\n<p>下面是我对本地锁画的一张示意图。</p>\\n<p></p>\\n<p>从图中可以看出，这些线程访问共享资源是互斥的，同一时刻只有一个线程可以获取到本地锁访问共享资源。</p>","copyright":{},"autoDesc":true}');export{e as data};
