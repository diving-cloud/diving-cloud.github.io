{
  "version": "https://jsonfeed.org/version/1.1",
  "title": "JavaGuide(Java面试+学习指南)",
  "home_page_url": "https://javaguide.cn/",
  "feed_url": "https://javaguide.cn/feed.json",
  "description": "「Java学习指北+Java面试指南」一份涵盖大部分 Java 程序员所需要掌握的核心知识。准备 Java 面试，复习 Java 知识点，首选 JavaGuide！  ",
  "icon": "https://javaguide.cn/logo.png",
  "authors": [
    {
      "name": "Guide",
      "url": "https://javaguide.cn/article/"
    }
  ],
  "items": [
    {
      "title": "性能优化",
      "url": "https://javaguide.cn/high-performance/performance-optimize.html",
      "id": "https://javaguide.cn/high-performance/performance-optimize.html",
      "content_html": "",
      "date_published": "2023-03-07T02:02:07.000Z",
      "date_modified": "2023-03-07T04:52:01.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "高性能"
      ]
    },
    {
      "title": "程序员的技术成长战略",
      "url": "https://javaguide.cn/high-quality-technical-articles/advanced-programmer/the-growth-strategy-of-the-technological-giant.html",
      "id": "https://javaguide.cn/high-quality-technical-articles/advanced-programmer/the-growth-strategy-of-the-technological-giant.html",
      "summary": "推荐语 ： 波波老师的一篇文章，写的非常好，不光是对技术成长有帮助，其他领域也是同样适用的！建议反复阅读，形成一套自己的技术成长策略。 原文地址： https://mp.weixin.qq.com/s/YrN8T67s801-MRo01lCHXA 1. 前言 在波波的微信技术交流群里头，经常有学员问关于技术人该如何学习成长的问题，虽然是微信交流，但我依然可以感受到小伙伴们焦虑的心情。 技术人为啥焦虑？ 恕我直言，说白了是胆识不足格局太小。胆就是胆量，焦虑的人一般对未来的不确定性怀有恐惧。识就是见识，焦虑的人一般看不清楚周围世界，也看不清自己和适合自己的道路。格局也称志向，容易焦虑的人通常视野窄志向小。如果从战略和管理的视角来看，就是对自己和周围世界的认知不足，没有一个清晰和长期的学习成长战略，也没有可执行的阶段性目标计划+严格的执行。",
      "content_html": "<blockquote>\n<p><strong>推荐语</strong> ： 波波老师的一篇文章，写的非常好，不光是对技术成长有帮助，其他领域也是同样适用的！建议反复阅读，形成一套自己的技术成长策略。</p>\n<br>\n<p><strong>原文地址：</strong> https://mp.weixin.qq.com/s/YrN8T67s801-MRo01lCHXA</p>\n</blockquote>\n<h2> 1. 前言</h2>\n<p>在波波的微信技术交流群里头，经常有学员问关于技术人该如何学习成长的问题，虽然是微信交流，但我依然可以感受到小伙伴们焦虑的心情。</p>\n<p><strong>技术人为啥焦虑？</strong> 恕我直言，说白了是胆识不足格局太小。胆就是胆量，焦虑的人一般对未来的不确定性怀有恐惧。识就是见识，焦虑的人一般看不清楚周围世界，也看不清自己和适合自己的道路。格局也称志向，容易焦虑的人通常视野窄志向小。如果从战略和管理的视角来看，就是对自己和周围世界的认知不足，没有一个清晰和长期的学习成长战略，也没有可执行的阶段性目标计划+严格的执行。</p>\n<p>因为问此类问题的学员很多，让我感觉有点烦了，为了避免重复回答，所以我专门总结梳理了这篇长文，试图统一来回答这类问题。如果后面还有学员问类似问题，我会引导他们来读这篇文章，然后让他们用三个月、一年甚至更长的时间，去思考和回答这样一个问题： <strong>你的技术成长战略究竟是什么？</strong> 如果你想清楚了这个问题，有清晰和可落地的答案，那么恭喜你，你只需按部就班执行就好，根本无需焦虑，你实现自己的战略目标并做出成就只是一个时间问题；否则，你仍然需要通过不断磨炼+思考，务必去搞清楚这个人生的大问题！！！</p>\n<p>下面我们来看一些行业技术大牛是怎么做的。</p>\n<h2> 二. 跟技术大牛学成长战略</h2>\n<p>我们知道软件设计是有设计模式(Design Pattern)的，其实技术人的成长也是有成长模式(Growth Pattern)的。波波经常在 Linkedin 上看一些技术大牛的成长履历，探究其中的成长模式，从而启发制定自己的技术成长战略。</p>\n<p>当然，很少有技术大牛会清晰地告诉你他们的技术成长战略，以及每一年的细分落地计划。但是，这并不妨碍我们通过他们的过往履历和产出成果，去溯源他们的技术成长战略。实际上， <strong>越是牛逼的技术人，他们的技术成长战略和路径越是清晰，我们越容易从中探究出一些成功的模式。</strong></p>\n<h3> 2.1 系统性能专家案例</h3>\n<p>国内的开发者大都热衷于系统性能优化，有些人甚至三句话离不开高性能/高并发，但真正能深入这个领域，做到专家级水平的却寥寥无几。</p>\n<p>我这边要特别介绍的这个技术大牛叫 <strong>Brendan Gregg</strong> ，他是系统性能领域经典书《System Performance: Enterprise and the Cloud》(中文版<a href=\"https://www.amazon.cn/dp/B08GC261P9\" target=\"_blank\" rel=\"noopener noreferrer\">《性能之巅：洞悉系统、企业和云计算》</a>)的作者，也是著名的<a href=\"https://github.com/brendangregg/FlameGraph\" target=\"_blank\" rel=\"noopener noreferrer\">性能分析利器火焰图(Flame Graph)</a>的作者。</p>\n<p>Brendan Gregg 之前是 Netflix 公司的高级性能架构师，在 Netflix 工作近 7 年。2022 年 4 月，他离开了 Netflix 去了 Intel，担任院士职位。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/cdb11ce2f1c3a69fd19e922a7f5f59bf.png\" alt=\"\"></p>\n<p>总体上，他已经在系统性能领域深耕超过 10 年，<a href=\"https://www.linkedin.com/in/brendangregg/\" target=\"_blank\" rel=\"noopener noreferrer\">Brendan Gregg 的过往履历</a>可以在 linkedin 上看到。在这 10 年间，除了书籍以外，Brendan Gregg 还产出了超过上百份和系统性能相关的技术文档，演讲视频/ppt，还有各种工具软件，相关内容都整整齐齐地分享在<a href=\"http://www.brendangregg.com/\" target=\"_blank\" rel=\"noopener noreferrer\">他的技术博客</a>上，可以说他是一个非常高产的技术大牛。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/fcd9e2d4dd351ac3ba1773fb1b50fe9e.webp?x-oss-process=image/format,png\" alt=\"性能工具\"></p>\n<p>上图来自 Brendan Gregg 的新书《BPF Performance Tools: Linux System and Application Observability》。从这个图可以看出，Brendan Gregg 对系统性能领域的掌握程度，已经深挖到了硬件、操作系统和应用的每一个角落，可以说是 360 度无死角，整个计算机系统对他来说几乎都是透明的。波波认为，Brendan Gregg 是名副其实的，世界级的，系统性能领域的大神级人物。</p>\n<h3> 2.2 从开源到企业案例</h3>\n<p>我要分享的第二个技术大牛是 <strong>Jay Kreps</strong>，他是知名的开源消息中间件 Kafka 的创始人/架构师，也是 Confluent 公司的联合创始人和 CEO，Confluent 公司是围绕 Kafka 开发企业级产品和服务的技术公司。</p>\n<p>从<a href=\"https://www.linkedin.com/in/jaykreps/\" target=\"_blank\" rel=\"noopener noreferrer\">Jay Kreps 的 Linkedin 的履历</a>上我们可以看出，Jay Kreps 之前在 Linkedin 工作了 7 年多(2007.6 ~ 2014. 9)，从高级工程师、工程主管，一直做到首席资深工程师。Kafka 大致是在 2010 年，Jay Kreps 在 Linkedin 发起的一个项目，解决 Linkedin 内部的大数据采集、存储和消费问题。之后，他和他的团队一直专注 Kafka 的打磨，开源(2011 年初)和社区生态的建设。</p>\n<p>到 2014 年底，Kafka 在社区已经非常成功，有了一个比较大的用户群，于是 Jay Kreps 就和几个早期作者一起离开了 Linkedin，成立了<a href=\"https://tech.163.com/14/1107/18/AAFG92LD00094ODU.html\" target=\"_blank\" rel=\"noopener noreferrer\">Confluent 公司</a>，开始了 Kafka 和周边产品的企业化服务道路。今年(2020.4 月)，Confluent 公司已经获得 E 轮 2.5 亿美金融资，公司估值达到 45 亿美金。从 Kafka 诞生到现在，Jay Kreps 差不多在这个产品和公司上投入了整整 10 年。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/7945a18b8d135fa1bb0eb3f0350452dd.webp?x-oss-process=image/format,png\" alt=\"Confluent创始人三人组\"></p>\n<p>上图是 Confluent 创始人三人组，一个非常有意思的组合，一个中国人(左)，一个印度人(右)，中间的 Jay Kreps 是美国人。</p>\n<p>我之所以对 Kafka 和 Jay Kreps 的印象特别深刻，是因为在 2012 年下半年，我在携程框架部也是专门搞大数据采集的，我还开发过一套功能类似 Kafka 的 Log Collector + Agent 产品。我记得同时期有不止 4 个同类型的开源产品：Facebook Scribe、Apache Chukwa、Apache Flume 和 Apache Kafka。现在回头看，只有 Kafka 走到现在发展得最好，这个和创始人的专注和持续投入是分不开的，当然背后和几个创始人的技术大格局也是分不开的。</p>\n<p>当年我对战略性思维几乎没有概念，还处在<strong>什么技术都想学、认为各种项目做得越多越牛的阶段</strong>。搞了半年的数据采集以后，我就掉头搞其它“更有趣的”项目去了(从这个事情的侧面，也可以看出我当年的技术格局是很小的)。中间我陆续关注过 Jay 的一些创业动向，但是没想到他能把 Confluent 公司发展到目前这个规模。现在回想，其实在十年前，Jay Kreps 对自己的技术成长就有比较明确的战略性思考，也具有大的技术格局和成事的一些必要特质。Jay Kreps 和 Kafka 给我上了一堂生动的技术战略和实践课。</p>\n<h3> 2.3 技术媒体大 V 案例</h3>\n<p>介绍到这里，有些同学可能会反驳说：波波你讲的这些大牛都是学历背景好，功底扎实起点高，所以他们才更能成功。其实不然，这里我再要介绍一位技术媒体界的大 V 叫 Brad Traversy，大家可以看<a href=\"https://www.linkedin.com/in/bradtraversy/\" target=\"_blank\" rel=\"noopener noreferrer\">他的 Linkedin 简历</a>，背景很一般，学历差不多是一个非正规的社区大学(相当于大专)，没有正规大厂工作经历，有限几份工作一直是在做网站外包。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/30d6d67dc6dd5f9251f2f01af4de53fc.png\" alt=\"\"></p>\n<p>但是！！！Brad Traversy 目前是技术媒体领域的一个大 V，当前<a href=\"https://www.youtube.com/c/TraversyMedia\" target=\"_blank\" rel=\"noopener noreferrer\">他在 Youtube 上的频道</a>有 138 万多的订阅量，10 年累计输出 Web 开发和编程相关教学视频超过 800 个。Brad Traversy 也是 <a href=\"https://www.udemy.com/user/brad-traversy/\" target=\"_blank\" rel=\"noopener noreferrer\">Udemy</a> 上的一个成功讲师，目前已经在 Udemy 上累计输出课程 19 门，购课学生数量近 42 万。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/160b0bc4f689413757b9b5e2448f940b.png\" alt=\"\"></p>\n<p>Brad Traversy 目前是自由职业者，他的 Youtube 广告+Udemy 课程的收入相当不错。</p>\n<p>就是这样一位技术媒体大 V，你很难想象，在年轻的时候，贴在他身上的标签是：不良少年，酗酒，抽烟，吸毒，纹身，进监狱。。。直</p>\n<p>到结婚后的第一个孩子诞生，他才开始担起责任做出改变，然后凭借对技术的一腔热情，开始在 Youtube 平台上持续输出免费课程。从此他找到了适合自己的战略目标，然后人生开始发生各种积极的变化。。。如果大家对 Brad Traversy 的过往经历感兴趣，推荐观看他在 Youtube 上的自述视频<a href=\"https://www.youtube.com/watch?v=zA9krklwADI\" target=\"_blank\" rel=\"noopener noreferrer\">《My Struggles &amp; Success》</a>。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/4de1f15cd0a047a3416f76501c26d288.webp?x-oss-process=image/format,png\" alt=\"My Struggles &amp; Success\"></p>\n<p>我粗略浏览了<a href=\"https://www.youtube.com/c/TraversyMedia/videos\" target=\"_blank\" rel=\"noopener noreferrer\">Brad Traversy 在 Youtube 上的所有视频</a>，10 年总计输出 800+视频，平均每年 80+。第一个视频提交于 2010 年 8 月，刚开始几年几乎没有订阅量，2017 年 1 月订阅量才到 50k，这中间差不多隔了 6 年。2017.10 月订阅量猛增到 200k，2018 年 3 月订阅量到 300k。当前 2021.1 月，订阅量达到 138 万。可以认为从 2017 开始，也就是在积累了 6 ～ 7 年后，他的订阅量开始出现拐点。<strong>如果把这些数据画出来，将会是一条非常漂亮的复利曲线</strong>。</p>\n<h3> 2.4 案例小结</h3>\n<p>Brendan Gregg，Jay Kreps 和 Brad Traversy 三个人走的技术路线各不相同，但是他们的成功具有共性或者说模式：</p>\n<p><strong>1、找到了适合自己的长期战略目标。</strong></p>\n<ul>\n<li>Brendan Gregg: 成为系统性能领域顶级专家</li>\n<li>Jay Kreps：开创基于 Kafka 开源消息队列的企业服务公司，并将公司做到上市</li>\n<li>Brad Traversy: 成为技术媒体领域大 V 和课程讲师，并以此作为自己的职业</li>\n</ul>\n<p><strong>2、专注深耕一个(或有限几个相关的)细分领域(Niche)，保持定力，不随便切换领域。</strong></p>\n<ul>\n<li>Brendan Gregg：系统性能领域</li>\n<li>Jay Kreps: 消息中间件/实时计算领域+创业</li>\n<li>Brad Traversy: 技术媒体/教学领域，方向 Web 开发 + 编程语言</li>\n</ul>\n<p><strong>3、长期投入，三人都持续投入了 10 年。</strong></p>\n<p><strong>4、年度细分计划+持续可量化的价值产出(Persistent &amp; Measurable Value Output)。</strong></p>\n<ul>\n<li>Brendan Gregg：除公司日常工作产出以外，每年有超过 10 份以上的技术文档和演讲视频产出，平均每年有 2.5 个开源工具产出。十年共产出书籍 2 本，其中《System Performance》已经更新到第二版。</li>\n<li>Jay Kreps：总体有开源产品+公司产出，1 本书产出，每年有 Kafka 和周边产品发版若干。</li>\n<li>Brad Traversy: 每年有 Youtube 免费视频产出（平均每年 80+）+Udemy 收费视频课产出(平均每年 1.5 门)。</li>\n</ul>\n<p><strong>5、以终为始是牛人和普通人的一大区别。</strong></p>\n<p>普通人通常走一步算一步，很少长远规划。牛人通 常是先有远大目标，然后采用倒推法，将大目标细化到每年/月/周的详细落地计划。Brendan Gregg，Jay Kreps 和 Brad Traversy 三人都是以终为始的典型。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/b83d495bd6b8765f127bb97e08e1544d.webp?x-oss-process=image/format,png\" alt=\"以终为始\"></p>\n<p>上面总结了几位技术大牛的成长模式，其中一个重点就是：这些大牛的成长都是通过 <strong>持续有价值产出(Persistent Valuable Output)</strong> 来驱动的。持续产出为啥如此重要，这个还要从下面的学习金字塔说起。</p>\n<h2> 三、学习金字塔和刻意训练</h2>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/41489858d0060f26e69c30bc964816bd.webp?x-oss-process=image/format,png\" alt=\"学习金字塔\"></p>\n<p>学习金字塔是美国缅因州国家训练实验室的研究成果，它认为：</p>\n<blockquote>\n<ol>\n<li>我们平时上课听讲之后，学习内容平均留存率大致只有 5%左右；</li>\n<li>书本阅读的平均留存率大致只有 10%左右；</li>\n<li>学习配上视听效果的课程，平均留存率大致在 20%左右；</li>\n<li>老师实际动手做实验演示后的平均留存率大致在 30%左右；</li>\n<li>小组讨论(尤其是辩论后)的平均留存率可以达到 50%左右；</li>\n<li>在实践中实际应用所学之后，平均留存率可以达到 75%左右；</li>\n<li>在实践的基础上，再把所学梳理出来，转而再传授给他人后，平均留存率可以达到 90%左右。</li>\n</ol>\n</blockquote>\n<p>上面列出的 7 种学习方法，前四种称为 <strong>被动学习</strong> ，后三种称为 <strong>主动学习</strong>。</p>\n<p>拿学游泳做个类比，被动学习相当于你看别人游泳，而主动学习则是你自己要下水去游。我们知道游泳或者跑步之类的运动是要燃烧身体卡路里的，这样才能达到锻炼身体和长肌肉的效果(肌肉是卡路里燃烧的结果)。如果你只是看别人游泳，自己不实际去游，是不会长肌肉的。同样的，主动学习也是要燃烧脑部卡路里的，这样才能达到训练大脑和长脑部“肌肉”的效果。</p>\n<p>我们也知道，燃烧身体的卡路里，通常会让人感觉不舒适，如果燃烧身体卡路里会让人感觉舒适的话，估计这个世界上应该不会有胖子这类人。同样，燃烧脑部卡路里也会让人感觉不适、紧张、出汗或语无伦次，如果燃烧脑部卡路里会让人感觉舒适的话，估计这个世界上人人都很聪明，人人都能发挥最大潜能。当然，这些不舒适是短期的，长期会使你更健康和聪明。波波一直认为， <strong>人与人之间的先天身体其实都差不多，但是后天身体素质和能力有差异，这些差异，很大程度是由后天对身体和大脑的训练质量、频度和强度所造成的。</strong></p>\n<p>明白这个道理之后，心智成熟和自律的人就会对自己进行持续地 <strong>刻意训练</strong> 。这个刻意训练包括对身体的训练，比如波波现在每天坚持跑步 3km，走 3km，每天做 60 个仰卧起坐，5 分钟平板撑等等，每天保持让身体燃烧一定量的卡路里。刻意训练也包括对大脑的训练，比如波波现在每天做项目写代码 coding(训练脑+手)，平均每天在 B 站上输出十分钟免费视频(训练脑+口头表达)，另外有定期总结输出公众号文章(训练脑+文字表达)，还有每天打半小时左右的平衡球(下图)或古墓丽影游戏(训练小脑+手)，每天保持让大脑燃烧一定量的卡路里，并保持一定强度(适度不适感)。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/5806350b9831d3a502ec84d40f81018f.webp?x-oss-process=image/format,png\" alt=\"平衡球游戏\"></p>\n<p>关于刻意训练的专业原理和方法论，推荐看书籍《刻意练习》。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/1707c3755515967caa138533eac3c53a.webp?x-oss-process=image/format,png\" alt=\"刻意练习\"></p>\n<p>注意，如果你平时从来不做举重锻炼的，那么某天突然做举重会很不适应甚至受伤。脑部训练也是一样的，如果你从来没有做过视频输出，那么刚开始做会很不适应，做出来的视频质量会很差。不过没有关系，任何训练都是一个循序渐进，不断强化的过程。等大脑相关区域的\"肌肉\"长出来以后，会逐步进入正循环，后面会越来越顺畅，相关\"肌肉\"会越来越发达。所以，和健身一样，健脑也不能遇到困难就放弃，需要循序渐进(Incremental)+持续地(Persistent)刻意训练。</p>\n<p>理解了学习金字塔和刻意训练以后，现在再来看 Brendan Gregg，Jay Kreps 和 Brad Traversy 这些大牛的做法，他们的学习成长都是建立在持续有价值产出的基础上的，这些产出都是刻意训练+燃烧脑部卡路里的成果。他们的产出要么是建立在实践基础上的产出，例如 Jay Kreps 的 Kafka 开源项目和 Confluent 公司；要么是在实践的基础上，再整理传授给其他人的产出，例如，Brendan Greeg 的技术演讲 ppt/视频，书籍，还有 Brad Traversy 的教学视频等等。换句话说，他们一直在学习金字塔的 5 ～ 7 层主动和高效地学习。并且，他们的学习产出还可以获得用户使用，有客户价值(Customer Value)，有用户就有反馈和度量。记住，有反馈和度量的学习，也称闭环学习，它是能够不断改进提升的；反之，没有反馈和度量的学习，无法改进提升。</p>\n<p>现在，你也应该明白，晒个书单秀个技能图谱很简单，读个书上个课也不难。但是要你给出 5 ～ 10 年的总体技术成长战略，再基于这个战略给出每年的细分落地计划(尤其是产出计划)，然后再严格按计划执行，这的确是很难的事情。这需要大量的实践训练+深度思考，要燃烧大量的脑部卡路里！但这是上天设置的进化法则，成长为真正的技术大牛如同成长为一流的运动员，是需要通过燃烧与之相匹配量的卡路里来交换的。成长为真正的技术大牛，也是需要通过产出与之匹配的社会价值来交换的，只有这样社会才能正常进化。你推进了社会进化，社会才会回馈你。如果不是这样，社会就无法正常进化。</p>\n<h2> 四、战略思维的诞生</h2>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/21f0ef179bea9aa15c1606bdf537f81d.webp?x-oss-process=image/format,png\" alt=\"思考周期和机会点\"></p>\n<p>一般毕业生刚进入企业工作的时候，思考大都是以天/星期/月为单位的，基本上都是今天学个什么技术，明天学个什么语言，很少会去思考一年甚至更长的目标。这是个眼前漆黑看不到的懵懂时期，捕捉到机会点的能力和概率都非常小。</p>\n<p>工作了三年以后，悟性好的人通常会以一年为思考周期，制定和实施一些年度计划。这个时期是相信天赋和比拼能力的阶段，可以捕捉到一些小机会。</p>\n<p>工作了五年以后，一些悟性好的人会产生出一定的胆识和眼光，他们会以 3 ～ 5 年为周期来制定和实施计划，开始主动布局去捕捉一些中型机会点。</p>\n<p>工作了十年以后，悟性高的人会看到模式和规则变化，例如看出行业发展模式，还有人才的成长模式等，于是开始诞生出战略性思维。然后他们会以 5 ～ 10 年为周期来制定和实施自己的战略计划，开始主动布局去捕捉一些中大机会点。Brendan Gregg，Jay Kreps 和 Brad Traversy 都是属于这个阶段的人。</p>\n<p>当然还有很少一些更牛的时代精英，他们能够看透时代和人性，他们的思考是以一生甚至更长时间为单位的，这些超人不在本文讨论范围内。</p>\n<h2> 五、建议</h2>\n<p><strong>1、以 5 ～ 10 年为周期去布局谋划你的战略。</strong></p>\n<p>现在大学生毕业的年龄一般在 22 ～ 23 岁，那么在工作了十年后，也就是在你 32 ～ 33 岁的时候，你也差不多看了十年了，应该对自己和周围的世界(你的行业和领域)有一个比较深刻的领悟了。<strong>如果你到这个年纪还懵懵懂懂，今天抓东明天抓西，那么只能说你的胆识格局是相当的低</strong>。在当前 IT 行业竞争这么激烈的情况下，到 35 岁被下岗可能就在眼前了。</p>\n<p>有了战略性思考，你应该以 5 ～ 10 年为周期去布局谋划你的战略。以 Brendan Gregg，Jay Kreps 和 Brad Traversy 这些大牛为例，<strong>人生若真的要干点成就出来，投入周期一般都要十年的</strong>。从 33 岁开始，你大致有 3 个十年，因为到 60 岁以后，一般人都老眼昏花干不了大事了。如果你悟性差一点，到 40 岁才开始规划，那么你大致还有 2 个十年。如果你规划好了，这 2 ～ 3 个十年可以成就不小的事业。否则，你很可能一生都成就不了什么事业，或者一直在帮助别人成就别人的事业。</p>\n<p><strong>2、专注自己的精力。</strong></p>\n<p>考虑到人生能干事业的时间也就是 2 ～ 3 个十年，你会发现人生其实很短暂，这时候你会把精力都投入到实现你的十年战略上去，没有时间再浪费在比如网上的闲聊和扯皮争论上去。</p>\n<p><strong>3、细分落地计划尤其是产出计划。</strong></p>\n<p>有了十年战略方向，下一步是每年的细分落地计划，尤其是产出计划。这些计划主要应该工作在学习金字塔的 5/6/7 层。<strong>产出应该是刻意训练+燃烧卡路里的结果，每天让身体和大脑都保持燃烧一定量的卡路里</strong>。</p>\n<p><strong>4、产出有价值的东西形成正反馈。</strong></p>\n<p>产出应该有客户价值，自己能学习(自己成长进化)，对别人还有用(推动社会成长进化)，这样可以得到<strong>用户回馈和度量</strong>，形成一个闭环，可以持续改进和提升你的学习。</p>\n<p><strong>5、少即是多。</strong></p>\n<p>深耕一个(或有限几个相关的)领域。所有细分计划应该紧密围绕你的战略展开。克制内心欲望，不要贪多和分心，不要被喧嚣的世界所迷惑。</p>\n<p><strong>6、战略方向+细分计划都要写下来，定期 review 优化。</strong></p>\n<p><strong>7、要有定力，持续努力。</strong></p>\n<p>曲则全、枉则直，战略实现是不可能直线的。战略方向和细分计划通常要按需调整，尤其在早期，但是最终要收敛。如果老是变不收敛，就是缺乏战略定力，是个必须思考和解决的大问题。</p>\n<p>别人的成长战略可以参考，但是不要刻意去模仿，你有你自己的颜色，<strong>你应该成为独一无二的你</strong>。</p>\n<p>战略方向和细分计划明确了，接下来就是按部就班执行，十年如一日铁打不动。</p>\n<p><strong>8、慢就是快。</strong></p>\n<p>战略目标的实现也和种树一样是生长出来的，需要时间耐心栽培，记住**慢就是快。**焦虑纠结的时候，像念经一样默念王阳明《传习录》中的教诲：</p>\n<blockquote>\n<p>立志用功，如种树然。方其根芽，犹未有干；及其有干，尚未有枝；枝而后叶，叶而后花实。初种根时，只管栽培灌溉。勿作枝想，勿作花想，勿作实想。悬想何益？但不忘栽培之功，怕没有枝叶花实？</p>\n<p>译文：</p>\n<p>实现战略目标，就像种树一样。刚开始只是一个小根芽，树干还没有长出来；树干长出来了，枝叶才能慢慢长出来；树枝长出来，然后才能开花和结果。刚开始种树的时候，只管栽培灌溉，别老是纠结枝什么时候长出来，花什么时候开，果实什么时候结出来。纠结有什么好处呢？只要你坚持投入栽培，还怕没有枝叶花实吗？</p>\n</blockquote>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/46cb8c4b3561f382bd5f333ceb5747b1.webp?x-oss-process=image/format,png\" alt=\"悬想何益\"></p>\n",
      "image": "https://img-blog.csdnimg.cn/img_convert/cdb11ce2f1c3a69fd19e922a7f5f59bf.png",
      "date_published": "2023-02-23T04:45:00.000Z",
      "date_modified": "2023-02-23T04:45:00.000Z",
      "authors": [
        {
          "name": "波波微课"
        }
      ],
      "tags": [
        "技术文章精选集"
      ]
    },
    {
      "title": "网络攻击常见手段总结",
      "url": "https://javaguide.cn/cs-basics/network/network-attack-means.html",
      "id": "https://javaguide.cn/cs-basics/network/network-attack-means.html",
      "summary": "本文整理完善自TCP/IP常见攻击手段 - 暖蓝笔记 - 2021这篇文章。 这篇文章的内容主要是介绍 TCP/IP常见攻击手段，尤其是 DDoS 攻击，也会补充一些其他的常见网络攻击手段。 IP 欺骗 IP 是什么? 在网络中，所有的设备都会分配一个地址。这个地址就仿佛小蓝的家地址「多少号多少室」，这个号就是分配给整个子网的，「室」对应的号码即分配给子网中计算机的，这就是网络中的地址。「号」对应的号码为网络号，「室」对应的号码为主机号，这个地址的整体就是 IP 地址。",
      "content_html": "<blockquote>\n<p>本文整理完善自<a href=\"https://mp.weixin.qq.com/s/AZwWrOlLxRSSi-ywBgZ0fA\" target=\"_blank\" rel=\"noopener noreferrer\">TCP/IP常见攻击手段 - 暖蓝笔记 - 2021</a>这篇文章。</p>\n</blockquote>\n<p>这篇文章的内容主要是介绍 TCP/IP常见攻击手段，尤其是 DDoS 攻击，也会补充一些其他的常见网络攻击手段。</p>\n<h2> IP 欺骗</h2>\n<h3> IP 是什么?</h3>\n<p>在网络中，所有的设备都会分配一个地址。这个地址就仿佛小蓝的家地址「<strong>多少号多少室</strong>」，这个号就是分配给整个子网的，「<strong>室</strong>」对应的号码即分配给子网中计算机的，这就是网络中的地址。「号」对应的号码为网络号，「<strong>室</strong>」对应的号码为主机号，这个地址的整体就是 <strong>IP 地址</strong>。</p>\n<h3> 通过 IP 地址我们能知道什么？</h3>\n<p>通过 IP 地址，我们就可以知道判断访问对象服务器的位置，从而将消息发送到服务器。一般发送者发出的消息首先经过子网的集线器，转发到最近的路由器，然后根据路由位置访问下一个路由器的位置，直到终点</p>\n<p><strong>IP 头部格式</strong> :</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/121f4f0c88f51a309a2c0566c0508034.png\" alt=\"\"></p>\n<h3> IP 欺骗技术是什么？</h3>\n<p>骗呗，拐骗，诱骗！</p>\n<p>IP 欺骗技术就是<strong>伪造</strong>某台主机的 IP 地址的技术。通过 IP 地址的伪装使得某台主机能够<strong>伪装</strong>另外的一台主机，而这台主机往往具有某种特权或者被另外的主机所信任。</p>\n<p>假设现在有一个合法用户 <strong>(1.1.1.1)</strong> 已经同服务器建立正常的连接，攻击者构造攻击的 TCP 数据，伪装自己的 IP 为 <strong>1.1.1.1</strong>，并向服务器发送一个带有 RSI 位的 TCP 数据段。服务器接收到这样的数据后，认为从 <strong>1.1.1.1</strong> 发送的连接有错误，就会清空缓冲区中建立好的连接。</p>\n<p>这时，如果合法用户 <strong>1.1.1.1</strong> 再发送合法数据，服务器就已经没有这样的连接了，该用户就必须从新开始建立连接。攻击时，伪造大量的 IP 地址，向目标发送 RST 数据，使服务器不对合法用户服务。虽然 IP 地址欺骗攻击有着相当难度，但我们应该清醒地意识到，这种攻击非常广泛，入侵往往从这种攻击开始。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/d0a3525fc3a55bf129aee9dea14db967.png\" alt=\"IP 欺骗 DDoS 攻击\"></p>\n<h3> 如何缓解 IP 欺骗？</h3>\n<p>虽然无法预防 IP 欺骗，但可以采取措施来阻止伪造数据包渗透网络。<strong>入口过滤</strong> 是防范欺骗的一种极为常见的防御措施，如 BCP38（通用最佳实践文档）所示。入口过滤是一种数据包过滤形式，通常在<a href=\"https://www.cloudflare.com/learning/serverless/glossary/what-is-edge-computing/\" target=\"_blank\" rel=\"noopener noreferrer\">网络边缘</a>设备上实施，用于检查传入的 IP 数据包并确定其源标头。如果这些数据包的源标头与其来源不匹配或者看上去很可疑，则拒绝这些数据包。一些网络还实施出口过滤，检查退出网络的 IP 数据包，确保这些数据包具有合法源标头，以防止网络内部用户使用 IP 欺骗技术发起出站恶意攻击。</p>\n<h2> SYN Flood(洪水)</h2>\n<h3> SYN Flood 是什么？</h3>\n<p>SYN Flood 是互联网上最原始、最经典的 DDoS（Distributed Denial of Service，分布式拒绝服务）攻击之一，旨在耗尽可用服务器资源，致使服务器无法传输合法流量</p>\n<p>SYN Flood 利用了 TCP 协议的三次握手机制，攻击者通常利用工具或者控制僵尸主机向服务器发送海量的变源 IP 地址或变源端口的 TCP SYN 报文，服务器响应了这些报文后就会生成大量的半连接，当系统资源被耗尽后，服务器将无法提供正常的服务。\n增加服务器性能，提供更多的连接能力对于 SYN Flood 的海量报文来说杯水车薪，防御 SYN Flood 的关键在于判断哪些连接请求来自于真实源，屏蔽非真实源的请求以保障正常的业务请求能得到服务。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20210608152327406.png\" alt=\"\"></p>\n<h3> TCP SYN Flood 攻击原理是什么？</h3>\n<p><strong>TCP SYN Flood</strong> 攻击利用的是 <strong>TCP</strong> 的三次握手（<strong>SYN -&gt; SYN/ACK -&gt; ACK</strong>），假设连接发起方是 A，连接接受方是 B，即 B 在某个端口（<strong>Port</strong>）上监听 A 发出的连接请求，过程如下图所示，左边是 A，右边是 B。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/fb84988f23bf0130426386316ad3d394.png\" alt=\"\"></p>\n<p>A 首先发送 <strong>SYN</strong>（Synchronization）消息给 B，要求 B 做好接收数据的准备；B 收到后反馈 <strong>SYN-ACK</strong>（Synchronization-Acknowledgement） 消息给 A，这个消息的目的有两个：</p>\n<ul>\n<li>向 A 确认已做好接收数据的准备，</li>\n<li>同时要求 A 也做好接收数据的准备，此时 B 已向 A 确认好接收状态，并等待 A 的确认，连接处于<strong>半开状态（Half-Open）</strong>，顾名思义只开了一半；A 收到后再次发送 <strong>ACK</strong> (Acknowledgement) 消息给 B，向 B 确认也做好了接收数据的准备，至此三次握手完成，「<strong>连接</strong>」就建立了，</li>\n</ul>\n<p>大家注意到没有，最关键的一点在于双方是否都按对方的要求进入了<strong>可以接收消息</strong>的状态。而这个状态的确认主要是双方将要使用的<strong>消息序号(<strong>SquenceNum)，<strong>TCP</strong> 为保证消息按发送顺序抵达接收方的上层应用，需要用</strong>消息序号</strong>来标记消息的发送先后顺序的。</p>\n<p><strong>TCP</strong>是「<strong>双工</strong>」(Duplex)连接，同时支持双向通信，也就是双方同时可向对方发送消息，其中 <strong>SYN</strong> 和 <strong>SYN-ACK</strong> 消息开启了 A→B 的单向通信通道（B 获知了 A 的消息序号）；<strong>SYN-ACK</strong> 和 <strong>ACK</strong> 消息开启了 B→A 单向通信通道（A 获知了 B 的消息序号）。</p>\n<p>上面讨论的是双方在诚实守信，正常情况下的通信。</p>\n<p>但实际情况是，网络可能不稳定会丢包，使握手消息不能抵达对方，也可能是对方故意不按规矩来，故意延迟或不发送握手确认消息。</p>\n<p>假设 B 通过某 <strong>TCP</strong> 端口提供服务，B 在收到 A 的 <strong>SYN</strong> 消息时，积极的反馈了 <strong>SYN-ACK</strong> 消息，使连接进入<strong>半开状态</strong>，因为 B 不确定自己发给 A 的 <strong>SYN-ACK</strong> 消息或 A 反馈的 ACK 消息是否会丢在半路，所以会给每个待完成的半开连接都设一个<strong>Timer</strong>，如果超过时间还没有收到 A 的 <strong>ACK</strong> 消息，则重新发送一次 <strong>SYN-ACK</strong> 消息给 A，直到重试超过一定次数时才会放弃。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/78bc8b670709adcc9de07622b6a9e5be.png\" alt=\"图片\"></p>\n<p>B 为帮助 A 能顺利连接，需要<strong>分配内核资源</strong>维护半开连接，那么当 B 面临海量的连接 A 时，如上图所示，<strong>SYN Flood</strong> 攻击就形成了。攻击方 A 可以控制肉鸡向 B 发送大量 SYN 消息但不响应 ACK 消息，或者干脆伪造 SYN 消息中的 <strong>Source IP</strong>，使 B 反馈的 <strong>SYN-ACK</strong> 消息石沉大海，导致 B 被大量注定不能完成的半开连接占据，直到资源耗尽，停止响应正常的连接请求。</p>\n<h3> SYN Flood 的常见形式有哪些？</h3>\n<p><strong>恶意用户可通过三种不同方式发起 SYN Flood 攻击</strong> ：</p>\n<ol>\n<li>**直接攻击：**不伪造 IP 地址的 SYN 洪水攻击称为直接攻击。在此类攻击中，攻击者完全不屏蔽其 IP 地址。由于攻击者使用具有真实 IP 地址的单一源设备发起攻击，因此很容易发现并清理攻击者。为使目标机器呈现半开状态，黑客将阻止个人机器对服务器的 SYN-ACK 数据包做出响应。为此，通常采用以下两种方式实现：部署防火墙规则，阻止除 SYN 数据包以外的各类传出数据包；或者，对传入的所有 SYN-ACK 数据包进行过滤，防止其到达恶意用户机器。实际上，这种方法很少使用（即便使用过也不多见），因为此类攻击相当容易缓解 – 只需阻止每个恶意系统的 IP 地址。哪怕攻击者使用僵尸网络（如 <a href=\"https://www.cloudflare.com/learning/ddos/glossary/mirai-botnet/\" target=\"_blank\" rel=\"noopener noreferrer\">Mirai 僵尸网络</a>），通常也不会刻意屏蔽受感染设备的 IP。</li>\n<li>**欺骗攻击：**恶意用户还可以伪造其发送的各个 SYN 数据包的 IP 地址，以便阻止缓解措施并加大身份暴露难度。虽然数据包可能经过伪装，但还是可以通过这些数据包追根溯源。此类检测工作很难开展，但并非不可实现；特别是，如果 Internet 服务提供商 (ISP) 愿意提供帮助，则更容易实现。</li>\n<li>**分布式攻击（DDoS）：**如果使用僵尸网络发起攻击，则追溯攻击源头的可能性很低。随着混淆级别的攀升，攻击者可能还会命令每台分布式设备伪造其发送数据包的 IP 地址。哪怕攻击者使用僵尸网络（如 Mirai 僵尸网络），通常也不会刻意屏蔽受感染设备的 IP。</li>\n</ol>\n<h3> 如何缓解 SYN Flood？</h3>\n<h4> 扩展积压工作队列</h4>\n<p>目标设备安装的每个操作系统都允许具有一定数量的半开连接。若要响应大量 SYN 数据包，一种方法是增加操作系统允许的最大半开连接数目。为成功扩展最大积压工作，系统必须额外预留内存资源以处理各类新请求。如果系统没有足够的内存，无法应对增加的积压工作队列规模，将对系统性能产生负面影响，但仍然好过拒绝服务。</p>\n<h4> 回收最先创建的 TCP 半开连接</h4>\n<p>另一种缓解策略是在填充积压工作后覆盖最先创建的半开连接。这项策略要求完全建立合法连接的时间低于恶意 SYN 数据包填充积压工作的时间。当攻击量增加或积压工作规模小于实际需求时，这项特定的防御措施将不奏效。</p>\n<h4> SYN Cookie</h4>\n<p>此策略要求服务器创建 Cookie。为避免在填充积压工作时断开连接，服务器使用 SYN-ACK 数据包响应每一项连接请求，而后从积压工作中删除 SYN 请求，同时从内存中删除请求，保证端口保持打开状态并做好重新建立连接的准备。如果连接是合法请求并且已将最后一个 ACK 数据包从客户端机器发回服务器，服务器将重建（存在一些限制）SYN 积压工作队列条目。虽然这项缓解措施势必会丢失一些 TCP 连接信息，但好过因此导致对合法用户发起拒绝服务攻击。</p>\n<h2> UDP Flood(洪水)</h2>\n<h3> UDP Flood 是什么？</h3>\n<p><strong>UDP Flood</strong> 也是一种拒绝服务攻击，将大量的用户数据报协议（<strong>UDP</strong>）数据包发送到目标服务器，目的是压倒该设备的处理和响应能力。防火墙保护目标服务器也可能因 <strong>UDP</strong> 泛滥而耗尽，从而导致对合法流量的拒绝服务。</p>\n<h3> UDP Flood 攻击原理是什么？</h3>\n<p><strong>UDP Flood</strong> 主要通过利用服务器响应发送到其中一个端口的 <strong>UDP</strong> 数据包所采取的步骤。在正常情况下，当服务器在特定端口接收到 <strong>UDP</strong> 数据包时，会经过两个步骤：</p>\n<ul>\n<li>服务器首先检查是否正在运行正在侦听指定端口的请求的程序。</li>\n<li>如果没有程序在该端口接收数据包，则服务器使用 <strong>ICMP</strong>（ping）数据包进行响应，以通知发送方目的地不可达。</li>\n</ul>\n<p>举个例子。假设今天要联系酒店的小蓝，酒店客服接到电话后先查看房间的列表来确保小蓝在客房内，随后转接给小蓝。</p>\n<p>首先，接待员接收到呼叫者要求连接到特定房间的电话。接待员然后需要查看所有房间的清单，以确保客人在房间中可用，并愿意接听电话。碰巧的是，此时如果突然间所有的电话线同时亮起来，那么他们就会很快就变得不堪重负了。</p>\n<p>当服务器接收到每个新的 <strong>UDP</strong> 数据包时，它将通过步骤来处理请求，并利用该过程中的服务器资源。发送 <strong>UDP</strong> 报文时，每个报文将包含源设备的 <strong>IP</strong> 地址。在这种类型的 <strong>DDoS</strong> 攻击期间，攻击者通常不会使用自己的真实 <strong>IP</strong> 地址，而是会欺骗 <strong>UDP</strong> 数据包的源 <strong>IP</strong> 地址，从而阻止攻击者的真实位置被暴露并潜在地饱和来自目标的响应数据包服务器。</p>\n<p>由于目标服务器利用资源检查并响应每个接收到的 <strong>UDP</strong> 数据包的结果，当接收到大量 <strong>UDP</strong> 数据包时，目标的资源可能会迅速耗尽，导致对正常流量的拒绝服务。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/7d0ff60a34c001a0806c46070b421a5b.png\" alt=\"\"></p>\n<h3> 如何缓解 UDP Flooding？</h3>\n<p>大多数操作系统部分限制了 <strong>ICMP</strong> 报文的响应速率，以中断需要 ICMP 响应的 <strong>DDoS</strong> 攻击。这种缓解的一个缺点是在攻击过程中，合法的数据包也可能被过滤。如果 <strong>UDP Flood</strong> 的容量足够高以使目标服务器的防火墙的状态表饱和，则在服务器级别发生的任何缓解都将不足以应对目标设备上游的瓶颈。</p>\n<h2> HTTP Flood(洪水)</h2>\n<h3> HTTP Flood 是什么？</h3>\n<p>HTTP Flood 是一种大规模的 DDoS（Distributed Denial of Service，分布式拒绝服务）攻击，旨在利用 HTTP 请求使目标服务器不堪重负。目标因请求而达到饱和，且无法响应正常流量后，将出现拒绝服务，拒绝来自实际用户的其他请求。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/4a388ae54275436d123a4179033ef148.png\" alt=\"HTTP 洪水攻击\"></p>\n<h3> HTTP Flood 的攻击原理是什么？</h3>\n<p>HTTP 洪水攻击是“第 7 层”DDoS 攻击的一种。第 7 层是 OSI 模型的应用程序层，指的是 HTTP 等互联网协议。HTTP 是基于浏览器的互联网请求的基础，通常用于加载网页或通过互联网发送表单内容。缓解应用程序层攻击特别复杂，因为恶意流量和正常流量很难区分。</p>\n<p>为了获得最大效率，恶意行为者通常会利用或创建僵尸网络，以最大程度地扩大攻击的影响。通过利用感染了恶意软件的多台设备，攻击者可以发起大量攻击流量来进行攻击。</p>\n<p>HTTP 洪水攻击有两种：</p>\n<ul>\n<li><strong>HTTP GET 攻击</strong> ：在这种攻击形式下，多台计算机或其他设备相互协调，向目标服务器发送对图像、文件或其他资产的多个请求。当目标被传入的请求和响应所淹没时，来自正常流量源的其他请求将被拒绝服务。</li>\n<li><strong>HTTP POST 攻击</strong> ： 一般而言，在网站上提交表单时，服务器必须处理传入的请求并将数据推送到持久层（通常是数据库）。与发送 POST 请求所需的处理能力和带宽相比，处理表单数据和运行必要数据库命令的过程相对密集。这种攻击利用相对资源消耗的差异，直接向目标服务器发送许多 POST 请求，直到目标服务器的容量饱和并拒绝服务为止。</li>\n</ul>\n<h3> 如何防护 HTTP Flood？</h3>\n<p>如前所述，缓解第 7 层攻击非常复杂，而且通常要从多方面进行。一种方法是对发出请求的设备实施质询，以测试它是否是机器人，这与在线创建帐户时常用的 CAPTCHA 测试非常相似。通过提出 JavaScript 计算挑战之类的要求，可以缓解许多攻击。</p>\n<p>其他阻止 HTTP 洪水攻击的途径包括使用 Web 应用程序防火墙 (WAF)、管理 IP 信誉数据库以跟踪和有选择地阻止恶意流量，以及由工程师进行动态分析。Cloudflare 具有超过 2000 万个互联网设备的规模优势，能够分析来自各种来源的流量并通过快速更新的 WAF 规则和其他防护策略来缓解潜在的攻击，从而消除应用程序层 DDoS 流量。</p>\n<h2> DNS Flood(洪水)</h2>\n<h3> DNS Flood 是什么？</h3>\n<p>域名系统（DNS）服务器是互联网的“电话簿“；互联网设备通过这些服务器来查找特定 Web 服务器以便访问互联网内容。DNS Flood攻击是一种分布式拒绝服务（DDoS）攻击，攻击者用大量流量淹没某个域的 DNS 服务器，以尝试中断该域的 DNS 解析。如果用户无法找到电话簿，就无法查找到用于调用特定资源的地址。通过中断 DNS 解析，DNS Flood攻击将破坏网站、API 或 Web 应用程序响应合法流量的能力。很难将 DNS Flood攻击与正常的大流量区分开来，因为这些大规模流量往往来自多个唯一地址，查询该域的真实记录，模仿合法流量。</p>\n<h3> DNS Flood 的攻击原理是什么？</h3>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/85f7e18d5f9d8c40c3bf3650060fac61.png\" alt=\"\"></p>\n<p>域名系统的功能是将易于记忆的名称（例如example.com）转换成难以记住的网站服务器地址（例如192.168.0.1），因此成功攻击 DNS 基础设施将导致大多数人无法使用互联网。DNS Flood攻击是一种相对较新的基于 DNS 的攻击，这种攻击是在高带宽<a href=\"https://www.cloudflare.com/learning/ddos/glossary/internet-of-things-iot/\" target=\"_blank\" rel=\"noopener noreferrer\">物联网（IoT）</a><a href=\"https://www.cloudflare.com/learning/ddos/what-is-a-ddos-botnet/\" target=\"_blank\" rel=\"noopener noreferrer\">僵尸网络</a>（如 <a href=\"https://www.cloudflare.com/learning/ddos/glossary/mirai-botnet/\" target=\"_blank\" rel=\"noopener noreferrer\">Mirai</a>）兴起后激增的。DNS Flood攻击使用 IP 摄像头、DVR 盒和其他 IoT 设备的高带宽连接直接淹没主要提供商的 DNS 服务器。来自 IoT 设备的大量请求淹没 DNS 提供商的服务，阻止合法用户访问提供商的 DNS 服务器。</p>\n<p>DNS Flood攻击不同于 <a href=\"https://www.cloudflare.com/zh-cn/learning/ddos/dns-amplification-ddos-attack/\" target=\"_blank\" rel=\"noopener noreferrer\">DNS 放大攻击</a>。与 DNS Flood攻击不同，DNS 放大攻击反射并放大不安全 DNS 服务器的流量，以便隐藏攻击的源头并提高攻击的有效性。DNS 放大攻击使用连接带宽较小的设备向不安全的 DNS 服务器发送无数请求。这些设备对非常大的 DNS 记录发出小型请求，但在发出请求时，攻击者伪造返回地址为目标受害者。这种放大效果让攻击者能借助有限的攻击资源来破坏较大的目标。</p>\n<h3> 如何防护 DNS Flood?</h3>\n<p>DNS Flood 对传统上基于放大的攻击方法做出了改变。借助轻易获得的高带宽僵尸网络，攻击者现能针对大型组织发动攻击。除非被破坏的 IoT 设备得以更新或替换，否则抵御这些攻击的唯一方法是使用一个超大型、高度分布式的 DNS 系统，以便实时监测、吸收和阻止攻击流量。</p>\n<h2> TCP 重置攻击</h2>\n<p>在 <strong>TCP</strong> 重置攻击中，攻击者通过向通信的一方或双方发送伪造的消息，告诉它们立即断开连接，从而使通信双方连接中断。正常情况下，如果客户端收发现到达的报文段对于相关连接而言是不正确的，<strong>TCP</strong> 就会发送一个重置报文段，从而导致 <strong>TCP</strong> 连接的快速拆卸。</p>\n<p><strong>TCP</strong> 重置攻击利用这一机制，通过向通信方发送伪造的重置报文段，欺骗通信双方提前关闭 TCP 连接。如果伪造的重置报文段完全逼真，接收者就会认为它有效，并关闭 <strong>TCP</strong> 连接，防止连接被用来进一步交换信息。服务端可以创建一个新的 <strong>TCP</strong> 连接来恢复通信，但仍然可能会被攻击者重置连接。万幸的是，攻击者需要一定的时间来组装和发送伪造的报文，所以一般情况下这种攻击只对长连接有杀伤力，对于短连接而言，你还没攻击呢，人家已经完成了信息交换。</p>\n<p>从某种意义上来说，伪造 <strong>TCP</strong> 报文段是很容易的，因为 <strong>TCP/IP</strong> 都没有任何内置的方法来验证服务端的身份。有些特殊的 IP 扩展协议（例如 <code>IPSec</code>）确实可以验证身份，但并没有被广泛使用。客户端只能接收报文段，并在可能的情况下使用更高级别的协议（如 <code>TLS</code>）来验证服务端的身份。但这个方法对 <strong>TCP</strong> 重置包并不适用，因为 <strong>TCP</strong> 重置包是 <strong>TCP</strong> 协议本身的一部分，无法使用更高级别的协议进行验证。</p>\n<h2> 模拟攻击</h2>\n<blockquote>\n<p>以下实验是在 <code>OSX</code> 系统中完成的，其他系统请自行测试。</p>\n</blockquote>\n<p>现在来总结一下伪造一个 <strong>TCP</strong> 重置报文要做哪些事情：</p>\n<ul>\n<li>嗅探通信双方的交换信息。</li>\n<li>截获一个 <code>ACK</code> 标志位置位 1 的报文段，并读取其 <code>ACK</code> 号。</li>\n<li>伪造一个 TCP 重置报文段（<code>RST</code> 标志位置为 1），其序列号等于上面截获的报文的 <code>ACK</code> 号。这只是理想情况下的方案，假设信息交换的速度不是很快。大多数情况下为了增加成功率，可以连续发送序列号不同的重置报文。</li>\n<li>将伪造的重置报文发送给通信的一方或双方，时其中断连接。</li>\n</ul>\n<p>为了实验简单，我们可以使用本地计算机通过 <code>localhost</code> 与自己通信，然后对自己进行 TCP 重置攻击。需要以下几个步骤：</p>\n<ul>\n<li>在两个终端之间建立一个 TCP 连接。</li>\n<li>编写一个能嗅探通信双方数据的攻击程序。</li>\n<li>修改攻击程序，伪造并发送重置报文。</li>\n</ul>\n<p>下面正式开始实验。</p>\n<blockquote>\n<p>建立 TCP 连接</p>\n</blockquote>\n<p>可以使用 netcat 工具来建立 TCP 连接，这个工很多操作系统都预装了。打开第一个终端窗口，运行以下命令：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>这个命令会启动一个 TCP 服务，监听端口为 <code>8000</code>。接着再打开第二个终端窗口，运行以下命令：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>该命令会尝试与上面的服务建立连接，在其中一个窗口输入一些字符，就会通过 TCP 连接发送给另一个窗口并打印出来。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/344d0433aa812121907b7dbe4ceef81f.gif\" alt=\"\"></p>\n<blockquote>\n<p>嗅探流量</p>\n</blockquote>\n<p>编写一个攻击程序，使用 Python 网络库 <code>scapy</code> 来读取两个终端窗口之间交换的数据，并将其打印到终端上。代码比较长，下面为一部份，完整代码后台回复 TCP 攻击，代码的核心是调用 <code>scapy</code> 的嗅探方法：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/1700a7e27b6eaa3e72a730236d52edce.png\" alt=\"\"></p>\n<p>这段代码告诉 <code>scapy</code> 在 <code>lo0</code> 网络接口上嗅探数据包，并记录所有 TCP 连接的详细信息。</p>\n<ul>\n<li><strong>iface</strong> : 告诉 scapy 在 <code>lo0</code>（localhost）网络接口上进行监听。</li>\n<li><strong>lfilter</strong> : 这是个过滤器，告诉 scapy 忽略所有不属于指定的 TCP 连接（通信双方皆为 <code>localhost</code>，且端口号为 <code>8000</code>）的数据包。</li>\n<li><strong>prn</strong> : scapy 通过这个函数来操作所有符合 <code>lfilter</code> 规则的数据包。上面的例子只是将数据包打印到终端，下文将会修改函数来伪造重置报文。</li>\n<li><strong>count</strong> : scapy 函数返回之前需要嗅探的数据包数量。</li>\n</ul>\n<blockquote>\n<p>发送伪造的重置报文</p>\n</blockquote>\n<p>下面开始修改程序，发送伪造的 TCP 重置报文来进行 TCP 重置攻击。根据上面的解读，只需要修改 prn 函数就行了，让其检查数据包，提取必要参数，并利用这些参数来伪造 TCP 重置报文并发送。</p>\n<p>例如，假设该程序截获了一个从（<code>src_ip</code>, <code>src_port</code>）发往 （<code>dst_ip</code>, <code>dst_port</code>）的报文段，该报文段的 ACK 标志位已置为 1，ACK 号为 <code>100,000</code>。攻击程序接下来要做的是：</p>\n<ul>\n<li>由于伪造的数据包是对截获的数据包的响应，所以伪造数据包的源 <code>IP/Port</code> 应该是截获数据包的目的 <code>IP/Port</code>，反之亦然。</li>\n<li>将伪造数据包的 <code>RST</code> 标志位置为 1，以表示这是一个重置报文。</li>\n<li>将伪造数据包的序列号设置为截获数据包的 ACK 号，因为这是发送方期望收到的下一个序列号。</li>\n<li>调用 <code>scapy</code> 的 <code>send</code> 方法，将伪造的数据包发送给截获数据包的发送方。</li>\n</ul>\n<p>对于我的程序而言，只需将这一行取消注释，并注释这一行的上面一行，就可以全面攻击了。按照步骤 1 的方法设置 TCP 连接，打开第三个窗口运行攻击程序，然后在 TCP 连接的其中一个终端输入一些字符串，你会发现 TCP 连接被中断了！</p>\n<blockquote>\n<p>进一步实验</p>\n</blockquote>\n<ol>\n<li>可以继续使用攻击程序进行实验，将伪造数据包的序列号加减 1 看看会发生什么，是不是确实需要和截获数据包的 <code>ACK</code> 号完全相同。</li>\n<li>打开 <code>Wireshark</code>，监听 lo0 网络接口，并使用过滤器 <code>ip.src == 127.0.0.1 &amp;&amp; ip.dst == 127.0.0.1 &amp;&amp; tcp.port == 8000</code> 来过滤无关数据。你可以看到 TCP 连接的所有细节。</li>\n<li>在连接上更快速地发送数据流，使攻击更难执行。</li>\n</ol>\n<h2> 中间人攻击</h2>\n<p>猪八戒要向小蓝表白，于是写了一封信给小蓝，结果第三者小黑拦截到了这封信，把这封信进行了篡改，于是乎在他们之间进行搞破坏行动。这个马文才就是中间人，实施的就是中间人攻击。好我们继续聊聊什么是中间人攻击。</p>\n<h3> 什么是中间人?</h3>\n<p>攻击中间人攻击英文名叫 Man-in-the-MiddleAttack，简称「MITM 攻击」。指攻击者与通讯的两端分别创建独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方 直接对话，但事实上整个会话都被攻击者完全控制。我们画一张图：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/53969bbd535dec6abadf76f57b3128c5.png\" alt=\"图片\"></p>\n<p>从这张图可以看到，中间人其实就是攻击者。通过这种原理，有很多实现的用途，比如说，你在手机上浏览不健康网站的时候，手机就会提示你，此网站可能含有病毒，是否继续访问还是做其他的操作等等。</p>\n<h3> 中间人攻击的原理是什么？</h3>\n<p>举个例子，我和公司签了一个一份劳动合同，一人一份合同。不晓得哪个可能改了合同内容，不知道真假了，怎么搞？只好找专业的机构来鉴定，自然就要花钱。</p>\n<p>在安全领域有句话：<strong>我们没有办法杜绝网络犯罪，只好想办法提高网络犯罪的成本</strong>。既然没法杜绝这种情况，那我们就想办法提高作案的成本，今天我们就简单了解下基本的网络安全知识，也是面试中的高频面试题了。</p>\n<p>为了避免双方说活不算数的情况，双方引入第三家机构，将合同原文给可信任的第三方机构，只要这个机构不监守自盗，合同就相对安全。</p>\n<p><strong>如果第三方机构内部不严格或容易出现纰漏？</strong></p>\n<p>虽然我们将合同原文给第三方机构了，为了防止内部人员的更改，需要采取什么措施呢</p>\n<p>一种可行的办法是引入 <strong>摘要算法</strong> 。即合同和摘要一起，为了简单的理解摘要。大家可以想象这个摘要为一个函数，这个函数对原文进行了加密，会产生一个唯一的散列值，一旦原文发生一点点变化，那么这个散列值将会变化。</p>\n<h4> 有哪些常用的摘要算法呢？</h4>\n<p>目前比较常用的加密算法有消息摘要算法和安全散列算法(<strong>SHA</strong>)。<strong>MD5</strong> 是将任意长度的文章转化为一个 128 位的散列值，可是在 2004 年，<strong>MD5</strong> 被证实了容易发生碰撞，即两篇原文产生相同的摘要。这样的话相当于直接给黑客一个后门，轻松伪造摘要。</p>\n<p>所以在大部分的情况下都会选择 <strong>SHA 算法</strong> 。</p>\n<p><strong>出现内鬼了怎么办？</strong></p>\n<p>看似很安全的场面了，理论上来说杜绝了篡改合同的做法。主要某个员工同时具有修改合同和摘要的权利，那搞事儿就是时间的问题了，毕竟没哪个系统可以完全的杜绝员工接触敏感信息，除非敏感信息都不存在。所以能不能考虑将合同和摘要分开存储呢</p>\n<p><strong>那如何确保员工不会修改合同呢？</strong></p>\n<p>这确实蛮难的，不过办法总比困难多。我们将合同放在双方手中，摘要放在第三方机构，篡改难度进一步加大</p>\n<p><strong>那么员工万一和某个用户串通好了呢？</strong></p>\n<p>看来放在第三方的机构还是不好使，同样存在不小风险。所以还需要寻找新的方案，这就出现了 <strong>数字签名和证书</strong>。</p>\n<h4> 数字证书和签名有什么用？</h4>\n<p>同样的，举个例子。Sum 和 Mike 两个人签合同。Sum 首先用 <strong>SHA</strong> 算法计算合同的摘要，然后用自己私钥将摘要加密，得到数字签名。Sum 将合同原文、签名，以及公钥三者都交给 Mike</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/d1f08fdee50f6eb3dca93bff83f3884c.png\" alt=\"\"></p>\n<p>如果 Sum 想要证明合同是 Mike 的，那么就要使用 Mike 的公钥，将这个签名解密得到摘要 x，然后 Mike 计算原文的 sha 摘要 Y，随后对比 x 和 y，如果两者相等，就认为数据没有被篡改</p>\n<p>在这样的过程中，Mike 是不能更改 Sum 的合同，因为要修改合同不仅仅要修改原文还要修改摘要，修改摘要需要提供 Mike 的私钥，私钥即 Sum 独有的密码，公钥即 Sum 公布给他人使用的密码</p>\n<p>总之，公钥加密的数据只能私钥可以解密。私钥加密的数据只有公钥可以解密，这就是 <strong>非对称加密</strong> 。</p>\n<p>隐私保护？不是吓唬大家，信息是透明的兄 die，不过尽量去维护个人的隐私吧，今天学习对称加密和非对称加密。</p>\n<p>大家先读读这个字\"钥\",是读\"yao\"，我以前也是，其实读\"yue\"</p>\n<h4> 什么是对称加密？</h4>\n<p>对称加密，顾名思义，加密方与解密方使用同一钥匙(秘钥)。具体一些就是，发送方通过使用相应的加密算法和秘钥，对将要发送的信息进行加密；对于接收方而言，使用解密算法和相同的秘钥解锁信息，从而有能力阅读信息。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/e72950f066af5db93023acb8d723a73b.png\" alt=\"图片\"></p>\n<h4> 常见的对称加密算法有哪些？</h4>\n<p><strong>DES</strong></p>\n<p>DES 使用的密钥表面上是 64 位的，然而只有其中的 56 位被实际用于算法，其余 8 位可以被用于奇偶校验，并在算法中被丢弃。因此，<strong>DES</strong> 的有效密钥长度为 56 位，通常称 <strong>DES</strong> 的密钥长度为 56 位。假设秘钥为 56 位，采用暴力破 Jie 的方式，其秘钥个数为 2 的 56 次方，那么每纳秒执行一次解密所需要的时间差不多 1 年的样子。当然，没人这么干。<strong>DES</strong> 现在已经不是一种安全的加密方法，主要因为它使用的 56 位密钥过短。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/c0b1c4844b8748edee698c11d9e76736.jpeg\" alt=\"\"></p>\n<p><strong>IDEA</strong></p>\n<p>国际数据加密算法(International Data Encryption Algorithm)。秘钥长度 128 位，优点没有专利的限制。</p>\n<p><strong>AES</strong></p>\n<p>当 DES 被破解以后，没过多久推出了 <strong>AES</strong> 算法，提供了三种长度供选择，128 位、192 位和 256，为了保证性能不受太大的影响，选择 128 即可。</p>\n<p><strong>SM1 和 SM4</strong></p>\n<p>之前几种都是国外的，我们国内自行研究了国密 **SM1 **和 <strong>SM4</strong>。其中 S 都属于国家标准，算法公开。优点就是国家的大力支持和认可</p>\n<p><strong>总结</strong> ：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/9e78eb3563d288234fcca7d8e918e798.png\" alt=\"\"></p>\n<h4> 常见的非对称加密算法有哪些？</h4>\n<p>在对称加密中，发送方与接收方使用相同的秘钥。那么在非对称加密中则是发送方与接收方使用的不同的秘钥。其主要解决的问题是防止在秘钥协商的过程中发生泄漏。比如在对称加密中，小蓝将需要发送的消息加密，然后告诉你密码是 123balala,ok,对于其他人而言，很容易就能劫持到密码是 123balala。那么在非对称的情况下，小蓝告诉所有人密码是 123balala,对于中间人而言，拿到也没用，因为没有私钥。所以，非对称密钥其实主要解决了密钥分发的难题。如下图</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/9da412ceb3b69c26403064b2f68c489b.png\" alt=\"\"></p>\n<p>其实我们经常都在使用非对称加密，比如使用多台服务器搭建大数据平台 hadoop，为了方便多台机器设置免密登录，是不是就会涉及到秘钥分发。再比如搭建 docker 集群也会使用相关非对称加密算法。</p>\n<p>常见的非对称加密算法：</p>\n<ul>\n<li>\n<p>RSA（RSA 加密算法，RSA Algorithm）：优势是性能比较快，如果想要较高的加密难度，需要很长的秘钥。</p>\n</li>\n<li>\n<p>ECC：基于椭圆曲线提出。是目前加密强度最高的非对称加密算法</p>\n</li>\n<li>\n<p>SM2：同样基于椭圆曲线问题设计。最大优势就是国家认可和大力支持。</p>\n</li>\n</ul>\n<p>总结：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/b99d66ac3f012643bb56d7ea36e3ddad.png\" alt=\"\"></p>\n<h4> 常见的散列算法有哪些？</h4>\n<p>这个大家应该更加熟悉了，比如我们平常使用的 MD5 校验，在很多时候，我并不是拿来进行加密，而是用来获得唯一性 ID。在做系统的过程中，存储用户的各种密码信息，通常都会通过散列算法，最终存储其散列值。</p>\n<p><strong>MD5</strong></p>\n<p>MD5 可以用来生成一个 128 位的消息摘要，它是目前应用比较普遍的散列算法，具体的应用场景你可以自行  参阅。虽然，因为算法的缺陷，它的唯一性已经被破解了，但是大部分场景下，这并不会构成安全问题。但是，如果不是长度受限（32 个字符），我还是不推荐你继续使用 <strong>MD5</strong> 的。</p>\n<p><strong>SHA</strong></p>\n<p>安全散列算法。<strong>SHA</strong> 分为 <strong>SHA1</strong> 和 <strong>SH2</strong> 两个版本。该算法的思想是接收一段明文，然后以一种不可逆的方式将它转换成一段（通常更小）密文，也可以简单的理解为取一串输入码（称为预映射或信息），并把它们转化为长度较短、位数固定的输出序列即散列值（也称为信息摘要或信息认证代码）的过程。</p>\n<p><strong>SM3</strong></p>\n<p>国密算法<strong>SM3</strong>。加密强度和 SHA-256 想不多。主要是收到国家的支持。</p>\n<p><strong>总结</strong> ：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/d8cca76a1e4998c9cad701ccf3fc7647.png\" alt=\"图片\"></p>\n<p><strong>大部分情况下使用对称加密，具有比较不错的安全性。如果需要分布式进行秘钥分发，考虑非对称。如果不需要可逆计算则散列算法。</strong> 因为这段时间有这方面需求，就看了一些这方面的资料，入坑信息安全，就怕以后洗发水都不用买。谢谢大家查看！</p>\n<h4> 第三方机构和证书机制有什么用？</h4>\n<p>问题还有，此时如果 Sum 否认给过 Mike 的公钥和合同，不久 gg 了</p>\n<p>所以需要 Sum 过的话做过的事儿需要足够的信誉，这就引入了 <strong>第三方机构和证书机制</strong> 。</p>\n<p>证书之所以会有信用，是因为证书的签发方拥有信用。所以如果 Sum 想让 Mike 承认自己的公钥，Sum 不会直接将公钥给 Mike ，而是提供由第三方机构，含有公钥的证书。如果 Mike 也信任这个机构，法律都认可，那 ik，信任关系成立</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/26a967ce97a857168e76c2d30c054ad3.png\" alt=\"\"></p>\n<p>如上图所示，Sum 将自己的申请提交给机构，产生证书的原文。机构用自己的私钥签名 Sum 的申请原文（先根据原文内容计算摘要，再用私钥加密），得到带有签名信息的证书。Mike 拿到带签名信息的证书，通过第三方机构的公钥进行解密，获得 Sum 证书的摘要、证书的原文。有了 Sum 证书的摘要和原文，Mike 就可以进行验签。验签通过，Mike 就可以确认 Sum 的证书的确是第三方机构签发的。</p>\n<p>用上面这样一个机制，合同的双方都无法否认合同。这个解决方案的核心在于需要第三方信用服务机构提供信用背书。这里产生了一个最基础的信任链，如果第三方机构的信任崩溃，比如被黑客攻破，那整条信任链条也就断裂了</p>\n<p>为了让这个信任条更加稳固，就需要环环相扣，打造更长的信任链，避免单点信任风险</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/64b9a566e397675dc948d3f34b57c412.png\" alt=\"\"></p>\n<p>上图中，由信誉最好的根证书机构提供根证书，然后根证书机构去签发二级机构的证书；二级机构去签发三级机构的证书；最后有由三级机构去签发 Sum 证书。</p>\n<p>如果要验证 Sum 证书的合法性，就需要用三级机构证书中的公钥去解密 Sum 证书的数字签名。</p>\n<p>如果要验证三级机构证书的合法性，就需要用二级机构的证书去解密三级机构证书的数字签名。</p>\n<p>如果要验证二级结构证书的合法性，就需要用根证书去解密。</p>\n<p>以上，就构成了一个相对长一些的信任链。如果其中一方想要作弊是非常困难的，除非链条中的所有机构同时联合起来，进行欺诈。</p>\n<h3> 中间人攻击如何避免?</h3>\n<p>既然知道了中间人攻击的原理也知道了他的危险，现在我们看看如何避免。相信我们都遇到过下面这种状况：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/c310fc8ccb7a1574a44e0a08d524df0b.png\" alt=\"\"></p>\n<p>出现这个界面的很多情况下，都是遇到了中间人攻击的现象，需要对安全证书进行及时地监测。而且大名鼎鼎的 github 网站，也曾遭遇过中间人攻击：</p>\n<p>想要避免中间人攻击的方法目前主要有两个：</p>\n<ul>\n<li>客户端不要轻易相信证书：因为这些证书极有可能是中间人。</li>\n<li>App 可以提前预埋证书在本地：意思是我们本地提前有一些证书，这样其他证书就不能再起作用了。</li>\n</ul>\n<h2> DDOS</h2>\n<p>通过上面的描述，总之即好多种攻击都是 <strong>DDOS</strong> 攻击，所以简单总结下这个攻击相关内容。</p>\n<p>其实，像全球互联网各大公司，均遭受过大量的 <strong>DDoS</strong>。</p>\n<p>2018 年，GitHub 在一瞬间遭到高达 1.35Tbps 的带宽攻击。这次 DDoS 攻击几乎可以堪称是互联网有史以来规模最大、威力最大的 DDoS 攻击了。在 GitHub 遭到攻击后，仅仅一周后，DDoS 攻击又开始对 Google、亚马逊甚至 Pornhub 等网站进行了 DDoS 攻击。后续的 DDoS 攻击带宽最高也达到了 1Tbps。</p>\n<h3> DDoS 攻击究竟是什么？</h3>\n<p>DDos 全名 Distributed Denial of Service，翻译成中文就是<strong>分布式拒绝服务</strong>。指的是处于不同位置的多个攻击者同时向一个或数个目标发动攻击，是一种分布的、协同的大规模攻击方式。单一的 DoS 攻击一般是采用一对一方式的，它利用网络协议和操作系统的一些缺陷，采用<strong>欺骗和伪装</strong>的策略来进行网络攻击，使网站服务器充斥大量要求回复的信息，消耗网络带宽或系统资源，导致网络或系统不胜负荷以至于瘫痪而停止提供正常的网络服务。</p>\n<blockquote>\n<p>举个例子</p>\n</blockquote>\n<p>我开了一家有五十个座位的重庆火锅店，由于用料上等，童叟无欺。平时门庭若市，生意特别红火，而对面二狗家的火锅店却无人问津。二狗为了对付我，想了一个办法，叫了五十个人来我的火锅店坐着却不点菜，让别的客人无法吃饭。</p>\n<p>上面这个例子讲的就是典型的 DDoS 攻击，一般来说是指攻击者利用“肉鸡”对目标网站在较短的时间内发起大量请求，大规模消耗目标网站的主机资源，让它无法正常服务。在线游戏、互联网金融等领域是 DDoS 攻击的高发行业。</p>\n<p>攻击方式很多，比如 <strong>ICMP Flood</strong>、<strong>UDP Flood</strong>、<strong>NTP Flood</strong>、<strong>SYN Flood</strong>、<strong>CC 攻击</strong>、<strong>DNS Query Flood</strong>等等。</p>\n<h3> 如何应对 DDoS 攻击？</h3>\n<h4> 高防服务器</h4>\n<p>还是拿开的重庆火锅店举例，高防服务器就是我给重庆火锅店增加了两名保安，这两名保安可以让保护店铺不受流氓骚扰，并且还会定期在店铺周围巡逻防止流氓骚扰。</p>\n<p>高防服务器主要是指能独立硬防御 50Gbps 以上的服务器，能够帮助网站拒绝服务攻击，定期扫描网络主节点等，这东西是不错，就是贵~</p>\n<h4> 黑名单</h4>\n<p>面对火锅店里面的流氓，我一怒之下将他们拍照入档，并禁止他们踏入店铺，但是有的时候遇到长得像的人也会禁止他进入店铺。这个就是设置黑名单，此方法秉承的就是“错杀一千，也不放一百”的原则，会封锁正常流量，影响到正常业务。</p>\n<h4> DDoS 清洗</h4>\n<p><strong>DDos</strong> 清洗，就是我发现客人进店几分钟以后，但是一直不点餐，我就把他踢出店里。</p>\n<p><strong>DDoS</strong> 清洗会对用户请求数据进行实时监控，及时发现 <strong>DOS</strong> 攻击等异常流量，在不影响正常业务开展的情况下清洗掉这些异常流量。</p>\n<h4> CDN 加速</h4>\n<p>CDN 加速，我们可以这么理解：为了减少流氓骚扰，我干脆将火锅店开到了线上，承接外卖服务，这样流氓找不到店在哪里，也耍不来流氓了。</p>\n<p>在现实中，CDN 服务将网站访问流量分配到了各个节点中，这样一方面隐藏网站的真实 IP，另一方面即使遭遇 <strong>DDoS</strong> 攻击，也可以将流量分散到各个节点中，防止源站崩溃。</p>\n<h2> 参考</h2>\n<ul>\n<li>HTTP 洪水攻击 - CloudFlare：https://www.cloudflare.com/zh-cn/learning/ddos/http-flood-ddos-attack/</li>\n<li>SYN 洪水攻击：https://www.cloudflare.com/zh-cn/learning/ddos/syn-flood-ddos-attack/</li>\n<li>什么是 IP 欺骗？：https://www.cloudflare.com/zh-cn/learning/ddos/glossary/ip-spoofing/</li>\n<li>什么是 DNS 洪水？| DNS 洪水 DDoS 攻击：https://www.cloudflare.com/zh-cn/learning/ddos/dns-flood-ddos-attack/</li>\n</ul>\n",
      "image": "https://img-blog.csdnimg.cn/img_convert/121f4f0c88f51a309a2c0566c0508034.png",
      "date_published": "2023-02-19T09:28:45.000Z",
      "date_modified": "2023-03-05T02:28:51.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "计算机基础"
      ]
    },
    {
      "title": "SQL常见面试题总结",
      "url": "https://javaguide.cn/database/sql/sql-questions-01.html",
      "id": "https://javaguide.cn/database/sql/sql-questions-01.html",
      "summary": "题目来源于：牛客题霸 - SQL 必知必会 检索数据 select 用于从数据库中查询数据。 从 Customers 表中检索所有的 ID 现有表 Customers 如下：",
      "content_html": "<blockquote>\n<p>题目来源于：<a href=\"https://www.nowcoder.com/exam/oj?page=1&amp;tab=SQL%E7%AF%87&amp;topicId=298\" target=\"_blank\" rel=\"noopener noreferrer\">牛客题霸 - SQL 必知必会</a></p>\n</blockquote>\n<h2> 检索数据</h2>\n<p><code>select</code> 用于从数据库中查询数据。</p>\n<h3> 从 Customers 表中检索所有的 ID</h3>\n<p>现有表 <code>Customers</code> 如下：</p>\n<table>\n<thead>\n<tr>\n<th>cust_id</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>A</td>\n</tr>\n<tr>\n<td>B</td>\n</tr>\n<tr>\n<td>C</td>\n</tr>\n</tbody>\n</table>\n<p>编写 SQL 语句，从 <code>Customers</code> 表中检索所有的 <code>cust_id</code>。</p>\n<p>答案：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 检索并列出已订购产品的清单</h3>\n<p>表 <code>OrderItems</code> 含有非空的列 <code>prod_id</code> 代表商品 id，包含了所有已订购的商品（有些已被订购多次）。</p>\n<table>\n<thead>\n<tr>\n<th>prod_id</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a1</td>\n</tr>\n<tr>\n<td>a2</td>\n</tr>\n<tr>\n<td>a3</td>\n</tr>\n<tr>\n<td>a4</td>\n</tr>\n<tr>\n<td>a5</td>\n</tr>\n<tr>\n<td>a6</td>\n</tr>\n<tr>\n<td>a7</td>\n</tr>\n</tbody>\n</table>\n<p>编写 SQL 语句，检索并列出所有已订购商品（<code>prod_id</code>）的去重后的清单。</p>\n<p>答案：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>知识点：<code>distinct</code> 用于返回列中的唯一不同值。</p>\n<h3> 检索所有列</h3>\n<p>现在有 <code>Customers</code> 表（表中含有列 <code>cust_id</code> 代表客户 id，<code>cust_name</code> 代表客户姓名）</p>\n<table>\n<thead>\n<tr>\n<th>cust_id</th>\n<th>cust_name</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a1</td>\n<td>andy</td>\n</tr>\n<tr>\n<td>a2</td>\n<td>ben</td>\n</tr>\n<tr>\n<td>a3</td>\n<td>tony</td>\n</tr>\n<tr>\n<td>a4</td>\n<td>tom</td>\n</tr>\n<tr>\n<td>a5</td>\n<td>an</td>\n</tr>\n<tr>\n<td>a6</td>\n<td>lee</td>\n</tr>\n<tr>\n<td>a7</td>\n<td>hex</td>\n</tr>\n</tbody>\n</table>\n<p>需要编写 SQL 语句，检索所有列。</p>\n<p>答案：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 排序检索数据</h2>\n<p><code>order by</code> 用于对结果集按照一个列或者多个列进行排序。默认按照升序对记录进行排序，如果需要按照降序对记录进行排序，可以使用 <code>desc</code> 关键字。</p>\n<h3> 检索顾客名称并且排序</h3>\n<p>有表 <code>Customers</code>，<code>cust_id</code> 代表客户 id，<code>cust_name</code> 代表客户姓名。</p>\n<table>\n<thead>\n<tr>\n<th>cust_id</th>\n<th>cust_name</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a1</td>\n<td>andy</td>\n</tr>\n<tr>\n<td>a2</td>\n<td>ben</td>\n</tr>\n<tr>\n<td>a3</td>\n<td>tony</td>\n</tr>\n<tr>\n<td>a4</td>\n<td>tom</td>\n</tr>\n<tr>\n<td>a5</td>\n<td>an</td>\n</tr>\n<tr>\n<td>a6</td>\n<td>lee</td>\n</tr>\n<tr>\n<td>a7</td>\n<td>hex</td>\n</tr>\n</tbody>\n</table>\n<p>从 <code>Customers</code> 中检索所有的顾客名称（<code>cust_name</code>），并按从 Z 到 A 的顺序显示结果。</p>\n<p>答案：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 对顾客 ID 和日期排序</h3>\n<p>有 <code>Orders</code> 表：</p>\n<table>\n<thead>\n<tr>\n<th>cust_id</th>\n<th>order_num</th>\n<th>order_date</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>andy</td>\n<td>aaaa</td>\n<td>2021-01-01 00:00:00</td>\n</tr>\n<tr>\n<td>andy</td>\n<td>bbbb</td>\n<td>2021-01-01 12:00:00</td>\n</tr>\n<tr>\n<td>bob</td>\n<td>cccc</td>\n<td>2021-01-10 12:00:00</td>\n</tr>\n<tr>\n<td>dick</td>\n<td>dddd</td>\n<td>2021-01-11 00:00:00</td>\n</tr>\n</tbody>\n</table>\n<p>编写 SQL 语句，从 <code>Orders</code> 表中检索顾客 ID（<code>cust_id</code>）和订单号（<code>order_num</code>），并先按顾客 ID 对结果进行排序，再按订单日期倒序排列。</p>\n<p>答案：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>知识点：<code>order by</code> 对多列排序的时候，先排序的列放前面，后排序的列放后面。并且，不同的列可以有不同的排序规则。</p>\n<h3> 按照数量和价格排序</h3>\n<p>假设有一个 <code>OrderItems</code> 表：</p>\n<table>\n<thead>\n<tr>\n<th>quantity</th>\n<th>item_price</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>100</td>\n</tr>\n<tr>\n<td>10</td>\n<td>1003</td>\n</tr>\n<tr>\n<td>2</td>\n<td>500</td>\n</tr>\n</tbody>\n</table>\n<p>编写 SQL 语句，显示 <code>OrderItems</code> 表中的数量（<code>quantity</code>）和价格（<code>item_price</code>），并按数量由多到少、价格由高到低排序。</p>\n<p>答案：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 检查 SQL 语句</h3>\n<p>有 <code>Vendors</code> 表：</p>\n<table>\n<thead>\n<tr>\n<th>vend_name</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>海底捞</td>\n</tr>\n<tr>\n<td>小龙坎</td>\n</tr>\n<tr>\n<td>大龙燚</td>\n</tr>\n</tbody>\n</table>\n<p>下面的 SQL 语句有问题吗？尝试将它改正确，使之能够正确运行，并且返回结果根据<code>vend_name</code> 逆序排列。</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>改正后：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>知识点：</p>\n<ul>\n<li>逗号作用是用来隔开列与列之间的。</li>\n<li>order by 是有 by 的，需要撰写完整，且位置正确。</li>\n</ul>\n<h2> 过滤数据</h2>\n<p><code>where</code> 可以过滤返回的数据。</p>\n<p>下面的运算符可以在 <code>where</code> 子句中使用：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">运算符</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">=</td>\n<td style=\"text-align:left\">等于</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&lt;&gt;</td>\n<td style=\"text-align:left\">不等于。**注释：**在 SQL 的一些版本中，该操作符可被写成 !=</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&gt;</td>\n<td style=\"text-align:left\">大于</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&lt;</td>\n<td style=\"text-align:left\">小于</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&gt;=</td>\n<td style=\"text-align:left\">大于等于</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&lt;=</td>\n<td style=\"text-align:left\">小于等于</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">BETWEEN</td>\n<td style=\"text-align:left\">在某个范围内</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">LIKE</td>\n<td style=\"text-align:left\">搜索某种模式</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">IN</td>\n<td style=\"text-align:left\">指定针对某个列的多个可能值</td>\n</tr>\n</tbody>\n</table>\n<h3> 返回固定价格的产品</h3>\n<p>有表 <code>Products</code> ：</p>\n<table>\n<thead>\n<tr>\n<th>prod_id</th>\n<th>prod_name</th>\n<th>prod_price</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a0018</td>\n<td>sockets</td>\n<td>9.49</td>\n</tr>\n<tr>\n<td>a0019</td>\n<td>iphone13</td>\n<td>600</td>\n</tr>\n<tr>\n<td>b0018</td>\n<td>gucci t-shirts</td>\n<td>1000</td>\n</tr>\n</tbody>\n</table>\n<p>【问题】从 <code>Products</code> 表中检索产品 ID（<code>prod_id</code>）和产品名称（<code>prod_name</code>），只返回价格为 9.49 美元的产品。</p>\n<p>答案：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 返回更高价格的产品</h3>\n<p>有表 <code>Products</code> ：</p>\n<table>\n<thead>\n<tr>\n<th>prod_id</th>\n<th>prod_name</th>\n<th>prod_price</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a0018</td>\n<td>sockets</td>\n<td>9.49</td>\n</tr>\n<tr>\n<td>a0019</td>\n<td>iphone13</td>\n<td>600</td>\n</tr>\n<tr>\n<td>b0019</td>\n<td>gucci t-shirts</td>\n<td>1000</td>\n</tr>\n</tbody>\n</table>\n<p>【问题】编写 SQL 语句，从 <code>Products</code> 表中检索产品 ID（<code>prod_id</code>）和产品名称（<code>prod_name</code>），只返回价格为 9 美元或更高的产品。</p>\n<p>答案：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 返回产品并且按照价格排序</h3>\n<p>有表 <code>Products</code> ：</p>\n<table>\n<thead>\n<tr>\n<th>prod_id</th>\n<th>prod_name</th>\n<th>prod_price</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a0011</td>\n<td>egg</td>\n<td>3</td>\n</tr>\n<tr>\n<td>a0019</td>\n<td>sockets</td>\n<td>4</td>\n</tr>\n<tr>\n<td>b0019</td>\n<td>coffee</td>\n<td>15</td>\n</tr>\n</tbody>\n</table>\n<p>【问题】编写 SQL 语句，返回 <code>Products</code> 表中所有价格在 3 美元到 6 美元之间的产品的名称（<code>prod_name</code>）和价格（<code>prod_price</code>），然后按价格对结果进行排序。</p>\n<p>答案：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 返回更多的产品</h3>\n<p><code>OrderItems</code> 表含有：订单号 <code>order_num</code>，<code>quantity</code>产品数量</p>\n<table>\n<thead>\n<tr>\n<th>order_num</th>\n<th>quantity</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a1</td>\n<td>105</td>\n</tr>\n<tr>\n<td>a2</td>\n<td>1100</td>\n</tr>\n<tr>\n<td>a2</td>\n<td>200</td>\n</tr>\n<tr>\n<td>a4</td>\n<td>1121</td>\n</tr>\n<tr>\n<td>a5</td>\n<td>10</td>\n</tr>\n<tr>\n<td>a2</td>\n<td>19</td>\n</tr>\n<tr>\n<td>a7</td>\n<td>5</td>\n</tr>\n</tbody>\n</table>\n<p>【问题】从 <code>OrderItems</code> 表中检索出所有不同且不重复的订单号（<code>order_num</code>），其中每个订单都要包含 100 个或更多的产品。</p>\n<p>答案：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 高级数据过滤</h2>\n<p><code>and</code> 和 <code>or</code> 运算符用于基于一个以上的条件对记录进行过滤，两者可以结合使用。<code>and</code> 必须 2 个条件都成立，<code>or</code>只要 2 个条件中的一个成立即可。</p>\n<h3> 检索供应商名称</h3>\n<p><code>Vendors</code> 表有字段供应商名称（<code>vend_name</code>）、供应商国家（<code>vend_country</code>）、供应商州（<code>vend_state</code>）</p>\n<table>\n<thead>\n<tr>\n<th>vend_name</th>\n<th>vend_country</th>\n<th>vend_state</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>apple</td>\n<td>USA</td>\n<td>CA</td>\n</tr>\n<tr>\n<td>vivo</td>\n<td>CNA</td>\n<td>shenzhen</td>\n</tr>\n<tr>\n<td>huawei</td>\n<td>CNA</td>\n<td>xian</td>\n</tr>\n</tbody>\n</table>\n<p>【问题】编写 SQL 语句，从 <code>Vendors</code> 表中检索供应商名称（<code>vend_name</code>），仅返回加利福尼亚州的供应商（这需要按国家[USA]和州[CA]进行过滤，没准其他国家也存在一个 CA）</p>\n<p>答案：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 检索并列出已订购产品的清单</h3>\n<p><code>OrderItems</code> 表包含了所有已订购的产品（有些已被订购多次）。</p>\n<table>\n<thead>\n<tr>\n<th>prod_id</th>\n<th>order_num</th>\n<th>quantity</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>BR01</td>\n<td>a1</td>\n<td>105</td>\n</tr>\n<tr>\n<td>BR02</td>\n<td>a2</td>\n<td>1100</td>\n</tr>\n<tr>\n<td>BR02</td>\n<td>a2</td>\n<td>200</td>\n</tr>\n<tr>\n<td>BR03</td>\n<td>a4</td>\n<td>1121</td>\n</tr>\n<tr>\n<td>BR017</td>\n<td>a5</td>\n<td>10</td>\n</tr>\n<tr>\n<td>BR02</td>\n<td>a2</td>\n<td>19</td>\n</tr>\n<tr>\n<td>BR017</td>\n<td>a7</td>\n<td>5</td>\n</tr>\n</tbody>\n</table>\n<p>【问题】编写 SQL 语句，查找所有订购了数量至少 100 个的 <code>BR01</code>、<code>BR02</code> 或 <code>BR03</code> 的订单。你需要返回 <code>OrderItems</code> 表的订单号（<code>order_num</code>）、产品 ID（<code>prod_id</code>）和数量（<code>quantity</code>），并按产品 ID 和数量进行过滤。</p>\n<p>答案：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 返回所有价格在 3 美元到 6 美元之间的产品的名称和价格</h3>\n<p>有表 <code>Products</code>：</p>\n<table>\n<thead>\n<tr>\n<th>prod_id</th>\n<th>prod_name</th>\n<th>prod_price</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a0011</td>\n<td>egg</td>\n<td>3</td>\n</tr>\n<tr>\n<td>a0019</td>\n<td>sockets</td>\n<td>4</td>\n</tr>\n<tr>\n<td>b0019</td>\n<td>coffee</td>\n<td>15</td>\n</tr>\n</tbody>\n</table>\n<p>【问题】编写 SQL 语句，返回所有价格在 3 美元到 6 美元之间的产品的名称（<code>prod_name</code>）和价格（<code>prod_price</code>），使用 AND 操作符，然后按价格对结果进行升序排序。</p>\n<p>答案：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 检查 SQL 语句</h3>\n<p>供应商表 <code>Vendors</code> 有字段供应商名称 <code>vend_name</code>、供应商国家 <code>vend_country</code>、供应商省份 <code>vend_state</code></p>\n<table>\n<thead>\n<tr>\n<th>vend_name</th>\n<th>vend_country</th>\n<th>vend_state</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>apple</td>\n<td>USA</td>\n<td>CA</td>\n</tr>\n<tr>\n<td>vivo</td>\n<td>CNA</td>\n<td>shenzhen</td>\n</tr>\n<tr>\n<td>huawei</td>\n<td>CNA</td>\n<td>xian</td>\n</tr>\n</tbody>\n</table>\n<p>【问题】修改正确下面 sql，使之正确返回。</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>修改后：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>order by</code> 语句必须放在 where 之后。</p>\n<h2> 用通配符进行过滤</h2>\n<p>SQL 通配符必须与 <code>LIKE</code> 运算符一起使用</p>\n<p>在 SQL 中，可使用以下通配符：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">通配符</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>%</code></td>\n<td style=\"text-align:left\">代表零个或多个字符</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>_</code></td>\n<td style=\"text-align:left\">仅替代一个字符</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>[charlist]</code></td>\n<td style=\"text-align:left\">字符列中的任何单一字符</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>[^charlist]</code> 或者 <code>[!charlist]</code></td>\n<td style=\"text-align:left\">不在字符列中的任何单一字符</td>\n</tr>\n</tbody>\n</table>\n<h3> 检索产品名称和描述（一）</h3>\n<p><code>Products</code> 表如下：</p>\n<table>\n<thead>\n<tr>\n<th>prod_name</th>\n<th>prod_desc</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a0011</td>\n<td>usb</td>\n</tr>\n<tr>\n<td>a0019</td>\n<td>iphone13</td>\n</tr>\n<tr>\n<td>b0019</td>\n<td>gucci t-shirts</td>\n</tr>\n<tr>\n<td>c0019</td>\n<td>gucci toy</td>\n</tr>\n<tr>\n<td>d0019</td>\n<td>lego toy</td>\n</tr>\n</tbody>\n</table>\n<p>【问题】编写 SQL 语句，从 <code>Products</code> 表中检索产品名称（<code>prod_name</code>）和描述（<code>prod_desc</code>），仅返回描述中包含 <code>toy</code> 一词的产品名称。</p>\n<p>答案：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 检索产品名称和描述（二）</h3>\n<p><code>Products</code> 表如下：</p>\n<table>\n<thead>\n<tr>\n<th>prod_name</th>\n<th>prod_desc</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a0011</td>\n<td>usb</td>\n</tr>\n<tr>\n<td>a0019</td>\n<td>iphone13</td>\n</tr>\n<tr>\n<td>b0019</td>\n<td>gucci t-shirts</td>\n</tr>\n<tr>\n<td>c0019</td>\n<td>gucci toy</td>\n</tr>\n<tr>\n<td>d0019</td>\n<td>lego toy</td>\n</tr>\n</tbody>\n</table>\n<p>【问题】编写 SQL 语句，从 <code>Products</code> 表中检索产品名称（<code>prod_name</code>）和描述（<code>prod_desc</code>），仅返回描述中未出现 <code>toy</code> 一词的产品，最后按”产品名称“对结果进行排序。</p>\n<p>答案：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 检索产品名称和描述（三）</h3>\n<p><code>Products</code> 表如下：</p>\n<table>\n<thead>\n<tr>\n<th>prod_name</th>\n<th>prod_desc</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a0011</td>\n<td>usb</td>\n</tr>\n<tr>\n<td>a0019</td>\n<td>iphone13</td>\n</tr>\n<tr>\n<td>b0019</td>\n<td>gucci t-shirts</td>\n</tr>\n<tr>\n<td>c0019</td>\n<td>gucci toy</td>\n</tr>\n<tr>\n<td>d0019</td>\n<td>lego carrots toy</td>\n</tr>\n</tbody>\n</table>\n<p>【问题】编写 SQL 语句，从 <code>Products</code> 表中检索产品名称（<code>prod_name</code>）和描述（<code>prod_desc</code>），仅返回描述中同时出现 <code>toy</code> 和 <code>carrots</code> 的产品。有好几种方法可以执行此操作，但对于这个挑战题，请使用 <code>AND</code> 和两个 <code>LIKE</code> 比较。</p>\n<p>答案：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 检索产品名称和描述（四）</h3>\n<p><code>Products</code> 表如下：</p>\n<table>\n<thead>\n<tr>\n<th>prod_name</th>\n<th>prod_desc</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a0011</td>\n<td>usb</td>\n</tr>\n<tr>\n<td>a0019</td>\n<td>iphone13</td>\n</tr>\n<tr>\n<td>b0019</td>\n<td>gucci t-shirts</td>\n</tr>\n<tr>\n<td>c0019</td>\n<td>gucci toy</td>\n</tr>\n<tr>\n<td>d0019</td>\n<td>lego toy carrots</td>\n</tr>\n</tbody>\n</table>\n<p>【问题】编写 SQL 语句，从 Products 表中检索产品名称（prod_name）和描述（prod_desc），仅返回在描述中以<strong>先后顺序</strong>同时出现 toy 和 carrots 的产品。提示：只需要用带有三个 <code>%</code> 符号的 <code>LIKE</code> 即可。</p>\n<p>答案：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 创建计算字段</h2>\n<h3> 别名</h3>\n<p>别名的常见用法是在检索出的结果中重命名表的列字段（为了符合特定的报表要求或客户需求）。有表 <code>Vendors</code> 代表供应商信息，<code>vend_id</code> 供应商 id、<code>vend_name</code> 供应商名称、<code>vend_address</code> 供应商地址、<code>vend_city</code> 供应商城市。</p>\n<table>\n<thead>\n<tr>\n<th>vend_id</th>\n<th>vend_name</th>\n<th>vend_address</th>\n<th>vend_city</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a001</td>\n<td>tencent cloud</td>\n<td>address1</td>\n<td>shenzhen</td>\n</tr>\n<tr>\n<td>a002</td>\n<td>huawei cloud</td>\n<td>address2</td>\n<td>dongguan</td>\n</tr>\n<tr>\n<td>a003</td>\n<td>aliyun cloud</td>\n<td>address3</td>\n<td>hangzhou</td>\n</tr>\n<tr>\n<td>a003</td>\n<td>netease cloud</td>\n<td>address4</td>\n<td>guangzhou</td>\n</tr>\n</tbody>\n</table>\n<p>【问题】编写 SQL 语句，从 <code>Vendors</code> 表中检索 <code>vend_id</code>、<code>vend_name</code>、<code>vend_address</code> 和 <code>vend_city</code>，将 <code>vend_name</code> 重命名为 <code>vname</code>，将 <code>vend_city</code> 重命名为 <code>vcity</code>，将 <code>vend_address</code> 重命名为 <code>vaddress</code>，按供应商名称对结果进行升序排序。</p>\n<p>答案：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 打折</h3>\n<p>我们的示例商店正在进行打折促销，所有产品均降价 10%。<code>Products</code> 表包含 <code>prod_id</code> 产品 id、<code>prod_price</code> 产品价格。</p>\n<p>【问题】编写 SQL 语句，从 <code>Products</code> 表中返回 <code>prod_id</code>、<code>prod_price</code> 和 <code>sale_price</code>。<code>sale_price</code> 是一个包含促销价格的计算字段。提示：可以乘以 0.9，得到原价的 90%（即 10%的折扣）。</p>\n<p>答案：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>注意：<code>sale_price</code> 是对计算结果的命名，而不是原有的列名。</p>\n<h2> 使用函数处理数据</h2>\n<h3> 顾客登录名</h3>\n<p>我们的商店已经上线了，正在创建顾客账户。所有用户都需要登录名，默认登录名是其名称和所在城市的组合。</p>\n<p>给出 <code>Customers</code> 表 如下：</p>\n<table>\n<thead>\n<tr>\n<th>cust_id</th>\n<th>cust_name</th>\n<th>cust_contact</th>\n<th>cust_city</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a1</td>\n<td>Andy Li</td>\n<td>Andy Li</td>\n<td>Oak Park</td>\n</tr>\n<tr>\n<td>a2</td>\n<td>Ben Liu</td>\n<td>Ben Liu</td>\n<td>Oak Park</td>\n</tr>\n<tr>\n<td>a3</td>\n<td>Tony Dai</td>\n<td>Tony Dai</td>\n<td>Oak Park</td>\n</tr>\n<tr>\n<td>a4</td>\n<td>Tom Chen</td>\n<td>Tom Chen</td>\n<td>Oak Park</td>\n</tr>\n<tr>\n<td>a5</td>\n<td>An Li</td>\n<td>An Li</td>\n<td>Oak Park</td>\n</tr>\n<tr>\n<td>a6</td>\n<td>Lee Chen</td>\n<td>Lee Chen</td>\n<td>Oak Park</td>\n</tr>\n<tr>\n<td>a7</td>\n<td>Hex Liu</td>\n<td>Hex Liu</td>\n<td>Oak Park</td>\n</tr>\n</tbody>\n</table>\n<p>【问题】编写 SQL 语句，返回顾客 ID（<code>cust_id</code>）、顾客名称（<code>cust_name</code>）和登录名（<code>user_login</code>），其中登录名全部为大写字母，并由顾客联系人的前两个字符（<code>cust_contact</code>）和其所在城市的前三个字符（<code>cust_city</code>）组成。提示：需要使用函数、拼接和别名。</p>\n<p>答案：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>知识点：</p>\n<ul>\n<li>\n<p>截取函数<code>substring()</code>：截取字符串，<code>substring(str ,n ,m)</code>：返回字符串 str 从第 n 个字符截取到第 m 个字符（左闭右闭）；</p>\n</li>\n<li>\n<p>拼接函数<code>concat()</code>：将两个或多个字符串连接成一个字符串，select concat(A,B) ：连接字符串 A 和 B。</p>\n</li>\n<li>\n<p>大写函数 <code>upper()</code>：将指定字符串转换为大写。</p>\n</li>\n</ul>\n<h3> 返回 2020 年 1 月的所有订单的订单号和订单日期</h3>\n<p><code>Orders</code> 订单表如下：</p>\n<table>\n<thead>\n<tr>\n<th>order_num</th>\n<th>order_date</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a0001</td>\n<td>2020-01-01 00:00:00</td>\n</tr>\n<tr>\n<td>a0002</td>\n<td>2020-01-02 00:00:00</td>\n</tr>\n<tr>\n<td>a0003</td>\n<td>2020-01-01 12:00:00</td>\n</tr>\n<tr>\n<td>a0004</td>\n<td>2020-02-01 00:00:00</td>\n</tr>\n<tr>\n<td>a0005</td>\n<td>2020-03-01 00:00:00</td>\n</tr>\n</tbody>\n</table>\n<p>【问题】编写 SQL 语句，返回 2020 年 1 月的所有订单的订单号（<code>order_num</code>）和订单日期（<code>order_date</code>），并按订单日期升序排序</p>\n<p>答案：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>也可以用通配符来做：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>知识点：</p>\n<ul>\n<li>日期格式：<code>YYYY-MM-DD</code></li>\n<li>时间格式：<code>HH:MM:SS</code></li>\n</ul>\n<p>日期和时间处理相关的常用函数：</p>\n<table>\n<thead>\n<tr>\n<th>函 数</th>\n<th>说 明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>adddate()</code></td>\n<td>增加一个日期（天、周等）</td>\n</tr>\n<tr>\n<td><code>addtime()</code></td>\n<td>增加一个时间（时、分等）</td>\n</tr>\n<tr>\n<td><code>curdate()</code></td>\n<td>返回当前日期</td>\n</tr>\n<tr>\n<td><code>curtime()</code></td>\n<td>返回当前时间</td>\n</tr>\n<tr>\n<td><code>date()</code></td>\n<td>返回日期时间的日期部分</td>\n</tr>\n<tr>\n<td><code>datediff()</code></td>\n<td>计算两个日期之差</td>\n</tr>\n<tr>\n<td><code>date_format()</code></td>\n<td>返回一个格式化的日期或时间串</td>\n</tr>\n<tr>\n<td><code>day()</code></td>\n<td>返回一个日期的天数部分</td>\n</tr>\n<tr>\n<td><code>dayofweek()</code></td>\n<td>对于一个日期，返回对应的星期几</td>\n</tr>\n<tr>\n<td><code>hour()</code></td>\n<td>返回一个时间的小时部分</td>\n</tr>\n<tr>\n<td><code>minute()</code></td>\n<td>返回一个时间的分钟部分</td>\n</tr>\n<tr>\n<td><code>month()</code></td>\n<td>返回一个日期的月份部分</td>\n</tr>\n<tr>\n<td><code>now()</code></td>\n<td>返回当前日期和时间</td>\n</tr>\n<tr>\n<td><code>second()</code></td>\n<td>返回一个时间的秒部分</td>\n</tr>\n<tr>\n<td><code>time()</code></td>\n<td>返回一个日期时间的时间部分</td>\n</tr>\n<tr>\n<td><code>year()</code></td>\n<td>返回一个日期的年份部分</td>\n</tr>\n</tbody>\n</table>\n<h2> 汇总数据</h2>\n<p>汇总数据相关的函数：</p>\n<table>\n<thead>\n<tr>\n<th>函 数</th>\n<th>说 明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>avg()</code></td>\n<td>返回某列的平均值</td>\n</tr>\n<tr>\n<td><code>count()</code></td>\n<td>返回某列的行数</td>\n</tr>\n<tr>\n<td><code>max()</code></td>\n<td>返回某列的最大值</td>\n</tr>\n<tr>\n<td><code>min()</code></td>\n<td>返回某列的最小值</td>\n</tr>\n<tr>\n<td><code>sum()</code></td>\n<td>返回某列值之和</td>\n</tr>\n</tbody>\n</table>\n<h3> 确定已售出产品的总数</h3>\n<p><code>OrderItems</code> 表代表售出的产品，<code>quantity</code> 代表售出商品数量。</p>\n<table>\n<thead>\n<tr>\n<th>quantity</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>10</td>\n</tr>\n<tr>\n<td>100</td>\n</tr>\n<tr>\n<td>1000</td>\n</tr>\n<tr>\n<td>10001</td>\n</tr>\n<tr>\n<td>2</td>\n</tr>\n<tr>\n<td>15</td>\n</tr>\n</tbody>\n</table>\n<p>【问题】编写 SQL 语句，确定已售出产品的总数。</p>\n<p>答案：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 确定已售出产品项 BR01 的总数</h3>\n<p><code>OrderItems</code> 表代表售出的产品，<code>quantity</code> 代表售出商品数量，产品项为 <code>prod_id</code>。</p>\n<table>\n<thead>\n<tr>\n<th>quantity</th>\n<th>prod_id</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>10</td>\n<td>AR01</td>\n</tr>\n<tr>\n<td>100</td>\n<td>AR10</td>\n</tr>\n<tr>\n<td>1000</td>\n<td>BR01</td>\n</tr>\n<tr>\n<td>10001</td>\n<td>BR010</td>\n</tr>\n</tbody>\n</table>\n<p>【问题】修改创建的语句，确定已售出产品项（<code>prod_id</code>）为\"BR01\"的总数。</p>\n<p>答案：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 确定 Products 表中价格不超过 10 美元的最贵产品的价格</h3>\n<p><code>Products</code> 表如下，<code>prod_price</code> 代表商品的价格。</p>\n<table>\n<thead>\n<tr>\n<th>prod_price</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>9.49</td>\n</tr>\n<tr>\n<td>600</td>\n</tr>\n<tr>\n<td>1000</td>\n</tr>\n</tbody>\n</table>\n<p>【问题】编写 SQL 语句，确定 <code>Products</code> 表中价格不超过 10 美元的最贵产品的价格（<code>prod_price</code>）。将计算所得的字段命名为 <code>max_price</code>。</p>\n<p>答案：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 分组数据</h2>\n<p><code>group by</code> ：</p>\n<ul>\n<li><code>group by</code> 子句将记录分组到汇总行中。</li>\n<li><code>group by</code> 为每个组返回一个记录。</li>\n<li><code>group by</code> 通常还涉及聚合<code>count</code>，<code>max</code>，<code>sum</code>，<code>avg</code> 等。</li>\n<li><code>group by</code> 可以按一列或多列进行分组。</li>\n<li><code>group by</code> 按分组字段进行排序后，<code>order by</code> 可以以汇总字段来进行排序。</li>\n</ul>\n<p><code>having</code>：</p>\n<ul>\n<li><code>having</code> 用于对汇总的 <code>group by</code> 结果进行过滤。</li>\n<li><code>having</code> 必须要与 <code>group by</code> 连用。</li>\n<li><code>where</code> 和 <code>having</code> 可以在相同的查询中。</li>\n</ul>\n<p><code>having</code> vs <code>where</code>：</p>\n<ul>\n<li><code>where</code>：过滤过滤指定的行，后面不能加聚合函数（分组函数）。</li>\n<li><code>having</code>：过滤分组，必须要与 <code>group by</code> 连用，不能单独使用。</li>\n</ul>\n<h3> 返回每个订单号各有多少行数</h3>\n<p><code>OrderItems</code> 表包含每个订单的每个产品</p>\n<table>\n<thead>\n<tr>\n<th>order_num</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a002</td>\n</tr>\n<tr>\n<td>a002</td>\n</tr>\n<tr>\n<td>a002</td>\n</tr>\n<tr>\n<td>a004</td>\n</tr>\n<tr>\n<td>a007</td>\n</tr>\n</tbody>\n</table>\n<p>【问题】编写 SQL 语句，返回每个订单号（<code>order_num</code>）各有多少行数（<code>order_lines</code>），并按 <code>order_lines</code> 对结果进行升序排序。</p>\n<p>答案：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>知识点：</p>\n<ol>\n<li><code>count(*)</code>,<code>count(列名)</code>都可以，区别在于，<code>count(列名)</code>是统计非 NULL 的行数；</li>\n<li><code>order by</code> 最后执行，所以可以使用列别名；</li>\n<li>分组聚合一定不要忘记加上 <code>group by</code> ,不然只会有一行结果。</li>\n</ol>\n<h3> 每个供应商成本最低的产品</h3>\n<p>有 <code>Products</code> 表，含有字段 <code>prod_price</code> 代表产品价格，<code>vend_id</code> 代表供应商 id</p>\n<table>\n<thead>\n<tr>\n<th>vend_id</th>\n<th>prod_price</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a0011</td>\n<td>100</td>\n</tr>\n<tr>\n<td>a0019</td>\n<td>0.1</td>\n</tr>\n<tr>\n<td>b0019</td>\n<td>1000</td>\n</tr>\n<tr>\n<td>b0019</td>\n<td>6980</td>\n</tr>\n<tr>\n<td>b0019</td>\n<td>20</td>\n</tr>\n</tbody>\n</table>\n<p>【问题】编写 SQL 语句，返回名为 <code>cheapest_item</code> 的字段，该字段包含每个供应商成本最低的产品（使用 <code>Products</code> 表中的 <code>prod_price</code>），然后从最低成本到最高成本对结果进行升序排序。</p>\n<p>答案：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 返回订单数量总和不小于 100 的所有订单的订单号</h3>\n<p><code>OrderItems</code> 代表订单商品表，包括：订单号 <code>order_num</code> 和订单数量 <code>quantity</code>。</p>\n<table>\n<thead>\n<tr>\n<th>order_num</th>\n<th>quantity</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a1</td>\n<td>105</td>\n</tr>\n<tr>\n<td>a2</td>\n<td>1100</td>\n</tr>\n<tr>\n<td>a2</td>\n<td>200</td>\n</tr>\n<tr>\n<td>a4</td>\n<td>1121</td>\n</tr>\n<tr>\n<td>a5</td>\n<td>10</td>\n</tr>\n<tr>\n<td>a2</td>\n<td>19</td>\n</tr>\n<tr>\n<td>a7</td>\n<td>5</td>\n</tr>\n</tbody>\n</table>\n<p>【问题】请编写 SQL 语句，返回订单数量总和不小于 100 的所有订单号，最后结果按照订单号升序排序。</p>\n<p>答案：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>知识点：</p>\n<ul>\n<li><code>where</code>：过滤过滤指定的行，后面不能加聚合函数（分组函数）。</li>\n<li><code>having</code>：过滤分组，与 <code>group by</code> 连用，不能单独使用。</li>\n</ul>\n<h3> 计算总和</h3>\n<p><code>OrderItems</code> 表代表订单信息，包括字段：订单号 <code>order_num</code> 和 <code>item_price</code> 商品售出价格、<code>quantity</code> 商品数量。</p>\n<table>\n<thead>\n<tr>\n<th>order_num</th>\n<th>item_price</th>\n<th>quantity</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a1</td>\n<td>10</td>\n<td>105</td>\n</tr>\n<tr>\n<td>a2</td>\n<td>1</td>\n<td>1100</td>\n</tr>\n<tr>\n<td>a2</td>\n<td>1</td>\n<td>200</td>\n</tr>\n<tr>\n<td>a4</td>\n<td>2</td>\n<td>1121</td>\n</tr>\n<tr>\n<td>a5</td>\n<td>5</td>\n<td>10</td>\n</tr>\n<tr>\n<td>a2</td>\n<td>1</td>\n<td>19</td>\n</tr>\n<tr>\n<td>a7</td>\n<td>7</td>\n<td>5</td>\n</tr>\n</tbody>\n</table>\n<p>【问题】编写 SQL 语句，根据订单号聚合，返回订单总价不小于 1000 的所有订单号，最后的结果按订单号进行升序排序。</p>\n<p>提示：总价 = item_price 乘以 quantity</p>\n<p>答案：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 检查 SQL 语句</h3>\n<p><code>OrderItems</code> 表含有 <code>order_num</code> 订单号</p>\n<table>\n<thead>\n<tr>\n<th>order_num</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a002</td>\n</tr>\n<tr>\n<td>a002</td>\n</tr>\n<tr>\n<td>a002</td>\n</tr>\n<tr>\n<td>a004</td>\n</tr>\n<tr>\n<td>a007</td>\n</tr>\n</tbody>\n</table>\n<p>【问题】将下面代码修改正确后执行</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>修改后：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 使用子查询</h2>\n<p>子查询是嵌套在较大查询中的 SQL 查询，也称内部查询或内部选择，包含子查询的语句也称为外部查询或外部选择。简单来说，子查询就是指将一个 <code>select</code> 查询（子查询）的结果作为另一个 SQL 语句（主查询）的数据来源或者判断条件。</p>\n<p>子查询可以嵌入 <code>select</code>、<code>insert</code>、<code>update</code> 和 <code>delete</code> 语句中，也可以和 <code>=</code>、<code>&lt;</code>、<code>&gt;</code>、<code>in</code>、<code>between</code>、<code>exists</code> 等运算符一起使用。</p>\n<p>子查询常用在 <code>where</code> 子句和 <code>from</code> 子句后边：</p>\n<ul>\n<li>当用于 <code>where</code> 子句时，根据不同的运算符，子查询可以返回单行单列、多行单列、单行多列数据。子查询就是要返回能够作为 WHERE 子句查询条件的值。</li>\n<li>当用于 <code>from</code> 子句时，一般返回多行多列数据，相当于返回一张临时表，这样才符合 <code>from</code> 后面是表的规则。这种做法能够实现多表联合查询。</li>\n</ul>\n<blockquote>\n<p>注意：MySQL 数据库从 4.1 版本才开始支持子查询，早期版本是不支持的。</p>\n</blockquote>\n<p>用于 <code>where</code> 子句的子查询的基本语法如下：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>子查询需要放在括号<code>( )</code>内。</li>\n<li><code>operator</code> 表示用于 where 子句的运算符。</li>\n</ul>\n<p>用于 <code>from</code> 子句的子查询的基本语法如下：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>用于 <code>from</code> 的子查询返回的结果相当于一张临时表，所以需要使用 AS 关键字为该临时表起一个名字。</p>\n<h3> 返回购买价格为 10 美元或以上产品的顾客列表</h3>\n<p><code>OrderItems</code> 表示订单商品表，含有字段订单号：<code>order_num</code>、订单价格：<code>item_price</code>；<code>Orders</code> 表代表订单信息表，含有顾客 <code>id：cust_id</code> 和订单号：<code>order_num</code></p>\n<p><code>OrderItems</code> 表:</p>\n<table>\n<thead>\n<tr>\n<th>order_num</th>\n<th>item_price</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a1</td>\n<td>10</td>\n</tr>\n<tr>\n<td>a2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>a2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>a4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>a5</td>\n<td>5</td>\n</tr>\n<tr>\n<td>a2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>a7</td>\n<td>7</td>\n</tr>\n</tbody>\n</table>\n<p><code>Orders</code> 表：</p>\n<table>\n<thead>\n<tr>\n<th>order_num</th>\n<th>cust_id</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a1</td>\n<td>cust10</td>\n</tr>\n<tr>\n<td>a2</td>\n<td>cust1</td>\n</tr>\n<tr>\n<td>a2</td>\n<td>cust1</td>\n</tr>\n<tr>\n<td>a4</td>\n<td>cust2</td>\n</tr>\n<tr>\n<td>a5</td>\n<td>cust5</td>\n</tr>\n<tr>\n<td>a2</td>\n<td>cust1</td>\n</tr>\n<tr>\n<td>a7</td>\n<td>cust7</td>\n</tr>\n</tbody>\n</table>\n<p>【问题】使用子查询，返回购买价格为 10 美元或以上产品的顾客列表，结果无需排序。</p>\n<p>答案：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 确定哪些订单购买了 prod_id 为 BR01 的产品（一）</h3>\n<p>表 <code>OrderItems</code> 代表订单商品信息表，<code>prod_id</code> 为产品 id；<code>Orders</code> 表代表订单表有 <code>cust_id</code> 代表顾客 id 和订单日期 <code>order_date</code></p>\n<p><code>OrderItems</code> 表：</p>\n<table>\n<thead>\n<tr>\n<th>prod_id</th>\n<th>order_num</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>BR01</td>\n<td>a0001</td>\n</tr>\n<tr>\n<td>BR01</td>\n<td>a0002</td>\n</tr>\n<tr>\n<td>BR02</td>\n<td>a0003</td>\n</tr>\n<tr>\n<td>BR02</td>\n<td>a0013</td>\n</tr>\n</tbody>\n</table>\n<p><code>Orders</code> 表：</p>\n<table>\n<thead>\n<tr>\n<th>order_num</th>\n<th>cust_id</th>\n<th>order_date</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a0001</td>\n<td>cust10</td>\n<td>2022-01-01 00:00:00</td>\n</tr>\n<tr>\n<td>a0002</td>\n<td>cust1</td>\n<td>2022-01-01 00:01:00</td>\n</tr>\n<tr>\n<td>a0003</td>\n<td>cust1</td>\n<td>2022-01-02 00:00:00</td>\n</tr>\n<tr>\n<td>a0013</td>\n<td>cust2</td>\n<td>2022-01-01 00:20:00</td>\n</tr>\n</tbody>\n</table>\n<p>【问题】</p>\n<p>编写 SQL 语句，使用子查询来确定哪些订单（在 <code>OrderItems</code> 中）购买了 <code>prod_id</code> 为 \"BR01\" 的产品，然后从 <code>Orders</code> 表中返回每个产品对应的顾客 ID（<code>cust_id</code>）和订单日期（<code>order_date</code>），按订购日期对结果进行升序排序。</p>\n<p>答案：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 返回购买 prod_id 为 BR01 的产品的所有顾客的电子邮件（一）</h3>\n<p>你想知道订购 BR01 产品的日期，有表 <code>OrderItems</code> 代表订单商品信息表，<code>prod_id</code> 为产品 id；<code>Orders</code> 表代表订单表有 <code>cust_id</code> 代表顾客 id 和订单日期 <code>order_date</code>；<code>Customers</code> 表含有 <code>cust_email</code> 顾客邮件和 <code>cust_id</code> 顾客 id</p>\n<p><code>OrderItems</code> 表：</p>\n<table>\n<thead>\n<tr>\n<th>prod_id</th>\n<th>order_num</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>BR01</td>\n<td>a0001</td>\n</tr>\n<tr>\n<td>BR01</td>\n<td>a0002</td>\n</tr>\n<tr>\n<td>BR02</td>\n<td>a0003</td>\n</tr>\n<tr>\n<td>BR02</td>\n<td>a0013</td>\n</tr>\n</tbody>\n</table>\n<p><code>Orders</code> 表：</p>\n<table>\n<thead>\n<tr>\n<th>order_num</th>\n<th>cust_id</th>\n<th>order_date</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a0001</td>\n<td>cust10</td>\n<td>2022-01-01 00:00:00</td>\n</tr>\n<tr>\n<td>a0002</td>\n<td>cust1</td>\n<td>2022-01-01 00:01:00</td>\n</tr>\n<tr>\n<td>a0003</td>\n<td>cust1</td>\n<td>2022-01-02 00:00:00</td>\n</tr>\n<tr>\n<td>a0013</td>\n<td>cust2</td>\n<td>2022-01-01 00:20:00</td>\n</tr>\n</tbody>\n</table>\n<p><code>Customers</code> 表代表顾客信息，<code>cust_id</code> 为顾客 id，<code>cust_email</code> 为顾客 email</p>\n<table>\n<thead>\n<tr>\n<th>cust_id</th>\n<th>cust_email</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>cust10</td>\n<td>cust10@cust.com</td>\n</tr>\n<tr>\n<td>cust1</td>\n<td>cust1@cust.com</td>\n</tr>\n<tr>\n<td>cust2</td>\n<td>cust2@cust.com</td>\n</tr>\n</tbody>\n</table>\n<p>【问题】返回购买 <code>prod_id</code> 为 <code>BR01</code> 的产品的所有顾客的电子邮件（<code>Customers</code> 表中的 <code>cust_email</code>），结果无需排序。</p>\n<p>提示：这涉及 <code>SELECT</code> 语句，最内层的从 <code>OrderItems</code> 表返回 <code>order_num</code>，中间的从 <code>Customers</code> 表返回 <code>cust_id</code>。</p>\n<p>答案：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 返回每个顾客不同订单的总金额</h3>\n<p>我们需要一个顾客 ID 列表，其中包含他们已订购的总金额。</p>\n<p><code>OrderItems</code> 表代表订单信息，<code>OrderItems</code> 表有订单号：<code>order_num</code> 和商品售出价格：<code>item_price</code>、商品数量：<code>quantity</code>。</p>\n<table>\n<thead>\n<tr>\n<th>order_num</th>\n<th>item_price</th>\n<th>quantity</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a0001</td>\n<td>10</td>\n<td>105</td>\n</tr>\n<tr>\n<td>a0002</td>\n<td>1</td>\n<td>1100</td>\n</tr>\n<tr>\n<td>a0002</td>\n<td>1</td>\n<td>200</td>\n</tr>\n<tr>\n<td>a0013</td>\n<td>2</td>\n<td>1121</td>\n</tr>\n<tr>\n<td>a0003</td>\n<td>5</td>\n<td>10</td>\n</tr>\n<tr>\n<td>a0003</td>\n<td>1</td>\n<td>19</td>\n</tr>\n<tr>\n<td>a0003</td>\n<td>7</td>\n<td>5</td>\n</tr>\n</tbody>\n</table>\n<p><code>Orders</code> 表订单号：<code>order_num</code>、顾客 id：<code>cust_id</code></p>\n<table>\n<thead>\n<tr>\n<th>order_num</th>\n<th>cust_id</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a0001</td>\n<td>cust10</td>\n</tr>\n<tr>\n<td>a0002</td>\n<td>cust1</td>\n</tr>\n<tr>\n<td>a0003</td>\n<td>cust1</td>\n</tr>\n<tr>\n<td>a0013</td>\n<td>cust2</td>\n</tr>\n</tbody>\n</table>\n<p>【问题】</p>\n<p>编写 SQL 语句，返回顾客 ID（<code>Orders</code> 表中的 <code>cust_id</code>），并使用子查询返回 <code>total_ordered</code> 以便返回每个顾客的订单总数，将结果按金额从大到小排序。</p>\n<p>答案：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 从 Products 表中检索所有的产品名称以及对应的销售总数</h3>\n<p><code>Products</code> 表中检索所有的产品名称：<code>prod_name</code>、产品 id：<code>prod_id</code></p>\n<table>\n<thead>\n<tr>\n<th>prod_id</th>\n<th>prod_name</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a0001</td>\n<td>egg</td>\n</tr>\n<tr>\n<td>a0002</td>\n<td>sockets</td>\n</tr>\n<tr>\n<td>a0013</td>\n<td>coffee</td>\n</tr>\n<tr>\n<td>a0003</td>\n<td>cola</td>\n</tr>\n</tbody>\n</table>\n<p><code>OrderItems</code> 代表订单商品表，订单产品：<code>prod_id</code>、售出数量：<code>quantity</code></p>\n<table>\n<thead>\n<tr>\n<th>prod_id</th>\n<th>quantity</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a0001</td>\n<td>105</td>\n</tr>\n<tr>\n<td>a0002</td>\n<td>1100</td>\n</tr>\n<tr>\n<td>a0002</td>\n<td>200</td>\n</tr>\n<tr>\n<td>a0013</td>\n<td>1121</td>\n</tr>\n<tr>\n<td>a0003</td>\n<td>10</td>\n</tr>\n<tr>\n<td>a0003</td>\n<td>19</td>\n</tr>\n<tr>\n<td>a0003</td>\n<td>5</td>\n</tr>\n</tbody>\n</table>\n<p>【问题】</p>\n<p>编写 SQL 语句，从 <code>Products</code> 表中检索所有的产品名称（<code>prod_name</code>），以及名为 <code>quant_sold</code> 的计算列，其中包含所售产品的总数（在 <code>OrderItems</code> 表上使用子查询和 <code>SUM(quantity)</code> 检索）。</p>\n<p>答案：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 连接表</h2>\n<p>JOIN 是“连接”的意思，顾名思义，SQL JOIN 子句用于将两个或者多个表联合起来进行查询。</p>\n<p>连接表时需要在每个表中选择一个字段，并对这些字段的值进行比较，值相同的两条记录将合并为一条。<strong>连接表的本质就是将不同表的记录合并起来，形成一张新表。当然，这张新表只是临时的，它仅存在于本次查询期间</strong>。</p>\n<p>使用 <code>JOIN</code> 连接两个表的基本语法如下：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>table1.common_column1 = table2.common_column2</code> 是连接条件，只有满足此条件的记录才会合并为一行。您可以使用多个运算符来连接表，例如 =、&gt;、&lt;、&lt;&gt;、&lt;=、&gt;=、!=、<code>between</code>、<code>like</code> 或者 <code>not</code>，但是最常见的是使用 =。</p>\n<p>当两个表中有同名的字段时，为了帮助数据库引擎区分是哪个表的字段，在书写同名字段名时需要加上表名。当然，如果书写的字段名在两个表中是唯一的，也可以不使用以上格式，只写字段名即可。</p>\n<p>另外，如果两张表的关联字段名相同，也可以使用 <code>USING</code>子句来代替 <code>ON</code>，举个例子：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong><code>ON</code> 和 <code>WHERE</code> 的区别</strong>：</p>\n<ul>\n<li>连接表时，SQL 会根据连接条件生成一张新的临时表。<code>ON</code> 就是连接条件，它决定临时表的生成。</li>\n<li><code>WHERE</code> 是在临时表生成以后，再对临时表中的数据进行过滤，生成最终的结果集，这个时候已经没有 JOIN-ON 了。</li>\n</ul>\n<p>所以总结来说就是：<strong>SQL 先根据 ON 生成一张临时表，然后再根据 WHERE 对临时表进行筛选</strong>。</p>\n<p>SQL 允许在 <code>JOIN</code> 左边加上一些修饰性的关键词，从而形成不同类型的连接，如下表所示：</p>\n<table>\n<thead>\n<tr>\n<th>连接类型</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>INNER JOIN 内连接</td>\n<td>（默认连接方式）只有当两个表都存在满足条件的记录时才会返回行。</td>\n</tr>\n<tr>\n<td>LEFT JOIN / LEFT OUTER JOIN 左(外)连接</td>\n<td>返回左表中的所有行，即使右表中没有满足条件的行也是如此。</td>\n</tr>\n<tr>\n<td>RIGHT JOIN / RIGHT OUTER JOIN 右(外)连接</td>\n<td>返回右表中的所有行，即使左表中没有满足条件的行也是如此。</td>\n</tr>\n<tr>\n<td>FULL JOIN / FULL OUTER JOIN 全(外)连接</td>\n<td>只要其中有一个表存在满足条件的记录，就返回行。</td>\n</tr>\n<tr>\n<td>SELF JOIN</td>\n<td>将一个表连接到自身，就像该表是两个表一样。为了区分两个表，在 SQL 语句中需要至少重命名一个表。</td>\n</tr>\n<tr>\n<td>CROSS JOIN</td>\n<td>交叉连接，从两个或者多个连接表中返回记录集的笛卡尔积。</td>\n</tr>\n</tbody>\n</table>\n<p>下图展示了 LEFT JOIN、RIGHT JOIN、INNER JOIN、OUTER JOIN 相关的 7 种用法。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/d1794312b448516831369f869814ab39.png\" alt=\"\"></p>\n<p>如果不加任何修饰词，只写 <code>JOIN</code>，那么默认为 <code>INNER JOIN</code></p>\n<p>对于 <code>INNER JOIN</code> 来说，还有一种隐式的写法，称为 “<strong>隐式内连接</strong>”，也就是没有 <code>INNER JOIN</code> 关键字，使用 <code>WHERE</code> 语句实现内连接的功能</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 返回顾客名称和相关订单号</h3>\n<p><code>Customers</code> 表有字段顾客名称 <code>cust_name</code>、顾客 id <code>cust_id</code></p>\n<table>\n<thead>\n<tr>\n<th>cust_id</th>\n<th>cust_name</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>cust10</td>\n<td>andy</td>\n</tr>\n<tr>\n<td>cust1</td>\n<td>ben</td>\n</tr>\n<tr>\n<td>cust2</td>\n<td>tony</td>\n</tr>\n<tr>\n<td>cust22</td>\n<td>tom</td>\n</tr>\n<tr>\n<td>cust221</td>\n<td>an</td>\n</tr>\n<tr>\n<td>cust2217</td>\n<td>hex</td>\n</tr>\n</tbody>\n</table>\n<p><code>Orders</code> 订单信息表，含有字段 <code>order_num</code> 订单号、<code>cust_id</code> 顾客 id</p>\n<table>\n<thead>\n<tr>\n<th>order_num</th>\n<th>cust_id</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a1</td>\n<td>cust10</td>\n</tr>\n<tr>\n<td>a2</td>\n<td>cust1</td>\n</tr>\n<tr>\n<td>a3</td>\n<td>cust2</td>\n</tr>\n<tr>\n<td>a4</td>\n<td>cust22</td>\n</tr>\n<tr>\n<td>a5</td>\n<td>cust221</td>\n</tr>\n<tr>\n<td>a7</td>\n<td>cust2217</td>\n</tr>\n</tbody>\n</table>\n<p>【问题】编写 SQL 语句，返回 <code>Customers</code> 表中的顾客名称（<code>cust_name</code>）和 <code>Orders</code> 表中的相关订单号（<code>order_num</code>），并按顾客名称再按订单号对结果进行升序排序。你可以尝试用两个不同的写法，一个使用简单的等连接语法，另外一个使用 INNER JOIN。</p>\n<p>答案：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 返回顾客名称和相关订单号以及每个订单的总价</h3>\n<p><code>Customers</code> 表有字段，顾客名称：<code>cust_name</code>、顾客 id：<code>cust_id</code></p>\n<table>\n<thead>\n<tr>\n<th>cust_id</th>\n<th>cust_name</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>cust10</td>\n<td>andy</td>\n</tr>\n<tr>\n<td>cust1</td>\n<td>ben</td>\n</tr>\n<tr>\n<td>cust2</td>\n<td>tony</td>\n</tr>\n<tr>\n<td>cust22</td>\n<td>tom</td>\n</tr>\n<tr>\n<td>cust221</td>\n<td>an</td>\n</tr>\n<tr>\n<td>cust2217</td>\n<td>hex</td>\n</tr>\n</tbody>\n</table>\n<p><code>Orders</code> 订单信息表，含有字段，订单号：<code>order_num</code>、顾客 id：<code>cust_id</code></p>\n<table>\n<thead>\n<tr>\n<th>order_num</th>\n<th>cust_id</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a1</td>\n<td>cust10</td>\n</tr>\n<tr>\n<td>a2</td>\n<td>cust1</td>\n</tr>\n<tr>\n<td>a3</td>\n<td>cust2</td>\n</tr>\n<tr>\n<td>a4</td>\n<td>cust22</td>\n</tr>\n<tr>\n<td>a5</td>\n<td>cust221</td>\n</tr>\n<tr>\n<td>a7</td>\n<td>cust2217</td>\n</tr>\n</tbody>\n</table>\n<p><code>OrderItems</code> 表有字段，商品订单号：<code>order_num</code>、商品数量：<code>quantity</code>、商品价格：<code>item_price</code></p>\n<table>\n<thead>\n<tr>\n<th>order_num</th>\n<th>quantity</th>\n<th>item_price</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a1</td>\n<td>1000</td>\n<td>10</td>\n</tr>\n<tr>\n<td>a2</td>\n<td>200</td>\n<td>10</td>\n</tr>\n<tr>\n<td>a3</td>\n<td>10</td>\n<td>15</td>\n</tr>\n<tr>\n<td>a4</td>\n<td>25</td>\n<td>50</td>\n</tr>\n<tr>\n<td>a5</td>\n<td>15</td>\n<td>25</td>\n</tr>\n<tr>\n<td>a7</td>\n<td>7</td>\n<td>7</td>\n</tr>\n</tbody>\n</table>\n<p>【问题】除了返回顾客名称和订单号，返回 <code>Customers</code> 表中的顾客名称（<code>cust_name</code>）和 <code>Orders</code> 表中的相关订单号（<code>order_num</code>），添加第三列 <code>OrderTotal</code>，其中包含每个订单的总价，并按顾客名称再按订单号对结果进行升序排序。</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>注意，可能有小伙伴会这样写：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这是错误的！只对 <code>cust_name</code> 进行聚类确实符合题意，但是不符合 <code>group by</code> 的语法。</p>\n<p>select 语句中，如果没有 <code>group by</code> 语句，那么 <code>cust_name</code>、<code>order_num</code> 会返回若干个值，而 <code>sum(quantity _ item_price)</code> 只返回一个值，通过 <code>group by</code> <code>cust_name</code> 可以让 <code>cust_name</code> 和 <code>sum(quantity _ item_price)</code> 一一对应起来，或者说<strong>聚类</strong>，所以同样的，也要对 <code>order_num</code> 进行聚类。</p>\n<blockquote>\n<p><strong>一句话，select 中的字段要么都聚类，要么都不聚类</strong></p>\n</blockquote>\n<h3> 确定哪些订单购买了 prod_id 为 BR01 的产品（二）</h3>\n<p>表 <code>OrderItems</code> 代表订单商品信息表，<code>prod_id</code> 为产品 id；<code>Orders</code> 表代表订单表有 <code>cust_id</code> 代表顾客 id 和订单日期 <code>order_date</code></p>\n<p><code>OrderItems</code> 表：</p>\n<table>\n<thead>\n<tr>\n<th>prod_id</th>\n<th>order_num</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>BR01</td>\n<td>a0001</td>\n</tr>\n<tr>\n<td>BR01</td>\n<td>a0002</td>\n</tr>\n<tr>\n<td>BR02</td>\n<td>a0003</td>\n</tr>\n<tr>\n<td>BR02</td>\n<td>a0013</td>\n</tr>\n</tbody>\n</table>\n<p><code>Orders</code> 表：</p>\n<table>\n<thead>\n<tr>\n<th>order_num</th>\n<th>cust_id</th>\n<th>order_date</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a0001</td>\n<td>cust10</td>\n<td>2022-01-01 00:00:00</td>\n</tr>\n<tr>\n<td>a0002</td>\n<td>cust1</td>\n<td>2022-01-01 00:01:00</td>\n</tr>\n<tr>\n<td>a0003</td>\n<td>cust1</td>\n<td>2022-01-02 00:00:00</td>\n</tr>\n<tr>\n<td>a0013</td>\n<td>cust2</td>\n<td>2022-01-01 00:20:00</td>\n</tr>\n</tbody>\n</table>\n<p>【问题】</p>\n<p>编写 SQL 语句，使用子查询来确定哪些订单（在 <code>OrderItems</code> 中）购买了 <code>prod_id</code> 为 \"BR01\" 的产品，然后从 <code>Orders</code> 表中返回每个产品对应的顾客 ID（<code>cust_id</code>）和订单日期（<code>order_date</code>），按订购日期对结果进行升序排序。</p>\n<p>提示：这一次使用连接和简单的等连接语法。</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 返回购买 prod_id 为 BR01 的产品的所有顾客的电子邮件（二）</h3>\n<p>有表 <code>OrderItems</code> 代表订单商品信息表，<code>prod_id</code> 为产品 id；<code>Orders</code> 表代表订单表有 <code>cust_id</code> 代表顾客 id 和订单日期 <code>order_date</code>；<code>Customers</code> 表含有 <code>cust_email</code> 顾客邮件和 cust_id 顾客 id</p>\n<p><code>OrderItems</code> 表：</p>\n<table>\n<thead>\n<tr>\n<th>prod_id</th>\n<th>order_num</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>BR01</td>\n<td>a0001</td>\n</tr>\n<tr>\n<td>BR01</td>\n<td>a0002</td>\n</tr>\n<tr>\n<td>BR02</td>\n<td>a0003</td>\n</tr>\n<tr>\n<td>BR02</td>\n<td>a0013</td>\n</tr>\n</tbody>\n</table>\n<p><code>Orders</code> 表：</p>\n<table>\n<thead>\n<tr>\n<th>order_num</th>\n<th>cust_id</th>\n<th>order_date</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a0001</td>\n<td>cust10</td>\n<td>2022-01-01 00:00:00</td>\n</tr>\n<tr>\n<td>a0002</td>\n<td>cust1</td>\n<td>2022-01-01 00:01:00</td>\n</tr>\n<tr>\n<td>a0003</td>\n<td>cust1</td>\n<td>2022-01-02 00:00:00</td>\n</tr>\n<tr>\n<td>a0013</td>\n<td>cust2</td>\n<td>2022-01-01 00:20:00</td>\n</tr>\n</tbody>\n</table>\n<p><code>Customers</code> 表代表顾客信息，<code>cust_id</code> 为顾客 id，<code>cust_email</code> 为顾客 email</p>\n<table>\n<thead>\n<tr>\n<th>cust_id</th>\n<th>cust_email</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>cust10</td>\n<td>cust10@cust.com</td>\n</tr>\n<tr>\n<td>cust1</td>\n<td>cust1@cust.com</td>\n</tr>\n<tr>\n<td>cust2</td>\n<td>cust2@cust.com</td>\n</tr>\n</tbody>\n</table>\n<p>【问题】返回购买 <code>prod_id</code> 为 BR01 的产品的所有顾客的电子邮件（<code>Customers</code> 表中的 <code>cust_email</code>），结果无需排序。</p>\n<p>提示：涉及到 <code>SELECT</code> 语句，最内层的从 <code>OrderItems</code> 表返回 <code>order_num</code>，中间的从 <code>Customers</code> 表返回 <code>cust_id</code>，但是必须使用 INNER JOIN 语法。</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 确定最佳顾客的另一种方式（二）</h3>\n<p><code>OrderItems</code> 表代表订单信息，确定最佳顾客的另一种方式是看他们花了多少钱，<code>OrderItems</code> 表有订单号 <code>order_num</code> 和 <code>item_price</code> 商品售出价格、<code>quantity</code> 商品数量</p>\n<table>\n<thead>\n<tr>\n<th>order_num</th>\n<th>item_price</th>\n<th>quantity</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a1</td>\n<td>10</td>\n<td>105</td>\n</tr>\n<tr>\n<td>a2</td>\n<td>1</td>\n<td>1100</td>\n</tr>\n<tr>\n<td>a2</td>\n<td>1</td>\n<td>200</td>\n</tr>\n<tr>\n<td>a4</td>\n<td>2</td>\n<td>1121</td>\n</tr>\n<tr>\n<td>a5</td>\n<td>5</td>\n<td>10</td>\n</tr>\n<tr>\n<td>a2</td>\n<td>1</td>\n<td>19</td>\n</tr>\n<tr>\n<td>a7</td>\n<td>7</td>\n<td>5</td>\n</tr>\n</tbody>\n</table>\n<p><code>Orders</code> 表含有字段 <code>order_num</code> 订单号、<code>cust_id</code> 顾客 id</p>\n<table>\n<thead>\n<tr>\n<th>order_num</th>\n<th>cust_id</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a1</td>\n<td>cust10</td>\n</tr>\n<tr>\n<td>a2</td>\n<td>cust1</td>\n</tr>\n<tr>\n<td>a3</td>\n<td>cust2</td>\n</tr>\n<tr>\n<td>a4</td>\n<td>cust22</td>\n</tr>\n<tr>\n<td>a5</td>\n<td>cust221</td>\n</tr>\n<tr>\n<td>a7</td>\n<td>cust2217</td>\n</tr>\n</tbody>\n</table>\n<p>顾客表 <code>Customers</code> 有字段 <code>cust_id</code> 客户 id、<code>cust_name</code> 客户姓名</p>\n<table>\n<thead>\n<tr>\n<th>cust_id</th>\n<th>cust_name</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>cust10</td>\n<td>andy</td>\n</tr>\n<tr>\n<td>cust1</td>\n<td>ben</td>\n</tr>\n<tr>\n<td>cust2</td>\n<td>tony</td>\n</tr>\n<tr>\n<td>cust22</td>\n<td>tom</td>\n</tr>\n<tr>\n<td>cust221</td>\n<td>an</td>\n</tr>\n<tr>\n<td>cust2217</td>\n<td>hex</td>\n</tr>\n</tbody>\n</table>\n<p>【问题】编写 SQL 语句，返回订单总价不小于 1000 的客户名称和总额（<code>OrderItems</code> 表中的 <code>order_num</code>）。</p>\n<p>提示：需要计算总和（<code>item_price</code> 乘以 <code>quantity</code>）。按总额对结果进行排序，请使用 INNER JOIN 语法。</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 创建高级连接</h2>\n<h3> 检索每个顾客的名称和所有的订单号（一）</h3>\n<p><code>Customers</code> 表代表顾客信息含有顾客 id <code>cust_id</code> 和 顾客名称 <code>cust_name</code></p>\n<table>\n<thead>\n<tr>\n<th>cust_id</th>\n<th>cust_name</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>cust10</td>\n<td>andy</td>\n</tr>\n<tr>\n<td>cust1</td>\n<td>ben</td>\n</tr>\n<tr>\n<td>cust2</td>\n<td>tony</td>\n</tr>\n<tr>\n<td>cust22</td>\n<td>tom</td>\n</tr>\n<tr>\n<td>cust221</td>\n<td>an</td>\n</tr>\n<tr>\n<td>cust2217</td>\n<td>hex</td>\n</tr>\n</tbody>\n</table>\n<p><code>Orders</code> 表代表订单信息含有订单号 <code>order_num</code> 和顾客 id <code>cust_id</code></p>\n<table>\n<thead>\n<tr>\n<th>order_num</th>\n<th>cust_id</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a1</td>\n<td>cust10</td>\n</tr>\n<tr>\n<td>a2</td>\n<td>cust1</td>\n</tr>\n<tr>\n<td>a3</td>\n<td>cust2</td>\n</tr>\n<tr>\n<td>a4</td>\n<td>cust22</td>\n</tr>\n<tr>\n<td>a5</td>\n<td>cust221</td>\n</tr>\n<tr>\n<td>a7</td>\n<td>cust2217</td>\n</tr>\n</tbody>\n</table>\n<p>【问题】使用 INNER JOIN 编写 SQL 语句，检索每个顾客的名称（<code>Customers</code> 表中的 <code>cust_name</code>）和所有的订单号（<code>Orders</code> 表中的 <code>order_num</code>），最后根据顾客姓名 <code>cust_name</code> 升序返回。</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 检索每个顾客的名称和所有的订单号（二）</h3>\n<p><code>Orders</code> 表代表订单信息含有订单号 <code>order_num</code> 和顾客 id <code>cust_id</code></p>\n<table>\n<thead>\n<tr>\n<th>order_num</th>\n<th>cust_id</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a1</td>\n<td>cust10</td>\n</tr>\n<tr>\n<td>a2</td>\n<td>cust1</td>\n</tr>\n<tr>\n<td>a3</td>\n<td>cust2</td>\n</tr>\n<tr>\n<td>a4</td>\n<td>cust22</td>\n</tr>\n<tr>\n<td>a5</td>\n<td>cust221</td>\n</tr>\n<tr>\n<td>a7</td>\n<td>cust2217</td>\n</tr>\n</tbody>\n</table>\n<p><code>Customers</code> 表代表顾客信息含有顾客 id <code>cust_id</code> 和 顾客名称 <code>cust_name</code></p>\n<table>\n<thead>\n<tr>\n<th>cust_id</th>\n<th>cust_name</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>cust10</td>\n<td>andy</td>\n</tr>\n<tr>\n<td>cust1</td>\n<td>ben</td>\n</tr>\n<tr>\n<td>cust2</td>\n<td>tony</td>\n</tr>\n<tr>\n<td>cust22</td>\n<td>tom</td>\n</tr>\n<tr>\n<td>cust221</td>\n<td>an</td>\n</tr>\n<tr>\n<td>cust2217</td>\n<td>hex</td>\n</tr>\n<tr>\n<td>cust40</td>\n<td>ace</td>\n</tr>\n</tbody>\n</table>\n<p>【问题】检索每个顾客的名称（<code>Customers</code> 表中的 <code>cust_name</code>）和所有的订单号（Orders 表中的 <code>order_num</code>），列出所有的顾客，即使他们没有下过订单。最后根据顾客姓名 <code>cust_name</code> 升序返回。</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 返回产品名称和与之相关的订单号</h3>\n<p><code>Products</code> 表为产品信息表含有字段 <code>prod_id</code> 产品 id、<code>prod_name</code> 产品名称</p>\n<table>\n<thead>\n<tr>\n<th>prod_id</th>\n<th>prod_name</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a0001</td>\n<td>egg</td>\n</tr>\n<tr>\n<td>a0002</td>\n<td>sockets</td>\n</tr>\n<tr>\n<td>a0013</td>\n<td>coffee</td>\n</tr>\n<tr>\n<td>a0003</td>\n<td>cola</td>\n</tr>\n<tr>\n<td>a0023</td>\n<td>soda</td>\n</tr>\n</tbody>\n</table>\n<p><code>OrderItems</code> 表为订单信息表含有字段 <code>order_num</code> 订单号和产品 id <code>prod_id</code></p>\n<table>\n<thead>\n<tr>\n<th>prod_id</th>\n<th>order_num</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a0001</td>\n<td>a105</td>\n</tr>\n<tr>\n<td>a0002</td>\n<td>a1100</td>\n</tr>\n<tr>\n<td>a0002</td>\n<td>a200</td>\n</tr>\n<tr>\n<td>a0013</td>\n<td>a1121</td>\n</tr>\n<tr>\n<td>a0003</td>\n<td>a10</td>\n</tr>\n<tr>\n<td>a0003</td>\n<td>a19</td>\n</tr>\n<tr>\n<td>a0003</td>\n<td>a5</td>\n</tr>\n</tbody>\n</table>\n<p>【问题】使用外连接（left join、 right join、full join）联结 <code>Products</code> 表和 <code>OrderItems</code> 表，返回产品名称（<code>prod_name</code>）和与之相关的订单号（<code>order_num</code>）的列表，并按照产品名称升序排序。</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 返回产品名称和每一项产品的总订单数</h3>\n<p><code>Products</code> 表为产品信息表含有字段 <code>prod_id</code> 产品 id、<code>prod_name</code> 产品名称</p>\n<table>\n<thead>\n<tr>\n<th>prod_id</th>\n<th>prod_name</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a0001</td>\n<td>egg</td>\n</tr>\n<tr>\n<td>a0002</td>\n<td>sockets</td>\n</tr>\n<tr>\n<td>a0013</td>\n<td>coffee</td>\n</tr>\n<tr>\n<td>a0003</td>\n<td>cola</td>\n</tr>\n<tr>\n<td>a0023</td>\n<td>soda</td>\n</tr>\n</tbody>\n</table>\n<p><code>OrderItems</code> 表为订单信息表含有字段 <code>order_num</code> 订单号和产品 id <code>prod_id</code></p>\n<table>\n<thead>\n<tr>\n<th>prod_id</th>\n<th>order_num</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a0001</td>\n<td>a105</td>\n</tr>\n<tr>\n<td>a0002</td>\n<td>a1100</td>\n</tr>\n<tr>\n<td>a0002</td>\n<td>a200</td>\n</tr>\n<tr>\n<td>a0013</td>\n<td>a1121</td>\n</tr>\n<tr>\n<td>a0003</td>\n<td>a10</td>\n</tr>\n<tr>\n<td>a0003</td>\n<td>a19</td>\n</tr>\n<tr>\n<td>a0003</td>\n<td>a5</td>\n</tr>\n</tbody>\n</table>\n<p>【问题】</p>\n<p>使用 OUTER JOIN 联结 <code>Products</code> 表和 <code>OrderItems</code> 表，返回产品名称（<code>prod_name</code>）和每一项产品的总订单数（不是订单号），并按产品名称升序排序。</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 列出供应商及其可供产品的数量</h3>\n<p>有 <code>Vendors</code> 表含有 <code>vend_id</code> （供应商 id）</p>\n<table>\n<thead>\n<tr>\n<th>vend_id</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a0002</td>\n</tr>\n<tr>\n<td>a0013</td>\n</tr>\n<tr>\n<td>a0003</td>\n</tr>\n<tr>\n<td>a0010</td>\n</tr>\n</tbody>\n</table>\n<p>有 <code>Products</code> 表含有 <code>vend_id</code>（供应商 id）和 prod_id（供应产品 id）</p>\n<table>\n<thead>\n<tr>\n<th>vend_id</th>\n<th>prod_id</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a0001</td>\n<td>egg</td>\n</tr>\n<tr>\n<td>a0002</td>\n<td>prod_id_iphone</td>\n</tr>\n<tr>\n<td>a00113</td>\n<td>prod_id_tea</td>\n</tr>\n<tr>\n<td>a0003</td>\n<td>prod_id_vivo phone</td>\n</tr>\n<tr>\n<td>a0010</td>\n<td>prod_id_huawei phone</td>\n</tr>\n</tbody>\n</table>\n<p>【问题】列出供应商（<code>Vendors</code> 表中的 <code>vend_id</code>）及其可供产品的数量，包括没有产品的供应商。你需要使用 OUTER JOIN 和 COUNT()聚合函数来计算 <code>Products</code> 表中每种产品的数量，最后根据 vend_id 升序排序。</p>\n<p>注意：<code>vend_id</code> 列会显示在多个表中，因此在每次引用它时都需要完全限定它。</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 组合查询</h2>\n<p><code>UNION</code> 运算符将两个或更多查询的结果组合起来，并生成一个结果集，其中包含来自 <code>UNION</code> 中参与查询的提取行。</p>\n<p><code>UNION</code> 基本规则：</p>\n<ul>\n<li>所有查询的列数和列顺序必须相同。</li>\n<li>每个查询中涉及表的列的数据类型必须相同或兼容。</li>\n<li>通常返回的列名取自第一个查询。</li>\n</ul>\n<p>默认地，<code>UNION</code> 操作符选取不同的值。如果允许重复的值，请使用 <code>UNION ALL</code>。</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>UNION</code> 结果集中的列名总是等于 <code>UNION</code> 中第一个 <code>SELECT</code> 语句中的列名。</p>\n<p><code>JOIN</code> vs <code>UNION</code>：</p>\n<ul>\n<li><code>JOIN</code> 中连接表的列可能不同，但在 <code>UNION</code> 中，所有查询的列数和列顺序必须相同。</li>\n<li><code>UNION</code> 将查询之后的行放在一起（垂直放置），但 <code>JOIN</code> 将查询之后的列放在一起（水平放置），即它构成一个笛卡尔积。</li>\n</ul>\n<h3> 将两个 SELECT 语句结合起来（一）</h3>\n<p>表 <code>OrderItems</code> 包含订单产品信息，字段 <code>prod_id</code> 代表产品 id、<code>quantity</code> 代表产品数量</p>\n<table>\n<thead>\n<tr>\n<th>prod_id</th>\n<th>quantity</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a0001</td>\n<td>105</td>\n</tr>\n<tr>\n<td>a0002</td>\n<td>100</td>\n</tr>\n<tr>\n<td>a0002</td>\n<td>200</td>\n</tr>\n<tr>\n<td>a0013</td>\n<td>1121</td>\n</tr>\n<tr>\n<td>a0003</td>\n<td>10</td>\n</tr>\n<tr>\n<td>a0003</td>\n<td>19</td>\n</tr>\n<tr>\n<td>a0003</td>\n<td>5</td>\n</tr>\n<tr>\n<td>BNBG</td>\n<td>10002</td>\n</tr>\n</tbody>\n</table>\n<p>【问题】将两个 <code>SELECT</code> 语句结合起来，以便从 <code>OrderItems</code> 表中检索产品 id（<code>prod_id</code>）和 <code>quantity</code>。其中，一个 <code>SELECT</code> 语句过滤数量为 100 的行，另一个 <code>SELECT</code> 语句过滤 id 以 BNBG 开头的产品，最后按产品 id 对结果进行升序排序。</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 将两个 SELECT 语句结合起来（二）</h3>\n<p>表 <code>OrderItems</code> 包含订单产品信息，字段 <code>prod_id</code> 代表产品 id、<code>quantity</code> 代表产品数量。</p>\n<table>\n<thead>\n<tr>\n<th>prod_id</th>\n<th>quantity</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a0001</td>\n<td>105</td>\n</tr>\n<tr>\n<td>a0002</td>\n<td>100</td>\n</tr>\n<tr>\n<td>a0002</td>\n<td>200</td>\n</tr>\n<tr>\n<td>a0013</td>\n<td>1121</td>\n</tr>\n<tr>\n<td>a0003</td>\n<td>10</td>\n</tr>\n<tr>\n<td>a0003</td>\n<td>19</td>\n</tr>\n<tr>\n<td>a0003</td>\n<td>5</td>\n</tr>\n<tr>\n<td>BNBG</td>\n<td>10002</td>\n</tr>\n</tbody>\n</table>\n<p>【问题】将两个 <code>SELECT</code> 语句结合起来，以便从 <code>OrderItems</code> 表中检索产品 id（<code>prod_id</code>）和 <code>quantity</code>。其中，一个 <code>SELECT</code> 语句过滤数量为 100 的行，另一个 <code>SELECT</code> 语句过滤 id 以 BNBG 开头的产品，最后按产品 id 对结果进行升序排序。 注意：<strong>这次仅使用单个 SELECT 语句。</strong></p>\n<p>答案：</p>\n<p>要求只用一条 select 语句，那就用 <code>or</code> 不用 <code>union</code> 了。</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 组合 Products 表中的产品名称和 Customers 表中的顾客名称</h3>\n<p><code>Products</code> 表含有字段 <code>prod_name</code> 代表产品名称</p>\n<table>\n<thead>\n<tr>\n<th>prod_name</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>flower</td>\n</tr>\n<tr>\n<td>rice</td>\n</tr>\n<tr>\n<td>ring</td>\n</tr>\n<tr>\n<td>umbrella</td>\n</tr>\n</tbody>\n</table>\n<p>Customers 表代表顾客信息，cust_name 代表顾客名称</p>\n<table>\n<thead>\n<tr>\n<th>cust_name</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>andy</td>\n</tr>\n<tr>\n<td>ben</td>\n</tr>\n<tr>\n<td>tony</td>\n</tr>\n<tr>\n<td>tom</td>\n</tr>\n<tr>\n<td>an</td>\n</tr>\n<tr>\n<td>lee</td>\n</tr>\n<tr>\n<td>hex</td>\n</tr>\n</tbody>\n</table>\n<p>【问题】编写 SQL 语句，组合 <code>Products</code> 表中的产品名称（<code>prod_name</code>）和 <code>Customers</code> 表中的顾客名称（<code>cust_name</code>）并返回，然后按产品名称对结果进行升序排序。</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 检查 SQL 语句</h3>\n<p>表 <code>Customers</code> 含有字段 <code>cust_name</code> 顾客名、<code>cust_contact</code> 顾客联系方式、<code>cust_state</code> 顾客州、<code>cust_email</code> 顾客 <code>email</code></p>\n<table>\n<thead>\n<tr>\n<th>cust_name</th>\n<th>cust_contact</th>\n<th>cust_state</th>\n<th>cust_email</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>cust10</td>\n<td>8695192</td>\n<td>MI</td>\n<td>cust10@cust.com</td>\n</tr>\n<tr>\n<td>cust1</td>\n<td>8695193</td>\n<td>MI</td>\n<td>cust1@cust.com</td>\n</tr>\n<tr>\n<td>cust2</td>\n<td>8695194</td>\n<td>IL</td>\n<td>cust2@cust.com</td>\n</tr>\n</tbody>\n</table>\n<p>【问题】修正下面错误的 SQL</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>修正后：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>使用 <code>union</code> 组合查询时，只能使用一条 <code>order by</code> 字句，他必须位于最后一条 <code>select</code> 语句之后</p>\n<p>或者直接用 <code>or</code> 来做：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "image": "https://img-blog.csdnimg.cn/img_convert/d1794312b448516831369f869814ab39.png",
      "date_published": "2023-02-17T05:40:22.000Z",
      "date_modified": "2023-02-27T03:53:21.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "数据库"
      ]
    },
    {
      "title": "SQL语法基础知识总结",
      "url": "https://javaguide.cn/database/sql/sql-syntax-summary.html",
      "id": "https://javaguide.cn/database/sql/sql-syntax-summary.html",
      "summary": "本文整理完善自下面这两份资料： SQL 语法速成手册 MySQL 超全教程",
      "content_html": "<blockquote>\n<p>本文整理完善自下面这两份资料：</p>\n<ul>\n<li><a href=\"https://juejin.cn/post/6844903790571700231\" target=\"_blank\" rel=\"noopener noreferrer\">SQL 语法速成手册</a></li>\n<li><a href=\"https://www.begtut.com/mysql/mysql-tutorial.html\" target=\"_blank\" rel=\"noopener noreferrer\">MySQL 超全教程</a></li>\n</ul>\n</blockquote>\n<h2> 基本概念</h2>\n<h3> 数据库术语</h3>\n<ul>\n<li><code>数据库（database）</code> - 保存有组织的数据的容器（通常是一个文件或一组文件）。</li>\n<li><code>数据表（table）</code> - 某种特定类型数据的结构化清单。</li>\n<li><code>模式（schema）</code> - 关于数据库和表的布局及特性的信息。模式定义了数据在表中如何存储，包含存储什么样的数据，数据如何分解，各部分信息如何命名等信息。数据库和表都有模式。</li>\n<li><code>列（column）</code> - 表中的一个字段。所有表都是由一个或多个列组成的。</li>\n<li><code>行（row）</code> - 表中的一个记录。</li>\n<li><code>主键（primary key）</code> - 一列（或一组列），其值能够唯一标识表中每一行。</li>\n</ul>\n<h3> SQL 语法</h3>\n<p>SQL（Structured Query Language)，标准 SQL 由 ANSI 标准委员会管理，从而称为 ANSI SQL。各个 DBMS 都有自己的实现，如 PL/SQL、Transact-SQL 等。</p>\n<h4> SQL 语法结构</h4>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/812dc1e042d44b6a2d4331d31a25ddc6.png\" alt=\"\"></p>\n<p>SQL 语法结构包括：</p>\n<ul>\n<li><strong><code>子句</code></strong> - 是语句和查询的组成成分。（在某些情况下，这些都是可选的。）</li>\n<li><strong><code>表达式</code></strong> - 可以产生任何标量值，或由列和行的数据库表</li>\n<li><strong><code>谓词</code></strong> - 给需要评估的 SQL 三值逻辑（3VL）（true/false/unknown）或布尔真值指定条件，并限制语句和查询的效果，或改变程序流程。</li>\n<li><strong><code>查询</code></strong> - 基于特定条件检索数据。这是 SQL 的一个重要组成部分。</li>\n<li><strong><code>语句</code></strong> - 可以持久地影响纲要和数据，也可以控制数据库事务、程序流程、连接、会话或诊断。</li>\n</ul>\n<h4> SQL 语法要点</h4>\n<ul>\n<li><strong>SQL 语句不区分大小写</strong>，但是数据库表名、列名和值是否区分，依赖于具体的 DBMS 以及配置。例如：<code>SELECT</code> 与 <code>select</code> 、<code>Select</code> 是相同的。</li>\n<li><strong>多条 SQL 语句必须以分号（<code>;</code>）分隔</strong>。</li>\n<li>处理 SQL 语句时，<strong>所有空格都被忽略</strong>。</li>\n</ul>\n<p>SQL 语句可以写成一行，也可以分写为多行。</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>SQL 支持三种注释：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> SQL 分类</h3>\n<h4> 数据定义语言（DDL）</h4>\n<p>数据定义语言（Data Definition Language，DDL）是 SQL 语言集中负责数据结构定义与数据库对象定义的语言。</p>\n<p>DDL 的主要功能是<strong>定义数据库对象</strong>。</p>\n<p>DDL 的核心指令是 <code>CREATE</code>、<code>ALTER</code>、<code>DROP</code>。</p>\n<h4> 数据操纵语言（DML）</h4>\n<p>数据操纵语言（Data Manipulation Language, DML）是用于数据库操作，对数据库其中的对象和数据运行访问工作的编程语句。</p>\n<p>DML 的主要功能是 <strong>访问数据</strong>，因此其语法都是以<strong>读写数据库</strong>为主。</p>\n<p>DML 的核心指令是 <code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>、<code>SELECT</code>。这四个指令合称 CRUD(Create, Read, Update, Delete)，即增删改查。</p>\n<h4> 事务控制语言（TCL）</h4>\n<p>事务控制语言 (Transaction Control Language, TCL) 用于<strong>管理数据库中的事务</strong>。这些用于管理由 DML 语句所做的更改。它还允许将语句分组为逻辑事务。</p>\n<p>TCL 的核心指令是 <code>COMMIT</code>、<code>ROLLBACK</code>。</p>\n<h4> 数据控制语言（DCL）</h4>\n<p>数据控制语言 (Data Control Language, DCL) 是一种可对数据访问权进行控制的指令，它可以控制特定用户账户对数据表、查看表、预存程序、用户自定义函数等数据库对象的控制权。</p>\n<p>DCL 的核心指令是 <code>GRANT</code>、<code>REVOKE</code>。</p>\n<p>DCL 以<strong>控制用户的访问权限</strong>为主，因此其指令作法并不复杂，可利用 DCL 控制的权限有：<code>CONNECT</code>、<code>SELECT</code>、<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>、<code>EXECUTE</code>、<code>USAGE</code>、<code>REFERENCES</code>。</p>\n<p>根据不同的 DBMS 以及不同的安全性实体，其支持的权限控制也有所不同。</p>\n<p><strong>我们先来介绍 DML 语句用法。 DML 的主要功能是读写数据库实现增删改查。</strong></p>\n<h2> 增删改查</h2>\n<p>增删改查，又称为 CRUD，数据库基本操作中的基本操作。</p>\n<h3> 插入数据</h3>\n<p><code>INSERT INTO</code> 语句用于向表中插入新记录。</p>\n<p><strong>插入完整的行</strong></p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>插入行的一部分</strong></p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>插入查询出来的数据</strong></p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 更新数据</h3>\n<p><code>UPDATE</code> 语句用于更新表中的记录。</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 删除数据</h3>\n<ul>\n<li><code>DELETE</code> 语句用于删除表中的记录。</li>\n<li><code>TRUNCATE TABLE</code> 可以清空表，也就是删除所有行。</li>\n</ul>\n<p><strong>删除表中的指定数据</strong></p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>清空表中的数据</strong></p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 查询数据</h3>\n<p><code>SELECT</code> 语句用于从数据库中查询数据。</p>\n<p><code>DISTINCT</code> 用于返回唯一不同的值。它作用于所有列，也就是说所有列的值都相同才算相同。</p>\n<p><code>LIMIT</code> 限制返回的行数。可以有两个参数，第一个参数为起始行，从 0 开始；第二个参数为返回的总行数。</p>\n<ul>\n<li><code>ASC</code> ：升序（默认）</li>\n<li><code>DESC</code> ：降序</li>\n</ul>\n<p><strong>查询单列</strong></p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>查询多列</strong></p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>查询所有列</strong></p>\n<div class=\"language-css line-numbers-mode\" data-ext=\"css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>查询不同的值</strong></p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>限制查询结果</strong></p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 排序</h2>\n<p><code>order by</code> 用于对结果集按照一个列或者多个列进行排序。默认按照升序对记录进行排序，如果需要按照降序对记录进行排序，可以使用 <code>desc</code> 关键字。</p>\n<p><code>order by</code> 对多列排序的时候，先排序的列放前面，后排序的列放后面。并且，不同的列可以有不同的排序规则。</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 分组</h2>\n<p><strong><code>group by</code></strong> ：</p>\n<ul>\n<li><code>group by</code> 子句将记录分组到汇总行中。</li>\n<li><code>group by</code> 为每个组返回一个记录。</li>\n<li><code>group by</code> 通常还涉及聚合<code>count</code>，<code>max</code>，<code>sum</code>，<code>avg</code> 等。</li>\n<li><code>group by</code> 可以按一列或多列进行分组。</li>\n<li><code>group by</code> 按分组字段进行排序后，<code>order by</code> 可以以汇总字段来进行排序。</li>\n</ul>\n<p><strong>分组</strong></p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>分组后排序</strong></p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong><code>having</code></strong>：</p>\n<ul>\n<li><code>having</code> 用于对汇总的 <code>group by</code> 结果进行过滤。</li>\n<li><code>having</code> 一般都是和 <code>group by</code> 连用。</li>\n<li><code>where</code> 和 <code>having</code> 可以在相同的查询中。</li>\n</ul>\n<p><strong>使用 WHERE 和 HAVING 过滤数据</strong></p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong><code>having</code> vs <code>where</code></strong> ：</p>\n<ul>\n<li><code>where</code>：过滤过滤指定的行，后面不能加聚合函数（分组函数）。<code>where</code> 在<code>group by</code> 前。</li>\n<li><code>having</code>：过滤分组，一般都是和 <code>group by</code> 连用，不能单独使用。<code>having</code> 在 <code>group by</code> 之后。</li>\n</ul>\n<h2> 子查询</h2>\n<p>子查询是嵌套在较大查询中的 SQL 查询，也称内部查询或内部选择，包含子查询的语句也称为外部查询或外部选择。简单来说，子查询就是指将一个 <code>select</code> 查询（子查询）的结果作为另一个 SQL 语句（主查询）的数据来源或者判断条件。</p>\n<p>子查询可以嵌入 <code>SELECT</code>、<code>INSERT</code>、<code>UPDATE</code> 和 <code>DELETE</code> 语句中，也可以和 <code>=</code>、<code>&lt;</code>、<code>&gt;</code>、<code>IN</code>、<code>BETWEEN</code>、<code>EXISTS</code> 等运算符一起使用。</p>\n<p>子查询常用在 <code>WHERE</code> 子句和 <code>FROM</code> 子句后边：</p>\n<ul>\n<li>当用于 <code>WHERE</code> 子句时，根据不同的运算符，子查询可以返回单行单列、多行单列、单行多列数据。子查询就是要返回能够作为 <code>WHERE</code> 子句查询条件的值。</li>\n<li>当用于 <code>FROM</code> 子句时，一般返回多行多列数据，相当于返回一张临时表，这样才符合 <code>FROM</code> 后面是表的规则。这种做法能够实现多表联合查询。</li>\n</ul>\n<blockquote>\n<p>注意：MYSQL 数据库从 4.1 版本才开始支持子查询，早期版本是不支持的。</p>\n</blockquote>\n<p>用于 <code>WHERE</code> 子句的子查询的基本语法如下：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>子查询需要放在括号<code>( )</code>内。</li>\n<li><code>operator</code> 表示用于 where 子句的运算符。</li>\n</ul>\n<p>用于 <code>FROM</code> 子句的子查询的基本语法如下：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>用于 <code>FROM</code> 的子查询返回的结果相当于一张临时表，所以需要使用 AS 关键字为该临时表起一个名字。</p>\n<p><strong>子查询的子查询</strong></p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>内部查询首先在其父查询之前执行，以便可以将内部查询的结果传递给外部查询。执行过程可以参考下图：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/898b370018bb52505e78ad6963d28aa1.png\" alt=\"\"></p>\n<h3> WHERE</h3>\n<ul>\n<li><code>WHERE</code> 子句用于过滤记录，即缩小访问数据的范围。</li>\n<li><code>WHERE</code> 后跟一个返回 <code>true</code> 或 <code>false</code> 的条件。</li>\n<li><code>WHERE</code> 可以与 <code>SELECT</code>，<code>UPDATE</code> 和 <code>DELETE</code> 一起使用。</li>\n<li>可以在 <code>WHERE</code> 子句中使用的操作符。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>=</td>\n<td>等于</td>\n</tr>\n<tr>\n<td>&lt;&gt;</td>\n<td>不等于。注释：在 SQL 的一些版本中，该操作符可被写成 !=</td>\n</tr>\n<tr>\n<td>&gt;</td>\n<td>大于</td>\n</tr>\n<tr>\n<td>&lt;</td>\n<td>小于</td>\n</tr>\n<tr>\n<td>&gt;=</td>\n<td>大于等于</td>\n</tr>\n<tr>\n<td>&lt;=</td>\n<td>小于等于</td>\n</tr>\n<tr>\n<td>BETWEEN</td>\n<td>在某个范围内</td>\n</tr>\n<tr>\n<td>LIKE</td>\n<td>搜索某种模式</td>\n</tr>\n<tr>\n<td>IN</td>\n<td>指定针对某个列的多个可能值</td>\n</tr>\n</tbody>\n</table>\n<p><strong><code>SELECT</code> 语句中的 <code>WHERE</code> 子句</strong></p>\n<div class=\"language-ini line-numbers-mode\" data-ext=\"ini\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong><code>UPDATE</code> 语句中的 <code>WHERE</code> 子句</strong></p>\n<div class=\"language-ini line-numbers-mode\" data-ext=\"ini\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong><code>DELETE</code> 语句中的 <code>WHERE</code> 子句</strong></p>\n<div class=\"language-ini line-numbers-mode\" data-ext=\"ini\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> IN 和 BETWEEN</h3>\n<ul>\n<li><code>IN</code> 操作符在 <code>WHERE</code> 子句中使用，作用是在指定的几个特定值中任选一个值。</li>\n<li><code>BETWEEN</code> 操作符在 <code>WHERE</code> 子句中使用，作用是选取介于某个范围内的值。</li>\n</ul>\n<p><strong>IN 示例</strong></p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>BETWEEN 示例</strong></p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> AND、OR、NOT</h3>\n<ul>\n<li><code>AND</code>、<code>OR</code>、<code>NOT</code> 是用于对过滤条件的逻辑处理指令。</li>\n<li><code>AND</code> 优先级高于 <code>OR</code>，为了明确处理顺序，可以使用 <code>()</code>。</li>\n<li><code>AND</code> 操作符表示左右条件都要满足。</li>\n<li><code>OR</code> 操作符表示左右条件满足任意一个即可。</li>\n<li><code>NOT</code> 操作符用于否定一个条件。</li>\n</ul>\n<p><strong>AND 示例</strong></p>\n<div class=\"language-ini line-numbers-mode\" data-ext=\"ini\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>OR 示例</strong></p>\n<div class=\"language-ini line-numbers-mode\" data-ext=\"ini\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>NOT 示例</strong></p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> LIKE</h3>\n<ul>\n<li><code>LIKE</code> 操作符在 <code>WHERE</code> 子句中使用，作用是确定字符串是否匹配模式。</li>\n<li>只有字段是文本值时才使用 <code>LIKE</code>。</li>\n<li><code>LIKE</code> 支持两个通配符匹配选项：<code>%</code> 和 <code>_</code>。</li>\n<li>不要滥用通配符，通配符位于开头处匹配会非常慢。</li>\n<li><code>%</code> 表示任何字符出现任意次数。</li>\n<li><code>_</code> 表示任何字符出现一次。</li>\n</ul>\n<p><strong>% 示例</strong></p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>_ 示例</strong></p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 连接</h2>\n<p>JOIN 是“连接”的意思，顾名思义，SQL JOIN 子句用于将两个或者多个表联合起来进行查询。</p>\n<p>连接表时需要在每个表中选择一个字段，并对这些字段的值进行比较，值相同的两条记录将合并为一条。<strong>连接表的本质就是将不同表的记录合并起来，形成一张新表。当然，这张新表只是临时的，它仅存在于本次查询期间</strong>。</p>\n<p>使用 <code>JOIN</code> 连接两个表的基本语法如下：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>table1.common_column1 = table2.common_column2</code> 是连接条件，只有满足此条件的记录才会合并为一行。您可以使用多个运算符来连接表，例如 =、&gt;、&lt;、&lt;&gt;、&lt;=、&gt;=、!=、<code>between</code>、<code>like</code> 或者 <code>not</code>，但是最常见的是使用 =。</p>\n<p>当两个表中有同名的字段时，为了帮助数据库引擎区分是哪个表的字段，在书写同名字段名时需要加上表名。当然，如果书写的字段名在两个表中是唯一的，也可以不使用以上格式，只写字段名即可。</p>\n<p>另外，如果两张表的关联字段名相同，也可以使用 <code>USING</code>子句来代替 <code>ON</code>，举个例子：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong><code>ON</code> 和 <code>WHERE</code> 的区别</strong>：</p>\n<ul>\n<li>连接表时，SQL 会根据连接条件生成一张新的临时表。<code>ON</code> 就是连接条件，它决定临时表的生成。</li>\n<li><code>WHERE</code> 是在临时表生成以后，再对临时表中的数据进行过滤，生成最终的结果集，这个时候已经没有 JOIN-ON 了。</li>\n</ul>\n<p>所以总结来说就是：<strong>SQL 先根据 ON 生成一张临时表，然后再根据 WHERE 对临时表进行筛选</strong>。</p>\n<p>SQL 允许在 <code>JOIN</code> 左边加上一些修饰性的关键词，从而形成不同类型的连接，如下表所示：</p>\n<table>\n<thead>\n<tr>\n<th>连接类型</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>INNER JOIN 内连接</td>\n<td>（默认连接方式）只有当两个表都存在满足条件的记录时才会返回行。</td>\n</tr>\n<tr>\n<td>LEFT JOIN / LEFT OUTER JOIN 左(外)连接</td>\n<td>返回左表中的所有行，即使右表中没有满足条件的行也是如此。</td>\n</tr>\n<tr>\n<td>RIGHT JOIN / RIGHT OUTER JOIN 右(外)连接</td>\n<td>返回右表中的所有行，即使左表中没有满足条件的行也是如此。</td>\n</tr>\n<tr>\n<td>FULL JOIN / FULL OUTER JOIN 全(外)连接</td>\n<td>只要其中有一个表存在满足条件的记录，就返回行。</td>\n</tr>\n<tr>\n<td>SELF JOIN</td>\n<td>将一个表连接到自身，就像该表是两个表一样。为了区分两个表，在 SQL 语句中需要至少重命名一个表。</td>\n</tr>\n<tr>\n<td>CROSS JOIN</td>\n<td>交叉连接，从两个或者多个连接表中返回记录集的笛卡尔积。</td>\n</tr>\n</tbody>\n</table>\n<p>下图展示了 LEFT JOIN、RIGHT JOIN、INNER JOIN、OUTER JOIN 相关的 7 种用法。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/d1794312b448516831369f869814ab39.png\" alt=\"\"></p>\n<p>如果不加任何修饰词，只写 <code>JOIN</code>，那么默认为 <code>INNER JOIIN</code></p>\n<p>对于 <code>INNER JOIIN</code> 来说，还有一种隐式的写法，称为 “<strong>隐式内连接</strong>”，也就是没有 <code>INNER JOIIN</code> 关键字，使用 <code>WHERE</code> 语句实现内连接的功能</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 组合</h2>\n<p><code>UNION</code> 运算符将两个或更多查询的结果组合起来，并生成一个结果集，其中包含来自 <code>UNION</code> 中参与查询的提取行。</p>\n<p><code>UNION</code> 基本规则：</p>\n<ul>\n<li>所有查询的列数和列顺序必须相同。</li>\n<li>每个查询中涉及表的列的数据类型必须相同或兼容。</li>\n<li>通常返回的列名取自第一个查询。</li>\n</ul>\n<p>默认地，<code>UNION</code> 操作符选取不同的值。如果允许重复的值，请使用 <code>UNION ALL</code>。</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>UNION</code> 结果集中的列名总是等于 <code>UNION</code> 中第一个 <code>SELECT</code> 语句中的列名。</p>\n<p><code>JOIN</code> vs <code>UNION</code>：</p>\n<ul>\n<li><code>JOIN</code> 中连接表的列可能不同，但在 <code>UNION</code> 中，所有查询的列数和列顺序必须相同。</li>\n<li><code>UNION</code> 将查询之后的行放在一起（垂直放置），但 <code>JOIN</code> 将查询之后的列放在一起（水平放置），即它构成一个笛卡尔积。</li>\n</ul>\n<h2> 函数</h2>\n<p>不同数据库的函数往往各不相同，因此不可移植。本节主要以 MysSQL 的函数为例。</p>\n<h3> 文本处理</h3>\n<table>\n<thead>\n<tr>\n<th>函数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>LEFT()</code>、<code>RIGHT()</code></td>\n<td>左边或者右边的字符</td>\n</tr>\n<tr>\n<td><code>LOWER()</code>、<code>UPPER()</code></td>\n<td>转换为小写或者大写</td>\n</tr>\n<tr>\n<td><code>LTRIM()</code>、<code>RTIM()</code></td>\n<td>去除左边或者右边的空格</td>\n</tr>\n<tr>\n<td><code>LENGTH()</code></td>\n<td>长度</td>\n</tr>\n<tr>\n<td><code>SOUNDEX()</code></td>\n<td>转换为语音值</td>\n</tr>\n</tbody>\n</table>\n<p>其中， <strong><code>SOUNDEX()</code></strong> 可以将一个字符串转换为描述其语音表示的字母数字模式。</p>\n<div class=\"language-scss line-numbers-mode\" data-ext=\"scss\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 日期和时间处理</h3>\n<ul>\n<li>日期格式：<code>YYYY-MM-DD</code></li>\n<li>时间格式：<code>HH:MM:SS</code></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>函 数</th>\n<th>说 明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>AddDate()</code></td>\n<td>增加一个日期（天、周等）</td>\n</tr>\n<tr>\n<td><code>AddTime()</code></td>\n<td>增加一个时间（时、分等）</td>\n</tr>\n<tr>\n<td><code>CurDate()</code></td>\n<td>返回当前日期</td>\n</tr>\n<tr>\n<td><code>CurTime()</code></td>\n<td>返回当前时间</td>\n</tr>\n<tr>\n<td><code>Date()</code></td>\n<td>返回日期时间的日期部分</td>\n</tr>\n<tr>\n<td><code>DateDiff()</code></td>\n<td>计算两个日期之差</td>\n</tr>\n<tr>\n<td><code>Date_Add()</code></td>\n<td>高度灵活的日期运算函数</td>\n</tr>\n<tr>\n<td><code>Date_Format()</code></td>\n<td>返回一个格式化的日期或时间串</td>\n</tr>\n<tr>\n<td><code>Day()</code></td>\n<td>返回一个日期的天数部分</td>\n</tr>\n<tr>\n<td><code>DayOfWeek()</code></td>\n<td>对于一个日期，返回对应的星期几</td>\n</tr>\n<tr>\n<td><code>Hour()</code></td>\n<td>返回一个时间的小时部分</td>\n</tr>\n<tr>\n<td><code>Minute()</code></td>\n<td>返回一个时间的分钟部分</td>\n</tr>\n<tr>\n<td><code>Month()</code></td>\n<td>返回一个日期的月份部分</td>\n</tr>\n<tr>\n<td><code>Now()</code></td>\n<td>返回当前日期和时间</td>\n</tr>\n<tr>\n<td><code>Second()</code></td>\n<td>返回一个时间的秒部分</td>\n</tr>\n<tr>\n<td><code>Time()</code></td>\n<td>返回一个日期时间的时间部分</td>\n</tr>\n<tr>\n<td><code>Year()</code></td>\n<td>返回一个日期的年份部分</td>\n</tr>\n</tbody>\n</table>\n<h3> 数值处理</h3>\n<table>\n<thead>\n<tr>\n<th>函数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>SIN()</td>\n<td>正弦</td>\n</tr>\n<tr>\n<td>COS()</td>\n<td>余弦</td>\n</tr>\n<tr>\n<td>TAN()</td>\n<td>正切</td>\n</tr>\n<tr>\n<td>ABS()</td>\n<td>绝对值</td>\n</tr>\n<tr>\n<td>SQRT()</td>\n<td>平方根</td>\n</tr>\n<tr>\n<td>MOD()</td>\n<td>余数</td>\n</tr>\n<tr>\n<td>EXP()</td>\n<td>指数</td>\n</tr>\n<tr>\n<td>PI()</td>\n<td>圆周率</td>\n</tr>\n<tr>\n<td>RAND()</td>\n<td>随机数</td>\n</tr>\n</tbody>\n</table>\n<h3> 汇总</h3>\n<table>\n<thead>\n<tr>\n<th>函 数</th>\n<th>说 明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>AVG()</code></td>\n<td>返回某列的平均值</td>\n</tr>\n<tr>\n<td><code>COUNT()</code></td>\n<td>返回某列的行数</td>\n</tr>\n<tr>\n<td><code>MAX()</code></td>\n<td>返回某列的最大值</td>\n</tr>\n<tr>\n<td><code>MIN()</code></td>\n<td>返回某列的最小值</td>\n</tr>\n<tr>\n<td><code>SUM()</code></td>\n<td>返回某列值之和</td>\n</tr>\n</tbody>\n</table>\n<p><code>AVG()</code> 会忽略 NULL 行。</p>\n<p>使用 <code>DISTINCT</code> 可以让汇总函数值汇总不同的值。</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>接下来，我们来介绍 DDL 语句用法。DDL 的主要功能是定义数据库对象（如：数据库、数据表、视图、索引等）</strong></p>\n<h2> 数据定义</h2>\n<h3> 数据库（DATABASE）</h3>\n<h4> 创建数据库</h4>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h4> 删除数据库</h4>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h4> 选择数据库</h4>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 数据表（TABLE）</h3>\n<h4> 创建数据表</h4>\n<p><strong>普通创建</strong></p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>根据已有的表创建新表</strong></p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 删除数据表</h4>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h4> 修改数据表</h4>\n<p><strong>添加列</strong></p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>删除列</strong></p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>修改列</strong></p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>添加主键</strong></p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>删除主键</strong></p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 视图（VIEW）</h3>\n<p>定义：</p>\n<ul>\n<li>视图是基于 SQL 语句的结果集的可视化的表。</li>\n<li>视图是虚拟的表，本身不包含数据，也就不能对其进行索引操作。对视图的操作和对普通表的操作一样。</li>\n</ul>\n<p>作用：</p>\n<ul>\n<li>简化复杂的 SQL 操作，比如复杂的联结；</li>\n<li>只使用实际表的一部分数据；</li>\n<li>通过只给用户访问视图的权限，保证数据的安全性；</li>\n<li>更改数据格式和表示。</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/b729ae386e7129e1b19f01b4b7d1ebe1.jpeg\" alt=\"mysql视图\"></p>\n<h4> 创建视图</h4>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 删除视图</h4>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 索引（INDEX）</h3>\n<p><strong>索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。</strong></p>\n<p>索引的作用就相当于书的目录。打个比方: 我们在查字典的时候，如果没有目录，那我们就只能一页一页的去找我们需要查的那个字，速度很慢。如果有目录了，我们只需要先去目录里查找字的位置，然后直接翻到那一页就行了。</p>\n<p><strong>优点</strong> ：</p>\n<ul>\n<li>使用索引可以大大加快 数据的检索速度（大大减少检索的数据量）, 这也是创建索引的最主要的原因。</li>\n<li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li>\n</ul>\n<p><strong>缺点</strong> ：</p>\n<ul>\n<li>创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。</li>\n<li>索引需要使用物理文件存储，也会耗费一定空间。</li>\n</ul>\n<p>但是，<strong>使用索引一定能提高查询性能吗?</strong></p>\n<p>大多数情况下，索引查询都是比全表扫描要快的。但是如果数据库的数据量不大，那么使用索引也不一定能够带来很大提升。</p>\n<p>关于索引的详细介绍，请看我写的 <a href=\"https://javaguide.cn/database/mysql/mysql-index.html\" target=\"_blank\" rel=\"noopener noreferrer\">MySQL 索引详解</a> 这篇文章。</p>\n<h4> 创建索引</h4>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 添加索引</h4>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h4> 创建唯一索引</h4>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 删除索引</h4>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 约束</h3>\n<p>SQL 约束用于规定表中的数据规则。</p>\n<p>如果存在违反约束的数据行为，行为会被约束终止。</p>\n<p>约束可以在创建表时规定（通过 CREATE TABLE 语句），或者在表创建之后规定（通过 ALTER TABLE 语句）。</p>\n<p>约束类型：</p>\n<ul>\n<li><code>NOT NULL</code> - 指示某列不能存储 NULL 值。</li>\n<li><code>UNIQUE</code> - 保证某列的每行必须有唯一的值。</li>\n<li><code>PRIMARY KEY</code> - NOT NULL 和 UNIQUE 的结合。确保某列（或两个列多个列的结合）有唯一标识，有助于更容易更快速地找到表中的一个特定的记录。</li>\n<li><code>FOREIGN KEY</code> - 保证一个表中的数据匹配另一个表中的值的参照完整性。</li>\n<li><code>CHECK</code> - 保证列中的值符合指定的条件。</li>\n<li><code>DEFAULT</code> - 规定没有给列赋值时的默认值。</li>\n</ul>\n<p>创建表时使用约束条件：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>接下来，我们来介绍 TCL 语句用法。TCL 的主要功能是管理数据库中的事务。</strong></p>\n<h2> 事务处理</h2>\n<p>不能回退 <code>SELECT</code> 语句，回退 <code>SELECT</code> 语句也没意义；也不能回退 <code>CREATE</code> 和 <code>DROP</code> 语句。</p>\n<p><strong>MySQL 默认是隐式提交</strong>，每执行一条语句就把这条语句当成一个事务然后进行提交。当出现 <code>START TRANSACTION</code> 语句时，会关闭隐式提交；当 <code>COMMIT</code> 或 <code>ROLLBACK</code> 语句执行后，事务会自动关闭，重新恢复隐式提交。</p>\n<p>通过 <code>set autocommit=0</code> 可以取消自动提交，直到 <code>set autocommit=1</code> 才会提交；<code>autocommit</code> 标记是针对每个连接而不是针对服务器的。</p>\n<p>指令：</p>\n<ul>\n<li><code>START TRANSACTION</code> - 指令用于标记事务的起始点。</li>\n<li><code>SAVEPOINT</code> - 指令用于创建保留点。</li>\n<li><code>ROLLBACK TO</code> - 指令用于回滚到指定的保留点；如果没有设置保留点，则回退到 <code>START TRANSACTION</code> 语句处。</li>\n<li><code>COMMIT</code> - 提交事务。</li>\n</ul>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>接下来，我们来介绍 DCL 语句用法。DCL 的主要功能是控制用户的访问权限。</strong></p>\n<h2> 权限控制</h2>\n<p>要授予用户帐户权限，可以用<code>GRANT</code>命令。有撤销用户的权限，可以用<code>REVOKE</code>命令。这里以 MySQl 为例，介绍权限控制实际应用。</p>\n<p><code>GRANT</code>授予权限语法：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>简单解释一下：</p>\n<ol>\n<li>在<code>GRANT</code>关键字后指定一个或多个权限。如果授予用户多个权限，则每个权限由逗号分隔。</li>\n<li><code>ON privilege_level</code> 确定权限应用级别。MySQL 支持 global（<code>*.*</code>），database（<code>database.*</code>），table（<code>database.table</code>）和列级别。如果使用列权限级别，则必须在每个权限之后指定一个或逗号分隔列的列表。</li>\n<li><code>user</code> 是要授予权限的用户。如果用户已存在，则<code>GRANT</code>语句将修改其权限。否则，<code>GRANT</code>语句将创建一个新用户。可选子句<code>IDENTIFIED BY</code>允许您为用户设置新的密码。</li>\n<li><code>REQUIRE tsl_option</code>指定用户是否必须通过 SSL，X059 等安全连接连接到数据库服务器。</li>\n<li>可选 <code>WITH GRANT OPTION</code> 子句允许您授予其他用户或从其他用户中删除您拥有的权限。此外，您可以使用<code>WITH</code>子句分配 MySQL 数据库服务器的资源，例如，设置用户每小时可以使用的连接数或语句数。这在 MySQL 共享托管等共享环境中非常有用。</li>\n</ol>\n<p><code>REVOKE</code> 撤销权限语法：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>简单解释一下：</p>\n<ol>\n<li>在 <code>REVOKE</code> 关键字后面指定要从用户撤消的权限列表。您需要用逗号分隔权限。</li>\n<li>指定在 <code>ON</code> 子句中撤销特权的特权级别。</li>\n<li>指定要撤消 <code>FROM</code> 子句中的权限的用户帐户。</li>\n</ol>\n<p><code>GRANT</code> 和 <code>REVOKE</code> 可在几个层次上控制访问权限：</p>\n<ul>\n<li>整个服务器，使用 <code>GRANT ALL</code> 和 <code>REVOKE ALL</code>；</li>\n<li>整个数据库，使用 <code>ON database.*</code>；</li>\n<li>特定的表，使用 <code>ON database.table</code>；</li>\n<li>特定的列；</li>\n<li>特定的存储过程。</li>\n</ul>\n<p>新创建的账户没有任何权限。账户用 <code>username@host</code> 的形式定义，<code>username@%</code> 使用的是默认主机名。MySQL 的账户信息保存在 mysql 这个数据库中。</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>下表说明了可用于<code>GRANT</code>和<code>REVOKE</code>语句的所有允许权限：</p>\n<table>\n<thead>\n<tr>\n<th><strong>特权</strong></th>\n<th><strong>说明</strong></th>\n<th><strong>级别</strong></th>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>全局</strong></td>\n<td>数据库</td>\n<td><strong>表</strong></td>\n<td><strong>列</strong></td>\n<td><strong>程序</strong></td>\n<td><strong>代理</strong></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>ALL [PRIVILEGES]</td>\n<td>授予除 GRANT OPTION 之外的指定访问级别的所有权限</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>ALTER</td>\n<td>允许用户使用 ALTER TABLE 语句</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>ALTER ROUTINE</td>\n<td>允许用户更改或删除存储的例程</td>\n<td>X</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td>X</td>\n<td></td>\n</tr>\n<tr>\n<td>CREATE</td>\n<td>允许用户创建数据库和表</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>CREATE ROUTINE</td>\n<td>允许用户创建存储的例程</td>\n<td>X</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>CREATE TABLESPACE</td>\n<td>允许用户创建，更改或删除表空间和日志文件组</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>CREATE TEMPORARY TABLES</td>\n<td>允许用户使用 CREATE TEMPORARY TABLE 创建临时表</td>\n<td>X</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>CREATE USER</td>\n<td>允许用户使用 CREATE USER，DROP USER，RENAME USER 和 REVOKE ALL PRIVILEGES 语句。</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>CREATE VIEW</td>\n<td>允许用户创建或修改视图。</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>DELETE</td>\n<td>允许用户使用 DELETE</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>DROP</td>\n<td>允许用户删除数据库，表和视图</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>EVENT</td>\n<td>启用事件计划程序的事件使用。</td>\n<td>X</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>EXECUTE</td>\n<td>允许用户执行存储的例程</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>FILE</td>\n<td>允许用户读取数据库目录中的任何文件。</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>GRANT OPTION</td>\n<td>允许用户拥有授予或撤消其他帐户权限的权限。</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td></td>\n<td>X</td>\n<td>X</td>\n</tr>\n<tr>\n<td>INDEX</td>\n<td>允许用户创建或删除索引。</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>INSERT</td>\n<td>允许用户使用 INSERT 语句</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>LOCK TABLES</td>\n<td>允许用户对具有 SELECT 权限的表使用 LOCK TABLES</td>\n<td>X</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>PROCESS</td>\n<td>允许用户使用 SHOW PROCESSLIST 语句查看所有进程。</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>PROXY</td>\n<td>启用用户代理。</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>REFERENCES</td>\n<td>允许用户创建外键</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>RELOAD</td>\n<td>允许用户使用 FLUSH 操作</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>REPLICATION CLIENT</td>\n<td>允许用户查询以查看主服务器或从属服务器的位置</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>REPLICATION SLAVE</td>\n<td>允许用户使用复制从属从主服务器读取二进制日志事件。</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>SELECT</td>\n<td>允许用户使用 SELECT 语句</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>SHOW DATABASES</td>\n<td>允许用户显示所有数据库</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>SHOW VIEW</td>\n<td>允许用户使用 SHOW CREATE VIEW 语句</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>SHUTDOWN</td>\n<td>允许用户使用 mysqladmin shutdown 命令</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>SUPER</td>\n<td>允许用户使用其他管理操作，例如 CHANGE MASTER TO，KILL，PURGE BINARY LOGS，SET GLOBAL 和 mysqladmin 命令</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>TRIGGER</td>\n<td>允许用户使用 TRIGGER 操作。</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>UPDATE</td>\n<td>允许用户使用 UPDATE 语句</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>USAGE</td>\n<td>相当于“没有特权”</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h3> 创建账户</h3>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 修改账户名</h3>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 删除账户</h3>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 查看权限</h3>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 授予权限</h3>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 删除权限</h3>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 更改密码</h3>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 存储过程</h2>\n<p>存储过程可以看成是对一系列 SQL 操作的批处理。存储过程可以由触发器，其他存储过程以及 Java， Python，PHP 等应用程序调用。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/704fc0ff1d31f4344dc1fca6f51fe1df.jpeg\" alt=\"mysql存储过程\"></p>\n<p>使用存储过程的好处：</p>\n<ul>\n<li>代码封装，保证了一定的安全性；</li>\n<li>代码复用；</li>\n<li>由于是预先编译，因此具有很高的性能。</li>\n</ul>\n<p>创建存储过程：</p>\n<ul>\n<li>命令行中创建存储过程需要自定义分隔符，因为命令行是以 <code>;</code> 为结束符，而存储过程中也包含了分号，因此会错误把这部分分号当成是结束符，造成语法错误。</li>\n<li>包含 <code>in</code>、<code>out</code> 和 <code>inout</code> 三种参数。</li>\n<li>给变量赋值都需要用 <code>select into</code> 语句。</li>\n<li>每次只能给一个变量赋值，不支持集合的操作。</li>\n</ul>\n<p>需要注意的是：<strong>阿里巴巴《Java 开发手册》强制禁止使用存储过程。因为存储过程难以调试和扩展，更没有移植性。</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/b21935087517d622d1f04e4a838cb12f.png\" alt=\"\"></p>\n<p>至于到底要不要在项目中使用，还是要看项目实际需求，权衡好利弊即可！</p>\n<h3> 创建存储过程</h3>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 使用存储过程</h3>\n<div class=\"language-less line-numbers-mode\" data-ext=\"less\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 游标</h2>\n<p>游标（cursor）是一个存储在 DBMS 服务器上的数据库查询，它不是一条 <code>SELECT</code> 语句，而是被该语句检索出来的结果集。</p>\n<p>在存储过程中使用游标可以对一个结果集进行移动遍历。</p>\n<p>游标主要用于交互式应用，其中用户需要滚动屏幕上的数据，并对数据进行浏览或做出更改。</p>\n<p>使用游标的几个明确步骤：</p>\n<ul>\n<li>\n<p>在使用游标前，必须声明(定义)它。这个过程实际上没有检索数据， 它只是定义要使用的 <code>SELECT</code> 语句和游标选项。</p>\n</li>\n<li>\n<p>一旦声明，就必须打开游标以供使用。这个过程用前面定义的 SELECT 语句把数据实际检索出来。</p>\n</li>\n<li>\n<p>对于填有数据的游标，根据需要取出(检索)各行。</p>\n</li>\n<li>\n<p>在结束游标使用时，必须关闭游标，可能的话，释放游标(有赖于具</p>\n<p>体的 DBMS)。</p>\n</li>\n</ul>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 触发器</h2>\n<p>触发器是一种与表操作有关的数据库对象，当触发器所在表上出现指定事件时，将调用该对象，即表的操作事件触发表上的触发器的执行。</p>\n<p>我们可以使用触发器来进行审计跟踪，把修改记录到另外一张表中。</p>\n<p>使用触发器的优点：</p>\n<ul>\n<li>SQL 触发器提供了另一种检查数据完整性的方法。</li>\n<li>SQL 触发器可以捕获数据库层中业务逻辑中的错误。</li>\n<li>SQL 触发器提供了另一种运行计划任务的方法。通过使用 SQL 触发器，您不必等待运行计划任务，因为在对表中的数据进行更改之前或之后会自动调用触发器。</li>\n<li>SQL 触发器对于审计表中数据的更改非常有用。</li>\n</ul>\n<p>使用触发器的缺点：</p>\n<ul>\n<li>SQL 触发器只能提供扩展验证，并且不能替换所有验证。必须在应用程序层中完成一些简单的验证。例如，您可以使用 JavaScript 在客户端验证用户的输入，或者使用服务器端脚本语言（如 JSP，PHP，ASP.NET，Perl）在服务器端验证用户的输入。</li>\n<li>从客户端应用程序调用和执行 SQL 触发器是不可见的，因此很难弄清楚数据库层中发生了什么。</li>\n<li>SQL 触发器可能会增加数据库服务器的开销。</li>\n</ul>\n<p>MySQL 不允许在触发器中使用 CALL 语句 ，也就是不能调用存储过程。</p>\n<blockquote>\n<p>注意：在 MySQL 中，分号 <code>;</code> 是语句结束的标识符，遇到分号表示该段语句已经结束，MySQL 可以开始执行了。因此，解释器遇到触发器执行动作中的分号后就开始执行，然后会报错，因为没有找到和 BEGIN 匹配的 END。</p>\n<p>这时就会用到 <code>DELIMITER</code> 命令（DELIMITER 是定界符，分隔符的意思）。它是一条命令，不需要语句结束标识，语法为：<code>DELIMITER new_delemiter</code>。<code>new_delemiter</code> 可以设为 1 个或多个长度的符号，默认的是分号 <code>;</code>，我们可以把它修改为其他符号，如 <code>$</code> - <code>DELIMITER $</code> 。在这之后的语句，以分号结束，解释器不会有什么反应，只有遇到了 <code>$</code>，才认为是语句结束。注意，使用完之后，我们还应该记得把它给修改回来。</p>\n</blockquote>\n<p>在 MySQL 5.7.2 版之前，可以为每个表定义最多六个触发器。</p>\n<ul>\n<li><code>BEFORE INSERT</code> - 在将数据插入表格之前激活。</li>\n<li><code>AFTER INSERT</code> - 将数据插入表格后激活。</li>\n<li><code>BEFORE UPDATE</code> - 在更新表中的数据之前激活。</li>\n<li><code>AFTER UPDATE</code> - 更新表中的数据后激活。</li>\n<li><code>BEFORE DELETE</code> - 在从表中删除数据之前激活。</li>\n<li><code>AFTER DELETE</code> - 从表中删除数据后激活。</li>\n</ul>\n<p>但是，从 MySQL 版本 5.7.2+开始，可以为同一触发事件和操作时间定义多个触发器。</p>\n<p><strong><code>NEW</code> 和 <code>OLD</code></strong> ：</p>\n<ul>\n<li>MySQL 中定义了 <code>NEW</code> 和 <code>OLD</code> 关键字，用来表示触发器的所在表中，触发了触发器的那一行数据。</li>\n<li>在 <code>INSERT</code> 型触发器中，<code>NEW</code> 用来表示将要（<code>BEFORE</code>）或已经（<code>AFTER</code>）插入的新数据；</li>\n<li>在 <code>UPDATE</code> 型触发器中，<code>OLD</code> 用来表示将要或已经被修改的原数据，<code>NEW</code> 用来表示将要或已经修改为的新数据；</li>\n<li>在 <code>DELETE</code> 型触发器中，<code>OLD</code> 用来表示将要或已经被删除的原数据；</li>\n<li>使用方法： <code>NEW.columnName</code> （columnName 为相应数据表某一列名）</li>\n</ul>\n<h3> 创建触发器</h3>\n<blockquote>\n<p>提示：为了理解触发器的要点，有必要先了解一下创建触发器的指令。</p>\n</blockquote>\n<p><code>CREATE TRIGGER</code> 指令用于创建触发器。</p>\n<p>语法：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>说明：</p>\n<ul>\n<li><code>trigger_name</code> ：触发器名</li>\n<li><code>trigger_time</code> : 触发器的触发时机。取值为 <code>BEFORE</code> 或 <code>AFTER</code>。</li>\n<li><code>trigger_event</code> : 触发器的监听事件。取值为 <code>INSERT</code>、<code>UPDATE</code> 或 <code>DELETE</code>。</li>\n<li><code>table_name</code> : 触发器的监听目标。指定在哪张表上建立触发器。</li>\n<li><code>FOR EACH ROW</code>: 行级监视，Mysql 固定写法，其他 DBMS 不同。</li>\n<li><code>trigger_statements</code>: 触发器执行动作。是一条或多条 SQL 语句的列表，列表内的每条语句都必须用分号 <code>;</code> 来结尾。</li>\n</ul>\n<p>当触发器的触发条件满足时，将会执行 <code>BEGIN</code> 和 <code>END</code> 之间的触发器执行动作。</p>\n<p>示例：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 查看触发器</h3>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 删除触发器</h3>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 文章推荐</h2>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/I-ZT3zGTNBZ6egS7T09jyQ\" target=\"_blank\" rel=\"noopener noreferrer\">后端程序员必备：SQL高性能优化指南！35+条优化建议立马GET!</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247486461&amp;idx=1&amp;sn=60a22279196d084cc398936fe3b37772&amp;chksm=cea24436f9d5cd20a4fa0e907590f3e700d7378b3f608d7b33bb52cfb96f503b7ccb65a1deed&amp;token=1987003517&amp;lang=zh_CN#rd\" target=\"_blank\" rel=\"noopener noreferrer\">后端程序员必备：书写高质量SQL的30条建议</a></li>\n</ul>\n",
      "image": "https://img-blog.csdnimg.cn/img_convert/812dc1e042d44b6a2d4331d31a25ddc6.png",
      "date_published": "2023-02-17T05:40:22.000Z",
      "date_modified": "2023-02-23T04:45:00.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "数据库"
      ]
    },
    {
      "title": "Gradle 核心概念总结",
      "url": "https://javaguide.cn/tools/gradle/gradle-core-concepts.html",
      "id": "https://javaguide.cn/tools/gradle/gradle-core-concepts.html",
      "summary": "这部分内容主要根据 Gradle 官方文档整理，做了对应的删减，主要保留比较重要的部分，不涉及实战，主要是一些重要概念的介绍。 Gradle 这部分内容属于可选内容，可以根据自身需求决定是否学习，目前国内还是使用 Maven 普遍一些。 Gradle 介绍 Gradle 官方文档是这样介绍的 Gradle 的： Gradle is an open-source build automation tool flexible enough to build almost any type of software. Gradle makes few assumptions about what you’re trying to build or how to build it. This makes Gradle particularly flexible. Gradle 是一个开源的构建自动化工具，它足够灵活，可以构建几乎任何类型的软件。Gradle 对你要构建什么或者如何构建它做了很少的假设。这使得 Gradle 特别灵活。",
      "content_html": "<blockquote>\n<p>这部分内容主要根据 Gradle 官方文档整理，做了对应的删减，主要保留比较重要的部分，不涉及实战，主要是一些重要概念的介绍。</p>\n</blockquote>\n<p>Gradle 这部分内容属于可选内容，可以根据自身需求决定是否学习，目前国内还是使用 Maven 普遍一些。</p>\n<h2> Gradle 介绍</h2>\n<p>Gradle 官方文档是这样介绍的 Gradle 的：</p>\n<blockquote>\n<p>Gradle is an open-source <a href=\"https://en.wikipedia.org/wiki/Build_automation\" target=\"_blank\" rel=\"noopener noreferrer\">build automation</a> tool flexible enough to build almost any type of software. Gradle makes few assumptions about what you’re trying to build or how to build it. This makes Gradle particularly flexible.</p>\n<p>Gradle 是一个开源的构建自动化工具，它足够灵活，可以构建几乎任何类型的软件。Gradle 对你要构建什么或者如何构建它做了很少的假设。这使得 Gradle 特别灵活。</p>\n</blockquote>\n<p>简单来说，Gradle 就是一个运行在 JVM 上的自动化的项目构建工具，用来帮助我们自动构建项目。</p>\n<p>对于开发者来说，Gradle 的主要作用主要有 3 个：</p>\n<ol>\n<li><strong>项目构建</strong> ：提供标准的、跨平台的自动化项目构建方式。</li>\n<li><strong>依赖管理</strong> ：方便快捷的管理项目依赖的资源（jar 包），避免资源间的版本冲突问题。</li>\n<li><strong>统一开发结构</strong> ：提供标准的、统一的项目结构。</li>\n</ol>\n<p>Gradle 构建脚本是使用 Groovy 或 Kotlin 语言编写的，表达能力非常强，也足够灵活。</p>\n<h2> Groovy 介绍</h2>\n<p>Gradle 是运行在 JVM 上的一个程序，它可以使用 Groovy 来编写构建脚本。</p>\n<p>Groovy 是运行在 JVM 上的脚本语言，是基于 Java 扩展的动态语言，它的语法和 Java 非常的相似，可以使用 Java 的类库。Groovy 可以用于面向对象编程，也可以用作纯粹的脚本语言。在语言的设计上它吸纳了 Java 、Python、Ruby 和 Smalltalk 语言的优秀特性，比如动态类型转换、闭包和元编程支持。</p>\n<p>我们可以用学习 Java 的方式去学习 Groovy ，学习成本相对来说还是比较低的，即使开发过程中忘记 Groovy 语法，也可以用 Java 语法继续编码。</p>\n<p>基于 JVM 的语言有很多种比如 Groovy，Kotlin，Java，Scala，他们最终都会编译生成 Java 字节码文件并在 JVM 上运行。</p>\n<h2> Gradle 优势</h2>\n<p>Gradle 是新一代的构建系统，具有高效和灵活等诸多优势，广泛用于 Java 开发。不仅 Android 将其作为官方构建系统, 越来越多的 Java 项目比如 Spring Boot 也慢慢迁移到 Gradle。</p>\n<ul>\n<li>在灵活性上，Gradle 支持基于 Groovy 语言编写脚本，侧重于构建过程的灵活性，适合于构建复杂度较高的项目，可以完成非常复杂的构建。</li>\n<li>在粒度性上，Gradle 构建的粒度细化到了每一个 task 之中。并且它所有的 Task 源码都是开源的，在我们掌握了这一整套打包流程后，我们就可以通过去修改它的 Task 去动态改变其执行流程。</li>\n<li>在扩展性上，Gradle 支持插件机制，所以我们可以复用这些插件，就如同复用库一样简单方便。</li>\n</ul>\n<h2> Gradle Wrapper 介绍</h2>\n<p>Gradle 官方文档是这样介绍的 Gradle Wrapper 的：</p>\n<blockquote>\n<p>The recommended way to execute any Gradle build is with the help of the Gradle Wrapper (in short just “Wrapper”). The Wrapper is a script that invokes a declared version of Gradle, downloading it beforehand if necessary. As a result, developers can get up and running with a Gradle project quickly without having to follow manual installation processes saving your company time and money.</p>\n<p>执行 Gradle 构建的推荐方法是借助 Gradle Wrapper(简而言之就是“Wrapper”)。Wrapper 它是一个脚本，调用了已经声明的 Gradle 版本，如果需要的话，可以预先下载它。因此，开发人员可以快速启动并运行 Gradle 项目，而不必遵循手动安装过程，从而为公司节省时间和金钱。</p>\n</blockquote>\n<p>我们可以称 Gradle Wrapper 为 Gradle 包装器，它将 Gradle 再次包装，让所有的 Gradle 构建方法在 Gradle 包装器的帮助下运行。</p>\n<p>Gradle Wrapper 的工作流程图如下（图源<a href=\"https://docs.gradle.org/current/userguide/gradle_wrapper.html\" target=\"_blank\" rel=\"noopener noreferrer\">Gradle Wrapper 官方文档介绍</a>）：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/efa7a0006b04051e2b84cd116c6ccdfc.png\" alt=\"包装器工作流程\"></p>\n<p>整个流程主要分为下面 3 步：</p>\n<ol>\n<li>首先当我们刚创建的时候，如果指定的版本没有被下载，就先会去 Gradle 的服务器中下载对应版本的压缩包；</li>\n<li>下载完成后需要先进行解压缩并且执行批处理文件；</li>\n<li>后续项目每次构建都会重用这个解压过的 Gradle 版本。</li>\n</ol>\n<p>Gradle Wrapper 会给我们带来下面这些好处：</p>\n<ol>\n<li>在给定的 Gradle 版本上标准化项目，从而实现更可靠和健壮的构建。</li>\n<li>可以让我们的电脑中不安装 Gradle 环境也可以运行 Gradle 项目。</li>\n<li>为不同的用户和执行环境（例如 IDE 或持续集成服务器）提供新的 Gradle 版本就像更改 Wrapper 定义一样简单。</li>\n</ol>\n<h3> 生成 Gradle Wrapper</h3>\n<p>如果想要生成 Gradle Wrapper 的话，需要本地配置好 Gradle 环境变量。Gradle 中已经内置了内置了 Wrapper Task，在项目根目录执行执行<code>gradle wrapper</code>命令即可帮助我们生成 Gradle Wrapper。</p>\n<p>执行命令 <code>gradle wrapper</code> 命令时可以指定一些参数来控制 wrapper 的生成。具体有如下两个配置参数：</p>\n<ul>\n<li><code>--gradle-version</code> 用于指定使用的 Gradle 的版本</li>\n<li><code>--gradle-distribution-url</code> 用于指定下载 Gradle 版本的 URL，该值的规则是 <code>http://services.gradle.org/distributions/gradle-${gradleVersion}-bin.zip</code></li>\n</ul>\n<p>执行<code>gradle wrapper</code>命令之后，Gradle Wrapper 就生成完成了，项目根目录中生成如下文件：</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>每个文件的含义如下：</p>\n<ul>\n<li><code>gradle-wrapper.jar</code>：包含了 Gradle 运行时的逻辑代码。</li>\n<li><code>gradle-wrapper.properties</code> ： 定义了 Gradle 的版本号和 Gradle 运行时的行为属性。</li>\n<li><code>gradlew</code>：Linux 平台下，用于执行 Gralde 命令的包装器脚本。</li>\n<li><code>gradlew.bat</code>：Windows 平台下，用于执行 Gralde 命令的包装器脚本。</li>\n</ul>\n<p><code>gradle-wrapper.properties</code> 文件的内容如下：</p>\n<div class=\"language-properties line-numbers-mode\" data-ext=\"properties\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li><code>distributionBase</code>： Gradle 解包后存储的父目录。</li>\n<li><code>distributionPath</code>： <code>distributionBase</code>指定目录的子目录。<code>distributionBase+distributionPath</code>就是 Gradle 解包后的存放的具体目录。</li>\n<li><code>distributionUrl</code>： Gradle 指定版本的压缩包下载地址。</li>\n<li><code>zipStoreBase</code>： Gradle 压缩包下载后存储父目录。</li>\n<li><code>zipStorePath</code>： <code>zipStoreBase</code>指定目录的子目录。<code>zipStoreBase+zipStorePath</code>就是 Gradle 压缩包的存放位置。</li>\n</ul>\n<h3> 更新 Gradle Wrapper</h3>\n<p>更新 Gradle Wrapper 有 2 种方式：</p>\n<ol>\n<li>接修改<code>distributionUrl</code>字段，然后执行 Gradle 命令。</li>\n<li>执行 gradlew 命令<code>gradlew wrapper –-gradle-version [version]</code>。</li>\n</ol>\n<p>下面的命令会将 Gradle 版本升级为 7.6。</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p><code>gradle-wrapper.properties</code> 文件中的 <code>distributionUrl</code> 属性也发生了改变。</p>\n<div class=\"language-properties line-numbers-mode\" data-ext=\"properties\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 自定义 Gradle Wrapper</h3>\n<p>Gradle 已经内置了 Wrapper Task，因此构建 Gradle Wrapper 会生成 Gradle Wrapper 的属性文件，这个属性文件可以通过自定义 Wrapper Task 来设置。比如我们想要修改要下载的 Gralde 版本为 7.6，可以这么设置：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>也可以设置 Gradle 发行版压缩包的下载地址和 Gradle 解包后的本地存储路径等配置。</p>\n<div class=\"language-groovy line-numbers-mode\" data-ext=\"groovy\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>distributionUrl</code> 属性可以设置为本地的项目目录，你也可以设置为网络地址。</p>\n<h2> Gradle 任务</h2>\n<p>在 Gradle 中，任务(Task)是构建执行的单个工作单元。</p>\n<p>Gradle 的构建是基于 Task 进行的，当你运行项目的时候，实际就是在执行了一系列的 Task 比如编译 Java 源码的 Task、生成 jar 文件的 Task。</p>\n<p>Task 的声明方式如下（还有其他几种声明方式）：</p>\n<div class=\"language-groovy line-numbers-mode\" data-ext=\"groovy\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>创建一个 Task 后，可以根据需要给 Task 添加不同的 Action，上面的“doLast”就是给队列尾增加一个 Action。</p>\n<div class=\"language-groovy line-numbers-mode\" data-ext=\"groovy\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>一个 Task 中可以有多个 Acton，从队列头部开始向队列尾部执行 Acton。</p>\n<p>Action 代表的是一个个函数、方法，每个 Task 都是一堆 Action 按序组成的执行图。</p>\n<p>Task 声明依赖的关键字是<code>dependsOn</code>，支持声明一个或多个依赖：</p>\n<div class=\"language-groovy line-numbers-mode\" data-ext=\"groovy\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>执行 Task 之前，会先执行它的依赖 Task。</p>\n<p>我们还可以设置默认 Task，脚本中我们不调用默认 Task ，也会执行。</p>\n<div class=\"language-groovy line-numbers-mode\" data-ext=\"groovy\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>Gradle 本身也内置了很多 Task 比如 copy（复制文件）、delete（删除文件）。</p>\n<div class=\"language-groovy line-numbers-mode\" data-ext=\"groovy\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> Gradle 插件</h2>\n<p>Gradle 提供的是一套核心的构建机制，而 Gradle 插件则是运行在这套机制上的一些具体构建逻辑，其本质上和 <code>.gradle</code> 文件是相同。你可以将 Gradle 插件看作是封装了一系列 Task 并执行的工具。</p>\n<p>Gradle 插件主要分为两类：</p>\n<ul>\n<li>脚本插件： 脚本插件就是一个普通的脚本文件，它可以被导入都其他构建脚本中。</li>\n<li>二进制插件 / 对象插件：在一个单独的插件模块中定义，其他模块通过 Plugin ID 应用插件。因为这种方式发布和复用更加友好，我们一般接触到的 Gradle 插件都是指二进制插件的形式。</li>\n</ul>\n<p>虽然 Gradle 插件与 .gradle 文件本质上没有区别，<code>.gradle</code> 文件也能实现 Gradle 插件类似的功能。但是，Gradle 插件使用了独立模块封装构建逻辑，无论是从开发开始使用来看，Gradle 插件的整体体验都更友好。</p>\n<ul>\n<li><strong>逻辑复用：</strong> 将相同的逻辑提供给多个相似项目复用，减少重复维护类似逻辑开销。当然 .gradle 文件也能做到逻辑复用，但 Gradle 插件的封装性更好；</li>\n<li><strong>组件发布：</strong> 可以将插件发布到 Maven 仓库进行管理，其他项目可以使用插件 ID 依赖。当然 .gradle 文件也可以放到一个远程路径被其他项目引用；</li>\n<li><strong>构建配置：</strong> Gradle 插件可以声明插件扩展来暴露可配置的属性，提供定制化能力。当然 .gradle 文件也可以做到，但实现会麻烦些。</li>\n</ul>\n<h2> Gradle 构建生命周期</h2>\n<p>Gradle 构建的生命周期有三个阶段：<strong>初始化阶段，配置阶段</strong>和<strong>运行阶段</strong>。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/dadbdf59fccd9a2ebf60a2d018541e52.png\" alt=\"\"></p>\n<p>在初始化阶段与配置阶段之间、配置阶段结束之后、执行阶段结束之后，我们都可以加一些定制化的 Hook。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/5c297ccc4dac83229ff3e19caee9d1d2.png\" alt=\"\"></p>\n<h3> 初始化阶段</h3>\n<p>Gradle 支持单项目和多项目构建。在初始化阶段，Gradle 确定哪些项目将参与构建，并为每个项目创建一个 <a href=\"https://docs.gradle.org/current/dsl/org.gradle.api.Project.html\" target=\"_blank\" rel=\"noopener noreferrer\">Project 实例</a> 。本质上也就是执行 <code>settings.gradle</code> 脚本，从而读取整个项目中有多少个 Project 实例。</p>\n<h3> 配置阶段</h3>\n<p>在配置阶段，Gradle 会解析每个工程的 <code>build.gradle</code> 文件，创建要执行的任务子集和确定各种任务之间的关系，以供执行阶段按照顺序执行，并对任务的做一些初始化配置。</p>\n<p>每个 <code>build.gradle</code> 对应一个 Project 对象，配置阶段执行的代码包括 <code>build.gradle</code> 中的各种语句、闭包以及 Task 中的配置语句。</p>\n<p>在配置阶段结束后，Gradle 会根据 Task 的依赖关系会创建一个 <strong>有向无环图</strong> 。</p>\n<h3> 运行阶段</h3>\n<p>在运行阶段，Gradle 根据配置阶段创建和配置的要执行的任务子集，执行任务。</p>\n<h2> 参考</h2>\n<ul>\n<li>Gradle 官方文档：https://docs.gradle.org/current/userguide/userguide.html</li>\n<li>Gradle 入门教程：https://www.imooc.com/wiki/gradlebase</li>\n<li>Groovy 快速入门看这篇就够了：https://cloud.tencent.com/developer/article/1358357</li>\n<li>【Gradle】Gradle 的生命周期详解：https://juejin.cn/post/7067719629874921508</li>\n<li>手把手带你自定义 Gradle 插件 —— Gradle 系列(2)：https://www.cnblogs.com/pengxurui/p/16281537.html</li>\n<li>Gradle 爬坑指南 -- 理解 Plugin、Task、构建流程：https://juejin.cn/post/6889090530593112077</li>\n</ul>\n",
      "image": "https://img-blog.csdnimg.cn/img_convert/efa7a0006b04051e2b84cd116c6ccdfc.png",
      "date_published": "2023-02-02T10:43:22.000Z",
      "date_modified": "2023-02-02T10:43:22.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "开发工具"
      ]
    },
    {
      "title": "MySQL自增主键一定是连续的吗",
      "url": "https://javaguide.cn/database/mysql/mysql-auto-increment-primary-key-continuous.html",
      "id": "https://javaguide.cn/database/mysql/mysql-auto-increment-primary-key-continuous.html",
      "summary": "作者：飞天小牛肉 原文：https://mp.weixin.qq.com/s/qci10h9rJx_COZbHV3aygQ 众所周知，自增主键可以让聚集索引尽量地保持递增顺序插入，避免了随机查询，从而提高了查询效率。 但实际上，MySQL 的自增主键并不能保证一定是连续递增的。 下面举个例子来看下，如下所示创建一张表：",
      "content_html": "<blockquote>\n<p>作者：飞天小牛肉</p>\n<p>原文：https://mp.weixin.qq.com/s/qci10h9rJx_COZbHV3aygQ</p>\n</blockquote>\n<p>众所周知，自增主键可以让聚集索引尽量地保持递增顺序插入，避免了随机查询，从而提高了查询效率。</p>\n<p>但实际上，MySQL 的自增主键并不能保证一定是连续递增的。</p>\n<p>下面举个例子来看下，如下所示创建一张表：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/a430d55df72ed9ff6e1af19f8261223c.png\" alt=\"\"></p>\n<h2> 自增值保存在哪里？</h2>\n<p>使用 <code>insert into test_pk values(null, 1, 1)</code> 插入一行数据，再执行 <code>show create table</code> 命令来看一下表的结构定义：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/0469b76c3792818802d6f43cf889d0ad.png\" alt=\"\"></p>\n<p>上述表的结构定义存放在后缀名为 <code>.frm</code> 的本地文件中，在 MySQL 安装目录下的 data 文件夹下可以找到这个 <code>.frm</code> 文件：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/6a48b796e4426ec51441b57575947441.png\" alt=\"\"></p>\n<p>从上述表结构可以看到，表定义里面出现了一个 <code>AUTO_INCREMENT=2</code>，表示下一次插入数据时，如果需要自动生成自增值，会生成 id = 2。</p>\n<p>但需要注意的是，自增值并不会保存在这个表结构也就是 <code>.frm</code> 文件中，不同的引擎对于自增值的保存策略不同：</p>\n<p>1）MyISAM 引擎的自增值保存在数据文件中</p>\n<p>2）InnoDB 引擎的自增值，其实是保存在了内存里，并没有持久化。第一次打开表的时候，都会去找自增值的最大值 <code>max(id)</code>，然后将 <code>max(id)+1</code> 作为这个表当前的自增值。</p>\n<p>举个例子：我们现在表里当前数据行里最大的 id 是 1，AUTO_INCREMENT=2，对吧。这时候，我们删除 id=1 的行，AUTO_INCREMENT 还是 2。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/ae4667ff97b8dc1d9362d1be31e8a166.png\" alt=\"\"></p>\n<p>但如果马上重启 MySQL 实例，重启后这个表的 AUTO_INCREMENT 就会变成 1。﻿也就是说，MySQL 重启可能会修改一个表的 AUTO_INCREMENT 的值。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/7c2c8bc3837fa2bca6ae21616aaa2f72.png\" alt=\"\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/44d93e6237a4212fe86d334615cee552.png\" alt=\"\"></p>\n<p>以上，是在我本地 MySQL 5.x 版本的实验，实际上，<strong>到了 MySQL 8.0 版本后，自增值的变更记录被放在了 redo log 中，提供了自增值持久化的能力</strong> ，也就是实现了“如果发生重启，表的自增值可以根据 redo  log 恢复为 MySQL 重启前的值”</p>\n<p>也就是说对于上面这个例子来说，重启实例后这个表的 AUTO_INCREMENT 仍然是 2。</p>\n<p>理解了 MySQL 自增值到底保存在哪里以后，我们再来看看自增值的修改机制，并以此引出第一种自增值不连续的场景。</p>\n<h2> 自增值不连续的场景</h2>\n<h3> 自增值不连续场景 1</h3>\n<p>在 MySQL 里面，如果字段 id 被定义为 AUTO_INCREMENT，在插入一行数据的时候，自增值的行为如下：</p>\n<ul>\n<li>如果插入数据时 id 字段指定为 0、null 或未指定值，那么就把这个表当前的 AUTO_INCREMENT 值填到自增字段；</li>\n<li>如果插入数据时 id 字段指定了具体的值，就直接使用语句里指定的值。</li>\n</ul>\n<p>根据要插入的值和当前自增值的大小关系，自增值的变更结果也会有所不同。假设某次要插入的值是 <code>insert_num</code>，当前的自增值是 <code>autoIncrement_num</code>：</p>\n<ul>\n<li>如果 <code>insert_num &lt; autoIncrement_num</code>，那么这个表的自增值不变</li>\n<li>如果 <code>insert_num &gt;= autoIncrement_num</code>，就需要把当前自增值修改为新的自增值</li>\n</ul>\n<p>也就是说，如果插入的 id 是 100，当前的自增值是 90，<code>insert_num &gt;= autoIncrement_num</code>，那么自增值就会被修改为新的自增值即 101</p>\n<p>一定是这样吗？</p>\n<p>非也~</p>\n<p>了解过分布式 id 的小伙伴一定知道，为了避免两个库生成的主键发生冲突，我们可以让一个库的自增 id 都是奇数，另一个库的自增 id 都是偶数</p>\n<p>这个奇数偶数其实是通过 <code>auto_increment_offset</code> 和 <code>auto_increment_increment</code> 这两个参数来决定的，这俩分别用来表示自增的初始值和步长，默认值都是 1。</p>\n<p>所以，上面的例子中生成新的自增值的步骤实际是这样的：从 <code>auto_increment_offset</code> 开始，以 <code>auto_increment_increment</code> 为步长，持续叠加，直到找到第一个大于 100  的值，作为新的自增值。</p>\n<p>所以，这种情况下，自增值可能会是 102，103 等等之类的，就会导致不连续的主键 id。</p>\n<p>更遗憾的是，即使在自增初始值和步长这两个参数都设置为 1 的时候，自增主键 id 也不一定能保证主键是连续的</p>\n<h3> 自增值不连续场景 2</h3>\n<p>举个例子，我们现在往表里插入一条 (null,1,1) 的记录，生成的主键是 1，AUTO_INCREMENT= 2，对吧</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/8f5b9dc2a5a2551280a3cf42c68b1b9c.png\" alt=\"\"></p>\n<p>这时我再执行一条插入 <code>(null,1,1)</code> 的命令，很显然会报错 <code>Duplicate entry</code>，因为我们设置了一个唯一索引字段 <code>a</code>：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/9681f77c79c1b1bb08d0b7af4b828faa.png\" alt=\"\"></p>\n<p>但是，你会惊奇的发现，虽然插入失败了，但自增值仍然从 2 增加到了 3！</p>\n<p>这是为啥？</p>\n<p>我们来分析下这个 insert 语句的执行流程：</p>\n<ol>\n<li>执行器调用 InnoDB 引擎接口准备插入一行记录 (null,1,1);</li>\n<li>InnoDB 发现用户没有指定自增 id 的值，则获取表 <code>test_pk</code> 当前的自增值 2；</li>\n<li>将传入的记录改成 (2,1,1);</li>\n<li>将表的自增值改成 3；</li>\n<li>继续执行插入数据操作，由于已经存在 a=1 的记录，所以报 Duplicate key error，语句返回</li>\n</ol>\n<p>可以看到，自增值修改的这个操作，是在真正执行插入数据的操作之前。</p>\n<p>这个语句真正执行的时候，因为碰到唯一键 a 冲突，所以 id = 2 这一行并没有插入成功，但也没有将自增值再改回去。所以，在这之后，再插入新的数据行时，拿到的自增 id 就是 3。也就是说，出现了自增主键不连续的情况。</p>\n<p>至此，我们已经罗列了两种自增主键不连续的情况：</p>\n<ol>\n<li>自增初始值和自增步长设置不为 1</li>\n<li>唯一键冲突</li>\n</ol>\n<p>除此之外，事务回滚也会导致这种情况</p>\n<h3> 自增值不连续场景 3</h3>\n<p>我们现在表里有一行 <code>(1,1,1)</code> 的记录，AUTO_INCREMENT = 3：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/385832cfaf3e138862989a04fc52189b.png\" alt=\"\"></p>\n<p>我们先插入一行数据 <code>(null, 2, 2)</code>，也就是 (3, 2, 2) 嘛，并且 AUTO_INCREMENT 变为 4：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/26566c70e17eface82dd6dbb543db13d.png\" alt=\"\"></p>\n<p>再去执行这样一段 SQL：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/e77bd5b426fca9748b9f4c795f525725.png\" alt=\"\"></p>\n<p>虽然我们插入了一条 (null, 3, 3) 记录，但是使用 rollback 进行回滚了，所以数据库中是没有这条记录的：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/6e201fea00dcf894d69abdc870dbdf20.png\" alt=\"\"></p>\n<p>在这种事务回滚的情况下，自增值并没有同样发生回滚！如下图所示，自增值仍然固执地从 4 增加到了 5：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/66b3931d62ead39d8e0bfc48af2eb04d.png\" alt=\"\"></p>\n<p>所以这时候我们再去插入一条数据（null, 3, 3）的时候，主键 id 就会被自动赋为 <code>5</code> 了：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/2ad04576a2bc47b4c6d6eabcae703636.png\" alt=\"\"></p>\n<p>那么，为什么在出现唯一键冲突或者回滚的时候，MySQL 没有把表的自增值改回去呢？回退回去的话不就不会发生自增 id 不连续了吗？</p>\n<p>事实上，这么做的主要原因是为了提高性能。</p>\n<p>我们直接用反证法来验证：假设 MySQL 在事务回滚的时候会把自增值改回去，会发生什么？</p>\n<p>现在有两个并行执行的事务 A 和 B，在申请自增值的时候，为了避免两个事务申请到相同的自增 id，肯定要加锁，然后顺序申请，对吧。</p>\n<ol>\n<li>假设事务 A 申请到了 id = 1， 事务 B 申请到 id=2，那么这时候表 t 的自增值是3，之后继续执行。</li>\n<li>事务 B 正确提交了，但事务 A 出现了唯一键冲突，也就是 id = 1 的那行记录插入失败了，那如果允许事务 A 把自增 id 回退，也就是把表的当前自增值改回 1，那么就会出现这样的情况：表里面已经有 id = 2 的行，而当前的自增 id 值是 1。</li>\n<li>接下来，继续执行的其他事务就会申请到 id=2。这时，就会出现插入语句报错“主键冲突”。</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/c98049ae564edae5609b8ec181923f11.png\" alt=\"\"></p>\n<p>而为了解决这个主键冲突，有两种方法：</p>\n<ol>\n<li>每次申请 id 之前，先判断表里面是否已经存在这个 id，如果存在，就跳过这个 id</li>\n<li>把自增 id 的锁范围扩大，必须等到一个事务执行完成并提交，下一个事务才能再申请自增 id</li>\n</ol>\n<p>很显然，上述两个方法的成本都比较高，会导致性能问题。而究其原因呢，是我们假设的这个 “允许自增 id 回退”。</p>\n<p>因此，InnoDB 放弃了这个设计，语句执行失败也不回退自增 id。也正是因为这样，所以才只保证了自增 id 是递增的，但不保证是连续的。</p>\n<p>综上，已经分析了三种自增值不连续的场景，还有第四种场景：批量插入数据。</p>\n<h3> 自增值不连续场景 4</h3>\n<p>对于批量插入数据的语句，MySQL 有一个批量申请自增 id 的策略：</p>\n<ol>\n<li>语句执行过程中，第一次申请自增 id，会分配 1 个；</li>\n<li>1 个用完以后，这个语句第二次申请自增 id，会分配 2 个；</li>\n<li>2 个用完以后，还是这个语句，第三次申请自增 id，会分配 4 个；</li>\n<li>依此类推，同一个语句去申请自增 id，每次申请到的自增 id 个数都是上一次的两倍。</li>\n</ol>\n<p>注意，这里说的批量插入数据，不是在普通的 insert 语句里面包含多个 value 值！！！，因为这类语句在申请自增 id 的时候，是可以精确计算出需要多少个 id 的，然后一次性申请，申请完成后锁就可以释放了。</p>\n<p>而对于 <code>insert … select</code>、replace … select 和 load data 这种类型的语句来说，MySQL 并不知道到底需要申请多少 id，所以就采用了这种批量申请的策略，毕竟一个一个申请的话实在太慢了。</p>\n<p>举个例子，假设我们现在这个表有下面这些数据：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/f01e0d9d7323af3152287a1dbb2f91fd.png\" alt=\"\"></p>\n<p>我们创建一个和当前表 <code>test_pk</code> 有相同结构定义的表 <code>test_pk2</code>：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/0683434e51e6e9b77f7b6b60c8c67de5.png\" alt=\"\"></p>\n<p>然后使用 <code>insert...select</code> 往 <code>teset_pk2</code> 表中批量插入数据：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/9984a82ce548f13485c2aca89efeca94.png\" alt=\"\"></p>\n<p>可以看到，成功导入了数据。</p>\n<p>再来看下 <code>test_pk2</code> 的自增值是多少：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/6613cf4eafc013b6e43a4a3f196d652e.png\" alt=\"\"></p>\n<p>如上分析，是 8 而不是 6</p>\n<p>具体来说，insert…select 实际上往表中插入了 5 行数据 （1 1）（2 2）（3 3）（4 4）（5 5）。但是，这五行数据是分三次申请的自增 id，结合批量申请策略，每次申请到的自增 id 个数都是上一次的两倍，所以：</p>\n<ul>\n<li>第一次申请到了一个 id：id=1</li>\n<li>第二次被分配了两个 id：id=2 和 id=3</li>\n<li>第三次被分配到了 4 个 id：id=4、id = 5、id = 6、id=7</li>\n</ul>\n<p>由于这条语句实际只用上了 5 个 id，所以 id=6 和 id=7 就被浪费掉了。之后，再执行 <code>insert into test_pk2 values(null,6,6)</code>，实际上插入的数据就是（8,6,6)：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/fe2de07fbf986b2eeaddea5404761358.png\" alt=\"\"></p>\n<h2> 小结</h2>\n<p>本文总结下自增值不连续的 4 个场景：</p>\n<ol>\n<li>自增初始值和自增步长设置不为 1</li>\n<li>唯一键冲突</li>\n<li>事务回滚</li>\n<li>批量插入（如 <code>insert...select</code> 语句）</li>\n</ol>\n",
      "image": "https://img-blog.csdnimg.cn/img_convert/a430d55df72ed9ff6e1af19f8261223c.png",
      "date_published": "2023-02-02T09:54:04.000Z",
      "date_modified": "2023-02-02T09:54:04.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "数据库"
      ]
    },
    {
      "title": "乐观锁和悲观锁详解",
      "url": "https://javaguide.cn/java/concurrent/optimistic-lock-and-pessimistic-lock.html",
      "id": "https://javaguide.cn/java/concurrent/optimistic-lock-and-pessimistic-lock.html",
      "summary": "如果将悲观锁和乐观锁对应到现实生活中来。悲观锁有点像是一位比较悲观（也可以说是未雨绸缪）的人，总是会假设最坏的情况，避免出现问题。乐观锁有点像是一位比较乐观的人，总是会假设最好的情况，在要出现问题之前快速解决问题。 在程序世界中，乐观锁和悲观锁的最终目的都是为了保证线程安全，避免在并发场景下的资源竞争问题。但是，相比于乐观锁，悲观锁对性能的影响更大！ 什么是悲观锁？使用场景是什么？ 悲观锁总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题(比如共享数据被修改)，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。",
      "content_html": "<p>如果将悲观锁和乐观锁对应到现实生活中来。悲观锁有点像是一位比较悲观（也可以说是未雨绸缪）的人，总是会假设最坏的情况，避免出现问题。乐观锁有点像是一位比较乐观的人，总是会假设最好的情况，在要出现问题之前快速解决问题。</p>\n<p>在程序世界中，乐观锁和悲观锁的最终目的都是为了保证线程安全，避免在并发场景下的资源竞争问题。但是，相比于乐观锁，悲观锁对性能的影响更大！</p>\n<h2> 什么是悲观锁？使用场景是什么？</h2>\n<p>悲观锁总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题(比如共享数据被修改)，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。</p>\n<p>也就是说，<strong>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</strong>。</p>\n<p>像 Java 中<code>synchronized</code>和<code>ReentrantLock</code>等独占锁就是悲观锁思想的实现。</p>\n<p><strong>悲观锁通常多用于写比较多的情况下（多写场景），避免频繁失败和重试影响性能。</strong></p>\n<h2> 什么是乐观锁？使用场景是什么？</h2>\n<p>乐观锁总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源（也就是数据）是否被其它线程修改了（具体方法可以使用版本号机制或 CAS 算法）。</p>\n<p>在 Java 中<code>java.util.concurrent.atomic</code>包下面的原子变量类就是使用了乐观锁的一种实现方式 <strong>CAS</strong> 实现的。</p>\n<p><strong>乐观锁通常多于写比较少的情况下（多读场景），避免频繁加锁影响性能，大大提升了系统的吞吐量。</strong></p>\n<h2> 如何实现乐观锁？</h2>\n<p>乐观锁一般会使用版本号机制或 CAS 算法实现，CAS 算法相对来说更多一些，这里需要格外注意。</p>\n<h3> 版本号机制</h3>\n<p>一般是在数据表中加上一个数据版本号 <code>version</code> 字段，表示数据被修改的次数。当数据被修改时，<code>version</code> 值会加一。当线程 A 要更新数据值时，在读取数据的同时也会读取 <code>version</code> 值，在提交更新时，若刚才读取到的 version 值为当前数据库中的 <code>version</code> 值相等时才更新，否则重试更新操作，直到更新成功。</p>\n<p><strong>举一个简单的例子</strong> ：假设数据库中帐户信息表中有一个 version 字段，当前值为 1 ；而当前帐户余额字段（ <code>balance</code> ）为 $100 。</p>\n<ol>\n<li>操作员 A 此时将其读出（ <code>version</code>=1 ），并从其帐户余额中扣除 $50（ $100-$50 ）。</li>\n<li>在操作员 A 操作的过程中，操作员 B 也读入此用户信息（ <code>version</code>=1 ），并从其帐户余额中扣除 $20 （ $100-$20 ）。</li>\n<li>操作员 A 完成了修改工作，将数据版本号（ <code>version</code>=1 ），连同帐户扣除后余额（ <code>balance</code>=$50 ），提交至数据库更新，此时由于提交数据版本等于数据库记录当前版本，数据被更新，数据库记录 <code>version</code> 更新为 2 。</li>\n<li>操作员 B 完成了操作，也将版本号（ <code>version</code>=1 ）试图向数据库提交数据（ <code>balance</code>=$80 ），但此时比对数据库记录版本时发现，操作员 B 提交的数据版本号为 1 ，数据库记录当前版本也为 2 ，不满足 “ 提交版本必须等于当前版本才能执行更新 “ 的乐观锁策略，因此，操作员 B 的提交被驳回。</li>\n</ol>\n<p>这样就避免了操作员 B 用基于 <code>version</code>=1 的旧数据修改的结果覆盖操作员 A 的操作结果的可能。</p>\n<h3> CAS 算法</h3>\n<p>CAS 的全称是 <strong>Compare And Swap（比较与交换）</strong> ，用于实现乐观锁，被广泛应用于各大框架中。CAS 的思想很简单，就是用一个预期值和要更新的变量值进行比较，两值相等才会进行更新。</p>\n<p>CAS 是一个原子操作，底层依赖于一条 CPU 的原子指令。</p>\n<blockquote>\n<p><strong>原子操作</strong> 即最小不可拆分的操作，也就是说操作一旦开始，就不能被打断，直到操作完成。</p>\n</blockquote>\n<p>CAS 涉及到三个操作数：</p>\n<ul>\n<li><strong>V</strong> ：要更新的变量值(Var)</li>\n<li><strong>E</strong> ：预期值(Expected)</li>\n<li><strong>N</strong> ：拟写入的新值(New)</li>\n</ul>\n<p>当且仅当 V 的值等于 E 时，CAS 通过原子方式用新值 N 来更新 V 的值。如果不等，说明已经有其它线程更新了V，则当前线程放弃更新。</p>\n<p><strong>举一个简单的例子</strong> ：线程 A 要修改变量 i 的值为 6，i 原值为 1（V = 1，E=1，N=6，假设不存在 ABA 问题）。</p>\n<ol>\n<li>i 与1 进行比较，如果相等， 则说明没被其他线程修改，可以被设置为 6 。</li>\n<li>i 与1 进行比较，如果不相等，则说明被其他线程修改，当前线程放弃更新，CAS 操作失败。</li>\n</ol>\n<p>当多个线程同时使用 CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。</p>\n<p>Java 语言并没有直接实现 CAS，CAS 相关的实现是通过 C++ 内联汇编的形式实现的（JNI 调用）。因此， CAS 的具体实现和操作系统以及CPU都有关系。</p>\n<p><code>sun.misc</code>包下的<code>Unsafe</code>类提供了<code>compareAndSwapObject</code>、<code>compareAndSwapInt</code>、<code>compareAndSwapLong</code>方法来实现的对<code>Object</code>、<code>int</code>、<code>long</code>类型的 CAS 操作</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>关于 <code>Unsafe</code> 类的详细介绍可以看这篇文章：<a href=\"https://javaguide.cn/java/basis/unsafe.html\" target=\"_blank\" rel=\"noopener noreferrer\">Java 魔法类 Unsafe 详解 - JavaGuide - 2022</a> 。</p>\n<h2> 乐观锁存在哪些问题？</h2>\n<p>ABA 问题是乐观锁最常见的问题。</p>\n<h3> ABA 问题</h3>\n<p>如果一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然是 A 值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回 A，那 CAS 操作就会误认为它从来没有被修改过。这个问题被称为 CAS 操作的 <strong>\"ABA\"问题。</strong></p>\n<p>ABA 问题的解决思路是在变量前面追加上<strong>版本号或者时间戳</strong>。JDK 1.5 以后的 <code>AtomicStampedReference </code> 类就是用来解决 ABA 问题的，其中的 <code>compareAndSet()</code> 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 循环时间长开销大</h3>\n<p>CAS 经常会用到自旋操作来进行重试，也就是不成功就一直循环执行直到成功。如果长时间不成功，会给 CPU 带来非常大的执行开销。</p>\n<p>如果 JVM 能支持处理器提供的 pause 指令那么效率会有一定的提升，pause 指令有两个作用：</p>\n<ol>\n<li>可以延迟流水线执行指令，使 CPU 不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。</li>\n<li>可以避免在退出循环的时候因内存顺序冲而引起 CPU 流水线被清空，从而提高 CPU 的执行效率。</li>\n</ol>\n<h3> 只能保证一个共享变量的原子操作</h3>\n<p>CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5 开始，提供了<code>AtomicReference</code>类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用<code>AtomicReference</code>类把多个共享变量合并成一个共享变量来操作。</p>\n",
      "date_published": "2023-01-31T08:27:36.000Z",
      "date_modified": "2023-02-24T03:26:31.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "Elasticsearch常见面试题总结(付费)",
      "url": "https://javaguide.cn/database/elasticsearch/elasticsearch-questions-01.html",
      "id": "https://javaguide.cn/database/elasticsearch/elasticsearch-questions-01.html",
      "summary": "Elasticsearch 相关的面试题为我的知识星球（点击链接即可查看详细介绍以及加入方法）专属内容，已经整理到了《Java 面试指北》中。",
      "content_html": "<p><strong>Elasticsearch</strong> 相关的面试题为我的<a href=\"https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html\" target=\"_blank\" rel=\"noopener noreferrer\">知识星球</a>（点击链接即可查看详细介绍以及加入方法）专属内容，已经整理到了<a href=\"https://javaguide.cn/zhuanlan/java-mian-shi-zhi-bei.html\" target=\"_blank\" rel=\"noopener noreferrer\">《Java 面试指北》</a>中。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javamianshizhibei/elasticsearch-questions.png\" alt=\"\"></p>\n<p><a href=\"https://javaguide.cn/zhuanlan/java-mian-shi-zhi-bei.html\" target=\"_blank\" rel=\"noopener noreferrer\">《Java 面试指北》</a>（点击链接即可查看详细介绍）的部分内容展示如下，你可以将其看作是 <a href=\"https://javaguide.cn/#/\" target=\"_blank\" rel=\"noopener noreferrer\">JavaGuide</a> 的补充完善，两者可以配合使用。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220304102536445.png\" alt=\"\"></p>\n<p>最近几年，市面上有越来越多的“技术大佬”开始办培训班/训练营，动辄成千上万的学费，却并没有什么干货，单纯的就是割韭菜。</p>\n<p>为了帮助更多同学准备 Java 面试以及学习 Java ，我创建了一个纯粹的知识星球。虽然收费只有培训班/训练营的百分之一，但是知识星球里的内容质量更高，提供的服务也更全面。</p>\n<p>欢迎准备 Java 面试以及学习 Java 的同学加入我的<a href=\"https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html\" target=\"_blank\" rel=\"noopener noreferrer\">知识星球</a>，干货非常多，学习氛围也很不错！收费虽然是白菜价，但星球里的内容或许比你参加上万的培训班质量还要高。</p>\n<div align=\"center\">\n  <a href=\"https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html\">\n    <img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220311203414600.png\" style=\"margin: 0 auto; \">\n  </a>\n</div>\n<p>下面是星球提供的部分服务（点击下方图片即可获取知识星球的详细介绍）：</p>\n<div align=\"center\">\n  <a href=\"https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html\">\n    <img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/xingqiufuwu.png\" style=\"margin: 0 auto; \">\n  </a>\n</div>\n<p><strong>我有自己的原则，不割韭菜，用心做内容，真心希望帮助到你！</strong></p>\n<p>如果你感兴趣的话，不妨花 3 分钟左右看看星球的详细介绍： <a href=\"https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html\" target=\"_blank\" rel=\"noopener noreferrer\">JavaGuide 知识星球详细介绍</a>。</p>\n<p>这里再送一个 30 元的新人优惠券（续费半价）。</p>\n<div align=\"center\">\n  <a href=\"https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html\">\n    <img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/xingqiuyouhuijuanheyi.png\" style=\"margin: 0 auto; \">\n  </a>\n</div>\n<p>进入星球之后，记得添加微信，我会发你详细的星球使用指南。</p>\n<div align=\"center\">\n  <a href=\"https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html\">\n    <img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/IMG_3007.jpg\" style=\"margin: 0 auto; \">\n  </a>\n</div>\n",
      "image": "https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javamianshizhibei/elasticsearch-questions.png",
      "date_published": "2023-01-29T03:31:13.000Z",
      "date_modified": "2023-01-29T03:31:13.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "数据库"
      ]
    },
    {
      "title": "MySQL执行计划分析",
      "url": "https://javaguide.cn/database/mysql/mysql-query-execution-plan.html",
      "id": "https://javaguide.cn/database/mysql/mysql-query-execution-plan.html",
      "summary": "本文来自公号 MySQL 技术，JavaGuide 对其做了补充完善。原文地址：https://mp.weixin.qq.com/s/d5OowNLtXBGEAbT31sSH4g 优化 SQL 的第一步应该是读懂 SQL 的执行计划。本篇文章，我们一起来学习下 MySQL EXPLAIN 执行计划相关知识。 什么是执行计划？ 执行计划 是指一条 SQL 语句在经过 MySQL 查询优化器 的优化会后，具体的执行方式。",
      "content_html": "<blockquote>\n<p>本文来自公号 MySQL 技术，JavaGuide 对其做了补充完善。原文地址：https://mp.weixin.qq.com/s/d5OowNLtXBGEAbT31sSH4g</p>\n</blockquote>\n<p>优化 SQL 的第一步应该是读懂 SQL 的执行计划。本篇文章，我们一起来学习下 MySQL   <code>EXPLAIN</code> 执行计划相关知识。</p>\n<h2> 什么是执行计划？</h2>\n<p><strong>执行计划</strong> 是指一条 SQL 语句在经过 <strong>MySQL 查询优化器</strong> 的优化会后，具体的执行方式。</p>\n<p>执行计划通常用于 SQL 性能分析、优化等场景。通过 <code>EXPLAIN</code> 的结果，可以了解到如数据表的查询顺序、数据查询操作的操作类型、哪些索引可以被命中、哪些索引实际会命中、每个数据表有多少行记录被查询等信息。</p>\n<h2> 如何获取执行计划？</h2>\n<p>MySQL 为我们提供了  <code>EXPLAIN</code> 命令，来获取执行计划的相关信息。</p>\n<p>需要注意的是，<code>EXPLAIN</code> 语句并不会真的去执行相关的语句，而是通过查询优化器对语句进行分析，找出最优的查询方案，并显示对应的信息。</p>\n<p><code>EXPLAIN</code> 执行计划支持 <code>SELECT</code>、<code>DELETE</code>、<code>INSERT</code>、<code>REPLACE</code> 以及 <code>UPDATE</code> 语句。我们一般多用于分析 <code>SELECT</code> 查询语句，使用起来非常简单，语法如下：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>我们简单来看下一条查询语句的执行计划：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>可以看到，执行计划结果中共有 12 列，各列代表的含义总结如下表：</p>\n<table>\n<thead>\n<tr>\n<th><strong>列名</strong></th>\n<th><strong>含义</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>id</td>\n<td>SELECT查询的序列标识符</td>\n</tr>\n<tr>\n<td>select_type</td>\n<td>SELECT关键字对应的查询类型</td>\n</tr>\n<tr>\n<td>table</td>\n<td>用到的表名</td>\n</tr>\n<tr>\n<td>partitions</td>\n<td>匹配的分区，对于未分区的表，值为 NULL</td>\n</tr>\n<tr>\n<td>type</td>\n<td>表的访问方法</td>\n</tr>\n<tr>\n<td>possible_keys</td>\n<td>可能用到的索引</td>\n</tr>\n<tr>\n<td>key</td>\n<td>实际用到的索引</td>\n</tr>\n<tr>\n<td>key_len</td>\n<td>所选索引的长度</td>\n</tr>\n<tr>\n<td>ref</td>\n<td>当使用索引等值查询时，与索引作比较的列或常量</td>\n</tr>\n<tr>\n<td>rows</td>\n<td>预计要读取的行数</td>\n</tr>\n<tr>\n<td>filtered</td>\n<td>按表条件过滤后，留存的记录数的百分比</td>\n</tr>\n<tr>\n<td>Extra</td>\n<td>附加信息</td>\n</tr>\n</tbody>\n</table>\n<h2> 如何分析 EXPLAIN 结果？</h2>\n<p>为了分析 <code>EXPLAIN</code> 语句的执行结果，我们需要搞懂执行计划中的重要字段。</p>\n<h3> id</h3>\n<p>SELECT 标识符，是查询中 SELECT 的序号，用来标识整个查询中 SELELCT 语句的顺序。</p>\n<p>id 如果相同，从上往下依次执行。id 不同，id 值越大，执行优先级越高，如果行引用其他行的并集结果，则该值可以为 NULL。</p>\n<h3> select_type</h3>\n<p>查询的类型，主要用于区分普通查询、联合查询、子查询等复杂的查询，常见的值有：</p>\n<ul>\n<li><strong>SIMPLE</strong>：简单查询，不包含 UNION 或者子查询。</li>\n<li><strong>PRIMARY</strong>：查询中如果包含子查询或其他部分，外层的 SELECT 将被标记为 PRIMARY。</li>\n<li><strong>SUBQUERY</strong>：子查询中的第一个 SELECT。</li>\n<li><strong>UNION</strong>：在 UNION 语句中，UNION 之后出现的 SELECT。</li>\n<li><strong>DERIVED</strong>：在 FROM 中出现的子查询将被标记为 DERIVED。</li>\n<li><strong>UNION RESULT</strong>：UNION 查询的结果。</li>\n</ul>\n<h3> table</h3>\n<p>查询用到的表名，每行都有对应的表名，表名除了正常的表之外，也可能是以下列出的值：</p>\n<ul>\n<li><strong><code>&lt;unionM,N&gt;</code></strong> : 本行引用了 id 为 M 和 N 的行的 UNION 结果；</li>\n<li><strong><code>&lt;derivedN&gt;</code></strong> : 本行引用了 id 为 N 的表所产生的的派生表结果。派生表有可能产生自 FROM 语句中的子查询。\n-<strong><code>&lt;subqueryN&gt;</code></strong> : 本行引用了 id 为 N 的表所产生的的物化子查询结果。</li>\n</ul>\n<h3> type（重要）</h3>\n<p>查询执行的类型，描述了查询是如何执行的。所有值的顺序从最优到最差排序为：system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</p>\n<p>常见的几种类型具体含义如下：</p>\n<ul>\n<li><strong>system</strong>：如果表使用的引擎对于表行数统计是精确的（如：MyISAM），且表中只有一行记录的情况下，访问方法是 system ，是 const 的一种特例。</li>\n<li><strong>const</strong>：表中最多只有一行匹配的记录，一次查询就可以找到，常用于使用主键或唯一索引的所有字段作为查询条件。</li>\n<li><strong>eq_ref</strong>：当连表查询时，前一张表的行在当前这张表中只有一行与之对应。是除了 system 与 const 之外最好的 join 方式，常用于使用主键或唯一索引的所有字段作为连表条件。</li>\n<li><strong>ref</strong>：使用普通索引作为查询条件，查询结果可能找到多个符合条件的行。</li>\n<li><strong>index_merge</strong>：当查询条件使用了多个索引时，表示开启了 Index Merge 优化，此时执行计划中的 key 列列出了使用到的索引。</li>\n<li><strong>range</strong>：对索引列进行范围查询，执行计划中的 key 列表示哪个索引被使用了。</li>\n<li><strong>index</strong>：查询遍历了整棵索引树，与 ALL 类似，只不过扫描的是索引，而索引一般在内存中，速度更快。</li>\n<li><strong>ALL</strong>：全表扫描。</li>\n</ul>\n<h3> possible_keys</h3>\n<p>possible_keys 列表示 MySQL 执行查询时可能用到的索引。如果这一列为 NULL ，则表示没有可能用到的索引；这种情况下，需要检查 WHERE 语句中所使用的的列，看是否可以通过给这些列中某个或多个添加索引的方法来提高查询性能。</p>\n<h3> key（重要）</h3>\n<p>key 列表示 MySQL 实际使用到的索引。如果为 NULL，则表示未用到索引。</p>\n<h3> key_len</h3>\n<p>key_len 列表示 MySQL 实际使用的索引的最大长度；当使用到联合索引时，有可能是多个列的长度和。在满足需求的前提下越短越好。如果 key 列显示 NULL ，则 key_len 列也显示 NULL 。</p>\n<h3> rows</h3>\n<p>rows 列表示根据表统计信息及选用情况，大致估算出找到所需的记录或所需读取的行数，数值越小越好。</p>\n<h3> Extra（重要）</h3>\n<p>这列包含了 MySQL 解析查询的额外信息，通过这些信息，可以更准确的理解 MySQL 到底是如何执行查询的。常见的值如下：</p>\n<ul>\n<li><strong>Using filesort</strong>：在排序时使用了外部的索引排序，没有用到表内索引进行排序。</li>\n<li><strong>Using temporary</strong>：MySQL 需要创建临时表来存储查询的结果，常见于 ORDER BY 和 GROUP BY。</li>\n<li><strong>Using index</strong>：表明查询使用了覆盖索引，不用回表，查询效率非常高。</li>\n<li><strong>Using index condition</strong>：表示查询优化器选择使用了索引条件下推这个特性。</li>\n<li><strong>Using where</strong>：表明查询使用了 WHERE 子句进行条件过滤。一般在没有使用到索引的时候会出现。</li>\n<li><strong>Using join buffer (Block Nested Loop)</strong>：连表查询的方式，表示当被驱动表的没有使用索引的时候，MySQL 会先将驱动表读出来放到 join buffer 中，再遍历被驱动表与驱动表进行查询。</li>\n</ul>\n<p>这里提醒下，当 Extra 列包含 Using filesort 或 Using temporary 时，MySQL 的性能可能会存在问题，需要尽可能避免。</p>\n<h2> 参考</h2>\n<ul>\n<li>https://dev.mysql.com/doc/refman/5.7/en/explain-output.html</li>\n<li>https://juejin.cn/post/6953444668973514789</li>\n</ul>\n",
      "date_published": "2023-01-14T10:33:11.000Z",
      "date_modified": "2023-01-14T10:33:11.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "数据库"
      ]
    },
    {
      "title": "NoSQL基础知识总结",
      "url": "https://javaguide.cn/database/nosql.html",
      "id": "https://javaguide.cn/database/nosql.html",
      "summary": "NoSQL 是什么？ NoSQL（Not Only SQL 的缩写）泛指非关系型的数据库，主要针对的是键值、文档以及图形类型数据存储。并且，NoSQL 数据库天生支持分布式，数据冗余和数据分片等特性，旨在提供可扩展的高可用高性能数据存储解决方案。 一个常见的误解是 NoSQL 数据库或非关系型数据库不能很好地存储关系型数据。NoSQL 数据库可以存储关系型数据—它们与关系型数据库的存储方式不同。 NoSQL 数据库代表：HBase 、Cassandra、MongoDB、Redis。",
      "content_html": "<h2> NoSQL 是什么？</h2>\n<p>NoSQL（Not Only SQL 的缩写）泛指非关系型的数据库，主要针对的是键值、文档以及图形类型数据存储。并且，NoSQL 数据库天生支持分布式，数据冗余和数据分片等特性，旨在提供可扩展的高可用高性能数据存储解决方案。</p>\n<p>一个常见的误解是 NoSQL 数据库或非关系型数据库不能很好地存储关系型数据。NoSQL 数据库可以存储关系型数据—它们与关系型数据库的存储方式不同。</p>\n<p>NoSQL 数据库代表：HBase 、Cassandra、MongoDB、Redis。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/mongodb/sql-nosql-tushi.png\" alt=\"\"></p>\n<h2> SQL 和 NoSQL 有什么区别？</h2>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"></th>\n<th>SQL 数据库</th>\n<th>NoSQL 数据库</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">数据存储模型</td>\n<td>结构化存储，具有固定行和列的表格</td>\n<td>非结构化存储。文档：JSON 文档，键值：键值对，宽列：包含行和动态列的表，图：节点和边</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">发展历程</td>\n<td>开发于 1970 年代，重点是减少数据重复</td>\n<td>开发于 2000 年代后期，重点是提升可扩展性，减少大规模数据的存储成本</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">例子</td>\n<td>Oracle、MySQL、Microsoft SQL Server 、PostgreSQL</td>\n<td>文档：MongoDB、CouchDB，键值：Redis 、DynamoDB，宽列：Cassandra 、 HBase，图表：Neo4j 、 Amazon Neptune、Giraph</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ACID 属性</td>\n<td>提供原子性、一致性、隔离性和持久性 (ACID) 属性</td>\n<td>通常不支持 ACID 事务，为了可扩展、高性能进行了权衡，少部分支持比如 MongoDB 。不过，MongoDB 对 ACID 事务 的支持和 MySQL 还是有所区别的。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">性能</td>\n<td>性能通常取决于磁盘子系统。要获得最佳性能，通常需要优化查询、索引和表结构。</td>\n<td>性能通常由底层硬件集群大小、网络延迟以及调用应用程序来决定。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">扩展</td>\n<td>垂直（使用性能更强大的服务器进行扩展）、读写分离、分库分表</td>\n<td>横向（增加服务器的方式横向扩展，通常是基于分片机制）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">用途</td>\n<td>普通企业级的项目的数据存储</td>\n<td>用途广泛比如图数据库支持分析和遍历连接数据之间的关系、键值数据库可以处理大量数据扩展和极高的状态变化</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">查询语法</td>\n<td>结构化查询语言 (SQL)</td>\n<td>数据访问语法可能因数据库而异</td>\n</tr>\n</tbody>\n</table>\n<h2> NoSQL 数据库有什么优势？</h2>\n<p>NoSQL 数据库非常适合许多现代应用程序，例如移动、Web 和游戏等应用程序，它们需要灵活、可扩展、高性能和功能强大的数据库以提供卓越的用户体验。</p>\n<ul>\n<li><strong>灵活性：</strong> NoSQL 数据库通常提供灵活的架构，以实现更快速、更多的迭代开发。灵活的数据模型使 NoSQL 数据库成为半结构化和非结构化数据的理想之选。</li>\n<li><strong>可扩展性：</strong> NoSQL 数据库通常被设计为通过使用分布式硬件集群来横向扩展，而不是通过添加昂贵和强大的服务器来纵向扩展。</li>\n<li><strong>高性能：</strong> NoSQL 数据库针对特定的数据模型和访问模式进行了优化，这与尝试使用关系数据库完成类似功能相比可实现更高的性能。</li>\n<li><strong>强大的功能：</strong> NoSQL 数据库提供功能强大的 API 和数据类型，专门针对其各自的数据模型而构建。</li>\n</ul>\n<h2> NoSQL 数据库有哪些类型？</h2>\n<p>NoSQL 数据库主要可以分为下面四种类型：</p>\n<ul>\n<li><strong>键值</strong> ：键值数据库是一种较简单的数据库，其中每个项目都包含键和值。这是极为灵活的 NoSQL 数据库类型，因为应用可以完全控制 value 字段中存储的内容，没有任何限制。Redis 和 DynanoDB 是两款非常流行的键值数据库。</li>\n<li><strong>文档</strong> ：文档数据库中的数据被存储在类似于 JSON（JavaScript 对象表示法）对象的文档中，非常清晰直观。每个文档包含成对的字段和值。这些值通常可以是各种类型，包括字符串、数字、布尔值、数组或对象等，并且它们的结构通常与开发者在代码中使用的对象保持一致。MongoDB 就是一款非常流行的文档数据库。</li>\n<li><strong>图形</strong> ：图形数据库旨在轻松构建和运行与高度连接的数据集一起使用的应用程序。图形数据库的典型使用案例包括社交网络、推荐引擎、欺诈检测和知识图形。Neo4j 和 Giraph 是两款非常流行的图形数据库。</li>\n<li><strong>宽列</strong> ：宽列存储数据库非常适合需要存储大量的数据。Cassandra 和 HBase 是两款非常流行的宽列存储数据库。</li>\n</ul>\n<p>下面这张图片来源于 <a href=\"https://learn.microsoft.com/en-us/dotnet/architecture/cloud-native/relational-vs-nosql-data\" target=\"_blank\" rel=\"noopener noreferrer\">微软的官方文档 | 关系数据与 NoSQL 数据</a>。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/mongodb/types-of-nosql-datastores.png\" alt=\"NoSQL 数据模型\"></p>\n<h2> 参考</h2>\n<ul>\n<li>NoSQL 是什么？- MongoDB 官方文档：https://www.mongodb.com/zh-cn/nosql-explained</li>\n<li>什么是 NoSQL? - AWS：https://aws.amazon.com/cn/nosql/</li>\n<li>NoSQL vs. SQL Databases - MongoDB 官方文档：https://www.mongodb.com/zh-cn/nosql-explained/nosql-vs-sql</li>\n</ul>\n",
      "image": "https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/mongodb/sql-nosql-tushi.png",
      "date_published": "2023-01-12T09:46:41.000Z",
      "date_modified": "2023-01-12T09:46:41.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "数据库"
      ]
    },
    {
      "title": "MongoDB常见面试题总结（上）",
      "url": "https://javaguide.cn/database/mongodb/mongodb-questions-01.html",
      "id": "https://javaguide.cn/database/mongodb/mongodb-questions-01.html",
      "summary": "少部分内容参考了 MongoDB 官方文档的描述，在此说明一下。 MongoDB 基础 MongoDB 是什么？ MongoDB 是一个基于 分布式文件存储 的开源 NoSQL 数据库系统，由 C++ 编写的。MongoDB 提供了 面向文档 的存储方式，操作起来比较简单和容易，支持“无模式”的数据建模，可以存储比较复杂的数据类型，是一款非常流行的 文档类型数据库 。",
      "content_html": "<blockquote>\n<p>少部分内容参考了 MongoDB 官方文档的描述，在此说明一下。</p>\n</blockquote>\n<h2> MongoDB 基础</h2>\n<h3> MongoDB 是什么？</h3>\n<p>MongoDB 是一个基于 <strong>分布式文件存储</strong> 的开源 NoSQL 数据库系统，由 <strong>C++</strong> 编写的。MongoDB 提供了 <strong>面向文档</strong> 的存储方式，操作起来比较简单和容易，支持“<strong>无模式</strong>”的数据建模，可以存储比较复杂的数据类型，是一款非常流行的 <strong>文档类型数据库</strong> 。</p>\n<p>在高负载的情况下，MongoDB 天然支持水平扩展和高可用，可以很方便地添加更多的节点/实例，以保证服务性能和可用性。在许多场景下，MongoDB 可以用于代替传统的关系型数据库或键/值存储方式，皆在为 Web 应用提供可扩展的高可用高性能数据存储解决方案。</p>\n<h3> MongoDB 的存储结构是什么？</h3>\n<p>MongoDB 的存储结构区别于传统的关系型数据库，主要由如下三个单元组成：</p>\n<ul>\n<li><strong>文档（Document）</strong> ：MongoDB 中最基本的单元，由 BSON 键值对（key-value）组成，类似于关系型数据库中的行（Row）。</li>\n<li><strong>集合（Collection）</strong> ：一个集合可以包含多个文档，类似于关系型数据库中的表（Table）。</li>\n<li><strong>数据库（Database）</strong> ：一个数据库中可以包含多个集合，可以在 MongoDB 中创建多个数据库，类似于关系型数据库中的数据库（Database）。</li>\n</ul>\n<p>也就是说，MongoDB 将数据记录存储为文档 （更具体来说是<a href=\"https://www.mongodb.com/docs/manual/core/document/#std-label-bson-document-format\" target=\"_blank\" rel=\"noopener noreferrer\">BSON 文档</a>），这些文档在集合中聚集在一起，数据库中存储一个或多个文档集合。</p>\n<p><strong>SQL 与 MongoDB 常见术语对比</strong> ：</p>\n<table>\n<thead>\n<tr>\n<th>SQL</th>\n<th>MongoDB</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>表（Table）</td>\n<td>集合（Collection）</td>\n</tr>\n<tr>\n<td>行（Row）</td>\n<td>文档（Document）</td>\n</tr>\n<tr>\n<td>列（Col）</td>\n<td>字段（Field）</td>\n</tr>\n<tr>\n<td>主键（Primary Key）</td>\n<td>对象 ID（Objectid）</td>\n</tr>\n<tr>\n<td>索引（Index）</td>\n<td>索引（Index）</td>\n</tr>\n<tr>\n<td>嵌套表（Embeded Table）</td>\n<td>嵌入式文档（Embeded Document）</td>\n</tr>\n<tr>\n<td>数组（Array）</td>\n<td>数组（Array）</td>\n</tr>\n</tbody>\n</table>\n<h4> 文档</h4>\n<p>MongoDB 中的记录就是一个 BSON 文档，它是由键值对组成的数据结构，类似于 JSON 对象，是 MongoDB 中的基本数据单元。字段的值可能包括其他文档、数组和文档数组。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/mongodb/crud-annotated-document..png\" alt=\"MongoDB 文档\"></p>\n<p>文档的键是字符串。除了少数例外情况，键可以使用任意 UTF-8 字符。</p>\n<ul>\n<li>键不能含有 <code>\\0</code>(空字符）。这个字符用来表示键的结尾。</li>\n<li><code>.</code> 和 <code>$</code> 有特别的意义，只有在特定环境下才能使用。</li>\n<li>以下划线<code>_</code>开头的键是保留的(不是严格要求的)。</li>\n</ul>\n<p><strong>BSON [bee·sahn]</strong> 是 Binary <a href=\"http://json.org/\" target=\"_blank\" rel=\"noopener noreferrer\">JSON</a>的简称，是 JSON 文档的二进制表示，支持将文档和数组嵌入到其他文档和数组中，还包含允许表示不属于 JSON 规范的数据类型的扩展。有关 BSON 规范的内容，可以参考 <a href=\"http://bsonspec.org/\" target=\"_blank\" rel=\"noopener noreferrer\">bsonspec.org</a>，另见<a href=\"https://www.mongodb.com/docs/manual/reference/bson-types/\" target=\"_blank\" rel=\"noopener noreferrer\">BSON 类型</a>。</p>\n<p>根据维基百科对 BJSON 的介绍，BJSON 的遍历速度优于 JSON，这也是 MongoDB 选择 BSON 的主要原因，但 BJSON 需要更多的存储空间。</p>\n<blockquote>\n<p>与 JSON 相比，BSON 着眼于提高存储和扫描效率。BSON 文档中的大型元素以长度字段为前缀以便于扫描。在某些情况下，由于长度前缀和显式数组索引的存在，BSON 使用的空间会多于 JSON。</p>\n</blockquote>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/mongodb/bsonspec.org.png\" alt=\"BSON 官网首页\"></p>\n<h4> 集合</h4>\n<p>MongoDB 集合存在于数据库中，<strong>没有固定的结构</strong>，也就是 <strong>无模式</strong> 的，这意味着可以往集合插入不同格式和类型的数据。不过，通常情况下，插入集合中的数据都会有一定的关联性。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/mongodb/crud-annotated-collection.png\" alt=\"MongoDB 集合\"></p>\n<p>集合不需要事先创建，当第一个文档插入或者第一个索引创建时，如果该集合不存在，则会创建一个新的集合。</p>\n<p>集合名可以是满足下列条件的任意 UTF-8 字符串：</p>\n<ul>\n<li>集合名不能是空字符串<code>\"\"</code>。</li>\n<li>集合名不能含有 <code>\\0</code> （空字符)，这个字符表示集合名的结尾。</li>\n<li>集合名不能以\"system.\"开头，这是为系统集合保留的前缀。例如 <code>system.users</code> 这个集合保存着数据库的用户信息，<code>system.namespaces</code> 集合保存着所有数据库集合的信息。</li>\n<li>集合名必须以下划线或者字母符号开始，并且不能包含 <code>$</code>。</li>\n</ul>\n<h4> 数据库</h4>\n<p>数据库用于存储所有集合，而集合又用于存储所有文档。一个 MongoDB 中可以创建多个数据库，每一个数据库都有自己的集合和权限。</p>\n<p>MongoDB 预留了几个特殊的数据库。</p>\n<ul>\n<li><strong>admin</strong> : admin 数据库主要是保存 root 用户和角色。例如，system.users 表存储用户，system.roles 表存储角色。一般不建议用户直接操作这个数据库。将一个用户添加到这个数据库，且使它拥有 admin 库上的名为 dbAdminAnyDatabase 的角色权限，这个用户自动继承所有数据库的权限。一些特定的服务器端命令也只能从这个数据库运行，比如关闭服务器。</li>\n<li><strong>local</strong> : local 数据库是不会被复制到其他分片的，因此可以用来存储本地单台服务器的任意 collection。一般不建议用户直接使用 local 库存储任何数据，也不建议进行 CRUD 操作，因为数据无法被正常备份与恢复。</li>\n<li><strong>config</strong> : 当 MongoDB 使用分片设置时，config 数据库可用来保存分片的相关信息。</li>\n<li><strong>test</strong> : 默认创建的测试库，连接 <a href=\"https://mongoing.com/docs/reference/program/mongod.html\" target=\"_blank\" rel=\"noopener noreferrer\">mongod</a> 服务时，如果不指定连接的具体数据库，默认就会连接到 test 数据库。</li>\n</ul>\n<p>数据库名可以是满足以下条件的任意 UTF-8 字符串：</p>\n<ul>\n<li>不能是空字符串<code>\"\"</code>。</li>\n<li>不得含有<code>' '</code>（空格)、<code>.</code>、<code>$</code>、<code>/</code>、<code>\\</code>和 <code>\\0</code> (空字符)。</li>\n<li>应全部小写。</li>\n<li>最多 64 字节。</li>\n</ul>\n<p>数据库名最终会变成文件系统里的文件，这也就是有如此多限制的原因。</p>\n<h3> MongoDB 有什么特点？</h3>\n<ul>\n<li><strong>数据记录被存储为文档</strong> ：MongoDB 中的记录就是一个 BSON 文档，它是由键值对组成的数据结构，类似于 JSON 对象，是 MongoDB 中的基本数据单元。</li>\n<li><strong>模式自由</strong> ：集合的概念类似 MySQL 里的表，但它不需要定义任何模式，能够用更少的数据对象表现复杂的领域模型对象。</li>\n<li><strong>支持多种查询方式</strong> ：MongoDB 查询 API 支持读写操作 (CRUD)以及数据聚合、文本搜索和地理空间查询。</li>\n<li><strong>支持 ACID 事务</strong> ：NoSQL 数据库通常不支持事务，为了可扩展和高性能进行了权衡。不过，也有例外，MongoDB 就支持事务。与关系型数据库一样，MongoDB 事务同样具有 ACID 特性。MongoDB 单文档原生支持原子性，也具备事务的特性。MongoDB 4.0 加入了对多文档事务的支持，但只支持复制集部署模式下的事务，也就是说事务的作用域限制为一个副本集内。MongoDB 4.2 引入了分布式事务，增加了对分片集群上多文档事务的支持，并合并了对副本集上多文档事务的现有支持。</li>\n<li><strong>高效的二进制存储</strong> ：存储在集合中的文档，是以键值对的形式存在的。键用于唯一标识一个文档，一般是 ObjectId 类型，值是以 BSON 形式存在的。BSON = Binary JSON， 是在 JSON 基础上加了一些类型及元数据描述的格式。</li>\n<li><strong>自带数据压缩功能</strong> ：存储同样的数据所需的资源更少。</li>\n<li><strong>支持 mapreduce</strong> ：通过分治的方式完成复杂的聚合任务。不过，从 MongoDB 5.0 开始，map-reduce 已经不被官方推荐使用了，替代方案是 <a href=\"https://www.mongodb.com/docs/manual/core/aggregation-pipeline/\" target=\"_blank\" rel=\"noopener noreferrer\">聚合管道</a>。聚合管道提供比 map-reduce 更好的性能和可用性。</li>\n<li><strong>支持多种类型的索引</strong> ：MongoDB 支持多种类型的索引，包括单字段索引、复合索引、多键索引、哈希索引、文本索引、 地理位置索引等，每种类型的索引有不同的使用场合。</li>\n<li><strong>支持 failover</strong> ：提供自动故障恢复的功能，主节点发生故障时，自动从从节点中选举出一个新的主节点，确保集群的正常使用，这对于客户端来说是无感知的。</li>\n<li><strong>支持分片集群</strong> ：MongoDB 支持集群自动切分数据，让集群存储更多的数据，具备更强的性能。在数据插入和更新时，能够自动路由和存储。</li>\n<li><strong>支持存储大文件</strong> ：MongoDB 的单文档存储空间要求不超过 16MB。对于超过 16MB 的大文件，MongoDB 提供了 GridFS 来进行存储，通过 GridFS，可以将大型数据进行分块处理，然后将这些切分后的小文档保存在数据库中。</li>\n</ul>\n<h3> MongoDB 适合什么应用场景？</h3>\n<p><strong>MongoDB 的优势在于其数据模型和存储引擎的灵活性、架构的可扩展性以及对强大的索引支持。</strong></p>\n<p>选用 MongoDB 应该充分考虑 MongoDB 的优势，结合实际项目的需求来决定：</p>\n<ul>\n<li>随着项目的发展，使用类 JSON 格式（BSON）保存数据是否满足项目需求？MongoDB 中的记录就是一个 BSON 文档，它是由键值对组成的数据结构，类似于 JSON 对象，是 MongoDB 中的基本数据单元。</li>\n<li>是否需要大数据量的存储？是否需要快速水平扩展？MongoDB 支持分片集群，可以很方便地添加更多的节点（实例），让集群存储更多的数据，具备更强的性能。</li>\n<li>是否需要更多类型索引来满足更多应用场景？MongoDB 支持多种类型的索引，包括单字段索引、复合索引、多键索引、哈希索引、文本索引、 地理位置索引等，每种类型的索引有不同的使用场合。</li>\n<li>......</li>\n</ul>\n<h2> MongoDB 存储引擎</h2>\n<h3> MongoDB 支持哪些存储引擎？</h3>\n<p>存储引擎（Storage Engine）是数据库的核心组件，负责管理数据在内存和磁盘中的存储方式。</p>\n<p>与 MySQL 一样，MongoDB 采用的也是 <strong>插件式的存储引擎架构</strong> ，支持不同类型的存储引擎，不同的存储引擎解决不同场景的问题。在创建数据库或集合时，可以指定存储引擎。</p>\n<blockquote>\n<p>插件式的存储引擎架构可以实现 Server 层和存储引擎层的解耦，可以支持多种存储引擎，如MySQL既可以支持B-Tree结构的InnoDB存储引擎，还可以支持LSM结构的RocksDB存储引擎。</p>\n</blockquote>\n<p>在存储引擎刚出来的时候，默认是使用 MMAPV1 存储引擎，MongoDB4.x 版本不再支持 MMAPv1 存储引擎。</p>\n<p>现在主要有下面这两种存储引擎：</p>\n<ul>\n<li><strong>WiredTiger 存储引擎</strong> ：自 MongoDB 3.2 以后，默认的存储引擎为 <a href=\"https://www.mongodb.com/docs/manual/core/wiredtiger/\" target=\"_blank\" rel=\"noopener noreferrer\">WiredTiger 存储引擎</a> 。非常适合大多数工作负载，建议用于新部署。WiredTiger 提供文档级并发模型、检查点和数据压缩（后文会介绍到）等功能。</li>\n<li><strong>In-Memory 存储引擎</strong> ：<a href=\"https://www.mongodb.com/docs/manual/core/inmemory/\" target=\"_blank\" rel=\"noopener noreferrer\">In-Memory 存储引擎</a>在 MongoDB Enterprise 中可用。它不是将文档存储在磁盘上，而是将它们保留在内存中以获得更可预测的数据延迟。</li>\n</ul>\n<p>此外，MongoDB 3.0 提供了 <strong>可插拔的存储引擎 API</strong> ，允许第三方为 MongoDB 开发存储引擎，这点和 MySQL 也比较类似。</p>\n<h3> WiredTiger 基于 LSM Tree 还是 B+ Tree？</h3>\n<p>目前绝大部分流行的数据库存储引擎都是基于 B/B+ Tree 或者 LSM(Log Structured Merge) Tree 来实现的。对于 NoSQL 数据库来说，绝大部分（比如 HBase、Cassandra、RocksDB）都是基于 LSM 树，MongoDB 不太一样。</p>\n<p>上面也说了，自 MongoDB 3.2 以后，默认的存储引擎为WiredTiger 存储引擎。在 WiredTiger 引擎官网上，我们发现 WiredTiger 使用的是 B+ 树作为其存储结构：</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>此外，WiredTiger 还支持 <a href=\"https://source.wiredtiger.com/3.1.0/lsm.html\" target=\"_blank\" rel=\"noopener noreferrer\">LSM(Log Structured Merge)</a> 树作为存储结构，MongoDB 在使用WiredTiger 作为存储引擎时，默认使用的是 B+ 树。</p>\n<p>如果想要了解 MongoDB 使用 B 树的原因，可以看看这篇文章：<a href=\"https://mp.weixin.qq.com/s/mMWdpbYRiT6LQcdaj4hgXQ\" target=\"_blank\" rel=\"noopener noreferrer\">为什么 MongoDB 使用 B 树？</a>。</p>\n<p>使用 B+ 树时，WiredTiger 以 <strong>page</strong> 为基本单位往磁盘读写数据。B+ 树的每个节点为一个 page，共有三种类型的 page：</p>\n<ul>\n<li><strong>root page（根节点）</strong> ： B+ 树的根节点。</li>\n<li><strong>internal page（内部节点）</strong> ：不实际存储数据的中间索引节点。</li>\n<li><strong>leaf page（叶子节点）</strong>：真正存储数据的叶子节点，包含一个页头（page header）、块头（block header）和真正的数据（key/value），其中页头定义了页的类型、页中实际载荷数据的大小、页中记录条数等信息；块头定义了此页的checksum、块在磁盘上的寻址位置等信息。</li>\n</ul>\n<p>其整体结构如下图所示：</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/mongodb/mongodb-b-plus-tree-integral-structure.png\" alt=\"WiredTiger B+树整体结构\"></p>\n<p>如果想要深入研究学习 WiredTiger 存储引擎，推荐阅读 MongoDB 中文社区的 <a href=\"https://mongoing.com/archives/category/wiredtiger%e5%ad%98%e5%82%a8%e5%bc%95%e6%93%8e%e7%b3%bb%e5%88%97\" target=\"_blank\" rel=\"noopener noreferrer\">WiredTiger存储引擎系列</a>。</p>\n<h2> MongoDB 聚合</h2>\n<h3> MongoDB 聚合有什么用？</h3>\n<p>实际项目中，我们经常需要将多个文档甚至是多个集合汇总到一起计算分析（比如求和、取最大值）并返回计算后的结果，这个过程被称为 <strong>聚合操作</strong> 。</p>\n<p>根据官方文档介绍，我们可以使用聚合操作来：</p>\n<ul>\n<li>将来自多个文档的值组合在一起。</li>\n<li>对集合中的数据进行的一系列运算。</li>\n<li>分析数据随时间的变化。</li>\n</ul>\n<h3> MongoDB 提供了哪几种执行聚合的方法？</h3>\n<p>MongoDB 提供了两种执行聚合的方法：</p>\n<ul>\n<li><strong>聚合管道（Aggregation Pipeline）</strong> ：执行聚合操作的首选方法。</li>\n<li><strong>单一目的聚合方法（Single purpose aggregation methods）</strong> ：也就是单一作用的聚合函数比如 <code>count()</code>、<code>distinct()</code>、<code>estimatedDocumentCount()</code>。</li>\n</ul>\n<p>绝大部分文章中还提到了 <strong>map-reduce</strong> 这种聚合方法。不过，从 MongoDB 5.0 开始，map-reduce 已经不被官方推荐使用了，替代方案是 <a href=\"https://www.mongodb.com/docs/manual/core/aggregation-pipeline/\" target=\"_blank\" rel=\"noopener noreferrer\">聚合管道</a>。聚合管道提供比 map-reduce 更好的性能和可用性。</p>\n<p>MongoDB 聚合管道由多个阶段组成，每个阶段在文档通过管道时转换文档。每个阶段接收前一个阶段的输出，进一步处理数据，并将其作为输入数据发送到下一个阶段。</p>\n<p>每个管道的工作流程是：</p>\n<ol>\n<li>接受一系列原始数据文档</li>\n<li>对这些文档进行一系列运算</li>\n<li>结果文档输出给下一个阶段</li>\n</ol>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/mongodb/mongodb-aggregation-stage.png\" alt=\"管道的工作流程\"></p>\n<p><strong>常用阶段操作符</strong> ：</p>\n<table>\n<thead>\n<tr>\n<th>操作符</th>\n<th>简述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>$match</td>\n<td>匹配操作符，用于对文档集合进行筛选</td>\n</tr>\n<tr>\n<td>$project</td>\n<td>投射操作符，用于重构每一个文档的字段，可以提取字段，重命名字段，甚至可以对原有字段进行操作后新增字段</td>\n</tr>\n<tr>\n<td>$sort</td>\n<td>排序操作符，用于根据一个或多个字段对文档进行排序</td>\n</tr>\n<tr>\n<td>$limit</td>\n<td>限制操作符，用于限制返回文档的数量</td>\n</tr>\n<tr>\n<td>$skip</td>\n<td>跳过操作符，用于跳过指定数量的文档</td>\n</tr>\n<tr>\n<td>$count</td>\n<td>统计操作符，用于统计文档的数量</td>\n</tr>\n<tr>\n<td>$group</td>\n<td>分组操作符，用于对文档集合进行分组</td>\n</tr>\n<tr>\n<td>$unwind</td>\n<td>拆分操作符，用于将数组中的每一个值拆分为单独的文档</td>\n</tr>\n<tr>\n<td>$lookup</td>\n<td>连接操作符，用于连接同一个数据库中另一个集合，并获取指定的文档，类似于 populate</td>\n</tr>\n</tbody>\n</table>\n<p>更多操作符介绍详见官方文档：https://docs.mongodb.com/manual/reference/operator/aggregation/</p>\n<p>阶段操作符用于 <code>db.collection.aggregate</code> 方法里面，数组参数中的第一层。</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>下面是 MongoDB 官方文档中的一个例子：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> MongoDB 事务</h2>\n<blockquote>\n<p>MongoDB 事务想要搞懂原理还是比较花费时间的，我自己也没有搞太明白。因此，我这里只是简单介绍一下 MongoDB 事务，想要了解原理的小伙伴，可以自行搜索查阅相关资料。</p>\n<p>这里推荐几篇文章，供大家参考：</p>\n<ul>\n<li><a href=\"https://mongoing.com/archives/82187\" target=\"_blank\" rel=\"noopener noreferrer\">技术干货| MongoDB 事务原理</a></li>\n<li><a href=\"https://developer.aliyun.com/article/782494\" target=\"_blank\" rel=\"noopener noreferrer\">MongoDB 一致性模型设计与实现</a></li>\n<li><a href=\"https://www.mongodb.com/docs/upcoming/core/transactions/\" target=\"_blank\" rel=\"noopener noreferrer\">MongoDB 官方文档对事务的介绍</a></li>\n</ul>\n</blockquote>\n<p>我们在介绍 NoSQL 数据的时候也说过，NoSQL 数据库通常不支持事务，为了可扩展和高性能进行了权衡。不过，也有例外，MongoDB 就支持事务。</p>\n<p>与关系型数据库一样，MongoDB 事务同样具有 ACID 特性：</p>\n<ul>\n<li><strong>原子性</strong>（<code>Atomicity</code>） ： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li>\n<li><strong>一致性</strong>（<code>Consistency</code>）： 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；</li>\n<li><strong>隔离性</strong>（<code>Isolation</code>）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的。WiredTiger 存储引擎支持读未提交（ read-uncommitted ）、读已提交（ read-committed ）和快照（ snapshot ）隔离，MongoDB 启动时默认选快照隔离。在不同隔离级别下，一个事务的生命周期内，可能出现脏读、不可重复读、幻读等现象。</li>\n<li><strong>持久性</strong>（<code>Durability</code>）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li>\n</ul>\n<p>关于事务的详细介绍这篇文章就不多说了，感兴趣的可以看看我写的<a href=\"https://javaguide.cn/database/mysql/mysql-questions-01.html\" target=\"_blank\" rel=\"noopener noreferrer\">MySQL常见面试题总结</a>这篇文章，里面有详细介绍到。</p>\n<p>MongoDB 单文档原生支持原子性，也具备事务的特性。当谈论 MongoDB 事务的时候，通常指的是 <strong>多文档</strong> 。MongoDB 4.0 加入了对多文档 ACID 事务的支持，但只支持复制集部署模式下的 ACID 事务，也就是说事务的作用域限制为一个副本集内。MongoDB 4.2 引入了 <strong>分布式事务</strong> ，增加了对分片集群上多文档事务的支持，并合并了对副本集上多文档事务的现有支持。</p>\n<p>根据官方文档介绍：</p>\n<blockquote>\n<p>从 MongoDB 4.2 开始，分布式事务和多文档事务在 MongoDB 中是一个意思。分布式事务是指分片集群和副本集上的多文档事务。从 MongoDB 4.2 开始，多文档事务（无论是在分片集群还是副本集上）也称为分布式事务。</p>\n</blockquote>\n<p>在大多数情况下，多文档事务比单文档写入会产生更大的性能成本。对于大部分场景来说， <a href=\"https://www.mongodb.com/docs/upcoming/core/data-model-design/#std-label-data-modeling-embedding\" target=\"_blank\" rel=\"noopener noreferrer\">非规范化数据模型（嵌入式文档和数组）</a> 依然是最佳选择。也就是说，适当地对数据进行建模可以最大限度地减少对多文档事务的需求。</p>\n<p><strong>注意</strong> ：</p>\n<ul>\n<li>从MongoDB 4.2开始，多文档事务支持副本集和分片集群，其中：主节点使用WiredTiger存储引擎，同时从节点使用WiredTiger存储引擎或In-Memory存储引擎。在MongoDB 4.0中，只有使用WiredTiger存储引擎的副本集支持事务。</li>\n<li>在MongoDB 4.2及更早版本中，你无法在事务中创建集合。从 MongoDB 4.4 开始，您可以在事务中创建集合和索引。有关详细信息，请参阅 <a href=\"https://www.mongodb.com/docs/upcoming/core/transactions/#std-label-transactions-create-collections-indexes\" target=\"_blank\" rel=\"noopener noreferrer\">在事务中创建集合和索引</a>。</li>\n</ul>\n<h2> MongoDB 数据压缩</h2>\n<p>借助 WiredTiger 存储引擎（ MongoDB 3.2 后的默认存储引擎），MongoDB 支持对所有集合和索引进行压缩。压缩以额外的 CPU 为代价最大限度地减少存储使用。</p>\n<p>默认情况下，WiredTiger 使用 <a href=\"https://github.com/google/snappy\" target=\"_blank\" rel=\"noopener noreferrer\">Snappy</a> 压缩算法（谷歌开源，旨在实现非常高的速度和合理的压缩，压缩比 3 ～ 5 倍）对所有集合使用块压缩，对所有索引使用前缀压缩。</p>\n<p>除了 Snappy 之外，对于集合还有下面这些压缩算法：</p>\n<ul>\n<li><a href=\"https://github.com/madler/zlib\" target=\"_blank\" rel=\"noopener noreferrer\">zlib</a>：高度压缩算法，压缩比 5 ～ 7 倍</li>\n<li><a href=\"https://github.com/facebook/zstd\" target=\"_blank\" rel=\"noopener noreferrer\">Zstandard</a>（简称 zstd）：Facebook 开源的一种快速无损压缩算法，针对 zlib 级别的实时压缩场景和更好的压缩比，提供更高的压缩率和更低的 CPU 使用率，MongoDB 4.2 开始可用。</li>\n</ul>\n<p>WiredTiger 日志也会被压缩，默认使用的也是 Snappy 压缩算法。如果日志记录小于或等于 128 字节，WiredTiger 不会压缩该记录。</p>\n<h2> 参考</h2>\n<ul>\n<li>MongoDB 官方文档（主要参考资料，以官方文档为准）：https://www.mongodb.com/docs/manual/</li>\n<li>《MongoDB 权威指南》</li>\n<li>技术干货| MongoDB 事务原理 - MongoDB 中文社区：https://mongoing.com/archives/82187</li>\n<li>Transactions - MongoDB 官方文档：https://www.mongodb.com/docs/manual/core/transactions/</li>\n<li>WiredTiger Storage Engine - MongoDB 官方文档：https://www.mongodb.com/docs/manual/core/wiredtiger/</li>\n<li>WiredTiger存储引擎之一：基础数据结构分析：https://mongoing.com/topic/archives-35143</li>\n</ul>\n",
      "image": "https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/mongodb/crud-annotated-document..png",
      "date_published": "2023-01-12T09:46:41.000Z",
      "date_modified": "2023-01-31T14:45:49.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "数据库"
      ]
    },
    {
      "title": "MongoDB常见面试题总结（下）",
      "url": "https://javaguide.cn/database/mongodb/mongodb-questions-02.html",
      "id": "https://javaguide.cn/database/mongodb/mongodb-questions-02.html",
      "summary": "MongoDB 索引 MongoDB 索引有什么用? 和关系型数据库类似，MongoDB 中也有索引。索引的目的主要是用来提高查询效率，如果没有索引的话，MongoDB 必须执行 集合扫描 ，即扫描集合中的每个文档，以选择与查询语句匹配的文档。如果查询存在合适的索引，MongoDB 可以使用该索引来限制它必须检查的文档数量。并且，MongoDB 可以使用索引中的排序返回排序后的结果。 虽然索引可以显著缩短查询时间，但是使用索引、维护索引是有代价的。在执行写入操作时，除了要更新文档之外，还必须更新索引，这必然会影响写入的性能。因此，当有大量写操作而读操作少时，或者不考虑读操作的性能时，都不推荐建立索引。",
      "content_html": "<h2> MongoDB 索引</h2>\n<h3> MongoDB 索引有什么用?</h3>\n<p>和关系型数据库类似，MongoDB 中也有索引。索引的目的主要是用来提高查询效率，如果没有索引的话，MongoDB 必须执行 <strong>集合扫描</strong> ，即扫描集合中的每个文档，以选择与查询语句匹配的文档。如果查询存在合适的索引，MongoDB 可以使用该索引来限制它必须检查的文档数量。并且，MongoDB 可以使用索引中的排序返回排序后的结果。</p>\n<p>虽然索引可以显著缩短查询时间，但是使用索引、维护索引是有代价的。在执行写入操作时，除了要更新文档之外，还必须更新索引，这必然会影响写入的性能。因此，当有大量写操作而读操作少时，或者不考虑读操作的性能时，都不推荐建立索引。</p>\n<h3> MongoDB 支持哪些类型的索引？</h3>\n<p><strong>MongoDB 支持多种类型的索引，包括单字段索引、复合索引、多键索引、哈希索引、文本索引、 地理位置索引等，每种类型的索引有不同的使用场合。</strong></p>\n<ul>\n<li><strong>单字段索引：</strong> 建立在单个字段上的索引，索引创建的排序顺序无所谓，MongoDB 可以头/尾开始遍历。</li>\n<li><strong>复合索引：</strong> 建立在多个字段上的索引，也可以称之为组合索引、联合索引。</li>\n<li><strong>多键索引</strong> ：MongoDB 的一个字段可能是数组，在对这种字段创建索引时，就是多键索引。MongoDB 会为数组的每个值创建索引。就是说你可以按照数组里面的值做条件来查询，这个时候依然会走索引。</li>\n<li><strong>哈希索引</strong> ：按数据的哈希值索引，用在哈希分片集群上。</li>\n<li><strong>文本索引：</strong> 支持对字符串内容的文本搜索查询。文本索引可以包含任何值为字符串或字符串元素数组的字段。一个集合只能有一个文本搜索索引，但该索引可以覆盖多个字段。MongoDB 虽然支持全文索引，但是性能低下，暂时不建议使用。</li>\n<li><strong>地理位置索引：</strong> 基于经纬度的索引，适合 2D 和 3D 的位置查询。</li>\n<li><strong>唯一索引</strong> ：确保索引字段不会存储重复值。如果集合已经存在了违反索引的唯一约束的文档，则后台创建唯一索引会失败。</li>\n<li><strong>TTL 索引</strong> ：TTL 索引提供了一个过期机制，允许为每一个文档设置一个过期时间，当一个文档达到预设的过期时间之后就会被删除。</li>\n<li>......</li>\n</ul>\n<h3> 复合索引中字段的顺序有影响吗？</h3>\n<p>复合索引中字段的顺序非常重要，例如下图中的复合索引由<code>{userid:1, score:-1}</code>组成，则该复合索引首先按照<code>userid</code>升序排序；然后再每个<code>userid</code>的值内，再按照<code>score</code>降序排序。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/mongodb/mongodb-composite-index.png\" alt=\"复合索引\"></p>\n<p>在复合索引中，按照何种方式排序，决定了该索引在查询中是否能被应用到。</p>\n<p>走复合索引的排序：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>不走复合索引的排序：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>我们可以通过 explain 进行分析：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 复合索引遵循左前缀原则吗？</h3>\n<p><strong>MongoDB 的复合索引遵循左前缀原则</strong> ：拥有多个键的索引，可以同时得到所有这些键的前缀组成的索引，但不包括除左前缀之外的其他子集。比如说，有一个类似 <code>{a: 1, b: 1, c: 1, ..., z: 1}</code> 这样的索引，那么实际上也等于有了 <code>{a: 1}</code>、<code>{a: 1, b: 1}</code>、<code>{a: 1, b: 1, c: 1}</code> 等一系列索引，但是不会有 <code>{b: 1}</code> 这样的非左前缀的索引。</p>\n<h3> 什么是 TTL 索引？</h3>\n<p>TTL 索引提供了一个过期机制，允许为每一个文档设置一个过期时间 <code>expireAfterSeconds</code> ，当一个文档达到预设的过期时间之后就会被删除。TTL 索引除了有 <code>expireAfterSeconds</code> 属性外，和普通索引一样。</p>\n<p>数据过期对于某些类型的信息很有用，比如机器生成的事件数据、日志和会话信息，这些信息只需要在数据库中保存有限的时间。</p>\n<p><strong>TTL 索引运行原理</strong> ：</p>\n<ul>\n<li>MongoDB 会开启一个后台线程读取该 TTL 索引的值来判断文档是否过期，但不会保证已过期的数据会立马被删除，因后台线程每 60 秒触发一次删除任务，且如果删除的数据量较大，会存在上一次的删除未完成，而下一次的任务已经开启的情况，导致过期的数据也会出现超过了数据保留时间 60 秒以上的现象。</li>\n<li>对于副本集而言，TTL 索引的后台进程只会在 Primary 节点开启，在从节点会始终处于空闲状态，从节点的数据删除是由主库删除后产生的 oplog 来做同步。</li>\n</ul>\n<p><strong>TTL 索引限制</strong> ：</p>\n<ul>\n<li>TTL 索引是单字段索引。复合索引不支持 TTL</li>\n<li><code>_id</code>字段不支持 TTL 索引。</li>\n<li>无法在上限集合(Capped Collection)上创建 TTL 索引，因为 MongoDB 无法从上限集合中删除文档。</li>\n<li>如果某个字段已经存在非 TTL 索引，那么在该字段上无法再创建 TTL 索引。</li>\n</ul>\n<h3> 什么是覆盖索引查询？</h3>\n<p>根据官方文档介绍，覆盖查询是以下的查询：</p>\n<ul>\n<li>所有的查询字段是索引的一部分。</li>\n<li>结果中返回的所有字段都在同一索引中。</li>\n<li>查询中没有字段等于<code>null</code>。</li>\n</ul>\n<p>由于所有出现在查询中的字段是索引的一部分， MongoDB 无需在整个数据文档中检索匹配查询条件和返回使用相同索引的查询结果。因为索引存在于内存中，从索引中获取数据比通过扫描文档读取数据要快得多。</p>\n<p>举个例子：我们有如下 <code>users</code> 集合:</p>\n<div class=\"language-json line-numbers-mode\" data-ext=\"json\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>我们在 <code>users</code> 集合中创建联合索引，字段为 <code>gender</code> 和 <code>user_name</code> :</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>现在，该索引会覆盖以下查询：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>为了让指定的索引覆盖查询，必须显式地指定 <code>_id: 0</code> 来从结果中排除 <code>_id</code> 字段，因为索引不包括 <code>_id</code> 字段。</p>\n<h2> MongoDB 高可用</h2>\n<h3> 复制集群</h3>\n<h4> 什么是复制集群？</h4>\n<p>MongoDB 的复制集群又称为副本集群，是一组维护相同数据集合的 mongod 进程。</p>\n<p>客户端连接到整个 Mongodb 复制集群，主节点机负责整个复制集群的写，从节点可以进行读操作，但默认还是主节点负责整个复制集群的读。主节点发生故障时，自动从从节点中选举出一个新的主节点，确保集群的正常使用，这对于客户端来说是无感知的。</p>\n<p>通常来说，一个复制集群包含 1 个主节点（Primary），多个从节点（Secondary）以及零个或 1 个仲裁节点（Arbiter）。</p>\n<ul>\n<li><strong>主节点</strong> ：整个集群的写操作入口，接收所有的写操作，并将集合所有的变化记录到操作日志中，即 oplog。主节点挂掉之后会自动选出新的主节点。</li>\n<li><strong>从节点</strong> ：从主节点同步数据，在主节点挂掉之后选举新节点。不过，从节点可以配置成 0 优先级，阻止它在选举中成为主节点。</li>\n<li><strong>仲裁节点</strong> ：这个是为了节约资源或者多机房容灾用，只负责主节点选举时投票不存数据，保证能有节点获得多数赞成票。</li>\n</ul>\n<p>下图是一个典型的三成员副本集群：</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/mongodb/replica-set-read-write-operations-primary.png\" alt=\"\"></p>\n<p>主节点与备节点之间是通过 <strong>oplog（操作日志）</strong> 来同步数据的。oplog 是 local 库下的一个特殊的 <strong>上限集合(Capped Collection)</strong> ，用来保存写操作所产生的增量日志，类似于 MySQL 中 的 Binlog。</p>\n<blockquote>\n<p>上限集合类似于定长的循环队列，数据顺序追加到集合的尾部，当集合空间达到上限时，它会覆盖集合中最旧的文档。上限集合的数据将会被顺序写入到磁盘的固定空间内，所以，I/O 速度非常快，如果不建立索引，性能更好。</p>\n</blockquote>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/mongodb/replica-set-primary-with-two-secondaries.png\" alt=\"\"></p>\n<p>当主节点上的一个写操作完成后，会向 oplog 集合写入一条对应的日志，而从节点则通过这个 oplog 不断拉取到新的日志，在本地进行回放以达到数据同步的目的。</p>\n<p>副本集最多有一个主节点。 如果当前主节点不可用，一个选举会抉择出新的主节点。MongoDB 的节点选举规则能够保证在 Primary 挂掉之后选取的新节点一定是集群中数据最全的一个。</p>\n<h4> 为什么要用复制集群？</h4>\n<ul>\n<li><strong>实现 failover</strong> ：提供自动故障恢复的功能，主节点发生故障时，自动从从节点中选举出一个新的主节点，确保集群的正常使用，这对于客户端来说是无感知的。</li>\n<li><strong>实现读写分离</strong> ：我们可以设置从节点上可以读取数据，主节点负责写入数据，这样的话就实现了读写分离，减轻了主节点读写压力过大的问题。MongoDB 4.0 之前版本如果主库压力不大,不建议读写分离，因为写会阻塞读，除非业务对响应时间不是非常关注以及读取历史数据接受一定时间延迟。</li>\n</ul>\n<h3> 分片集群</h3>\n<h4> 什么是分片集群？</h4>\n<p>分片集群是 MongoDB 的分布式版本，相较副本集，分片集群数据被均衡的分布在不同分片中， 不仅大幅提升了整个集群的数据容量上限，也将读写的压力分散到不同分片，以解决副本集性能瓶颈的难题。</p>\n<p>MongoDB 的分片集群由如下三个部分组成（下图来源于<a href=\"https://www.mongodb.com/docs/manual/sharding/\" target=\"_blank\" rel=\"noopener noreferrer\">官方文档对分片集群的介绍</a>）：</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/mongodb/sharded-cluster-production-architecture.png\" alt=\"\"></p>\n<ul>\n<li><strong>Config Servers</strong>：配置服务器，本质上是一个 MongoDB 的副本集，负责存储集群的各种元数据和配置，如分片地址、Chunks 等</li>\n<li><strong>Mongos</strong>：路由服务，不存具体数据，从 Config 获取集群配置讲请求转发到特定的分片，并且整合分片结果返回给客户端。</li>\n<li><strong>Shard</strong>：每个分片是整体数据的一部分子集，从MongoDB3.6版本开始，每个Shard必须部署为副本集（replica set）架构</li>\n</ul>\n<h4> 为什么要用分片集群？</h4>\n<p>随着系统数据量以及吞吐量的增长，常见的解决办法有两种：垂直扩展和水平扩展。</p>\n<p>垂直扩展通过增加单个服务器的能力来实现，比如磁盘空间、内存容量、CPU 数量等；水平扩展则通过将数据存储到多个服务器上来实现，根据需要添加额外的服务器以增加容量。</p>\n<p>类似于 Redis Cluster，MongoDB 也可以通过分片实现 <strong>水平扩展</strong> 。水平扩展这种方式更灵活，可以满足更大数据量的存储需求，支持更高吞吐量。并且，水平扩展所需的整体成本更低，仅仅需要相对较低配置的单机服务器即可，代价是增加了部署的基础设施和维护的复杂性。</p>\n<p>也就是说当你遇到如下问题时，可以使用分片集群解决：</p>\n<ul>\n<li>存储容量受单机限制，即磁盘资源遭遇瓶颈。</li>\n<li>读写能力受单机限制，可能是 CPU、内存或者网卡等资源遭遇瓶颈，导致读写能力无法扩展。</li>\n</ul>\n<h4> 什么是分片键？</h4>\n<p><strong>分片键（Shard Key）</strong> 是数据分区的前提， 从而实现数据分发到不同服务器上，减轻服务器的负担。也就是说，分片键决定了集合内的文档如何在集群的多个分片间的分布状况。</p>\n<p>分片键就是文档里面的一个字段，但是这个字段不是普通的字段，有一定的要求：</p>\n<ul>\n<li>它必须在所有文档中都出现。</li>\n<li>它必须是集合的一个索引，可以是单索引或复合索引的前缀索引，不能是多索引、文本索引或地理空间位置索引。</li>\n<li>MongoDB 4.2 之前的版本，文档的分片键字段值不可变。MongoDB 4.2 版本开始，除非分片键字段是不可变的 <code>_id</code> 字段，否则您可以更新文档的分片键值。MongoDB 5.0 版本开始，实现了实时重新分片（live resharding），可以实现分片键的完全重新选择。</li>\n<li>它的大小不能超过 512 字节。</li>\n</ul>\n<h4> 如何选择分片键？</h4>\n<p>选择合适的片键对 sharding 效率影响很大，主要基于如下四个因素（摘自<a href=\"https://cloud.tencent.com/document/product/240/44611\" target=\"_blank\" rel=\"noopener noreferrer\">分片集群使用注意事项 - - 腾讯云文档</a>）：</p>\n<ul>\n<li><strong>取值基数</strong> 取值基数建议尽可能大，如果用小基数的片键，因为备选值有限，那么块的总数量就有限，随着数据增多，块的大小会越来越大，导致水平扩展时移动块会非常困难。 例如：选择年龄做一个基数，范围最多只有100个，随着数据量增多，同一个值分布过多时，导致 chunck 的增长超出 chuncksize 的范围，引起 jumbo chunk，从而无法迁移，导致数据分布不均匀，性能瓶颈。</li>\n<li><strong>取值分布</strong> 取值分布建议尽量均匀，分布不均匀的片键会造成某些块的数据量非常大，同样有上面数据分布不均匀，性能瓶颈的问题。</li>\n<li><strong>查询带分片</strong> 查询时建议带上分片，使用分片键进行条件查询时，mongos 可以直接定位到具体分片，否则 mongos 需要将查询分发到所有分片，再等待响应返回。</li>\n<li><strong>避免单调递增或递减</strong> 单调递增的 sharding key，数据文件挪动小，但写入会集中，导致最后一篇的数据量持续增大，不断发生迁移，递减同理。</li>\n</ul>\n<p>综上，在选择片键时要考虑以上4个条件，尽可能满足更多的条件，才能降低 MoveChuncks 对性能的影响，从而获得最优的性能体验。</p>\n<h4> 分片策略有哪些？</h4>\n<p>MongoDB 支持两种分片算法来满足不同的查询需求（摘自<a href=\"https://help.aliyun.com/document_detail/64561.html?spm=a2c4g.11186623.0.0.3121565eQhUGGB#h2--shard-key-3\" target=\"_blank\" rel=\"noopener noreferrer\">MongoDB 分片集群介绍 - 阿里云文档</a>）：</p>\n<p><strong>1、基于范围的分片</strong> ：</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/mongodb/example-of-scope-based-sharding.png\" alt=\"\"></p>\n<p>MongoDB 按照分片键（Shard Key）的值的范围将数据拆分为不同的块（Chunk），每个块包含了一段范围内的数据。当分片键的基数大、频率低且值非单调变更时，范围分片更高效。</p>\n<ul>\n<li>优点： Mongos 可以快速定位请求需要的数据，并将请求转发到相应的 Shard 节点中。</li>\n<li>缺点： 可能导致数据在 Shard 节点上分布不均衡，容易造成读写热点，且不具备写分散性。</li>\n<li>适用场景：分片键的值不是单调递增或单调递减、分片键的值基数大且重复的频率低、需要范围查询等业务场景。</li>\n</ul>\n<p><strong>2、基于 Hash 值的分片</strong></p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/mongodb/example-of-hash-based-sharding.png\" alt=\"\"></p>\n<p>MongoDB 计算单个字段的哈希值作为索引值，并以哈希值的范围将数据拆分为不同的块（Chunk）。</p>\n<ul>\n<li>优点：可以将数据更加均衡地分布在各 Shard 节点中，具备写分散性。</li>\n<li>缺点：不适合进行范围查询，进行范围查询时，需要将读请求分发到所有的 Shard 节点。</li>\n<li>适用场景：分片键的值存在单调递增或递减、片键的值基数大且重复的频率低、需要写入的数据随机分发、数据读取随机性较大等业务场景。</li>\n</ul>\n<p>除了上述两种分片策略，您还可以配置 <strong>复合片键</strong> ，例如由一个低基数的键和一个单调递增的键组成。</p>\n<h4> 分片数据如何存储？</h4>\n<p><strong>Chunk（块）</strong> 是 MongoDB 分片集群的一个核心概念，其本质上就是由一组 Document 组成的逻辑数据单元。每个 Chunk 包含一定范围片键的数据，互不相交且并集为全部数据，即离散数学中<strong>划分</strong>的概念。</p>\n<p>分片集群不会记录每条数据在哪个分片上，而是记录 Chunk 在哪个分片上一级这个 Chunk 包含哪些数据。</p>\n<p>默认情况下，一个 Chunk 的最大值默认为 64MB（可调整，取值范围为 1~1024 MB。如无特殊需求，建议保持默认值），进行数据插入、更新、删除时，如果此时 Mongos 感知到了目标 Chunk 的大小或者其中的数据量超过上限，则会触发 <strong>Chunk 分裂</strong>。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/mongodb/chunk-splitting-shard-a.png\" alt=\"Chunk 分裂\"></p>\n<p>数据的增长会让 Chunk 分裂得越来越多。这个时候，各个分片上的 Chunk 数量可能会不平衡。Mongos 中的 <strong>均衡器(Balancer)</strong> 组件就会执行自动平衡，尝试使各个 Shard 上 Chunk 的数量保持均衡，这个过程就是 <strong>再平衡（Rebalance）</strong>。默认情况下，数据库和集合的 Rebalance 是开启的。</p>\n<p>如下图所示，随着数据插入，导致 Chunk 分裂，让 AB 两个分片有 3 个 Chunk，C 分片只有一个，这个时候就会把 B 分配的迁移一个到 C 分片实现集群数据均衡。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/mongodb/mongo-reblance-three-shards.png\" alt=\"Chunk 迁移\"></p>\n<blockquote>\n<p>Balancer 是 MongoDB 的一个运行在 Config Server 的 Primary 节点上(自 MongoDB 3.4 版本起)的后台进程，它监控每个分片上 Chunk 数量，并在某个分片上 Chunk 数量达到阈值进行迁移。</p>\n</blockquote>\n<p>Chunk 只会分裂，不会合并，即使 chunkSize 的值变大。</p>\n<p>Rebalance 操作是比较耗费系统资源的，我们可以通过在业务低峰期执行、预分片或者设置 Rebalance 时间窗等方式来减少其对 MongoDB 正常使用所带来的影响。</p>\n<h4> Chunk 迁移原理是什么？</h4>\n<p>关于 Chunk 迁移原理的详细介绍，推荐阅读 MongoDB 中文社区的<a href=\"https://mongoing.com/archives/77479\" target=\"_blank\" rel=\"noopener noreferrer\">一文读懂 MongoDB chunk 迁移</a>这篇文章。</p>\n<h2> 学习资料推荐</h2>\n<ul>\n<li><a href=\"https://docs.mongoing.com/\" target=\"_blank\" rel=\"noopener noreferrer\">MongoDB 中文手册|官方文档中文版</a>（推荐）：基于 4.2 版本，不断与官方最新版保持同步。</li>\n<li><a href=\"https://mongoing.com/archives/docs/mongodb%e5%88%9d%e5%ad%a6%e8%80%85%e6%95%99%e7%a8%8b/mongodb%e5%a6%82%e4%bd%95%e5%88%9b%e5%bb%ba%e6%95%b0%e6%8d%ae%e5%ba%93%e5%92%8c%e9%9b%86%e5%90%88\" target=\"_blank\" rel=\"noopener noreferrer\">MongoDB 初学者教程——7 天学习 MongoDB</a>：快速入门。</li>\n<li><a href=\"https://www.cnblogs.com/dxflqm/p/16643981.html\" target=\"_blank\" rel=\"noopener noreferrer\">SpringBoot 整合 MongoDB 实战 - 2022</a> ：很不错的一篇 MongoDB 入门文章，主要围绕 MongoDB 的 Java 客户端使用进行基本的增删改查操作介绍。</li>\n</ul>\n<h2> 参考</h2>\n<ul>\n<li>MongoDB 官方文档（主要参考资料，以官方文档为准）：https://www.mongodb.com/docs/manual/</li>\n<li>《MongoDB 权威指南》</li>\n<li>Indexes - MongoDB 官方文档：https://www.mongodb.com/docs/manual/indexes/</li>\n<li>MongoDB - 索引知识 - 程序员翔仔 - 2022：https://fatedeity.cn/posts/database/mongodb-index-knowledge.html</li>\n<li>MongoDB - 索引: https://www.cnblogs.com/Neeo/articles/14325130.html</li>\n<li>Sharding - MongoDB 官方文档：https://www.mongodb.com/docs/manual/sharding/</li>\n<li>MongoDB 分片集群介绍 - 阿里云文档：https://help.aliyun.com/document_detail/64561.html</li>\n<li>分片集群使用注意事项 - - 腾讯云文档：https://cloud.tencent.com/document/product/240/44611</li>\n</ul>\n",
      "image": "https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/mongodb/mongodb-composite-index.png",
      "date_published": "2023-01-12T09:46:41.000Z",
      "date_modified": "2023-01-12T09:46:41.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "数据库"
      ]
    },
    {
      "title": "软件工程简明教程",
      "url": "https://javaguide.cn/system-design/basis/software-engineering.html",
      "id": "https://javaguide.cn/system-design/basis/software-engineering.html",
      "summary": "大部分软件开发从业者，都会忽略软件开发中的一些最基础、最底层的一些概念。但是，这些软件开发的概念对于软件开发来说非常重要，就像是软件开发的基石一样。这也是我写这篇文章的原因。 何为软件工程？ 1968 年 NATO（北大西洋公约组织）提出了软件危机（Software crisis）一词。同年，为了解决软件危机问题，“软件工程”的概念诞生了。一门叫做软件工程的学科也就应运而生。 随着时间的推移，软件工程这门学科也经历了一轮又一轮的完善，其中的一些核心内容比如软件开发模型越来越丰富实用！",
      "content_html": "<p>大部分软件开发从业者，都会忽略软件开发中的一些最基础、最底层的一些概念。但是，这些软件开发的概念对于软件开发来说非常重要，就像是软件开发的基石一样。这也是我写这篇文章的原因。</p>\n<h2> 何为软件工程？</h2>\n<p>1968 年 NATO（北大西洋公约组织）提出了<strong>软件危机</strong>（<strong>Software crisis</strong>）一词。同年，为了解决软件危机问题，“<strong>软件工程</strong>”的概念诞生了。一门叫做软件工程的学科也就应运而生。</p>\n<p>随着时间的推移，软件工程这门学科也经历了一轮又一轮的完善，其中的一些核心内容比如软件开发模型越来越丰富实用！</p>\n<p><strong>什么是软件危机呢？</strong></p>\n<p>简单来说，软件危机描述了当时软件开发的一个痛点：我们很难高效地开发出质量高的软件。</p>\n<p>Dijkstra（Dijkstra算法的作者） 在 1972年图灵奖获奖感言中也提高过软件危机，他是这样说的：“导致软件危机的主要原因是机器变得功能强大了几个数量级！坦率地说：只要没有机器，编程就完全没有问题。当我们有一些弱小的计算机时，编程成为一个温和的问题，而现在我们有了庞大的计算机，编程也同样成为一个巨大的问题”。</p>\n<p><strong>说了这么多，到底什么是软件工程呢？</strong></p>\n<p>工程是为了解决实际的问题将理论应用于实践。软件工程指的就是将工程思想应用于软件开发。</p>\n<p>上面是我对软件工程的定义，我们再来看看比较权威的定义。IEEE 软件工程汇刊给出的定义是这样的：　(1)将系统化的、规范的、可量化的方法应用到软件的开发、运行及维护中，即将工程化方法应用于软件。　(2)在(1)中所述方法的研究。</p>\n<p>总之，软件工程的终极目标就是：<strong>在更少资源消耗的情况下，创造出更好、更容易维护的软件。</strong></p>\n<h2> 软件开发过程</h2>\n<p><a href=\"https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B\" target=\"_blank\" rel=\"noopener noreferrer\">维基百科是这样定义软件开发过程</a>的：</p>\n<blockquote>\n<p>软件开发过程（英语：software development process），或软件过程（英语：software process），是软件开发的开发生命周期（software development life cycle），其各个阶段实现了软件的需求定义与分析、设计、实现、测试、交付和维护。软件过程是在开发与构建系统时应遵循的步骤，是软件开发的路线图。</p>\n</blockquote>\n<ul>\n<li>需求分析 ：分析用户的需求，建立逻辑模型。</li>\n<li>软件设计 ： 根据需求分析的结果对软件架构进行设计。</li>\n<li>编码 ：编写程序运行的源代码。</li>\n<li>测试 :  确定测试用例，编写测试报告。</li>\n<li>交付 ：将做好的软件交付给客户。</li>\n<li>维护 ：对软件进行维护比如解决 bug，完善功能。</li>\n</ul>\n<p>软件开发过程只是比较笼统的层面上，一定义了一个软件开发可能涉及到的一些流程。</p>\n<p>软件开发模型更具体地定义了软件开发过程，对开发过程提供了强有力的理论支持。</p>\n<h2> 软件开发模型</h2>\n<p>软件开发模型有很多种，比如瀑布模型（Waterfall Model）、快速原型模型（Rapid Prototype Model）、V模型（V-model）、W模型（W-model）、敏捷开发模型。其中最具有代表性的还是 <strong>瀑布模型</strong> 和  <strong>敏捷开发</strong> 。</p>\n<p><strong>瀑布模型</strong> 定义了一套完成的软件开发周期，完整地展示了一个软件的的生命周期。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/0046e9b9aec475b9fe690f96597ff597.png\" alt=\"\"></p>\n<p><strong>敏捷开发模型</strong> 是目前使用的最多的一种软件开发模型。<a href=\"https://wiki.mbalib.com/wiki/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91\" target=\"_blank\" rel=\"noopener noreferrer\">MBA智库百科对敏捷开发的描述</a>是这样的:</p>\n<blockquote>\n<p><strong>敏捷开发</strong> 是一种以人为核心、迭代、循序渐进的开发方法。在敏捷开发中，软件项目的构建被切分成多个子项目，各个子项目的成果都经过测试，具备集成和可运行的特征。换言之，就是把一个大项目分为多个相互联系，但也可独立运行的小项目，并分别完成，在此过程中软件一直处于可使用状态。</p>\n</blockquote>\n<p>像现在比较常见的一些概念比如 <strong>持续集成</strong> 、<strong>重构</strong> 、<strong>小版本发布</strong> 、<strong>低文档</strong> 、<strong>站会</strong> 、<strong>结对编程</strong> 、<strong>测试驱动开发</strong> 都是敏捷开发的核心。</p>\n<h2> 软件开发的基本策略</h2>\n<h3> 软件复用</h3>\n<p>我们在构建一个新的软件的时候，不需要从零开始，通过复用已有的一些轮子（框架、第三方库等）、设计模式、设计原则等等现成的物料，我们可以更快地构建出一个满足要求的软件。</p>\n<p>像我们平时接触的开源项目就是最好的例子。我想，如果不是开源，我们构建出一个满足要求的软件，耗费的精力和时间要比现在多的多！</p>\n<h3> 分而治之</h3>\n<p>构建软件的过程中，我们会遇到很多问题。我们可以将一些比较复杂的问题拆解为一些小问题，然后，一一攻克。</p>\n<p>我结合现在比较火的软件设计方法—领域驱动设计（Domain Driven Design，简称 DDD）来说说。</p>\n<p>在领域驱动设计中，很重要的一个概念就是<strong>领域（Domain）</strong>，它就是我们要解决的问题。在领域驱动设计中，我们要做的就是把比较大的领域（问题）拆解为若干的小领域（子域）。</p>\n<p>除此之外，分而治之也是一个比较常用的算法思想，对应的就是分治算法。如果你想了解分治算法的话，推荐你看一下北大的<a href=\"https://www.coursera.org/learn/algorithms\" target=\"_blank\" rel=\"noopener noreferrer\">《算法设计与分析 Design and Analysis of Algorithms》</a>。</p>\n<h3> 逐步演进</h3>\n<p>软件开发是一个逐步演进的过程，我们需要不断进行迭代式增量开发，最终交付符合客户价值的产品。</p>\n<p>这里补充一个在软件开发领域，非常重要的概念：<strong>MVP（Minimum Viable Product，最小可行产品</strong>）。</p>\n<p>这个最小可行产品，可以理解为刚好能够满足客户需求的产品。下面这张图片把这个思想展示的非常精髓。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/9d0e06bbf8eeee5751ffb10e3bc21dc6.jpeg\" alt=\"Running hypothesis driven experiments using the MVP\"></p>\n<p>利用最小可行产品，我们可以也可以提早进行市场分析，这对于我们在探索产品不确定性的道路上非常有帮助。可以非常有效地指导我们下一步该往哪里走。</p>\n<h3> 优化折中</h3>\n<p>软件开发是一个不断优化改进的过程。任何软件都有很多可以优化的点，不可能完美。我们需要不断改进和提升软件的质量。</p>\n<p>但是，也不要陷入这个怪圈。要学会折中，在有限的投入内，以最有效的方式提高现有软件的质量。</p>\n<h2> 参考</h2>\n<ul>\n<li>软件工程的基本概念-清华大学软件学院 刘强：https://www.xuetangx.com/course/THU08091000367</li>\n<li>软件开发过程-维基百科 ：<a href=\"https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B\" target=\"_blank\" rel=\"noopener noreferrer\">https://zh.wikipedia.org/wiki/软件开发过程</a></li>\n</ul>\n",
      "image": "https://img-blog.csdnimg.cn/img_convert/0046e9b9aec475b9fe690f96597ff597.png",
      "date_published": "2022-12-30T05:45:11.000Z",
      "date_modified": "2022-12-30T05:45:11.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "系统设计"
      ]
    },
    {
      "title": "Maven 核心概念总结",
      "url": "https://javaguide.cn/tools/maven/maven-core-concepts.html",
      "id": "https://javaguide.cn/tools/maven/maven-core-concepts.html",
      "summary": "这部分内容主要根据 Maven 官方文档整理，做了对应的删减，主要保留比较重要的部分，不涉及实战，主要是一些重要概念的介绍。 Maven 介绍 Maven 官方文档是这样介绍的 Maven 的： Apache Maven is a software project management and comprehension tool. Based on the concept of a project object model (POM), Maven can manage a project's build, reporting and documentation from a central piece of information. Apache Maven 的本质是一个软件项目管理和理解工具。基于项目对象模型 (Project Object Model，POM) 的概念，Maven 可以从一条中心信息管理项目的构建、报告和文档。",
      "content_html": "<blockquote>\n<p>这部分内容主要根据 Maven 官方文档整理，做了对应的删减，主要保留比较重要的部分，不涉及实战，主要是一些重要概念的介绍。</p>\n</blockquote>\n<h2> Maven 介绍</h2>\n<p><a href=\"https://github.com/apache/maven\" target=\"_blank\" rel=\"noopener noreferrer\">Maven</a> 官方文档是这样介绍的 Maven 的：</p>\n<blockquote>\n<p>Apache Maven is a software project management and comprehension tool. Based on the concept of a project object model (POM), Maven can manage a project's build, reporting and documentation from a central piece of information.</p>\n<p>Apache Maven 的本质是一个软件项目管理和理解工具。基于项目对象模型 (Project Object Model，POM) 的概念，Maven 可以从一条中心信息管理项目的构建、报告和文档。</p>\n</blockquote>\n<p><strong>什么是 POM？</strong> 每一个 Maven 工程都有一个 <code>pom.xml</code> 文件，位于根目录中，包含项目构建生命周期的详细信息。通过 <code>pom.xml</code> 文件，我们可以定义项目的坐标、项目依赖、项目信息、插件信息等等配置。</p>\n<p>对于开发者来说，Maven 的主要作用主要有 3 个：</p>\n<ol>\n<li><strong>项目构建</strong> ：提供标准的、跨平台的自动化项目构建方式。</li>\n<li><strong>依赖管理</strong> ：方便快捷的管理项目依赖的资源（jar 包），避免资源间的版本冲突问题。</li>\n<li><strong>统一开发结构</strong> ：提供标准的、统一的项目结构。</li>\n</ol>\n<p>关于 Maven 的基本使用这里就不介绍了，建议看看官网的 5 分钟上手 Maven 的教程：<a href=\"https://maven.apache.org/guides/getting-started/maven-in-five-minutes.html\" target=\"_blank\" rel=\"noopener noreferrer\">Maven in 5 Minutes</a> 。</p>\n<h2> Maven 坐标</h2>\n<p>项目中依赖的第三方库以及插件可统称为构件。每一个构件都可以使用 Maven 坐标唯一标识，坐标元素包括：</p>\n<ul>\n<li><strong>goupId</strong>(必须): 定义了当前 Maven 项目隶属的组织或公司。groupId 一般分为多段，通常情况下，第一段为域，第二段为公司名称。域又分为 org、com、cn 等，其中 org 为非营利组织，com 为商业组织，cn 表示中国。以 apache 开源社区的 tomcat 项目为例，这个项目的 groupId 是 org.apache，它的域是 org（因为 tomcat 是非营利项目），公司名称是 apache，artifactId 是 tomcat。</li>\n<li><strong>artifactId</strong>(必须)：定义了当前 Maven 项目的名称，项目的唯一的标识符，对应项目根目录的名称。</li>\n<li><strong>version</strong>(必须)： 定义了 Maven 项目当前所处版本。</li>\n<li><strong>packaging</strong>（可选）：定义了 Maven 项目的打包方式（比如 jar，war...），默认使用 jar。</li>\n<li><strong>classifier</strong>(可选)：常用于区分从同一 POM 构建的具有不同内容的构件，可以是任意的字符串，附加在版本号之后。</li>\n</ul>\n<p>只要你提供正确的坐标，就能从 Maven 仓库中找到相应的构件供我们使用。</p>\n<p>举个例子（引入阿里巴巴开源的 EasyExcel） ：</p>\n<div class=\"language-xml line-numbers-mode\" data-ext=\"xml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>你可以在 https://mvnrepository.com/ 这个网站上找到几乎所有可用的构件，如果你的项目使用的是 Maven 作为构建工具，那这个网站你一定会经常接触。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/tools/maven/mvnrepository.com.png\" alt=\"Maven 仓库\"></p>\n<h2> Maven 依赖</h2>\n<p>如果使用 Maven 构建产生的构件（例如 Jar 文件）被其他的项目引用，那么该构件就是其他项目的依赖。</p>\n<h3> 依赖配置</h3>\n<p><strong>配置信息示例</strong> ：</p>\n<div class=\"language-xml line-numbers-mode\" data-ext=\"xml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>配置说明</strong> ：</p>\n<ul>\n<li>dependencies ： 一个 pom.xml 文件中只能存在一个这样的标签，是用来管理依赖的总标签。</li>\n<li>dependency：包含在 dependencies 标签中，可以有多个，每一个表示项目的一个依赖。</li>\n<li>groupId,artifactId,version(必要)：依赖的基本坐标，对于任何一个依赖来说，基本坐标是最重要的，Maven 根据坐标才能找到需要的依赖。我们在上面解释过这些元素的具体意思，这里就不重复提了。</li>\n<li>type(可选)：依赖的类型，对应于项目坐标定义的 packaging。大部分情况下，该元素不必声明，其默认值是 jar。</li>\n<li>scope(可选)：依赖的范围，默认值是 compile。</li>\n<li>optional(可选)： 标记依赖是否可选</li>\n<li>exclusions(可选)：用来排除传递性依赖,例如 jar 包冲突</li>\n</ul>\n<h3> 依赖范围</h3>\n<p><strong>classpath</strong> 用于指定 <code>.class</code> 文件存放的位置，类加载器会从该路径中加载所需的 <code>.class</code> 文件到内存中。</p>\n<p>Maven 在编译、执行测试、实际运行有着三套不同的 classpath：</p>\n<ul>\n<li><strong>编译 classpath</strong> ：编译主代码有效</li>\n<li><strong>测试 classpath</strong> ：编译、运行测试代码有效</li>\n<li><strong>运行 classpath</strong> ：项目运行时有效</li>\n</ul>\n<p>Maven 的依赖范围如下：</p>\n<ul>\n<li><strong>compile</strong>：编译依赖范围（默认），使用此依赖范围对于编译、测试、运行三种都有效，即在编译、测试和运行的时候都要使用该依赖 Jar 包。</li>\n<li><strong>test</strong>：测试依赖范围，从字面意思就可以知道此依赖范围只能用于测试，而在编译和运行项目时无法使用此类依赖，典型的是 JUnit，它只用于编译测试代码和运行测试代码的时候才需要。</li>\n<li><strong>provided</strong> ：此依赖范围，对于编译和测试有效，而对运行时无效。比如 <code>servlet-api.jar</code> 在 Tomcat 中已经提供了，我们只需要的是编译期提供而已。</li>\n<li><strong>runtime</strong>：运行时依赖范围，对于测试和运行有效，但是在编译主代码时无效，典型的就是 JDBC 驱动实现。</li>\n<li><strong>system</strong>：系统依赖范围，使用 system 范围的依赖时必须通过 systemPath 元素显示地指定依赖文件的路径，不依赖 Maven 仓库解析，所以可能会造成建构的不可移植。</li>\n</ul>\n<h3> 传递依赖性</h3>\n<h3> 依赖冲突</h3>\n<p><strong>1、对于 Maven 而言，同一个 groupId 同一个 artifactId 下，只能使用一个 version。</strong></p>\n<div class=\"language-xml line-numbers-mode\" data-ext=\"xml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>若相同类型但版本不同的依赖存在于同一个 pom 文件，只会引入后一个声明的依赖。</p>\n<p><strong>2、项目的两个依赖同时引入了某个依赖。</strong></p>\n<p>举个例子，项目存在下面这样的依赖关系：</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这两条依赖路径上有两个版本的 X，为了避免依赖重复，Maven 只会选择其中的一个进行解析。</p>\n<p><strong>哪个版本的 X 会被 Maven 解析使用呢?</strong></p>\n<p>Maven 在遇到这种问题的时候，会遵循 <strong>路径最短优先</strong> 和 <strong>声明顺序优先</strong> 两大原则。解决这个问题的过程也被称为 <strong>Maven 依赖调解</strong> 。</p>\n<p><strong>路径最短优先</strong></p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>依赖链路二的路径最短，因此，X(2.0)会被解析使用。</p>\n<p>不过，你也可以发现。路径最短优先原则并不是通用的，像下面这种路径长度相等的情况就不能单单通过其解决了：</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>因此，Maven 又定义了声明顺序优先原则。</p>\n<p>依赖调解第一原则不能解决所有问题，比如这样的依赖关系：A-&gt;B-&gt;Y(1.0)、A-&gt; C-&gt;Y(2.0)，Y(1.0)和 Y(2.0)的依赖路径长度是一样的，都为 2。Maven 定义了依赖调解的第二原则：</p>\n<p><strong>声明顺序优先</strong></p>\n<p>在依赖路径长度相等的前提下，在 <code>pom.xml</code> 中依赖声明的顺序决定了谁会被解析使用，顺序最前的那个依赖优胜。该例中，如果 B 的依赖声明在 D 之前，那么 X (1.0)就会被解析使用。</p>\n<div class=\"language-xml line-numbers-mode\" data-ext=\"xml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 排除依赖</h3>\n<p>单纯依赖 Maven 来进行依赖调解，在很多情况下是不适用的，需要我们手动排除依赖。</p>\n<p>举个例子，当前项目存在下面这样的依赖关系：</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>根据路径最短优先原则，X(1.0) 会被解析使用，也就是说实际用的是 1.0 版本的 X。</p>\n<p>但是！！！这会一些问题：如果 D 依赖用到了 1.5 版本的 X 中才有的一个类，运行项目就会报<code>NoClassDefFoundError</code>错误。如果 D 依赖用到了 1.5 版本的 X 中才有的一个方法，运行项目就会报<code>NoSuchMethodError</code>错误。</p>\n<p>现在知道为什么你的 Maven 项目总是会报<code>NoClassDefFoundError</code>和<code>NoSuchMethodError</code>错误了吧？</p>\n<p><strong>如何解决呢？</strong> 我们可以通过<code>exclusive</code>标签手动将 X(1.0) 给排除。</p>\n<div class=\"language-xml line-numbers-mode\" data-ext=\"xml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>一般我们在解决依赖冲突的时候，都会优先保留版本较高的。这是因为大部分 jar 在升级的时候都会做到向下兼容。</p>\n<p>如果高版本修改了低版本的一些类或者方法的话，这个时候就能直接保留高版本了，而是应该考虑优化上层依赖，比如升级上层依赖的版本。</p>\n<p>还是上面的例子：</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>我们保留了 1.5 版本的 X，但是这个版本的 X 删除了 1.0 版本中的某些类。这个时候，我们可以考虑升级 D 的版本到一个 X 兼容的版本。</p>\n<h2> Maven 仓库</h2>\n<p>在 Maven 世界中，任何一个依赖、插件或者项目构建的输出，都可以称为 <strong>构件</strong> 。</p>\n<p>坐标和依赖是构件在 Maven 世界中的逻辑表示方式，构件的物理表示方式是文件，Maven 通过仓库来统一管理这些文件。 任何一个构件都有一组坐标唯一标识。有了仓库之后，无需手动引入构件，我们直接给定构件的坐标即可在 Maven 仓库中找到该构件。</p>\n<p>Maven 仓库分为：</p>\n<ul>\n<li><strong>本地仓库</strong> ：运行 Maven 的计算机上的一个目录，它缓存远程下载的构件并包含尚未发布的临时构件。<code>settings.xml</code> 文件中可以看到 Maven 的本地仓库路径配置，默认本地仓库路径是在 <code>${user.home}/.m2/repository</code>。</li>\n<li><strong>远程仓库</strong> ：官方或者其他组织维护的 Maven 仓库。</li>\n</ul>\n<p>Maven 远程仓库可以分为：</p>\n<ul>\n<li><strong>中央仓库</strong> ：这个仓库是由 Maven 社区来维护的，里面存放了绝大多数开源软件的包，并且是作为 Maven 的默认配置，不需要开发者额外配置。另外为了方便查询，还提供了一个<a href=\"https://search.maven.org/\" target=\"_blank\" rel=\"noopener noreferrer\">查询地址</a>，开发者可以通过这个地址更快的搜索需要构件的坐标。</li>\n<li><strong>私服</strong> ：私服是一种特殊的远程 Maven 仓库，它是架设在局域网内的仓库服务，私服一般被配置为互联网远程仓库的镜像，供局域网内的 Maven 用户使用。</li>\n<li><strong>其他的公共仓库</strong> ：有一些公共仓库是未来加速访问（比如阿里云 Maven 镜像仓库）或者部分构件不存在于中央仓库中。</li>\n</ul>\n<p>Maven 依赖包寻找顺序：</p>\n<ol>\n<li>先去本地仓库找寻，有的话，直接使用。</li>\n<li>本地仓库没有找到的话，会去远程仓库找寻，下载包到本地仓库。</li>\n<li>远程仓库没有找到的话，会报错。</li>\n</ol>\n<h2> Maven 生命周期</h2>\n<p>Maven 的生命周期就是为了对所有的构建过程进行抽象和统一，包含了项目的清理、初始化、编译、测试、打包、集成测试、验证、部署和站点生成等几乎所有构建步骤。</p>\n<p>Maven 定义了 3 个生命周期<code>META-INF/plexus/components.xml</code>：</p>\n<ul>\n<li><code>default</code> 生命周期</li>\n<li><code>clean</code>生命周期</li>\n<li><code>site</code>生命周期</li>\n</ul>\n<p>这些生命周期是相互独立的，每个生命周期包含多个阶段(phase)。并且，这些阶段是有序的，也就是说，后面的阶段依赖于前面的阶段。当执行某个阶段的时候，会先执行它前面的阶段。</p>\n<p>执行 Maven 生命周期的命令格式如下：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> default 生命周期</h3>\n<p><code>default</code>生命周期是在没有任何关联插件的情况下定义的，是 Maven 的主要生命周期，用于构建应用程序，共包含 23 个阶段。</p>\n<div class=\"language-xml line-numbers-mode\" data-ext=\"xml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>根据前面提到的阶段间依赖关系理论，当我们执行 <code>mvn test</code>命令的时候，会执行从 validate 到 test 的所有阶段，这也就解释了为什么执行测试的时候，项目的代码能够自动编译。</p>\n<h3> clean 生命周期</h3>\n<p>clean 生命周期的目的是清理项目，共包含 3 个阶段：</p>\n<ol>\n<li>pre-clean</li>\n<li>clean</li>\n<li>post-clean</li>\n</ol>\n<div class=\"language-xml line-numbers-mode\" data-ext=\"xml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>根据前面提到的阶段间依赖关系理论，当我们执行 <code>mvn clean</code> 的时候，会执行 clean 生命周期中的 pre-clean 和 clean 阶段。</p>\n<h3> site 生命周期</h3>\n<p>site 生命周期的目的是建立和发布项目站点，共包含 4 个阶段：</p>\n<ol>\n<li>pre-site</li>\n<li>site</li>\n<li>post-site</li>\n<li>site-deploy</li>\n</ol>\n<div class=\"language-xml line-numbers-mode\" data-ext=\"xml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>Maven 能够基于 <code>pom.xml</code> 所包含的信息，自动生成一个友好的站点，方便团队交流和发布项目信息。</p>\n<h2> Maven 插件</h2>\n<p>Maven 本质上是一个插件执行框架，所有的执行过程，都是由一个一个插件独立完成的。像咱们日常使用到的 install、clean、deploy 等命令，其实底层都是一个一个的 Maven 插件。关于 Maven 的核心插件可以参考官方的这篇文档：https://maven.apache.org/plugins/index.html 。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/tools/maven/maven-plugins.png\" alt=\"\"></p>\n<p>除了 Maven 自带的插件之外，还有一些三方提供的插件比如单测覆盖率插件 jacoco-maven-plugin、帮助开发检测代码中不合规范的地方的插件 maven-checkstyle-plugin、分析代码质量的 sonar-maven-plugin。并且，我们还可以自定义插件来满足自己的需求。</p>\n<p>jacoco-maven-plugin 使用示例：</p>\n<div class=\"language-xml line-numbers-mode\" data-ext=\"xml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>你可以将 Maven 插件理解为一组任务的集合，用户可以通过命令行直接运行指定插件的任务，也可以将插件任务挂载到构建生命周期，随着生命周期运行。</p>\n<p>Maven 插件被分为下面两种类型：</p>\n<ul>\n<li><strong>Build plugins</strong> ：在构建时执行。</li>\n<li><strong>Reporting plugins</strong>：在网站生成过程中执行。</li>\n</ul>\n<h2> Maven 多模块管理</h2>\n<p>多模块管理简单地来说就是将一个项目分为多个模块，每个模块只负责单一的功能实现。直观的表现就是一个 Maven 项目中不止有一个 <code>pom.xml</code> 文件，会在不同的目录中有多个 <code>pom.xml</code> 文件，进而实现多模块管理。</p>\n<p>多模块管理除了可以更加便于项目开发和管理，还有如下好处：</p>\n<ol>\n<li>降低代码之间的耦合性（从类级别的耦合提升到 jar 包级别的耦合）；</li>\n<li>减少重复，提升复用性；</li>\n<li>每个模块都可以是自解释的（通过模块名或者模块文档）；</li>\n<li>模块还规范了代码边界的划分，开发者很容易通过模块确定自己所负责的内容。</li>\n</ol>\n<p>多模块管理下，会有一个父模块，其他的都是子模块。父模块通常只有一个 <code>pom.xml</code>，没有其他内容。父模块的 <code>pom.xml</code> 一般只定义了各个依赖的版本号、包含哪些子模块以及插件有哪些。不过，要注意的是，如果依赖只在某个子项目中使用，则可以在子项目的 pom.xml 中直接引入，防止父 pom 的过于臃肿。</p>\n<p>如下图所示，Dubbo 项目就被分成了多个子模块比如 dubbo-common（公共逻辑模块）、dubbo-remoting（远程通讯模块）、dubbo-rpc（远程调用模块）。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/tools/maven/dubbo-maven-multi-module.png\" alt=\"\"></p>\n<h2> 文章推荐</h2>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/flniMiP-eu3JSBnswfd_Ew\" target=\"_blank\" rel=\"noopener noreferrer\">安全同学讲 Maven 间接依赖场景的仲裁机制 - 阿里开发者 - 2022</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/Wvq7t2FC58jaCh4UFJ6GGQ\" target=\"_blank\" rel=\"noopener noreferrer\">高效使用 Java 构建工具｜ Maven 篇 - 阿里开发者 - 2022</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/xsJkB0onUkakrVH0wejcIg\" target=\"_blank\" rel=\"noopener noreferrer\">安全同学讲 Maven 重打包的故事 - 阿里开发者 - 2022</a></li>\n</ul>\n<h2> 参考</h2>\n<ul>\n<li>《Maven 实战》</li>\n<li>Introduction to Repositories - Maven 官方文档：https://maven.apache.org/guides/introduction/introduction-to-repositories.html</li>\n<li>Introduction to the Build Lifecycle - Maven 官方文档：https://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html#Lifecycle_Reference</li>\n<li>Maven 依赖范围：http://www.mvnbook.com/maven-dependency.html</li>\n<li>解决 maven 依赖冲突，这篇就够了！：https://www.cnblogs.com/qdhxhz/p/16363532.html</li>\n<li>Multi-Module Project with Maven：https://www.baeldung.com/maven-multi-module</li>\n</ul>\n",
      "image": "https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/tools/maven/mvnrepository.com.png",
      "date_published": "2022-12-16T14:32:28.000Z",
      "date_modified": "2023-02-27T01:50:14.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "开发工具"
      ]
    },
    {
      "title": "分布式配置中心详解(付费)",
      "url": "https://javaguide.cn/distributed-system/distributed-configuration-center.html",
      "id": "https://javaguide.cn/distributed-system/distributed-configuration-center.html",
      "summary": "分布式配置中心",
      "content_html": "<p><strong>分布式配置中心</strong></p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javamianshizhibei/distributed-system.png\" alt=\"\"></p>\n",
      "image": "https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javamianshizhibei/distributed-system.png",
      "date_published": "2022-11-03T15:33:32.000Z",
      "date_modified": "2023-01-29T03:31:13.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "分布式"
      ]
    },
    {
      "title": "常见 SQL 优化手段总结（付费）",
      "url": "https://javaguide.cn/high-performance/sql-optimization.html",
      "id": "https://javaguide.cn/high-performance/sql-optimization.html",
      "summary": "常见 SQL 优化手段总结 相关的内容为我的知识星球（点击链接即可查看详细介绍以及加入方法）专属内容，已经整理到了《Java 面试指北》中。",
      "content_html": "<p><strong>常见 SQL 优化手段总结</strong> 相关的内容为我的<a href=\"https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html\" target=\"_blank\" rel=\"noopener noreferrer\">知识星球</a>（点击链接即可查看详细介绍以及加入方法）专属内容，已经整理到了<a href=\"https://javaguide.cn/zhuanlan/java-mian-shi-zhi-bei.html\" target=\"_blank\" rel=\"noopener noreferrer\">《Java 面试指北》</a>中。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javamianshizhibei/sql-optimization.png\" alt=\"\"></p>\n<p><a href=\"https://javaguide.cn/zhuanlan/java-mian-shi-zhi-bei.html\" target=\"_blank\" rel=\"noopener noreferrer\">《Java 面试指北》</a>（点击链接即可查看详细介绍）的部分内容展示如下，你可以将其看作是 <a href=\"https://javaguide.cn\" target=\"_blank\" rel=\"noopener noreferrer\">JavaGuide</a> 的补充完善，两者可以配合使用。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220304102536445.png\" alt=\"\"></p>\n<p>最近几年，市面上有越来越多的“技术大佬”开始办培训班/训练营，动辄成千上万的学费，却并没有什么干货，单纯的就是割韭菜。</p>\n<p>为了帮助更多同学准备 Java 面试以及学习 Java ，我创建了一个纯粹的知识星球。虽然收费只有培训班/训练营的百分之一，但是知识星球里的内容质量更高，提供的服务也更全面。</p>\n<p>欢迎准备 Java 面试以及学习 Java 的同学加入我的<a href=\"https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html\" target=\"_blank\" rel=\"noopener noreferrer\">知识星球</a>，干货非常多，学习氛围也很不错！收费虽然是白菜价，但星球里的内容或许比你参加上万的培训班质量还要高。</p>\n<div align=\"center\">\n  <a href=\"https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html\">\n    <img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220311203414600.png\" style=\"margin: 0 auto; \">\n  </a>\n</div>\n<p>下面是星球提供的部分服务（点击下方图片即可获取知识星球的详细介绍）：</p>\n<div align=\"center\">\n  <a href=\"https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html\">\n    <img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/xingqiufuwu.png\" style=\"margin: 0 auto; \">\n  </a>\n</div>\n<p><strong>我有自己的原则，不割韭菜，用心做内容，真心希望帮助到你！</strong></p>\n<p>如果你感兴趣的话，不妨花 3 分钟左右看看星球的详细介绍： <a href=\"https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html\" target=\"_blank\" rel=\"noopener noreferrer\">JavaGuide 知识星球详细介绍</a>。</p>\n<p>这里再送一个 30 元的新人优惠券（续费半价）。</p>\n<div align=\"center\">\n  <a href=\"https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html\">\n    <img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/xingqiuyouhuijuanheyi.png\" style=\"margin: 0 auto; \">\n  </a>\n</div>\n<p>进入星球之后，记得添加微信，我会发你详细的星球使用指南。</p>\n<div align=\"center\">\n  <a href=\"https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html\">\n    <img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/IMG_3007.jpg\" style=\"margin: 0 auto; \">\n  </a>\n</div>",
      "image": "https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javamianshizhibei/sql-optimization.png",
      "date_published": "2022-11-03T15:33:32.000Z",
      "date_modified": "2023-01-29T03:31:13.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "高性能"
      ]
    },
    {
      "title": "项目经验指南",
      "url": "https://javaguide.cn/interview-preparation/project-experience-guide.html",
      "id": "https://javaguide.cn/interview-preparation/project-experience-guide.html",
      "summary": "没有项目经验怎么办? 没有项目经验是大部分应届生会碰到的一个问题。甚至说，有很多有工作经验的程序员，对自己在公司做的项目不满意，也想找一个比较有技术含量的项目来做。 说几种我觉得比较靠谱的获取项目经验的方式，希望能够对你有启发。 实战项目视频/专栏 在网上找一个符合自己能力与找工作需求的实战项目视频或者专栏，跟着老师一起做。 你可以通过慕课网、哔哩哔哩、拉勾、极客时间、培训机构（比如黑马、尚硅谷）等渠道获取到适合自己的实战项目视频/专栏。",
      "content_html": "<h2> 没有项目经验怎么办?</h2>\n<p>没有项目经验是大部分应届生会碰到的一个问题。甚至说，有很多有工作经验的程序员，对自己在公司做的项目不满意，也想找一个比较有技术含量的项目来做。</p>\n<p>说几种我觉得比较靠谱的获取项目经验的方式，希望能够对你有启发。</p>\n<h3> 实战项目视频/专栏</h3>\n<p>在网上找一个符合自己能力与找工作需求的实战项目视频或者专栏，跟着老师一起做。</p>\n<p>你可以通过慕课网、哔哩哔哩、拉勾、极客时间、培训机构（比如黑马、尚硅谷）等渠道获取到适合自己的实战项目视频/专栏。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javamianshizhibei/mukewangzhiazhanke.png\" alt=\"慕课网实战课\"></p>\n<p>尽量选择一个适合自己的项目，没必要必须做分布式/微服务项目，对于绝大部分同学来说，能把一个单机项目做好就已经很不错了。</p>\n<p>我面试过很多求职者，简历上看着有微服务的项目经验，结果随便问两个问题就知道根本不是自己做的或者说做的时候压根没认真思考。这种情况会给我留下非常不好的印象。</p>\n<p>我在 <strong><a href=\"/zhuanlan/java-mian-shi-zhi-bei.html\" target=\"blank\">《Java 面试指北》</a></strong> 的「面试准备篇」中也说过：</p>\n<blockquote>\n<p>个人认为也没必要非要去做微服务或者分布式项目，不一定对你面试有利。微服务或者分布式项目涉及的知识点太多，一般人很难吃透。并且，这类项目其实对于校招生来说稍微有一点超标了。即使你做出来，很多面试官也会认为不是你独立完成的。</p>\n<p>其实，你能把一个单体项目做到极致也很好，对于个人能力提升不比做微服务或者分布式项目差。如何做到极致？代码质量这里就不提了，更重要的是你要尽量让自己的项目有一些亮点（比如你是如何提升项目性能的、如何解决项目中存在的一个痛点的），项目经历取得的成果尽量要量化一下比如我使用 xxx 技术解决了 xxx 问题，系统 qps 从 xxx 提高到了 xxx。</p>\n</blockquote>\n<p>跟着老师做的过程中，你一定要有自己的思考，不要浅尝辄止。对于很多知识点，别人的讲解可能只是满足项目就够了，你自己想多点知识的话，对于重要的知识点就要自己学会去深入学习。</p>\n<h3> 实战类开源项目</h3>\n<p>Github 或者码云上面有很多实战类别项目，你可以选择一个来研究，为了让自己对这个项目更加理解，在理解原有代码的基础上，你可以对原有项目进行改进或者增加功能。</p>\n<p>你可以参考 <a href=\"https://javaguide.cn/open-source-project/practical-project.html\" title=\"Java 优质开源实战项目\" target=\"_blank\" rel=\"noopener noreferrer\">Java 优质开源实战项目</a> 上面推荐的实战类开源项目，质量都很高，项目类型也比较全面，涵盖博客/论坛系统、考试/刷题系统、商城系统、权限管理系统、快速开发脚手架以及各种轮子。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javamianshizhibei/javaguide-practical-project.png\" alt=\"Java 优质开源实战项目\"></p>\n<p>一定要记住： <strong>不光要做，还要改进，改善。不论是实战项目视频或者专栏还是实战类开源项目，都一定会有很多可以完善改进的地方。</strong></p>\n<h3> 从头开始做</h3>\n<p>自己动手去做一个自己想完成的东西，遇到不会的东西就临时去学，现学现卖。</p>\n<p>这个要求比较高，我建议你已经有了一个项目经验之后，再采用这个方法。如果你没有做过项目的话，还是老老实实采用上面两个方法比较好。</p>\n<h3> 参加各种大公司组织的各种大赛</h3>\n<p>如果参加这种赛事能获奖的话，项目含金量非常高。即使没获奖也没啥，也可以写简历上。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/7767035c52854759adf8cff5be8a2a3d.png\" alt=\"阿里云天池大赛\"></p>\n<h3> 参与实际项目</h3>\n<p>通常情况下，你有如下途径接触到企业实际项目的开发：</p>\n<ol>\n<li>老师接的项目；</li>\n<li>自己接的私活；</li>\n<li>实习/工作接触到的项目；</li>\n</ol>\n<p>老师接的项目和自己接的私活通常都是一些偏业务的项目，很少会涉及到性能优化。这种情况下，你可以考虑对项目进行改进，别怕花时间，某个时间用心做好一件事情就好比如你对项目的数据模型进行改进、引入缓存提高访问速度等等。</p>\n<p>实习/工作接触到的项目类似，如果遇到一些偏业务的项目，也是要自己私下对项目进行改进优化。</p>\n<p>尽量是真的对项目进行了优化，这本身也是对个人能力的提升。如果你实在是没时间去实践的话，也没关系，吃透这个项目优化手段就好，把一些面试可能会遇到的问题提前准备一下。</p>\n<h2> 有没有还不错的项目推荐？</h2>\n<p><strong><a href=\"/zhuanlan/java-mian-shi-zhi-bei.html\" target=\"blank\">《Java 面试指北》</a></strong> 的「面试准备篇」中有一篇文章专门整理了一些比较高质量的实战项目，非常适合用来学习或者作为项目经验。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javamianshizhibei/project-experience-guide.png\" alt=\"\"></p>\n<p>这篇文章一共推荐了 15+ 个实战项目，有业务类的，也有轮子类的，有开源项目、也有视频教程。对于参加校招的小伙伴，我更建议做一个业务类项目加上一个轮子类的项目。</p>\n<h2> 我跟着视频做的项目会被面试官嫌弃不？</h2>\n<p>很多应届生都是跟着视频做的项目，这个大部分面试官都心知肚明。</p>\n<p>不排除确实有些面试官不吃这一套，这个也看人。不过我相信大多数面试官都是能理解的，毕竟你在学校的时候实际上是没有什么获得实际项目经验的途径的。</p>\n<p>大部分应届生的项目经验都是自己在网上找的或者像你一样买的付费课程跟着做的，极少部分是比较真实的项目。 从你能想着做一个实战项目来说，我觉得初衷是好的，确实也能真正学到东西。 但是，究竟有多少是自己掌握了很重要。看视频最忌讳的是被动接受，自己多改进一下，多思考一下！就算是你跟着视频做的项目，也是可以优化的！</p>\n<p><strong>如果你想真正学到东西的话，建议不光要把项目单纯完成跑起来，还要去自己尝试着优化！</strong></p>\n<p>简单说几个比较容易的优化点：</p>\n<ol>\n<li><strong>全局异常处理</strong> ：很多项目这方面都做的不是很好，可以参考我的这篇文章：<a href=\"https://mp.weixin.qq.com/s/Y4Q4yWRqKG_lw0GLUsY2qw\" target=\"_blank\" rel=\"noopener noreferrer\">《使用枚举简单封装一个优雅的 Spring Boot 全局异常处理！》</a> 来做优化。</li>\n<li><strong>项目的技术选型优化</strong> ：比如使用 Guava 做本地缓存的地方可以换成 <strong>Caffeine</strong> 。Caffeine 的各方面的表现要更加好！再比如 Controller 层是否放了太多的业务逻辑。</li>\n<li><strong>数据库方面</strong> ：数据库设计可否优化？索引是否使用使用正确？SQL 语句是否可以优化？是否需要进行读写分离？</li>\n<li><strong>缓存</strong> ：项目有没有哪些数据是经常被访问的？是否引入缓存来提高响应速度？</li>\n<li><strong>安全</strong> ： 项目是否存在安全问题？</li>\n<li>......</li>\n</ol>\n<p>另外，我在星球分享过常见的性能优化方向实践案例，涉及到多线程、异步、索引、缓存等方向，强烈推荐你看看：https://t.zsxq.com/06EqfeMZZ 。</p>\n<p>最后，<strong>再给大家推荐一个 IDEA 优化代码的小技巧，超级实用！</strong></p>\n<p>分析你的代码：右键项目-&gt; Analyze-&gt;Inspect Code</p>\n<p><img src=\"https://oscimg.oschina.net/oscnet/up-651672bce128025a135c1536cd5dc00532e.png\" alt=\"\"></p>\n<p>扫描完成之后，IDEA 会给出一些可能存在的代码坏味道比如命名问题。</p>\n<p><img src=\"https://oscimg.oschina.net/oscnet/up-05c83b319941995b07c8020fddc57f26037.png\" alt=\"\"></p>\n<p>并且，你还可以自定义检查规则。</p>\n<p><img src=\"https://oscimg.oschina.net/oscnet/up-6b618ad3bad0bc3f76e6066d90c8cd2f255.png\" alt=\"\"></p>\n",
      "image": "https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javamianshizhibei/mukewangzhiazhanke.png",
      "date_published": "2022-11-03T15:33:32.000Z",
      "date_modified": "2022-11-04T09:55:58.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "面试准备"
      ]
    },
    {
      "title": "Java 14 新特性概览",
      "url": "https://javaguide.cn/java/new-features/java14.html",
      "id": "https://javaguide.cn/java/new-features/java14.html",
      "summary": "空指针异常精准提示 通过 JVM 参数中添加-XX:+ShowCodeDetailsInExceptionMessages，可以在空指针异常中获取更为详细的调用信息，更快的定位和解决问题。 a.b.c.i = 99; // 假设这段代码会发生空指针",
      "content_html": "<h2> 空指针异常精准提示</h2>\n<p>通过 JVM 参数中添加<code>-XX:+ShowCodeDetailsInExceptionMessages</code>，可以在空指针异常中获取更为详细的调用信息，更快的定位和解决问题。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>Java 14 之前：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>Java 14 之后：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> switch 的增强(转正)</h2>\n<p>Java12 引入的 switch（预览特性）在 Java14 变为正式版本，不需要增加参数来启用，直接在 JDK14 中就能使用。</p>\n<p>Java12 为 switch 表达式引入了类似 lambda 语法条件匹配成功后的执行块，不需要多写 break ，Java13 提供了 <code>yield</code> 来在 block 中返回值。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 预览新特性</h2>\n<h3> record 关键字</h3>\n<p><code>record</code> 关键字可以简化 <strong>数据类</strong>（一个 Java 类一旦实例化就不能再修改）的定义方式，使用 <code>record</code> 代替 <code>class</code> 定义的类，只需要声明属性，就可以在获得属性的访问方法，以及 <code>toString()</code>，<code>hashCode()</code>, <code>equals()</code>方法</p>\n<p>类似于使用 <code>class</code> 定义类，同时使用了 lombok 插件，并打上了<code>@Getter,@ToString,@EqualsAndHashCode</code>注解</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 文本块</h3>\n<p>Java14 中，文本块依然是预览特性，不过，其引入了两个新的转义字符：</p>\n<ul>\n<li><code>\\</code> : 表示行尾，不引入换行符</li>\n<li><code>\\s</code> ：表示单个空格</li>\n</ul>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> instanceof 增强</h3>\n<p>依然是<strong>预览特性</strong> ，Java 12 新特性中介绍过。</p>\n<h2> Java14 其他特性</h2>\n<ul>\n<li>从 Java11 引入的 ZGC 作为继 G1 过后的下一代 GC 算法，从支持 Linux 平台到 Java14 开始支持 MacOS 和 Window（个人感觉是终于可以在日常开发工具中先体验下 ZGC 的效果了，虽然其实 G1 也够用）</li>\n<li>移除了 CMS(Concurrent Mark Sweep) 垃圾收集器（功成而退）</li>\n<li>新增了 jpackage 工具，标配将应用打成 jar 包外，还支持不同平台的特性包，比如 linux 下的<code>deb</code>和<code>rpm</code>，window 平台下的<code>msi</code>和<code>exe</code></li>\n</ul>\n",
      "date_published": "2022-09-28T12:35:46.000Z",
      "date_modified": "2022-09-28T12:35:46.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "Java 15 新特性概览",
      "url": "https://javaguide.cn/java/new-features/java15.html",
      "id": "https://javaguide.cn/java/new-features/java15.html",
      "summary": "CharSequence CharSequence 接口添加了一个默认方法 isEmpty() 来判断字符序列为空，如果是则返回 true。 public interface CharSequence { default boolean isEmpty() { return this.length() == 0; } }",
      "content_html": "<h2> CharSequence</h2>\n<p><code>CharSequence</code> 接口添加了一个默认方法 <code>isEmpty()</code> 来判断字符序列为空，如果是则返回 true。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> TreeMap</h2>\n<p><code>TreeMap</code> 新引入了下面这些方法：</p>\n<ul>\n<li><code>putIfAbsent()</code></li>\n<li><code>computeIfAbsent()</code></li>\n<li><code>computeIfPresent()</code></li>\n<li><code>compute()</code></li>\n<li><code>merge()</code></li>\n</ul>\n<h2> ZGC(转正)</h2>\n<p>Java11 的时候 ，ZGC 还在试验阶段。</p>\n<p>当时，ZGC 的出现让众多 Java 开发者看到了垃圾回收器的另外一种可能，因此备受关注。</p>\n<p>经过多个版本的迭代，不断的完善和修复问题，ZGC 在 Java 15 已经可以正式使用了！</p>\n<p>不过，默认的垃圾回收器依然是 G1。你可以通过下面的参数启动 ZGC：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> EdDSA(数字签名算法)</h2>\n<p>新加入了一个安全性和性能都更强的基于 Edwards-Curve Digital Signature Algorithm （EdDSA）实现的数字签名算法。</p>\n<p>虽然其性能优于现有的 ECDSA 实现，不过，它并不会完全取代 JDK 中现有的椭圆曲线数字签名算法( ECDSA)。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出：</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 文本块(转正)</h2>\n<p>在 Java 15 ，文本块是正式的功能特性了。</p>\n<h2> 隐藏类(Hidden Classes)</h2>\n<p>隐藏类是为框架（frameworks）所设计的，隐藏类不能直接被其他类的字节码使用，只能在运行时生成类并通过反射间接使用它们。</p>\n<h2> 预览新特性</h2>\n<h3> 密封类</h3>\n<p><strong>密封类（Sealed Classes）</strong> 是 Java 15 中的一个预览新特性。</p>\n<p>没有密封类之前，在 Java 中如果想让一个类不能被继承和修改，我们可以使用<code>final</code> 关键字对类进行修饰。不过，这种方式不太灵活，直接把一个类的继承和修改渠道给堵死了。</p>\n<p>密封类可以对继承或者实现它们的类进行限制，这样这个类就只能被指定的类继承。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>另外，任何扩展密封类的类本身都必须声明为 <code>sealed</code>、<code>non-sealed</code> 或 <code>final</code>。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/image-20210820153955587.png\" alt=\"\"></p>\n<p>如果允许扩展的子类和封闭类在同一个源代码文件里，封闭类可以不使用 permits 语句，Java 编译器将检索源文件，在编译期为封闭类添加上许可的子类。</p>\n<h3> instanceof 模式匹配</h3>\n<p>Java 15 并没有对此特性进行调整，继续预览特性，主要用于接受更多的使用反馈。</p>\n<p>在未来的 Java 版本中，Java 的目标是继续完善 <code>instanceof</code> 模式匹配新特性。</p>\n<h2> Java15 其他新特性</h2>\n<ul>\n<li><strong>Nashorn JavaScript 引擎彻底移除</strong> ：Nashorn 从 Java8 开始引入的 JavaScript 引擎，Java9 对 Nashorn 做了些增强，实现了一些 ES6 的新特性。在 Java 11 中就已经被弃用，到了 Java 15 就彻底被删除了。</li>\n<li><strong>DatagramSocket API 重构</strong></li>\n<li><strong>禁用和废弃偏向锁（Biased Locking）</strong> ： 偏向锁的引入增加了 JVM 的复杂性大于其带来的性能提升。不过，你仍然可以使用 <code>-XX:+UseBiasedLocking</code> 启用偏向锁定，但它会提示 这是一个已弃用的 API。</li>\n<li>......</li>\n</ul>\n<h2> 总结</h2>\n<h3> 关于预览特性</h3>\n<p>先贴一段 oracle 官网原文：<code>This is a preview feature, which is a feature whose design, specification, and implementation are complete, but is not permanent, which means that the feature may exist in a different form or not at all in future JDK releases. To compile and run code that contains preview features, you must specify additional command-line options.</code></p>\n<p>这是一个预览功能，该功能的设计，规格和实现是完整的，但不是永久性的，这意味着该功能可能以其他形式存在或在将来的 JDK 版本中根本不存在。 要编译和运行包含预览功能的代码，必须指定其他命令行选项。</p>\n<p>就以<code>switch</code>的增强为例子，从 Java12 中推出，到 Java13 中将继续增强，直到 Java14 才正式转正进入 JDK 可以放心使用，不用考虑后续 JDK 版本对其的改动或修改</p>\n<p>一方面可以看出 JDK 作为标准平台在增加新特性的严谨态度，另一方面个人认为是对于预览特性应该采取审慎使用的态度。特性的设计和实现容易，但是其实际价值依然需要在使用中去验证</p>\n<h3> JVM 虚拟机优化</h3>\n<p>每次 Java 版本的发布都伴随着对 JVM 虚拟机的优化，包括对现有垃圾回收算法的改进，引入新的垃圾回收算法，移除老旧的不再适用于今天的垃圾回收算法等</p>\n<p>整体优化的方向是<strong>高效，低时延的垃圾回收表现</strong></p>\n<p>对于日常的应用开发者可能比较关注新的语法特性，但是从一个公司角度来说，在考虑是否升级 Java 平台时更加考虑的是<strong>JVM 运行时的提升</strong></p>\n",
      "image": "https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/image-20210820153955587.png",
      "date_published": "2022-09-28T12:35:46.000Z",
      "date_modified": "2022-09-28T12:35:46.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "Java 17 新特性概览",
      "url": "https://javaguide.cn/java/new-features/java17.html",
      "id": "https://javaguide.cn/java/new-features/java17.html",
      "summary": "Java 17 在 2021 年 9 月 14 日正式发布，是一个长期支持（LTS）版本。 下面这张图是 Oracle 官方给出的 Oracle JDK 支持的时间线。可以看得到，Java 17 最多可以支持到 2029 年 9 月份。 Java 17 将是继 Java 8 以来最重要的长期支持（LTS）版本，是 Java 社区八年努力的成果。Spring 6.x 和 Spring Boot 3.x 最低支持的就是 Java 17。",
      "content_html": "<p>Java 17 在 2021 年 9 月 14 日正式发布，是一个长期支持（LTS）版本。</p>\n<p>下面这张图是 Oracle 官方给出的 Oracle JDK 支持的时间线。可以看得到，Java</p>\n<p>17 最多可以支持到 2029 年 9 月份。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/4c1611fad59449edbbd6e233690e9fa7.png\" alt=\"\"></p>\n<p>Java 17 将是继 Java 8 以来最重要的长期支持（LTS）版本，是 Java 社区八年努力的成果。Spring 6.x 和 Spring Boot 3.x 最低支持的就是 Java 17。</p>\n<p>这次更新共带来 14 个新特性：</p>\n<ul>\n<li><a href=\"https://openjdk.java.net/jeps/306\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 306:Restore Always-Strict Floating-Point Semantics（恢复始终严格的浮点语义）</a></li>\n<li><a href=\"https://openjdk.java.net/jeps/356\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 356:Enhanced Pseudo-Random Number Generators（增强的伪随机数生成器）</a></li>\n<li><a href=\"https://openjdk.java.net/jeps/382\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 382:New macOS Rendering Pipeline（新的 macOS 渲染管道）</a></li>\n<li><a href=\"https://openjdk.java.net/jeps/391\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 391:macOS/AArch64 Port（支持 macOS AArch64）</a></li>\n<li><a href=\"https://openjdk.java.net/jeps/398\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 398:Deprecate the Applet API for Removal（删除已弃用的 Applet API）</a></li>\n<li><a href=\"https://openjdk.java.net/jeps/403\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 403:Strongly Encapsulate JDK Internals（更强大的封装 JDK 内部元素）</a></li>\n<li><a href=\"https://openjdk.java.net/jeps/406\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 406:Pattern Matching for switch (switch 的类型匹配)</a>（预览）</li>\n<li><a href=\"https://openjdk.java.net/jeps/407\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 407:Remove RMI Activation（删除远程方法调用激活机制）</a></li>\n<li><a href=\"https://openjdk.java.net/jeps/409\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 409:Sealed Classes（密封类）</a>（转正）</li>\n<li><a href=\"https://openjdk.java.net/jeps/410\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 410:Remove the Experimental AOT and JIT Compiler（删除实验性的 AOT 和 JIT 编译器）</a></li>\n<li><a href=\"https://openjdk.java.net/jeps/411\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 411:Deprecate the Security Manager for Removal（弃用安全管理器以进行删除）</a></li>\n<li><a href=\"https://openjdk.java.net/jeps/412\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 412:Foreign Function &amp; Memory API (外部函数和内存 API)</a>（孵化）</li>\n<li><a href=\"https://openjdk.java.net/jeps/417\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 414:Vector（向量） API </a>（第二次孵化）</li>\n<li><a href=\"https://openjdk.java.net/jeps/415\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 415:Context-Specific Deserialization Filters</a></li>\n</ul>\n<p>这里只对 356、398、413、406、407、409、410、411、412、414 这几个我觉得比较重要的新特性进行详细介绍。</p>\n<p>相关阅读：<a href=\"https://openjdk.java.net/projects/jdk/17/\" target=\"_blank\" rel=\"noopener noreferrer\">OpenJDK Java 17 文档</a> 。</p>\n<h2> JEP 356:增强的伪随机数生成器</h2>\n<p>JDK 17 之前，我们可以借助 <code>Random</code>、<code>ThreadLocalRandom</code>和<code>SplittableRandom</code>来生成随机数。不过，这 3 个类都各有缺陷，且缺少常见的伪随机算法支持。</p>\n<p>Java 17 为伪随机数生成器 （pseudorandom number generator，RPNG，又称为确定性随机位生成器）增加了新的接口类型和实现，使得开发者更容易在应用程序中互换使用各种 PRNG 算法。</p>\n<blockquote>\n<p><a href=\"https://ctf-wiki.org/crypto/streamcipher/prng/intro/\" target=\"_blank\" rel=\"noopener noreferrer\">RPNG</a> 用来生成接近于绝对随机数序列的数字序列。一般来说，PRNG 会依赖于一个初始值，也称为种子，来生成对应的伪随机数序列。只要种子确定了，PRNG 所生成的随机数就是完全确定的，因此其生成的随机数序列并不是真正随机的。</p>\n</blockquote>\n<p>使用示例：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> JEP 398:弃用 Applet API 以进行删除</h2>\n<p>Applet API 用于编写在 Web 浏览器端运行的 Java 小程序，很多年前就已经被淘汰了，已经没有理由使用了。</p>\n<p>Applet API 在 Java 9 时被标记弃用（<a href=\"https://openjdk.java.net/jeps/289\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 289</a>），但不是为了删除。</p>\n<h2> JEP 406:switch 的类型匹配（预览）</h2>\n<p>正如 <code>instanceof</code> 一样， <code>switch</code> 也紧跟着增加了类型匹配自动转换功能。</p>\n<p><code>instanceof</code> 代码示例：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>switch</code> 代码示例：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>对于 <code>null</code> 值的判断也进行了优化。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> JEP 407:删除远程方法调用激活机制</h2>\n<p>删除远程方法调用 (RMI) 激活机制，同时保留 RMI 的其余部分。RMI 激活机制已过时且不再使用。</p>\n<h2> JEP 409：密封类（转正）</h2>\n<p>密封类由 <a href=\"https://openjdk.java.net/jeps/360\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 360</a> 提出预览，集成到了 Java 15 中。在 JDK 16 中， 密封类得到了改进（更加严格的引用检查和密封类的继承关系），由 <a href=\"https://openjdk.java.net/jeps/397\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 397</a> 提出了再次预览。</p>\n<p>在 <a href=\"/java/new-features/java15.html\" target=\"blank\">Java 15 新特性概览</a> 中，我有详细介绍到密封类，这里就不再做额外的介绍了。</p>\n<h2> JEP 410:删除实验性的 AOT 和 JIT 编译器</h2>\n<p>在 Java 9 的 <a href=\"https://openjdk.java.net/jeps/295\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 295</a> ,引入了实验性的提前 (AOT) 编译器，在启动虚拟机之前将 Java 类编译为本机代码。</p>\n<p>Java 17，删除实验性的提前 (AOT) 和即时 (JIT) 编译器，因为该编译器自推出以来很少使用，维护它所需的工作量很大。保留实验性的 Java 级 JVM 编译器接口 (JVMCI)，以便开发人员可以继续使用外部构建的编译器版本进行 JIT 编译。</p>\n<h2> JEP 411:弃用安全管理器以进行删除</h2>\n<p>弃用安全管理器以便在将来的版本中删除。</p>\n<p>安全管理器可追溯到 Java 1.0，多年来，它一直不是保护客户端 Java 代码的主要方法，也很少用于保护服务器端代码。为了推动 Java 向前发展，Java 17 弃用安全管理器，以便与旧版 Applet API ( <a href=\"https://openjdk.java.net/jeps/398\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 398</a> ) 一起移除。</p>\n<h2> JEP 412:外部函数和内存 API（孵化）</h2>\n<p>Java 程序可以通过该 API 与 Java 运行时之外的代码和数据进行互操作。通过高效地调用外部函数（即 JVM 之外的代码）和安全地访问外部内存（即不受 JVM 管理的内存），该 API 使 Java 程序能够调用本机库并处理本机数据，而不会像 JNI 那样危险和脆弱。</p>\n<p>外部函数和内存 API 在 Java 17 中进行了第一轮孵化，由 <a href=\"https://openjdk.java.net/jeps/412\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 412</a> 提出。第二轮孵化由<a href=\"https://openjdk.org/jeps/419\" target=\"_blank\" rel=\"noopener noreferrer\"> JEP 419</a> 提出并集成到了 Java 18 中，预览由 <a href=\"https://openjdk.org/jeps/424\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 424</a> 提出并集成到了 Java 19 中。</p>\n<p>在 <a href=\"/java/new-features/java19.html\" target=\"blank\">Java 19 新特性概览</a> 中，我有详细介绍到外部函数和内存 API，这里就不再做额外的介绍了。</p>\n<h2> JEP 414:向量 API（第二次孵化）</h2>\n<p>向量（Vector） API 最初由 <a href=\"https://openjdk.java.net/jeps/338\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 338</a> 提出，并作为<a href=\"http://openjdk.java.net/jeps/11\" target=\"_blank\" rel=\"noopener noreferrer\">孵化 API</a>集成到 Java 16 中。第二轮孵化由 <a href=\"https://openjdk.java.net/jeps/414\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 414</a> 提出并集成到 Java 17 中，第三轮孵化由 <a href=\"https://openjdk.java.net/jeps/417\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 417</a> 提出并集成到 Java 18 中，第四轮由 <a href=\"https://openjdk.java.net/jeps/426\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 426</a> 提出并集成到了 Java 19 中。</p>\n<p>该孵化器 API 提供了一个 API 的初始迭代以表达一些向量计算，这些计算在运行时可靠地编译为支持的 CPU 架构上的最佳向量硬件指令，从而获得优于同等标量计算的性能，充分利用单指令多数据（SIMD）技术（大多数现代 CPU 上都可以使用的一种指令）。尽管 HotSpot 支持自动向量化，但是可转换的标量操作集有限且易受代码更改的影响。该 API 将使开发人员能够轻松地用 Java 编写可移植的高性能向量算法。</p>\n<p>在 <a href=\"/java/new-features/java18.html\" target=\"blank\">Java 18 新特性概览</a> 中，我有详细介绍到向量 API，这里就不再做额外的介绍了。</p>\n",
      "image": "https://img-blog.csdnimg.cn/4c1611fad59449edbbd6e233690e9fa7.png",
      "date_published": "2022-09-28T12:35:46.000Z",
      "date_modified": "2022-12-03T03:14:20.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "Java 18 新特性概览",
      "url": "https://javaguide.cn/java/new-features/java18.html",
      "id": "https://javaguide.cn/java/new-features/java18.html",
      "summary": "Java 18 在 2022 年 3 月 22 日正式发布，非长期支持版本。 Java 18 带来了 9 个新特性： JEP 400:UTF-8 by Default（默认字符集为 UTF-8） JEP 408:Simple Web Server（简易的 Web 服务器） JEP 413:Code Snippets in Java API Documentation（Java API 文档中的代码片段） JEP 416:Reimplement Core Reflection with Method Handles（使用方法句柄重新实现反射核心） JEP 417:Vector（向量） API （第三次孵化） JEP 418:Internet-Address Resolution（互联网地址解析）SPI JEP 419:Foreign Function &amp; Memory API（外部函数和内存 API）（第二次孵化） JEP 420:Pattern Matching for switch（switch 模式匹配）（第二次预览） JEP 421:Deprecate Finalization for Removal",
      "content_html": "<p>Java 18 在 2022 年 3 月 22 日正式发布，非长期支持版本。</p>\n<p>Java 18 带来了 9 个新特性：</p>\n<ul>\n<li><a href=\"https://openjdk.java.net/jeps/400\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 400:UTF-8 by Default（默认字符集为 UTF-8）</a></li>\n<li><a href=\"https://openjdk.java.net/jeps/408\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 408:Simple Web Server（简易的 Web 服务器）</a></li>\n<li><a href=\"https://openjdk.java.net/jeps/413\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 413:Code Snippets in Java API Documentation（Java API 文档中的代码片段）</a></li>\n<li><a href=\"https://openjdk.java.net/jeps/416\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 416:Reimplement Core Reflection with Method Handles（使用方法句柄重新实现反射核心）</a></li>\n<li><a href=\"https://openjdk.java.net/jeps/417\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 417:Vector（向量） API </a>（第三次孵化）</li>\n<li><a href=\"https://openjdk.java.net/jeps/418\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 418:Internet-Address Resolution（互联网地址解析）SPI</a></li>\n<li><a href=\"https://openjdk.java.net/jeps/419\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 419:Foreign Function &amp; Memory API（外部函数和内存 API）</a>（第二次孵化）</li>\n<li><a href=\"https://openjdk.java.net/jeps/420\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 420:Pattern Matching for switch（switch 模式匹配）</a>（第二次预览）</li>\n<li><a href=\"https://openjdk.java.net/jeps/421\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 421:Deprecate Finalization for Removal</a></li>\n</ul>\n<p>Java 17 中包含 14 个特性，Java 16 中包含 17 个特性，Java 15 中包含 14 个特性，Java 14 中包含 16 个特性。相比于前面发布的版本来说，Java 18 的新特性少了很多。</p>\n<p>这里只对 400、408、413、416、417、418、419 这几个我觉得比较重要的新特性进行详细介绍。</p>\n<p>相关阅读：</p>\n<ul>\n<li><a href=\"https://openjdk.java.net/projects/jdk/18/\" target=\"_blank\" rel=\"noopener noreferrer\">OpenJDK Java 18 文档</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/PocFKR9z9u7-YCZHsrA5kQ\" target=\"_blank\" rel=\"noopener noreferrer\">IntelliJ IDEA | Java 18 功能支持</a></li>\n</ul>\n<h2> JEP 400:默认字符集为 UTF-8</h2>\n<p>JDK 终于将 UTF-8 设置为默认字符集。</p>\n<p>在 Java 17 及更早版本中，默认字符集是在 Java 虚拟机运行时才确定的，取决于不同的操作系统、区域设置等因素，因此存在潜在的风险。就比如说你在 Mac 上运行正常的一段打印文字到控制台的 Java 程序到了 Windows 上就会出现乱码，如果你不手动更改字符集的话。</p>\n<h2> JEP 408:简易的 Web 服务器</h2>\n<p>Java 18 之后，你可以使用 <code>jwebserver</code> 命令启动一个简易的静态 Web 服务器。</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这个服务器不支持 CGI 和 Servlet，只限于静态文件。</p>\n<h2> JEP 413:优化 Java API 文档中的代码片段</h2>\n<p>在 Java 18 之前，如果我们想要在 Javadoc 中引入代码片段可以使用 <code>&lt;pre&gt;{@code ...}&lt;/pre&gt;</code> 。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>&lt;pre&gt;{@code ...}&lt;/pre&gt;</code> 这种方式生成的效果比较一般。</p>\n<p>在 Java 18 之后，可以通过 <code>@snippet</code> 标签来做这件事情。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>@snippet</code> 这种方式生成的效果更好且使用起来更方便一些。</p>\n<h2> JEP 416:使用方法句柄重新实现反射核心</h2>\n<p>Java 18 改进了 <code>java.lang.reflect.Method</code>、<code>Constructor</code> 的实现逻辑，使之性能更好，速度更快。这项改动不会改动相关 API ，这意味着开发中不需要改动反射相关代码，就可以体验到性能更好反射。</p>\n<p>OpenJDK 官方给出了新老实现的反射性能基准测试结果。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/new-features/JEP416Benchmark.png\" alt=\"新老实现的反射性能基准测试结果\"></p>\n<h2> JEP 417: 向量 API（第三次孵化）</h2>\n<p>向量（Vector） API 最初由 <a href=\"https://openjdk.java.net/jeps/338\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 338</a> 提出，并作为<a href=\"http://openjdk.java.net/jeps/11\" target=\"_blank\" rel=\"noopener noreferrer\">孵化 API</a>集成到 Java 16 中。第二轮孵化由 <a href=\"https://openjdk.java.net/jeps/414\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 414</a> 提出并集成到 Java 17 中，第三轮孵化由 <a href=\"https://openjdk.java.net/jeps/417\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 417</a> 提出并集成到 Java 18 中，第四轮由 <a href=\"https://openjdk.java.net/jeps/426\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 426</a> 提出并集成到了 Java 19 中。</p>\n<p>向量计算由对向量的一系列操作组成。向量 API 用来表达向量计算，该计算可以在运行时可靠地编译为支持的 CPU 架构上的最佳向量指令，从而实现优于等效标量计算的性能。</p>\n<p>向量 API 的目标是为用户提供简洁易用且与平台无关的表达范围广泛的向量计算。</p>\n<p>这是对数组元素的简单标量计算：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这是使用 Vector API 进行的等效向量计算：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在 JDK 18 中，向量 API 的性能得到了进一步的优化。</p>\n<h2> JEP 418:互联网地址解析 SPI</h2>\n<p>Java 18 定义了一个全新的 SPI（service-provider interface），用于主要名称和地址的解析，以便 <code>java.net.InetAddress</code> 可以使用平台之外的第三方解析器。</p>\n<h2> JEP 419:Foreign Function &amp; Memory API（第二次孵化）</h2>\n<p>Java 程序可以通过该 API 与 Java 运行时之外的代码和数据进行互操作。通过高效地调用外部函数（即 JVM 之外的代码）和安全地访问外部内存（即不受 JVM 管理的内存），该 API 使 Java 程序能够调用本机库并处理本机数据，而不会像 JNI 那样危险和脆弱。</p>\n<p>外部函数和内存 API 在 Java 17 中进行了第一轮孵化，由 <a href=\"https://openjdk.java.net/jeps/412\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 412</a> 提出。第二轮孵化由<a href=\"https://openjdk.org/jeps/419\" target=\"_blank\" rel=\"noopener noreferrer\"> JEP 419</a> 提出并集成到了 Java 18 中，预览由 <a href=\"https://openjdk.org/jeps/424\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 424</a> 提出并集成到了 Java 19 中。</p>\n<p>在  <a href=\"/java/new-features/java19.html\" target=\"blank\">Java 19 新特性概览</a> 中，我有详细介绍到外部函数和内存 API，这里就不再做额外的介绍了。</p>\n",
      "image": "https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/new-features/JEP416Benchmark.png",
      "date_published": "2022-09-13T12:49:20.000Z",
      "date_modified": "2022-12-03T03:14:20.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "Java 19 新特性概览",
      "url": "https://javaguide.cn/java/new-features/java19.html",
      "id": "https://javaguide.cn/java/new-features/java19.html",
      "summary": "JDK 19 定于 9 月 20 日正式发布以供生产使用，非长期支持版本。不过，JDK 19 中有一些比较重要的新特性值得关注。 JDK 19 只有 7 个新特性： JEP 405: Record Patterns（记录模式）（预览） JEP 422: Linux/RISC-V Port JEP 424: Foreign Function &amp; Memory API（外部函数和内存 API）（预览） JEP 425: Virtual Threads（虚拟线程）（预览） JEP 426: Vector（向量）API（第四次孵化） JEP 427: Pattern Matching for switch（switch 模式匹配） JEP 428: Structured Concurrency（结构化并发）（孵化）",
      "content_html": "<p>JDK 19 定于 9 月 20 日正式发布以供生产使用，非长期支持版本。不过，JDK 19 中有一些比较重要的新特性值得关注。</p>\n<p>JDK 19 只有 7 个新特性：</p>\n<ul>\n<li><a href=\"https://openjdk.org/jeps/405\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 405: Record Patterns（记录模式）</a>（预览）</li>\n<li><a href=\"https://openjdk.org/jeps/422\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 422: Linux/RISC-V Port</a></li>\n<li><a href=\"https://openjdk.org/jeps/424\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 424: Foreign Function &amp; Memory API（外部函数和内存 API）</a>（预览）</li>\n<li><a href=\"https://openjdk.org/jeps/425\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 425: Virtual Threads（虚拟线程）</a>（预览）</li>\n<li><a href=\"https://openjdk.java.net/jeps/426\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 426: Vector（向量）API</a>（第四次孵化）</li>\n<li><a href=\"https://openjdk.java.net/jeps/427\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 427: Pattern Matching for switch（switch 模式匹配）</a></li>\n<li><a href=\"https://openjdk.org/jeps/428\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 428: Structured Concurrency（结构化并发）</a>（孵化）</li>\n</ul>\n<p>这里只对 424、425、426、428 这 4 个我觉得比较重要的新特性进行详细介绍。</p>\n<p>相关阅读：<a href=\"https://openjdk.org/projects/jdk/19/\" target=\"_blank\" rel=\"noopener noreferrer\">OpenJDK Java 19 文档</a></p>\n<h2> JEP 424: 外部函数和内存 API（预览）</h2>\n<p>Java 程序可以通过该 API 与 Java 运行时之外的代码和数据进行互操作。通过高效地调用外部函数（即 JVM 之外的代码）和安全地访问外部内存（即不受 JVM 管理的内存），该 API 使 Java 程序能够调用本机库并处理本机数据，而不会像 JNI 那样危险和脆弱。</p>\n<p>外部函数和内存 API 在 Java 17 中进行了第一轮孵化，由 <a href=\"https://openjdk.java.net/jeps/412\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 412</a> 提出。第二轮孵化由<a href=\"https://openjdk.org/jeps/419\" target=\"_blank\" rel=\"noopener noreferrer\"> JEP 419</a> 提出并集成到了 Java 18 中，预览由 <a href=\"https://openjdk.org/jeps/424\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 424</a> 提出并集成到了 Java 19 中。</p>\n<p>在没有外部函数和内存 API 之前：</p>\n<ul>\n<li>Java 通过 <a href=\"https://hg.openjdk.java.net/jdk/jdk/file/tip/src/jdk.unsupported/share/classes/sun/misc/Unsafe.java\" target=\"_blank\" rel=\"noopener noreferrer\"><code>sun.misc.Unsafe</code></a> 提供一些执行低级别、不安全操作的方法（如直接访问系统内存资源、自主管理内存资源等），<code>Unsafe</code> 类让 Java 语言拥有了类似 C 语言指针一样操作内存空间的能力的同时，也增加了 Java 语言的不安全性，不正确使用 <code>Unsafe</code> 类会使得程序出错的概率变大。</li>\n<li>Java 1.1 就已通过 Java 原生接口（JNI）支持了原生方法调用，但并不好用。JNI 实现起来过于复杂，步骤繁琐（具体的步骤可以参考这篇文章：<a href=\"https://www.baeldung.com/jni\" target=\"_blank\" rel=\"noopener noreferrer\">Guide to JNI (Java Native Interface)</a> ），不受 JVM 的语言安全机制控制，影响 Java 语言的跨平台特性。并且，JNI 的性能也不行，因为 JNI 方法调用不能从许多常见的 JIT 优化(如内联)中受益。虽然<a href=\"https://github.com/java-native-access/jna\" target=\"_blank\" rel=\"noopener noreferrer\">JNA</a>、<a href=\"https://github.com/jnr/jnr-ffi\" target=\"_blank\" rel=\"noopener noreferrer\">JNR</a>和<a href=\"https://github.com/bytedeco/javacpp\" target=\"_blank\" rel=\"noopener noreferrer\">JavaCPP</a>等框架对 JNI 进行了改进，但效果还是不太理想。</li>\n</ul>\n<p>引入外部函数和内存 API 就是为了解决 Java 访问外部函数和外部内存存在的一些痛点。</p>\n<p>Foreign Function &amp; Memory API (FFM API) 定义了类和接口：</p>\n<ul>\n<li>分配外部内存 ：<code>MemorySegment</code>、、<code>MemoryAddress</code>和<code>SegmentAllocator</code>）；</li>\n<li>操作和访问结构化的外部内存： <code>MemoryLayout</code>, <code>VarHandle</code>；</li>\n<li>控制外部内存的分配和释放：<code>MemorySession</code>；</li>\n<li>调用外部函数：<code>Linker</code>、<code>FunctionDescriptor</code>和<code>SymbolLookup</code>。</li>\n</ul>\n<p>下面是 FFM API 使用示例，这段代码获取了 C 库函数的 <code>radixsort</code> 方法句柄，然后使用它对 Java 数组中的四个字符串进行排序。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> JEP 425: 虚拟线程（预览）</h2>\n<p>虚拟线程（Virtual Thread-）是 JDK 而不是 OS 实现的轻量级线程(Lightweight Process，LWP），许多虚拟线程共享同一个操作系统线程，虚拟线程的数量可以远大于操作系统线程的数量。</p>\n<p>虚拟线程在其他多线程语言中已经被证实是十分有用的，比如 Go 中的 Goroutine、Erlang 中的进程。</p>\n<p>虚拟线程避免了上下文切换的额外耗费，兼顾了多线程的优点，简化了高并发程序的复杂，可以有效减少编写、维护和观察高吞吐量并发应用程序的工作量。</p>\n<p>知乎有一个关于 Java 19 虚拟线程的讨论，感兴趣的可以去看看：https://www.zhihu.com/question/536743167 。</p>\n<p>Java 虚拟线程的详细解读和原理可以看下面这两篇文章：</p>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/yyApBXxpXxVwttr01Hld6Q\" target=\"_blank\" rel=\"noopener noreferrer\">Java19 正式 GA！看虚拟线程如何大幅提高系统吞吐量</a></li>\n<li><a href=\"https://www.cnblogs.com/throwable/p/16758997.html\" target=\"_blank\" rel=\"noopener noreferrer\">虚拟线程 - VirtualThread源码透视</a></li>\n</ul>\n<h2> JEP 426: 向量 API（第四次孵化）</h2>\n<p>向量（Vector） API 最初由 <a href=\"https://openjdk.java.net/jeps/338\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 338</a> 提出，并作为<a href=\"http://openjdk.java.net/jeps/11\" target=\"_blank\" rel=\"noopener noreferrer\">孵化 API</a>集成到 Java 16 中。第二轮孵化由 <a href=\"https://openjdk.java.net/jeps/414\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 414</a> 提出并集成到 Java 17 中，第三轮孵化由 <a href=\"https://openjdk.java.net/jeps/417\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 417</a> 提出并集成到 Java 18 中，第四轮由 <a href=\"https://openjdk.java.net/jeps/426\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 426</a> 提出并集成到了 Java 19 中。</p>\n<p>在 <a href=\"/java/new-features/java18.html\" target=\"blank\">Java 18 新特性概览</a> 中，我有详细介绍到向量 API，这里就不再做额外的介绍了。</p>\n<h2> JEP 428: 结构化并发(孵化)</h2>\n<p>JDK 19 引入了结构化并发，一种多线程编程方法，目的是为了通过结构化并发 API 来简化多线程编程，并不是为了取代<code>java.util.concurrent</code>，目前处于孵化器阶段。</p>\n<p>结构化并发将不同线程中运行的多个任务视为单个工作单元，从而简化错误处理、提高可靠性并增强可观察性。也就是说，结构化并发保留了单线程代码的可读性、可维护性和可观察性。</p>\n<p>结构化并发的基本 API 是<a href=\"https://download.java.net/java/early_access/loom/docs/api/jdk.incubator.concurrent/jdk/incubator/concurrent/StructuredTaskScope.html\" target=\"_blank\" rel=\"noopener noreferrer\"><code>StructuredTaskScope</code></a>。<code>StructuredTaskScope</code> 支持将任务拆分为多个并发子任务，在它们自己的线程中执行，并且子任务必须在主任务继续之前完成。</p>\n<p><code>StructuredTaskScope</code> 的基本用法如下：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>结构化并发非常适合虚拟线程，虚拟线程是 JDK 实现的轻量级线程。许多虚拟线程共享同一个操作系统线程，从而允许非常多的虚拟线程。</p>\n",
      "date_published": "2022-09-13T01:11:51.000Z",
      "date_modified": "2022-10-15T01:13:48.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "ARP 协议详解(网络层)",
      "url": "https://javaguide.cn/cs-basics/network/arp.html",
      "id": "https://javaguide.cn/cs-basics/network/arp.html",
      "summary": "每当我们学习一个新的网络协议的时候，都要把他结合到 OSI 七层模型中，或者是 TCP/IP 协议栈中来学习，一是要学习该协议在整个网络协议栈中的位置，二是要学习该协议解决了什么问题，地位如何？三是要学习该协议的工作原理，以及一些更深入的细节。 ARP 协议，可以说是在协议栈中属于一个偏底层的、非常重要的、又非常简单的通信协议。 开始阅读这篇文章之前，你可以先看看下面几个问题： ARP 协议在协议栈中的位置？ ARP 协议在协议栈中的位置非常重要，在理解了它的工作原理之后，也很难说它到底是网络层协议，还是链路层协议，因为它恰恰串联起了网络层和链路层。国外的大部分教程通常将 ARP 协议放在网络层。 ARP 协议解决了什么问题，地位如何？ ARP 协议，全称 地址解析协议（Address Resolution Protocol），它解决的是网络层地址和链路层地址之间的转换问题。因为一个 IP 数据报在物理上传输的过程中，总是需要知道下一跳（物理上的下一个目的地）该去往何处，但 IP 地址属于逻辑地址，而 MAC 地址才是物理地址，ARP 协议解决了 IP 地址转 MAC 地址的一些问题。 ARP 工作原理？ 只希望大家记住几个关键词：ARP 表、广播问询、单播响应。",
      "content_html": "<p>每当我们学习一个新的网络协议的时候，都要把他结合到 OSI 七层模型中，或者是 TCP/IP 协议栈中来学习，一是要学习该协议在整个网络协议栈中的位置，二是要学习该协议解决了什么问题，地位如何？三是要学习该协议的工作原理，以及一些更深入的细节。</p>\n<p><strong>ARP 协议</strong>，可以说是在协议栈中属于一个<strong>偏底层的、非常重要的、又非常简单的</strong>通信协议。</p>\n<p>开始阅读这篇文章之前，你可以先看看下面几个问题：</p>\n<ol>\n<li><strong>ARP 协议在协议栈中的位置？</strong> ARP 协议在协议栈中的位置非常重要，在理解了它的工作原理之后，也很难说它到底是网络层协议，还是链路层协议，因为它恰恰串联起了网络层和链路层。国外的大部分教程通常将 ARP 协议放在网络层。</li>\n<li><strong>ARP 协议解决了什么问题，地位如何？</strong> ARP 协议，全称 <strong>地址解析协议（Address Resolution Protocol）</strong>，它解决的是网络层地址和链路层地址之间的转换问题。因为一个 IP 数据报在物理上传输的过程中，总是需要知道下一跳（物理上的下一个目的地）该去往何处，但 IP 地址属于逻辑地址，而 MAC 地址才是物理地址，ARP 协议解决了 IP 地址转 MAC 地址的一些问题。</li>\n<li><strong>ARP 工作原理？</strong> 只希望大家记住几个关键词：<strong>ARP 表、广播问询、单播响应</strong>。</li>\n</ol>\n<h2> MAC 地址</h2>\n<p>在介绍 ARP 协议之前，有必要介绍一下 MAC 地址。</p>\n<p>MAC 地址的全称是 <strong>媒体访问控制地址（Media Access Control Address）</strong>。如果说，互联网中每一个资源都由 IP 地址唯一标识（IP 协议内容），那么一切网络设备都由 MAC 地址唯一标识。</p>\n<p></p>\n<p>可以理解为，MAC 地址是一个网络设备真正的身份证号，IP 地址只是一种不重复的定位方式（比如说住在某省某市某街道的张三，这种逻辑定位是 IP 地址，他的身份证号才是他的 MAC 地址），也可以理解为 MAC 地址是身份证号，IP 地址是邮政地址。MAC 地址也有一些别称，如 LAN 地址、物理地址、以太网地址等。</p>\n<blockquote>\n<p>还有一点要知道的是，不仅仅是网络资源才有 IP 地址，网络设备也有 IP 地址，比如路由器。但从结构上说，路由器等网络设备的作用是组成一个网络，而且通常是内网，所以它们使用的 IP 地址通常是内网 IP，内网的设备在与内网以外的设备进行通信时，需要用到 NAT 协议。</p>\n</blockquote>\n<p>MAC 地址的长度为 6 字节（48 比特），地址空间大小有 280 万亿之多（$2^{48}$），MAC 地址由 IEEE 统一管理与分配，理论上，一个网络设备中的网卡上的 MAC 地址是永久的。不同的网卡生产商从 IEEE 那里购买自己的 MAC 地址空间（MAC 的前 24 比特），也就是前 24 比特由 IEEE 统一管理，保证不会重复。而后 24 比特，由各家生产商自己管理，同样保证生产的两块网卡的 MAC 地址不会重复。</p>\n<p>MAC 地址具有可携带性、永久性，身份证号永久地标识一个人的身份，不论他到哪里都不会改变。而 IP 地址不具有这些性质，当一台设备更换了网络，它的 IP 地址也就可能发生改变，也就是它在互联网中的定位发生了变化。</p>\n<p>最后，记住，MAC 地址有一个特殊地址：FF-FF-FF-FF-FF-FF（全 1 地址），该地址表示广播地址。</p>\n<h2> ARP 协议工作原理</h2>\n<p>ARP 协议工作时有一个大前提，那就是 <strong>ARP 表</strong>。</p>\n<p>在一个局域网内，每个网络设备都自己维护了一个 ARP 表，ARP 表记录了某些其他网络设备的 IP 地址-MAC 地址映射关系，该映射关系以 <code>&lt;IP, MAC, TTL&gt;</code> 三元组的形式存储。其中，TTL 为该映射关系的生存周期，典型值为 20 分钟，超过该时间，该条目将被丢弃。</p>\n<p>ARP 的工作原理将分两种场景讨论：</p>\n<ol>\n<li><strong>同一局域网内的 MAC 寻址</strong>；</li>\n<li><strong>从一个局域网到另一个局域网中的网络设备的寻址</strong>。</li>\n</ol>\n<h3> 同一局域网内的 MAC 寻址</h3>\n<p>假设当前有如下场景：IP 地址为<code>137.196.7.23</code>的主机 A，想要给同一局域网内的 IP 地址为<code>137.196.7.14</code>主机 B，发送 IP 数据报文。</p>\n<blockquote>\n<p>再次强调，当主机发送 IP 数据报文时（网络层），仅知道目的地的 IP 地址，并不清楚目的地的 MAC 地址，而 ARP 协议就是解决这一问题的。</p>\n</blockquote>\n<p>为了达成这一目标，主机 A 将不得不通过 ARP 协议来获取主机 B 的 MAC 地址，并将 IP 报文封装成链路层帧，发送到下一跳上。在该局域网内，关于此将按照时间顺序，依次发生如下事件：</p>\n<ol>\n<li>\n<p>主机 A 检索自己的 ARP 表，发现 ARP 表中并无主机 B 的 IP 地址对应的映射条目，也就无从知道主机 B 的 MAC 地址。</p>\n</li>\n<li>\n<p>主机 A 将构造一个 ARP 查询分组，并将其广播到所在的局域网中。</p>\n<p>ARP 分组是一种特殊报文，ARP 分组有两类，一种是查询分组，另一种是响应分组，它们具有相同的格式，均包含了发送和接收的 IP 地址、发送和接收的 MAC 地址。当然了，查询分组中，发送的 IP 地址，即为主机 A 的 IP 地址，接收的 IP 地址即为主机 B 的 IP 地址，发送的 MAC 地址也是主机 A 的 MAC 地址，但接收的 MAC 地址绝不会是主机 B 的 MAC 地址（因为这正是我们要问询的！），而是一个特殊值——<code>FF-FF-FF-FF-FF-FF</code>，之前说过，该 MAC 地址是广播地址，也就是说，查询分组将广播给该局域网内的所有设备。</p>\n</li>\n<li>\n<p>主机 A 构造的查询分组将在该局域网内广播，理论上，每一个设备都会收到该分组，并检查查询分组的接收 IP 地址是否为自己的 IP 地址，如果是，说明查询分组已经到达了主机 B，否则，该查询分组对当前设备无效，丢弃之。</p>\n</li>\n<li>\n<p>主机 B 收到了查询分组之后，验证是对自己的问询，接着构造一个 ARP 响应分组，该分组的目的地只有一个——主机 A，发送给主机 A。同时，主机 B 提取查询分组中的 IP 地址和 MAC 地址信息，在自己的 ARP 表中构造一条主机 A 的 IP-MAC 映射记录。</p>\n<p>ARP 响应分组具有和 ARP 查询分组相同的构造，不同的是，发送和接受的 IP 地址恰恰相反，发送的 MAC 地址为发送者本身，目标 MAC 地址为查询分组的发送者，也就是说，ARP 响应分组只有一个目的地，而非广播。</p>\n</li>\n<li>\n<p>主机 A 终将收到主机 B 的响应分组，提取出该分组中的 IP 地址和 MAC 地址后，构造映射信息，加入到自己的 ARP 表中。</p>\n</li>\n</ol>\n<p></p>\n<p>在整个过程中，有几点需要补充说明的是：</p>\n<ol>\n<li>主机 A 想要给主机 B 发送 IP 数据报，如果主机 B 的 IP-MAC 映射信息已经存在于主机 A 的 ARP 表中，那么主机 A 无需广播，只需提取 MAC 地址并构造链路层帧发送即可。</li>\n<li>ARP 表中的映射信息是有生存周期的，典型值为 20 分钟。</li>\n<li>目标主机接收到了问询主机构造的问询报文后，将先把问询主机的 IP-MAC 映射存进自己的 ARP 表中，这样才能获取到响应的目标 MAC 地址，顺利的发送响应分组。</li>\n</ol>\n<p>总结来说，ARP 协议是一个<strong>广播问询，单播响应</strong>协议。</p>\n<h3> 不同局域网内的 MAC 寻址</h3>\n<p>更复杂的情况是，发送主机 A 和接收主机 B 不在同一个子网中，假设一个一般场景，两台主机所在的子网由一台路由器联通。这里需要注意的是，一般情况下，我们说网络设备都有一个 IP 地址和一个 MAC 地址，这里说的网络设备，更严谨的说法应该是一个接口。路由器作为互联设备，具有多个接口，每个接口同样也应该具备不重复的 IP 地址和 MAC 地址。因此，在讨论 ARP 表时，路由器的多个接口都各自维护一个 ARP 表，而非一个路由器只维护一个 ARP 表。</p>\n<p>接下来，回顾同一子网内的 MAC 寻址，如果主机 A 发送一个广播问询分组，那么 A 所在子网内的所有设备（接口）都将不会捕获该分组，因为该分组的目的 IP 地址在另一个子网中，本子网内不会有设备成功接收。那么，主机 A 应该发送怎样的查询分组呢？整个过程按照时间顺序发生的事件如下：</p>\n<ol>\n<li>\n<p>主机 A 查询 ARP 表，期望寻找到目标路由器的本子网接口的 MAC 地址。</p>\n<p>目标路由器指的是，根据目的主机 B 的 IP 地址，分析出 B 所在的子网，能够把报文转发到 B 所在子网的那个路由器。</p>\n</li>\n<li>\n<p>主机 A 未能找到目标路由器的本子网接口的 MAC 地址，将采用 ARP 协议，问询到该 MAC 地址，由于目标接口与主机 A 在同一个子网内，该过程与同一局域网内的 MAC 寻址相同。</p>\n</li>\n<li>\n<p>主机 A 获取到目标接口的 MAC 地址，先构造 IP 数据报，其中源 IP 是 A 的 IP 地址，目的 IP 地址是 B 的 IP 地址，再构造链路层帧，其中源 MAC 地址是 A 的 MAC 地址，目的 MAC 地址是<strong>本子网内与路由器连接的接口的 MAC 地址</strong>。主机 A 将把这个链路层帧，以单播的方式，发送给目标接口。</p>\n</li>\n<li>\n<p>目标接口接收到了主机 A 发过来的链路层帧，解析，根据目的 IP 地址，查询转发表，将该 IP 数据报转发到与主机 B 所在子网相连的接口上。</p>\n<p>到此，该帧已经从主机 A 所在的子网，转移到了主机 B 所在的子网了。</p>\n</li>\n<li>\n<p>路由器接口查询 ARP 表，期望寻找到主机 B 的 MAC 地址。</p>\n</li>\n<li>\n<p>路由器接口如未能找到主机 B 的 MAC 地址，将采用 ARP 协议，广播问询，单播响应，获取到主机 B 的 MAC 地址。</p>\n</li>\n<li>\n<p>路由器接口将对 IP 数据报重新封装成链路层帧，目标 MAC 地址为主机 B 的 MAC 地址，单播发送，直到目的地。</p>\n</li>\n</ol>\n<p></p>\n",
      "date_published": "2022-08-28T07:18:49.000Z",
      "date_modified": "2023-02-14T08:37:37.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "计算机基础"
      ]
    },
    {
      "title": "分布式锁详解",
      "url": "https://javaguide.cn/distributed-system/distributed-lock.html",
      "id": "https://javaguide.cn/distributed-system/distributed-lock.html",
      "summary": "网上有很多分布式锁相关的文章，写了一个相对简洁易懂的版本，针对面试和工作应该够用了。 分布式锁介绍 对于单机多线程来说，在 Java 中，我们通常使用 ReetrantLock 类、synchronized 关键字这类 JDK 自带的 本地锁 来控制一个 JVM 进程内的多个线程对本地共享资源的访问。 下面是我对本地锁画的一张示意图。 从图中可以看出，这些线程访问共享资源是互斥的，同一时刻只有一个线程可以获取到本地锁访问共享资源。",
      "content_html": "<p>网上有很多分布式锁相关的文章，写了一个相对简洁易懂的版本，针对面试和工作应该够用了。</p>\n<h2> 分布式锁介绍</h2>\n<p>对于单机多线程来说，在 Java 中，我们通常使用 <code>ReetrantLock</code> 类、<code>synchronized</code> 关键字这类 JDK 自带的 <strong>本地锁</strong> 来控制一个 JVM 进程内的多个线程对本地共享资源的访问。</p>\n<p>下面是我对本地锁画的一张示意图。</p>\n<p></p>\n<p>从图中可以看出，这些线程访问共享资源是互斥的，同一时刻只有一个线程可以获取到本地锁访问共享资源。</p>\n<p>分布式系统下，不同的服务/客户端通常运行在独立的 JVM 进程上。如果多个 JVM 进程共享同一份资源的话，使用本地锁就没办法实现资源的互斥访问了。于是，<strong>分布式锁</strong> 就诞生了。</p>\n<p>举个例子：系统的订单服务一共部署了 3 份，都对外提供服务。用户下订单之前需要检查库存，为了防止超卖，这里需要加锁以实现对检查库存操作的同步访问。由于订单服务位于不同的 JVM 进程中，本地锁在这种情况下就没办法正常工作了。我们需要用到分布式锁，这样的话，即使多个线程不在同一个 JVM 进程中也能获取到同一把锁，进而实现共享资源的互斥访问。</p>\n<p>下面是我对分布式锁画的一张示意图。</p>\n<p></p>\n<p>从图中可以看出，这些独立的进程中的线程访问共享资源是互斥的，同一时刻只有一个线程可以获取到分布式锁访问共享资源。</p>\n<p>一个最基本的分布式锁需要满足：</p>\n<ul>\n<li><strong>互斥</strong> ：任意一个时刻，锁只能被一个线程持有；</li>\n<li><strong>高可用</strong> ：锁服务是高可用的。并且，即使客户端的释放锁的代码逻辑出现问题，锁最终一定还是会被释放，不会影响其他线程对共享资源的访问。</li>\n<li><strong>可重入</strong>：一个节点获取了锁之后，还可以再次获取锁。</li>\n</ul>\n<p>通常情况下，我们一般会选择基于 Redis 或者 ZooKeeper 实现分布式锁，Redis 用的要更多一点，我这里也以 Redis 为例介绍分布式锁的实现。</p>\n<h2> 基于 Redis 实现分布式锁</h2>\n<h3> 如何基于 Redis 实现一个最简易的分布式锁？</h3>\n<p>不论是本地锁还是分布式锁，核心都在于“互斥”。</p>\n<p>在 Redis 中， <code>SETNX</code> 命令是可以帮助我们实现互斥。<code>SETNX</code> 即 <strong>SET</strong> if <strong>N</strong>ot e<strong>X</strong>ists (对应 Java 中的 <code>setIfAbsent</code> 方法)，如果 key 不存在的话，才会设置 key 的值。如果 key 已经存在， <code>SETNX</code> 啥也不做。</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>释放锁的话，直接通过 <code>DEL</code> 命令删除对应的 key 即可。</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>为了防止误删到其他的锁，这里我们建议使用 Lua 脚本通过 key 对应的 value（唯一值）来判断。</p>\n<p>选用 Lua 脚本是为了保证解锁操作的原子性。因为 Redis 在执行 Lua 脚本时，可以以原子性的方式执行，从而保证了锁释放操作的原子性。</p>\n<div class=\"language-lua line-numbers-mode\" data-ext=\"lua\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p></p>\n<p>这是一种最简易的 Redis 分布式锁实现，实现方式比较简单，性能也很高效。不过，这种方式实现分布式锁存在一些问题。就比如应用程序遇到一些问题比如释放锁的逻辑突然挂掉，可能会导致锁无法被释放，进而造成共享资源无法再被其他线程/进程访问。</p>\n<h3> 为什么要给锁设置一个过期时间？</h3>\n<p>为了避免锁无法被释放，我们可以想到的一个解决办法就是： <strong>给这个 key（也就是锁） 设置一个过期时间</strong> 。</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li><strong>lockKey</strong> ：加锁的锁名；</li>\n<li><strong>uniqueValue</strong> ：能够唯一标示锁的随机字符串；</li>\n<li><strong>NX</strong> ：只有当 lockKey 对应的 key 值不存在的时候才能 SET 成功；</li>\n<li><strong>EX</strong> ：过期时间设置（秒为单位）EX 3 标示这个锁有一个 3 秒的自动过期时间。与 EX 对应的是 PX（毫秒为单位），这两个都是过期时间设置。</li>\n</ul>\n<p><strong>一定要保证设置指定 key 的值和过期时间是一个原子操作！！！</strong> 不然的话，依然可能会出现锁无法被释放的问题。</p>\n<p>这样确实可以解决问题，不过，这种解决办法同样存在漏洞：<strong>如果操作共享资源的时间大于过期时间，就会出现锁提前过期的问题，进而导致分布式锁直接失效。如果锁的超时时间设置过长，又会影响到性能。</strong></p>\n<p>你或许在想： <strong>如果操作共享资源的操作还未完成，锁过期时间能够自己续期就好了！</strong></p>\n<h3> 如何实现锁的优雅续期？</h3>\n<p>对于 Java 开发的小伙伴来说，已经有了现成的解决方案：<strong><a href=\"https://github.com/redisson/redisson\" target=\"_blank\" rel=\"noopener noreferrer\">Redisson</a></strong> 。其他语言的解决方案，可以在 Redis 官方文档中找到，地址：https://redis.io/topics/distlock 。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/redis-distributed-lock.png\" alt=\"Distributed locks with Redis\"></p>\n<p>Redisson 是一个开源的 Java 语言 Redis 客户端，提供了很多开箱即用的功能，不仅仅包括多种分布式锁的实现。并且，Redisson 还支持 Redis 单机、Redis Sentinel 、Redis Cluster 等多种部署架构。</p>\n<p>Redisson 中的分布式锁自带自动续期机制，使用起来非常简单，原理也比较简单，其提供了一个专门用来监控和续期锁的 <strong>Watch Dog（ 看门狗）</strong>，如果操作共享资源的线程还未执行完成的话，Watch Dog 会不断地延长锁的过期时间，进而保证锁不会因为超时而被释放。</p>\n<p></p>\n<p>看门狗名字的由来于 <code>getLockWatchdogTimeout()</code> 方法，这个方法返回的是看门狗给锁续期的过期时间，默认为 30 秒（<a href=\"https://github.com/redisson/redisson/releases/tag/redisson-3.17.6\" target=\"_blank\" rel=\"noopener noreferrer\">redisson-3.17.6</a>）。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>renewExpiration()</code> 方法包含了看门狗的主要逻辑：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>默认情况下，每过 10 秒，看门狗就会执行续期操作，将锁的超时时间设置为 30 秒。看门狗续期前也会先判断是否需要执行续期操作，需要才会执行续期，否则取消续期操作。</p>\n<p>Watch Dog 通过调用 <code>renewExpirationAsync()</code> 方法实现锁的异步续期：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>可以看出， <code>renewExpirationAsync</code> 方法其实是调用 Lua 脚本实现的续期，这样做主要是为了保证续期操作的原子性。</p>\n<p>我这里以 Redisson 的分布式可重入锁 <code>RLock</code> 为例来说明如何使用 Redisson 实现分布式锁：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>只有未指定锁超时时间，才会使用到 Watch Dog 自动续期机制。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果使用 Redis 来实现分布式锁的话，还是比较推荐直接基于 Redisson 来做的。</p>\n<h3> 如何实现可重入锁？</h3>\n<p>所谓可重入锁指的是在一个线程中可以多次获取同一把锁，比如一个线程在执行一个带锁的方法，该方法中又调用了另一个需要相同锁的方法，则该线程可以直接执行调用的方法即可重入 ，而无需重新获得锁。像 Java 中的 <code>synchronized</code> 和 <code>ReentrantLock</code> 都属于可重入锁。</p>\n<p><strong>不可重入的分布式锁基本可以满足绝大部分业务场景了，一些特殊的场景可能会需要使用可重入的分布式锁。</strong></p>\n<p>可重入分布式锁的实现核心思路是线程在获取锁的时候判断是否为自己的锁，如果是的话，就不用再重新获取了。为此，我们可以为每个锁关联一个可重入计数器和一个占有它的线程。当可重入计数器大于 0 时，则锁被占有，需要判断占有该锁的线程和请求获取锁的线程是否为同一个。</p>\n<p>实际项目中，我们不需要自己手动实现，推荐使用我们上面提到的 <strong>Redisson</strong> ，其内置了多种类型的锁比如可重入锁（Reentrant Lock）、自旋锁（Spin Lock）、公平锁（Fair Lock）、多重锁（MultiLock）、 红锁（RedLock）、 读写锁（ReadWriteLock）。</p>\n<p></p>\n<h3> Redis 如何解决集群情况下分布式锁的可靠性？</h3>\n<p>为了避免单点故障，生产环境下的 Redis 服务通常是集群化部署的。</p>\n<p>Redis 集群下，上面介绍到的分布式锁的实现会存在一些问题。由于 Redis 集群数据同步到各个节点时是异步的，如果在 Redis 主节点获取到锁后，在没有同步到其他节点时，Redis 主节点宕机了，此时新的 Redis 主节点依然可以获取锁，所以多个应用服务就可以同时获取到锁。</p>\n<p></p>\n<p>针对这个问题，Redis 之父 antirez 设计了 <a href=\"https://redis.io/topics/distlock\" target=\"_blank\" rel=\"noopener noreferrer\">Redlock 算法</a> 来解决。</p>\n<p></p>\n<p>Redlock 算法的思想是让客户端向 Redis 集群中的多个独立的 Redis 实例依次请求申请加锁，如果客户端能够和半数以上的实例成功地完成加锁操作，那么我们就认为，客户端成功地获得分布式锁，否则加锁失败。</p>\n<p>即使部分 Redis 节点出现问题，只要保证 Redis 集群中有半数以上的 Redis 节点可用，分布式锁服务就是正常的。</p>\n<p>Redlock 是直接操作 Redis 节点的，并不是通过 Redis 集群操作的，这样才可以避免 Redis 集群主从切换导致的锁丢失问题。</p>\n<p>Redlock 实现比较复杂，性能比较差，发生时钟变迁的情况下还存在安全性隐患。《数据密集型应用系统设计》一书的作者 Martin Kleppmann 曾经专门发文（<a href=\"https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html\" target=\"_blank\" rel=\"noopener noreferrer\">How to do distributed locking - Martin Kleppmann - 2016</a>）怼过 Redlock，他认为这是一个很差的分布式锁实现。感兴趣的朋友可以看看<a href=\"https://mp.weixin.qq.com/s?__biz=Mzg3NjU3NTkwMQ==&amp;mid=2247505097&amp;idx=1&amp;sn=5c03cb769c4458350f4d4a321ad51f5a&amp;source=41#wechat_redirect\" target=\"_blank\" rel=\"noopener noreferrer\">Redis 锁从面试连环炮聊到神仙打架</a>这篇文章，有详细介绍到 antirez 和 Martin Kleppmann 关于 Redlock 的激烈辩论。</p>\n<p>实际项目中不建议使用 Redlock 算法，成本和收益不成正比。</p>\n<p>如果不是非要实现绝对可靠的分布式锁的话，其实单机版 Redis 就完全够了，实现简单，性能也非常高。如果你必须要实现一个绝对可靠的分布式锁的话，可以基于 ZooKeeper 来做，只是性能会差一些。</p>\n<h2> 基于 ZooKeeper 实现分布式锁</h2>\n<p>Redis 实现分布式锁性能较高，ZooKeeper 实现分布式锁可靠性更高。实际项目中，我们应该根据业务的具体需求来选择。</p>\n<h3> 如何基于 ZooKeeper 实现分布式锁？</h3>\n<p>ZooKeeper 分布式锁是基于 <strong>临时顺序节点</strong> 和 <strong>Watcher（事件监听器）</strong> 实现的。</p>\n<p>获取锁：</p>\n<ol>\n<li>首先我们要有一个持久节点<code>/locks</code>，客户端获取锁就是在<code>locks</code>下创建临时顺序节点。</li>\n<li>假设客户端 1 创建了<code>/locks/lock1</code>节点，创建成功之后，会判断 <code>lock1</code>是否是 <code>/locks</code> 下最小的子节点。</li>\n<li>如果 <code>lock1</code>是最小的子节点，则获取锁成功。否则，获取锁失败。</li>\n<li>如果获取锁失败，则说明有其他的客户端已经成功获取锁。客户端 1 并不会不停地循环去尝试加锁，而是在前一个节点比如<code>/locks/lock0</code>上注册一个事件监听器。这个监听器的作用是当前一个节点释放锁之后通知客户端 1（避免无效自旋），这样客户端 1 就加锁成功了。</li>\n</ol>\n<p>释放锁：</p>\n<ol>\n<li>成功获取锁的客户端在执行完业务流程之后，会将对应的子节点删除。</li>\n<li>成功获取锁的客户端在出现故障之后，对应的子节点由于是临时顺序节点，也会被自动删除，避免了锁无法被释放。</li>\n<li>我们前面说的事件监听器其实监听的就是这个子节点删除事件，子节点删除就意味着锁被释放。</li>\n</ol>\n<p></p>\n<p>实际项目中，推荐使用 Curator 来实现 ZooKeeper 分布式锁。Curator 是 Netflix 公司开源的一套 ZooKeeper Java 客户端框架，相比于 ZooKeeper 自带的客户端 zookeeper 来说，Curator 的封装更加完善，各种 API 都可以比较方便地使用。</p>\n<p><code>Curator</code>主要实现了下面四种锁：</p>\n<ul>\n<li><code>InterProcessMutex</code>：分布式可重入排它锁</li>\n<li><code>InterProcessSemaphoreMutex</code>：分布式不可重入排它锁</li>\n<li><code>InterProcessReadWriteLock</code>：分布式读写锁</li>\n<li><code>InterProcessMultiLock</code>：将多个锁作为单个实体管理的容器，获取锁的时候获取所有锁，释放锁也会释放所有锁资源（忽略释放失败的锁）。</li>\n</ul>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 为什么要用临时顺序节点？</h3>\n<p>每个数据节点在 ZooKeeper 中被称为 <strong>znode</strong>，它是 ZooKeeper 中数据的最小单元。</p>\n<p>我们通常是将 znode 分为 4 大类：</p>\n<ul>\n<li><strong>持久（PERSISTENT）节点</strong> ：一旦创建就一直存在即使 ZooKeeper 集群宕机，直到将其删除。</li>\n<li><strong>临时（EPHEMERAL）节点</strong> ：临时节点的生命周期是与 <strong>客户端会话（session）</strong> 绑定的，<strong>会话消失则节点消失</strong> 。并且，<strong>临时节点只能做叶子节点</strong> ，不能创建子节点。</li>\n<li><strong>持久顺序（PERSISTENT_SEQUENTIAL）节点</strong> ：除了具有持久（PERSISTENT）节点的特性之外， 子节点的名称还具有顺序性。比如 <code>/node1/app0000000001</code> 、<code>/node1/app0000000002</code> 。</li>\n<li><strong>临时顺序（EPHEMERAL_SEQUENTIAL）节点</strong> ：除了具备临时（EPHEMERAL）节点的特性之外，子节点的名称还具有顺序性。</li>\n</ul>\n<p>可以看出，临时节点相比持久节点，最主要的是对会话失效的情况处理不一样，临时节点会话消失则对应的节点消失。这样的话，如果客户端发生异常导致没来得及释放锁也没关系，会话失效节点自动被删除，不会发生死锁的问题。</p>\n<p>使用 Redis 实现分布式锁的时候，我们是通过过期时间来避免锁无法被释放导致死锁问题的，而 ZooKeeper 直接利用临时节点的特性即可。</p>\n<p>假设不适用顺序节点的话，所有尝试获取锁的客户端都会对持有锁的子节点加监听器。当该锁被释放之后，势必会造成所有尝试获取锁的客户端来争夺锁，这样对性能不友好。使用顺序节点之后，只需要监听前一个节点就好了，对性能更友好。</p>\n<h3> 为什么要设置对前一个节点的监听？</h3>\n<blockquote>\n<p>Watcher（事件监听器），是 ZooKeeper 中的一个很重要的特性。ZooKeeper 允许用户在指定节点上注册一些 Watcher，并且在一些特定事件触发的时候，ZooKeeper 服务端会将事件通知到感兴趣的客户端上去，该机制是 ZooKeeper 实现分布式协调服务的重要特性。</p>\n</blockquote>\n<p>同一时间段内，可能会有很多客户端同时获取锁，但只有一个可以获取成功。如果获取锁失败，则说明有其他的客户端已经成功获取锁。获取锁失败的客户端并不会不停地循环去尝试加锁，而是在前一个节点注册一个事件监听器。</p>\n<p>这个事件监听器的作用是： <strong>当前一个节点对应的客户端释放锁之后（也就是前一个节点被删除之后，监听的是删除事件），通知获取锁失败的客户端（唤醒等待的线程，Java 中的 <code>wait/notifyAll</code> ），让它尝试去获取锁，然后就成功获取锁了。</strong></p>\n<h3> 如何实现可重入锁？</h3>\n<p>这里以 Curator 的 <code>InterProcessMutex</code> 对可重入锁的实现来介绍（源码地址：<a href=\"https://github.com/apache/curator/blob/master/curator-recipes/src/main/java/org/apache/curator/framework/recipes/locks/InterProcessMutex.java\" target=\"_blank\" rel=\"noopener noreferrer\">InterProcessMutex.java</a>）。</p>\n<p>当我们调用 <code>InterProcessMutex#acquire</code>方法获取锁的时候，会调用<code>InterProcessMutex#internalLock</code>方法。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>internalLock</code> 方法会先获取当前请求锁的线程，然后从 <code>threadData</code>( <code>ConcurrentMap&lt;Thread, LockData&gt;</code> 类型)中获取当前线程对应的 <code>lockData</code> 。 <code>lockData</code> 包含锁的信息和加锁的次数，是实现可重入锁的关键。</p>\n<p>第一次获取锁的时候，<code>lockData</code>为 <code>null</code>。获取锁成功之后，会将当前线程和对应的 <code>lockData</code> 放到 <code>threadData</code> 中</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>LockData</code>是 <code>InterProcessMutex</code>中的一个静态内部类。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果已经获取过一次锁，后面再来获取锁的话，直接就会在 <code>if (lockData != null)</code> 这里被拦下了，然后就会执行<code>lockData.lockCount.incrementAndGet();</code> 将加锁次数加 1。</p>\n<p>整个可重入锁的实现逻辑非常简单，直接在客户端判断当前线程有没有获取锁，有的话直接将加锁次数加 1 就可以了。</p>\n<h2> 总结</h2>\n<p>这篇文章我们介绍了分布式锁的基本概念以及实现分布式锁的两种常见方式。至于具体选择 Redis 还是 ZooKeeper 来实现分布式锁，还是要看业务的具体需求。如果对性能要求比较高的话，建议使用 Redis 实现分布式锁。如果对可靠性要求比较高的话，建议使用 ZooKeeper 实现分布式锁。</p>\n",
      "date_published": "2022-08-23T10:53:21.000Z",
      "date_modified": "2023-03-04T12:00:03.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "分布式"
      ]
    },
    {
      "title": "CDN（内容分发网络）详解",
      "url": "https://javaguide.cn/high-performance/cdn.html",
      "id": "https://javaguide.cn/high-performance/cdn.html",
      "summary": "什么是 CDN ？ CDN 全称是 Content Delivery Network/Content Distribution Network，翻译过的意思是 内容分发网络 。 我们可以将内容分发网络拆开来看： 内容 ：指的是静态资源比如图片、视频、文档、JS、CSS、HTML。 分发网络 ：指的是将这些静态资源分发到位于多个不同的地理位置机房中的服务器上，这样，就可以实现静态资源的就近访问比如北京的用户直接访问北京机房的数据。",
      "content_html": "<h2> 什么是 CDN ？</h2>\n<p><strong>CDN</strong> 全称是 Content Delivery Network/Content Distribution Network，翻译过的意思是 <strong>内容分发网络</strong> 。</p>\n<p>我们可以将内容分发网络拆开来看：</p>\n<ul>\n<li>内容 ：指的是静态资源比如图片、视频、文档、JS、CSS、HTML。</li>\n<li>分发网络 ：指的是将这些静态资源分发到位于多个不同的地理位置机房中的服务器上，这样，就可以实现静态资源的就近访问比如北京的用户直接访问北京机房的数据。</li>\n</ul>\n<p>所以，简单来说，<strong>CDN 就是将静态资源分发到多个不同的地方以实现就近访问，进而加快静态资源的访问速度，减轻服务器以及带宽的负担。</strong></p>\n<p>类似于京东建立的庞大的仓储运输体系，京东物流在全国拥有非常多的仓库，仓储网络几乎覆盖全国所有区县。这样的话，用户下单的第一时间，商品就从距离用户最近的仓库，直接发往对应的配送站，再由京东小哥送到你家。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/high-performance/cdn/jingdong-wuliu-cangpei.png\" alt=\"京东仓配系统\"></p>\n<p>你可以将 CDN 看作是服务上一层的特殊缓存服务，分布在全国各地，主要用来处理静态资源的请求。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/high-performance/cdn/cdn-101.png\" alt=\"CDN 简易示意图\"></p>\n<p>我们经常拿全站加速和内容分发网络做对比，不要把两者搞混了！全站加速（不同云服务商叫法不同，腾讯云叫 ECDN、阿里云叫 DCDN）既可以加速静态资源又可以加速动态资源，内容分发网络（CDN）主要针对的是 <strong>静态资源</strong> 。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/high-performance/cdn/cdn-aliyun-dcdn.png\" alt=\"阿里云文档：https://help.aliyun.com/document_detail/64836.html\"></p>\n<p>绝大部分公司都会在项目开发中交使用 CDN 服务，但很少会有自建 CDN 服务的公司。基于成本、稳定性和易用性考虑，建议直接选择专业的云厂商（比如阿里云、腾讯云、华为云、青云）或者 CDN 厂商（比如网宿、蓝汛）提供的开箱即用的 CDN 服务。</p>\n<p>很多朋友可能要问了：<strong>既然是就近访问，为什么不直接将服务部署在多个不同的地方呢？</strong></p>\n<ul>\n<li>成本太高，需要部署多份相同的服务。</li>\n<li>静态资源通常占用空间比较大且经常会被访问到，如果直接使用服务器或者缓存来处理静态资源请求的话，对系统资源消耗非常大，可能会影响到系统其他服务的正常运行。</li>\n</ul>\n<p>同一个服务在在多个不同的地方部署多份（比如同城灾备、异地灾备、同城多活、异地多活）是为了实现系统的高可用而不是就近访问。</p>\n<h2> CDN 工作原理是什么？</h2>\n<p>搞懂下面 3 个问题也就搞懂了 CDN 的工作原理：</p>\n<ol>\n<li>静态资源是如何被缓存到 CDN 节点中的？</li>\n<li>如何找到最合适的 CDN 节点？</li>\n<li>如何防止静态资源被盗用？</li>\n</ol>\n<h3> 静态资源是如何被缓存到 CDN 节点中的？</h3>\n<p>你可以通过预热的方式将源站的资源同步到 CDN 的节点中。这样的话，用户首次请求资源可以直接从 CDN 节点中取，无需回源。这样可以降低源站压力，提升用户体验。</p>\n<p>如果不预热的话，你访问的资源可能不再 CDN 节点中，这个时候 CDN 节点将请求源站获取资源，这个过程是大家经常说的 <strong>回源</strong>。</p>\n<p><strong>命中率</strong> 和 <strong>回源率</strong> 是衡量 CDN 服务质量两个重要指标。命中率越高越好，回源率越低越好。</p>\n<p>如果资源有更新的话，你也可以对其 <strong>刷新</strong> ，删除 CDN 节点上缓存的资源，当用户访问对应的资源时直接回源获取最新的资源，并重新缓存。</p>\n<h3> 如何找到最合适的 CDN 节点？</h3>\n<p>GSLB （Global Server Load Balance，全局负载均衡）是 CDN 的大脑，负责多个CDN节点之间相互协作，最常用的是基于 DNS 的 GSLB。</p>\n<p>CDN 会通过 GSLB 找到最合适的 CDN 节点，更具体点来说是下面这样的：</p>\n<ol>\n<li>浏览器向 DNS 服务器发送域名请求；</li>\n<li>DNS 服务器向根据 CNAME( Canonical Name ) 别名记录向 GSLB 发送请求；</li>\n<li>GSLB 返回性能最好（通常距离请求地址最近）的 CDN 节点（边缘服务器，真正缓存内容的地方）的地址给浏览器；</li>\n<li>浏览器直接访问指定的 CDN 节点。</li>\n</ol>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/high-performance/cdn/cdn-overview.png\" alt=\"CDN 原理示意图\"></p>\n<p>为了方便理解，上图其实做了一点简化。GSLB 内部可以看作是 CDN 专用 DNS 服务器和负载均衡系统组合。CDN 专用 DNS 服务器会返回负载均衡系统 IP 地址给浏览器，浏览器使用 IP 地址请求负载均衡系统进而找到对应的 CDN 节点。</p>\n<p><strong>GSLB 是如何选择出最合适的 CDN 节点呢？</strong> GSLB 会根据请求的 IP 地址、CDN 节点状态（比如负载情况、性能、响应时间、带宽）等指标来综合判断具体返回哪一个 CDN 节点的地址。</p>\n<h3> 如何防止资源被盗刷？</h3>\n<p>如果我们的资源被其他用户或者网站非法盗刷的话，将会是一笔不小的开支。</p>\n<p>解决这个问题最常用最简单的办法设置 <strong>Referer 防盗链</strong>，具体来说就是根据 HTTP 请求的头信息里面的 Referer 字段对请求进行限制。我们可以通过 Referer 字段获取到当前请求页面的来源页面的网站地址，这样我们就能确定请求是否来自合法的网站。</p>\n<p>CDN 服务提供商几乎都提供了这种比较基础的防盗链机制。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/high-performance/cdn/cnd-tencent-cloud-anti-theft.png\" alt=\"腾讯云 CDN Referer 防盗链配置\"></p>\n<p>不过，如果站点的防盗链配置允许 Referer 为空的话，通过隐藏 Referer，可以直接绕开防盗链。</p>\n<p>通常情况下，我们会配合其他机制来确保静态资源被盗用，一种常用的机制是 <strong>时间戳防盗链</strong> 。相比之下，<strong>时间戳防盗链</strong> 的安全性更强一些。时间戳防盗链加密的 URL 具有时效性，过期之后就无法再被允许访问。</p>\n<p>时间戳防盗链的 URL 通常会有两个参数一个是签名字符串，一个是过期时间。签名字符串一般是通过对用户设定的加密字符串、请求路径、过期时间通过  MD5 哈希算法取哈希的方式获得。</p>\n<p>时间戳防盗链 URL示例：</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><ul>\n<li><code>wsSecret</code> ：签名字符串。</li>\n<li><code>wsTime</code>: 过期时间。</li>\n</ul>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/high-performance/cdn/timestamp-anti-theft.png\" alt=\"\"></p>\n<p>时间戳防盗链的实现也比较简单，并且可靠性较高，推荐使用。并且，绝大部分 CDN 服务提供商都提供了开箱即用的时间戳防盗链机制。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/high-performance/cdn/qiniuyun-timestamp-anti-theft.png\" alt=\"七牛云时间戳防盗链配置\"></p>\n<p>除了 Referer 防盗链和时间戳防盗链之外，你还可以 IP 黑白名单配置、IP 访问限频配置等机制来防盗刷。</p>\n<h2> 总结</h2>\n<ul>\n<li>CDN 就是将静态资源分发到多个不同的地方以实现就近访问，进而加快静态资源的访问速度，减轻服务器以及带宽的负担。</li>\n<li>基于成本、稳定性和易用性考虑，建议直接选择专业的云厂商（比如阿里云、腾讯云、华为云、青云）或者 CDN 厂商（比如网宿、蓝汛）提供的开箱即用的 CDN 服务。</li>\n<li>GSLB （Global Server Load Balance，全局负载均衡）是 CDN 的大脑，负责多个 CDN 节点之间相互协作，最常用的是基于 DNS 的 GSLB。CDN 会通过 GSLB 找到最合适的 CDN 节点。</li>\n<li>为了防止静态资源被盗用，我们可以利用 <strong>Referer 防盗链</strong> + <strong>时间戳防盗链</strong> 。</li>\n</ul>\n<h2> 参考</h2>\n<ul>\n<li>时间戳防盗链 - 七牛云 CDN：https://developer.qiniu.com/fusion/kb/1670/timestamp-hotlinking-prevention</li>\n<li>CDN是个啥玩意？一文说个明白：https://mp.weixin.qq.com/s/Pp0C8ALUXsmYCUkM5QnkQw</li>\n<li>《透视 HTTP 协议》- 37 | CDN：加速我们的网络服务：http://gk.link/a/11yOG</li>\n</ul>\n",
      "image": "https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/high-performance/cdn/jingdong-wuliu-cangpei.png",
      "date_published": "2022-08-21T05:04:07.000Z",
      "date_modified": "2022-11-22T14:32:15.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "高性能"
      ]
    },
    {
      "title": "Web 实时消息推送详解",
      "url": "https://javaguide.cn/system-design/web-real-time-message-push.html",
      "id": "https://javaguide.cn/system-design/web-real-time-message-push.html",
      "summary": "原文地址：https://juejin.cn/post/7122014462181113887，JavaGuide 对本文进行了完善总结。 我有一个朋友做了一个小破站，现在要实现一个站内信 Web 消息推送的功能，对，就是下图这个小红点，一个很常用的功能。",
      "content_html": "<blockquote>\n<p>原文地址：https://juejin.cn/post/7122014462181113887，JavaGuide 对本文进行了完善总结。</p>\n</blockquote>\n<p>我有一个朋友做了一个小破站，现在要实现一个站内信 Web 消息推送的功能，对，就是下图这个小红点，一个很常用的功能。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/system-design/web-real-time-message-push/1460000042192380.png\" alt=\"站内信 Web 消息推送\"></p>\n<p>不过他还没想好用什么方式做，这里我帮他整理了一下几种方案，并简单做了实现。</p>\n<h2> 什么是消息推送？</h2>\n<p>推送的场景比较多，比如有人关注我的公众号，这时我就会收到一条推送消息，以此来吸引我点击打开应用。</p>\n<p>消息推送通常是指网站的运营工作等人员，通过某种工具对用户当前网页或移动设备 APP 进行的主动消息推送。</p>\n<p>消息推送一般又分为 Web 端消息推送和移动端消息推送。</p>\n<p>移动端消息推送示例 ：</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/system-design/web-real-time-message-push/IKleJ9auR1Ojdicyr0bH.png\" alt=\"移动端消息推送示例\"></p>\n<p>Web 端消息推送示例：</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/system-design/web-real-time-message-push/image-20220819100512941.png\" alt=\"Web 端消息推送示例\"></p>\n<p>在具体实现之前，咱们再来分析一下前边的需求，其实功能很简单，只要触发某个事件（主动分享了资源或者后台主动推送消息），Web 页面的通知小红点就会实时的 <code>+1</code> 就可以了。</p>\n<p>通常在服务端会有若干张消息推送表，用来记录用户触发不同事件所推送不同类型的消息，前端主动查询（拉）或者被动接收（推）用户所有未读的消息数。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/system-design/web-real-time-message-push/1460000042192384.png\" alt=\"消息推送表\"></p>\n<p>消息推送无非是推（push）和拉（pull）两种形式，下边我们逐个了解下。</p>\n<h2> 消息推送常见方案</h2>\n<h3> 短轮询</h3>\n<p><strong>轮询(polling)</strong> 应该是实现消息推送方案中最简单的一种，这里我们暂且将轮询分为短轮询和长轮询。</p>\n<p>短轮询很好理解，指定的时间间隔，由浏览器向服务器发出 HTTP 请求，服务器实时返回未读消息数据给客户端，浏览器再做渲染显示。</p>\n<p>一个简单的 JS 定时器就可以搞定，每秒钟请求一次未读消息数接口，返回的数据展示即可。</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>效果还是可以的，短轮询实现固然简单，缺点也是显而易见，由于推送数据并不会频繁变更，无论后端此时是否有新的消息产生，客户端都会进行请求，势必会对服务端造成很大压力，浪费带宽和服务器资源。</p>\n<h3> 长轮询</h3>\n<p>长轮询是对上边短轮询的一种改进版本，在尽可能减少对服务器资源浪费的同时，保证消息的相对实时性。长轮询在中间件中应用的很广泛，比如 Nacos 和 Apollo 配置中心，消息队列 Kafka、RocketMQ 中都有用到长轮询。</p>\n<p><a href=\"https://mp.weixin.qq.com/s/94ftESkDoZI9gAGflLiGwg\" target=\"_blank\" rel=\"noopener noreferrer\">Nacos 配置中心交互模型是 push 还是 pull？</a>一文中我详细介绍过 Nacos 长轮询的实现原理，感兴趣的小伙伴可以瞅瞅。</p>\n<p>长轮询其实原理跟轮询差不多，都是采用轮询的方式。不过，如果服务端的数据没有发生变更，会 一直 hold 住请求，直到服务端的数据发生变化，或者等待一定时间超时才会返回。返回后，客户端又会立即再次发起下一次长轮询。</p>\n<p>这次我使用 Apollo 配置中心实现长轮询的方式，应用了一个类<code>DeferredResult</code>，它是在 Servelet3.0 后经过 Spring 封装提供的一种异步请求机制，直意就是延迟结果。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/system-design/web-real-time-message-push/1460000042192386.png\" alt=\"长轮询示意图\"></p>\n<p><code>DeferredResult</code>可以允许容器线程快速释放占用的资源，不阻塞请求线程，以此接受更多的请求提升系统的吞吐量，然后启动异步工作线程处理真正的业务逻辑，处理完成调用<code>DeferredResult.setResult(200)</code>提交响应结果。</p>\n<p>下边我们用长轮询来实现消息推送。</p>\n<p>因为一个 ID 可能会被多个长轮询请求监听，所以我采用了 Guava 包提供的<code>Multimap</code>结构存放长轮询，一个 key 可以对应多个 value。一旦监听到 key 发生变化，对应的所有长轮询都会响应。前端得到非请求超时的状态码，知晓数据变更，主动查询未读消息数接口，更新页面数据。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>当请求超过设置的超时时间，会抛出<code>AsyncRequestTimeoutException</code>异常，这里直接用<code>@ControllerAdvice</code>全局捕获统一返回即可，前端获取约定好的状态码后再次发起长轮询请求，如此往复调用。</p>\n<div class=\"language-kotlin line-numbers-mode\" data-ext=\"kt\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>我们来测试一下，首先页面发起长轮询请求<code>/polling/watch/10086</code>监听消息更变，请求被挂起，不变更数据直至超时，再次发起了长轮询请求；紧接着手动变更数据<code>/polling/publish/10086</code>，长轮询得到响应，前端处理业务逻辑完成后再次发起请求，如此循环往复。</p>\n<p>长轮询相比于短轮询在性能上提升了很多，但依然会产生较多的请求，这是它的一点不完美的地方。</p>\n<h3> iframe 流</h3>\n<p>iframe 流就是在页面中插入一个隐藏的<code>&lt;iframe&gt;</code>标签，通过在<code>src</code>中请求消息数量 API 接口，由此在服务端和客户端之间创建一条长连接，服务端持续向<code>iframe</code>传输数据。</p>\n<p>传输的数据通常是 HTML、或是内嵌的JavaScript 脚本，来达到实时更新页面的效果。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/system-design/web-real-time-message-push/1460000042192388.png\" alt=\"iframe 流示意图\"></p>\n<p>这种方式实现简单，前端只要一个<code>&lt;iframe&gt;</code>标签搞定了</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>服务端直接组装 HTML、JS 脚本数据向 response 写入就行了</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>iframe 流的服务器开销很大，而且IE、Chrome等浏览器一直会处于 loading 状态，图标会不停旋转，简直是强迫症杀手。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/system-design/web-real-time-message-push/1460000042192389.png\" alt=\"iframe 流效果\"></p>\n<p>iframe 流非常不友好，强烈不推荐。</p>\n<h3> SSE (我的方式)</h3>\n<p>很多人可能不知道，服务端向客户端推送消息，其实除了可以用<code>WebSocket</code>这种耳熟能详的机制外，还有一种服务器发送事件(Server-Sent Events)，简称 SSE。这是一种服务器端到客户端(浏览器)的单向消息推送。</p>\n<p>SSE 基于 HTTP 协议的，我们知道一般意义上的 HTTP 协议是无法做到服务端主动向客户端推送消息的，但 SSE 是个例外，它变换了一种思路。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/system-design/web-real-time-message-push/1460000042192390.png\" alt=\"\"></p>\n<p>SSE 在服务器和客户端之间打开一个单向通道，服务端响应的不再是一次性的数据包而是<code>text/event-stream</code>类型的数据流信息，在有数据变更时从服务器流式传输到客户端。</p>\n<p>整体的实现思路有点类似于在线视频播放，视频流会连续不断的推送到浏览器，你也可以理解成，客户端在完成一次用时很长（网络不畅）的下载。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/system-design/web-real-time-message-push/1460000042192391.png\" alt=\"SSE 示意图\"></p>\n<p>SSE 与 WebSocket 作用相似，都可以建立服务端与浏览器之间的通信，实现服务端向客户端推送消息，但还是有些许不同：</p>\n<ul>\n<li>SSE 是基于 HTTP 协议的，它们不需要特殊的协议或服务器实现即可工作；WebSocket 需单独服务器来处理协议。</li>\n<li>SSE 单向通信，只能由服务端向客户端单向通信；WebSocket 全双工通信，即通信的双方可以同时发送和接受信息。</li>\n<li>SSE 实现简单开发成本低，无需引入其他组件；WebSocket 传输数据需做二次解析，开发门槛高一些。</li>\n<li>SSE 默认支持断线重连；WebSocket 则需要自己实现。</li>\n<li>SSE 只能传送文本消息，二进制数据需要经过编码后传送；WebSocket 默认支持传送二进制数据。</li>\n</ul>\n<p><strong>SSE 与 WebSocket 该如何选择？</strong></p>\n<blockquote>\n<p>技术并没有好坏之分，只有哪个更合适</p>\n</blockquote>\n<p>SSE 好像一直不被大家所熟知，一部分原因是出现了 WebSocket，这个提供了更丰富的协议来执行双向、全双工通信。对于游戏、即时通信以及需要双向近乎实时更新的场景，拥有双向通道更具吸引力。</p>\n<p>但是，在某些情况下，不需要从客户端发送数据。而你只需要一些服务器操作的更新。比如：站内信、未读消息数、状态更新、股票行情、监控数量等场景，SEE 不管是从实现的难易和成本上都更加有优势。此外，SSE 具有 WebSocket 在设计上缺乏的多种功能，例如：自动重新连接、事件 ID 和发送任意事件的能力。</p>\n<p>前端只需进行一次 HTTP 请求，带上唯一 ID，打开事件流，监听服务端推送的事件就可以了</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>服务端的实现更简单，创建一个<code>SseEmitter</code>对象放入<code>sseEmitterMap</code>进行管理</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>注意：</strong> SSE 不支持 IE 浏览器，对其他主流浏览器兼容性做的还不错。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/system-design/web-real-time-message-push/1460000042192393.png\" alt=\"SSE 兼容性\"></p>\n<h3> Websocket</h3>\n<p>Websocket 应该是大家都比较熟悉的一种实现消息推送的方式，上边我们在讲 SSE 的时候也和 Websocket 进行过比较。</p>\n<p>是一种在 TCP 连接上进行全双工通信的协议，建立客户端和服务器之间的通信渠道。浏览器和服务器仅需一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/system-design/web-real-time-message-push/1460000042192394.png\" alt=\"Websocket 示意图\"></p>\n<p>SpringBoot 整合 Websocket，先引入 Websocket 相关的工具包，和 SSE 相比额外的开发成本。</p>\n<div class=\"language-xml line-numbers-mode\" data-ext=\"xml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>服务端使用<code>@ServerEndpoint</code>注解标注当前类为一个 WebSocket 服务器，客户端可以通过<code>ws://localhost:7777/webSocket/10086</code>来连接到 WebSocket 服务器端。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>前端初始化打开 WebSocket 连接，并监听连接状态，接收服务端数据或向服务端发送数据。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>页面初始化建立 WebSocket 连接，之后就可以进行双向通信了，效果还不错。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/system-design/web-real-time-message-push/1460000042192395.png\" alt=\"\"></p>\n<h3> MQTT</h3>\n<p><strong>什么是 MQTT 协议？</strong></p>\n<p>MQTT (Message Queue Telemetry Transport)是一种基于发布/订阅（publish/subscribe）模式的轻量级通讯协议，通过订阅相应的主题来获取消息，是物联网（Internet of Thing）中的一个标准传输协议。</p>\n<p>该协议将消息的发布者（publisher）与订阅者（subscriber）进行分离，因此可以在不可靠的网络环境中，为远程连接的设备提供可靠的消息服务，使用方式与传统的 MQ 有点类似。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/system-design/web-real-time-message-push/1460000022986325.png\" alt=\"MQTT 协议示例\"></p>\n<p>TCP 协议位于传输层，MQTT 协议位于应用层，MQTT 协议构建于 TCP/IP 协议上，也就是说只要支持 TCP/IP 协议栈的地方，都可以使用 MQTT 协议。</p>\n<p><strong>为什么要用 MQTT 协议？</strong></p>\n<p>MQTT 协议为什么在物联网（IOT）中如此受偏爱？而不是其它协议，比如我们更为熟悉的 HTTP 协议呢？</p>\n<ul>\n<li>首先 HTTP 协议它是一种同步协议，客户端请求后需要等待服务器的响应。而在物联网（IOT）环境中，设备会很受制于环境的影响，比如带宽低、网络延迟高、网络通信不稳定等，显然异步消息协议更为适合 IOT 应用程序。</li>\n<li>HTTP 是单向的，如果要获取消息客户端必须发起连接，而在物联网（IOT）应用程序中，设备或传感器往往都是客户端，这意味着它们无法被动地接收来自网络的命令。</li>\n<li>通常需要将一条命令或者消息，发送到网络上的所有设备上。HTTP 要实现这样的功能不但很困难，而且成本极高。</li>\n</ul>\n<p>具体的 MQTT 协议介绍和实践，这里我就不再赘述了，大家可以参考我之前的两篇文章，里边写的也都很详细了。</p>\n<ul>\n<li>MQTT 协议的介绍：<a href=\"https://mp.weixin.qq.com/s/udFE6k9pPetIWsa6KeErrA\" target=\"_blank\" rel=\"noopener noreferrer\">我也没想到 SpringBoot + RabbitMQ 做智能家居，会这么简单</a></li>\n<li>MQTT 实现消息推送：<a href=\"https://mp.weixin.qq.com/s/U-fUGr9i1MVa4PoVyiDFCg\" target=\"_blank\" rel=\"noopener noreferrer\">未读消息（小红点），前端 与 RabbitMQ 实时消息推送实践，贼简单~</a></li>\n</ul>\n<h2> 总结</h2>\n<blockquote>\n<p>以下内容为 JavaGuide 补充</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>介绍</th>\n<th>优点</th>\n<th>缺点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>短轮询</td>\n<td>客户端定时向服务端发送请求，服务端直接返回响应数据（即使没有数据更新）</td>\n<td>简单、易理解、易实现</td>\n<td>实时性太差，无效请求太多，频繁建立连接太耗费资源</td>\n</tr>\n<tr>\n<td>长轮询</td>\n<td>与短轮询不同是，长轮询接收到客户端请求之后等到有数据更新才返回请求</td>\n<td>减少了无效请求</td>\n<td>挂起请求会导致资源浪费</td>\n</tr>\n<tr>\n<td>iframe 流</td>\n<td>服务端和客户端之间创建一条长连接，服务端持续向<code>iframe</code>传输数据。</td>\n<td>简单、易理解、易实现</td>\n<td>维护一个长连接会增加开销，效果太差（图标会不停旋转）</td>\n</tr>\n<tr>\n<td>SSE</td>\n<td>一种服务器端到客户端(浏览器)的单向消息推送。</td>\n<td>简单、易实现，功能丰富</td>\n<td>不支持双向通信</td>\n</tr>\n<tr>\n<td>WebSocket</td>\n<td>除了最初建立连接时用 HTTP 协议，其他时候都是直接基于 TCP 协议进行通信的，可以实现客户端和服务端的全双工通信。</td>\n<td>性能高、开销小</td>\n<td>对开发人员要求更高，实现相对复杂一些</td>\n</tr>\n<tr>\n<td>MQTT</td>\n<td>基于发布/订阅（publish/subscribe）模式的轻量级通讯协议，通过订阅相应的主题来获取消息。</td>\n<td>成熟稳定，轻量级</td>\n<td>对开发人员要求更高，实现相对复杂一些</td>\n</tr>\n</tbody>\n</table>\n",
      "image": "https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/system-design/web-real-time-message-push/1460000042192380.png",
      "date_published": "2022-08-19T03:13:03.000Z",
      "date_modified": "2022-11-22T14:32:15.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "系统设计"
      ]
    },
    {
      "title": "Java 语法糖详解",
      "url": "https://javaguide.cn/java/basis/syntactic-sugar.html",
      "id": "https://javaguide.cn/java/basis/syntactic-sugar.html",
      "summary": "作者：Hollis 原文：https://mp.weixin.qq.com/s/o4XdEMq1DL-nBS-f8Za5Aw 语法糖是大厂 Java 面试常问的一个知识点。 本文从 Java 编译原理角度，深入字节码及 class 文件，抽丝剥茧，了解 Java 中的语法糖原理及用法，帮助大家在学会如何使用 Java 语法糖的同时，了解这些语法糖背后的原理。 什么是语法糖？ 语法糖（Syntactic Sugar） 也称糖衣语法，是英国计算机学家 Peter.J.Landin 发明的一个术语，指在计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。简而言之，语法糖让程序更加简洁，有更高的可读性。",
      "content_html": "<blockquote>\n<p>作者：Hollis</p>\n<p>原文：https://mp.weixin.qq.com/s/o4XdEMq1DL-nBS-f8Za5Aw</p>\n</blockquote>\n<p>语法糖是大厂 Java 面试常问的一个知识点。</p>\n<p>本文从 Java 编译原理角度，深入字节码及 class 文件，抽丝剥茧，了解 Java 中的语法糖原理及用法，帮助大家在学会如何使用 Java 语法糖的同时，了解这些语法糖背后的原理。</p>\n<h2> 什么是语法糖？</h2>\n<p><strong>语法糖（Syntactic Sugar）</strong> 也称糖衣语法，是英国计算机学家 Peter.J.Landin 发明的一个术语，指在计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。简而言之，语法糖让程序更加简洁，有更高的可读性。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/basis/syntactic-sugar/image-20220818175953954.png\" alt=\"\"></p>\n<blockquote>\n<p>有意思的是，在编程领域，除了语法糖，还有语法盐和语法糖精的说法，篇幅有限这里不做扩展了。</p>\n</blockquote>\n<p>我们所熟知的编程语言中几乎都有语法糖。作者认为，语法糖的多少是评判一个语言够不够牛逼的标准之一。很多人说 Java 是一个“低糖语言”，其实从 Java 7 开始 Java 语言层面上一直在添加各种糖，主要是在“Project Coin”项目下研发。尽管现在 Java 有人还是认为现在的 Java 是低糖，未来还会持续向着“高糖”的方向发展。</p>\n<h2> Java 中有哪些常见的语法糖？</h2>\n<p>前面提到过，语法糖的存在主要是方便开发人员使用。但其实， <strong>Java 虚拟机并不支持这些语法糖。这些语法糖在编译阶段就会被还原成简单的基础语法结构，这个过程就是解语法糖。</strong></p>\n<p>说到编译，大家肯定都知道，Java 语言中，<code>javac</code>命令可以将后缀名为<code>.java</code>的源文件编译为后缀名为<code>.class</code>的可以运行于 Java 虚拟机的字节码。如果你去看<code>com.sun.tools.javac.main.JavaCompiler</code>的源码，你会发现在<code>compile()</code>中有一个步骤就是调用<code>desugar()</code>，这个方法就是负责解语法糖的实现的。</p>\n<p>Java 中最常用的语法糖主要有泛型、变长参数、条件编译、自动拆装箱、内部类等。本文主要来分析下这些语法糖背后的原理。一步一步剥去糖衣，看看其本质。</p>\n<p>我们这里会用到<a href=\"https://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&amp;mid=2650120609&amp;idx=1&amp;sn=5659f96310963ad57d55b48cee63c788&amp;chksm=f36bbc80c41c3596a1e4bf9501c6280481f1b9e06d07af354474e6f3ed366fef016df673a7ba&amp;scene=21#wechat_redirect\" target=\"_blank\" rel=\"noopener noreferrer\">反编译</a>，你可以通过 <a href=\"http://www.javadecompilers.com/\" target=\"_blank\" rel=\"noopener noreferrer\">Decompilers online</a> 对 Class 文件进行在线反编译。</p>\n<h3> switch 支持 String 与枚举</h3>\n<p>前面提到过，从 Java 7 开始，Java 语言中的语法糖在逐渐丰富，其中一个比较重要的就是 Java 7 中<code>switch</code>开始支持<code>String</code>。</p>\n<p>在开始之前先科普下，Java 中的<code>switch</code>自身原本就支持基本类型。比如<code>int</code>、<code>char</code>等。对于<code>int</code>类型，直接进行数值的比较。对于<code>char</code>类型则是比较其 ascii 码。所以，对于编译器来说，<code>switch</code>中其实只能使用整型，任何类型的比较都要转换成整型。比如<code>byte</code>。<code>short</code>，<code>char</code>(ackii 码是整型)以及<code>int</code>。</p>\n<p>那么接下来看下<code>switch</code>对<code>String</code>得支持，有以下代码：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>反编译后内容如下：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>看到这个代码，你知道原来 <strong>字符串的 switch 是通过<code>equals()</code>和<code>hashCode()</code>方法来实现的。</strong> 还好<code>hashCode()</code>方法返回的是<code>int</code>，而不是<code>long</code>。</p>\n<p>仔细看下可以发现，进行<code>switch</code>的实际是哈希值，然后通过使用<code>equals</code>方法比较进行安全检查，这个检查是必要的，因为哈希可能会发生碰撞。因此它的性能是不如使用枚举进行 <code>switch</code> 或者使用纯整数常量，但这也不是很差。</p>\n<h3> 泛型</h3>\n<p>我们都知道，很多语言都是支持泛型的，但是很多人不知道的是，不同的编译器对于泛型的处理方式是不同的，通常情况下，一个编译器处理泛型有两种方式：<code>Code specialization</code>和<code>Code sharing</code>。C++和 C#是使用<code>Code specialization</code>的处理机制，而 Java 使用的是<code>Code sharing</code>的机制。</p>\n<blockquote>\n<p>Code sharing 方式为每个泛型类型创建唯一的字节码表示，并且将该泛型类型的实例都映射到这个唯一的字节码表示上。将多种泛型类形实例映射到唯一的字节码表示是通过类型擦除（<code>type erasue</code>）实现的。</p>\n</blockquote>\n<p>也就是说，<strong>对于 Java 虚拟机来说，他根本不认识<code>Map&lt;String, String&gt; map</code>这样的语法。需要在编译阶段通过类型擦除的方式进行解语法糖。</strong></p>\n<p>类型擦除的主要过程如下： 1.将所有的泛型参数用其最左边界（最顶级的父类型）类型替换。 2.移除所有的类型参数。</p>\n<p>以下代码：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>解语法糖之后会变成：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>以下代码：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>类型擦除后会变成：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>虚拟机中没有泛型，只有普通类和普通方法，所有泛型类的类型参数在编译时都会被擦除，泛型类并没有自己独有的<code>Class</code>类对象。比如并不存在<code>List&lt;String&gt;.class</code>或是<code>List&lt;Integer&gt;.class</code>，而只有<code>List.class</code>。</strong></p>\n<h3> 自动装箱与拆箱</h3>\n<p>自动装箱就是 Java 自动将原始类型值转换成对应的对象，比如将 int 的变量转换成 Integer 对象，这个过程叫做装箱，反之将 Integer 对象转换成 int 类型值，这个过程叫做拆箱。因为这里的装箱和拆箱是自动进行的非人为转换，所以就称作为自动装箱和拆箱。原始类型 byte, short, char, int, long, float, double 和 boolean 对应的封装类为 Byte, Short, Character, Integer, Long, Float, Double, Boolean。</p>\n<p>先来看个自动装箱的代码：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>反编译后代码如下:</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>再来看个自动拆箱的代码：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>反编译后代码如下：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>从反编译得到内容可以看出，在装箱的时候自动调用的是<code>Integer</code>的<code>valueOf(int)</code>方法。而在拆箱的时候自动调用的是<code>Integer</code>的<code>intValue</code>方法。</p>\n<p>所以，<strong>装箱过程是通过调用包装器的 valueOf 方法实现的，而拆箱过程是通过调用包装器的 xxxValue 方法实现的。</strong></p>\n<h3> 可变长参数</h3>\n<p>可变参数(<code>variable arguments</code>)是在 Java 1.5 中引入的一个特性。它允许一个方法把任意数量的值作为参数。</p>\n<p>看下以下可变参数代码，其中 <code>print</code> 方法接收可变参数：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>反编译后代码：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>从反编译后代码可以看出，可变参数在被使用的时候，他首先会创建一个数组，数组的长度就是调用该方法是传递的实参的个数，然后再把参数值全部放到这个数组当中，然后再把这个数组作为参数传递到被调用的方法中。</p>\n<h3> 枚举</h3>\n<p>Java SE5 提供了一种新的类型-Java 的枚举类型，关键字<code>enum</code>可以将一组具名的值的有限集合创建为一种新的类型，而这些具名的值可以作为常规的程序组件使用，这是一种非常有用的功能。</p>\n<p>要想看源码，首先得有一个类吧，那么枚举类型到底是什么类呢？是<code>enum</code>吗？答案很明显不是，<code>enum</code>就和<code>class</code>一样，只是一个关键字，他并不是一个类，那么枚举是由什么类维护的呢，我们简单的写一个枚举：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>然后我们使用反编译，看看这段代码到底是怎么实现的，反编译后代码内容如下：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>通过反编译后代码我们可以看到，<code>public final class T extends Enum</code>，说明，该类是继承了<code>Enum</code>类的，同时<code>final</code>关键字告诉我们，这个类也是不能被继承的。</p>\n<p><strong>当我们使用<code>enum</code>来定义一个枚举类型的时候，编译器会自动帮我们创建一个<code>final</code>类型的类继承<code>Enum</code>类，所以枚举类型不能被继承。</strong></p>\n<h3> 内部类</h3>\n<p>内部类又称为嵌套类，可以把内部类理解为外部类的一个普通成员。</p>\n<p><strong>内部类之所以也是语法糖，是因为它仅仅是一个编译时的概念，<code>outer.java</code>里面定义了一个内部类<code>inner</code>，一旦编译成功，就会生成两个完全不同的<code>.class</code>文件了，分别是<code>outer.class</code>和<code>outer$inner.class</code>。所以内部类的名字完全可以和它的外部类名字相同。</strong></p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>以上代码编译后会生成两个 class 文件：<code>OutterClass$InnerClass.class</code> 、<code>OutterClass.class</code> 。当我们尝试对<code>OutterClass.class</code>文件进行反编译的时候，命令行会打印以下内容：<code>Parsing OutterClass.class...Parsing inner class OutterClass$InnerClass.class... Generating OutterClass.jad</code> 。他会把两个文件全部进行反编译，然后一起生成一个<code>OutterClass.jad</code>文件。文件内容如下：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 条件编译</h3>\n<p>—般情况下，程序中的每一行代码都要参加编译。但有时候出于对程序代码优化的考虑，希望只对其中一部分内容进行编译，此时就需要在程序中加上条件，让编译器只对满足条件的代码进行编译，将不满足条件的代码舍弃，这就是条件编译。</p>\n<p>如在 C 或 CPP 中，可以通过预处理语句来实现条件编译。其实在 Java 中也可实现条件编译。我们先来看一段代码：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>反编译后代码如下：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>首先，我们发现，在反编译后的代码中没有<code>System.out.println(\"Hello, ONLINE!\");</code>，这其实就是条件编译。当<code>if(ONLINE)</code>为 false 的时候，编译器就没有对其内的代码进行编译。</p>\n<p>所以，<strong>Java 语法的条件编译，是通过判断条件为常量的 if 语句实现的。其原理也是 Java 语言的语法糖。根据 if 判断条件的真假，编译器直接把分支为 false 的代码块消除。通过该方式实现的条件编译，必须在方法体内实现，而无法在正整个 Java 类的结构或者类的属性上进行条件编译，这与 C/C++的条件编译相比，确实更有局限性。在 Java 语言设计之初并没有引入条件编译的功能，虽有局限，但是总比没有更强。</strong></p>\n<h3> 断言</h3>\n<p>在 Java 中，<code>assert</code>关键字是从 JAVA SE 1.4 引入的，为了避免和老版本的 Java 代码中使用了<code>assert</code>关键字导致错误，Java 在执行的时候默认是不启动断言检查的（这个时候，所有的断言语句都将忽略！），如果要开启断言检查，则需要用开关<code>-enableassertions</code>或<code>-ea</code>来开启。</p>\n<p>看一段包含断言的代码：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>反编译后代码如下：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>很明显，反编译之后的代码要比我们自己的代码复杂的多。所以，使用了 assert 这个语法糖我们节省了很多代码。<strong>其实断言的底层实现就是 if 语言，如果断言结果为 true，则什么都不做，程序继续执行，如果断言结果为 false，则程序抛出 AssertError 来打断程序的执行。</strong><code>-enableassertions</code>会设置$assertionsDisabled 字段的值。</p>\n<h3> 数值字面量</h3>\n<p>在 java 7 中，数值字面量，不管是整数还是浮点数，都允许在数字之间插入任意多个下划线。这些下划线不会对字面量的数值产生影响，目的就是方便阅读。</p>\n<p>比如：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>反编译后：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>反编译后就是把<code>_</code>删除了。也就是说 <strong>编译器并不认识在数字字面量中的<code>_</code>，需要在编译阶段把他去掉。</strong></p>\n<h3> for-each</h3>\n<p>增强 for 循环（<code>for-each</code>）相信大家都不陌生，日常开发经常会用到的，他会比 for 循环要少写很多代码，那么这个语法糖背后是如何实现的呢？</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>反编译后代码如下：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>代码很简单，<strong>for-each 的实现原理其实就是使用了普通的 for 循环和迭代器。</strong></p>\n<h3> try-with-resource</h3>\n<p>Java 里，对于文件操作 IO 流、数据库连接等开销非常昂贵的资源，用完之后必须及时通过 close 方法将其关闭，否则资源会一直处于打开状态，可能会导致内存泄露等问题。</p>\n<p>关闭资源的常用方式就是在<code>finally</code>块里是释放，即调用<code>close</code>方法。比如，我们经常会写这样的代码：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>从 Java 7 开始，jdk 提供了一种更好的方式关闭资源，使用<code>try-with-resources</code>语句，改写一下上面的代码，效果如下：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>看，这简直是一大福音啊，虽然我之前一般使用<code>IOUtils</code>去关闭流，并不会使用在<code>finally</code>中写很多代码的方式，但是这种新的语法糖看上去好像优雅很多呢。看下他的背后：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>其实背后的原理也很简单，那些我们没有做的关闭资源的操作，编译器都帮我们做了。所以，再次印证了，语法糖的作用就是方便程序员的使用，但最终还是要转成编译器认识的语言。</strong></p>\n<h3> Lambda 表达式</h3>\n<p>关于 lambda 表达式，有人可能会有质疑，因为网上有人说他并不是语法糖。其实我想纠正下这个说法。<strong>Labmda 表达式不是匿名内部类的语法糖，但是他也是一个语法糖。实现方式其实是依赖了几个 JVM 底层提供的 lambda 相关 api。</strong></p>\n<p>先来看一个简单的 lambda 表达式。遍历一个 list：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>为啥说他并不是内部类的语法糖呢，前面讲内部类我们说过，内部类在编译之后会有两个 class 文件，但是，包含 lambda 表达式的类编译后只有一个文件。</p>\n<p>反编译后代码如下:</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>可以看到，在<code>forEach</code>方法中，其实是调用了<code>java.lang.invoke.LambdaMetafactory#metafactory</code>方法，该方法的第四个参数 <code>implMethod</code> 指定了方法实现。可以看到这里其实是调用了一个<code>lambda$main$0</code>方法进行了输出。</p>\n<p>再来看一个稍微复杂一点的，先对 List 进行过滤，然后再输出：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>反编译后代码如下：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>两个 lambda 表达式分别调用了<code>lambda$main$1</code>和<code>lambda$main$0</code>两个方法。</p>\n<p><strong>所以，lambda 表达式的实现其实是依赖了一些底层的 api，在编译阶段，编译器会把 lambda 表达式进行解糖，转换成调用内部 api 的方式。</strong></p>\n<h2> 可能遇到的坑</h2>\n<h3> 泛型</h3>\n<p><strong>一、当泛型遇到重载</strong></p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面这段代码，有两个重载的函数，因为他们的参数类型不同，一个是<code>List&lt;String&gt;</code>另一个是<code>List&lt;Integer&gt;</code> ，但是，这段代码是编译通不过的。因为我们前面讲过，参数<code>List&lt;Integer&gt;</code>和<code>List&lt;String&gt;</code>编译之后都被擦除了，变成了一样的原生类型 List，擦除动作导致这两个方法的特征签名变得一模一样。</p>\n<p><strong>二、当泛型遇到 catch</strong></p>\n<p>泛型的类型参数不能用在 Java 异常处理的 catch 语句中。因为异常处理是由 JVM 在运行时刻来进行的。由于类型信息被擦除，JVM 是无法区分两个异常类型<code>MyException&lt;String&gt;</code>和<code>MyException&lt;Integer&gt;</code>的</p>\n<p><strong>三、当泛型内包含静态变量</strong></p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>以上代码输出结果为：2！</p>\n<p>由于经过类型擦除，所有的泛型类实例都关联到同一份字节码上，泛型类的所有静态变量是共享的。</p>\n<h3> 自动装箱与拆箱</h3>\n<p><strong>对象相等比较</strong></p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出结果：</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在 Java 5 中，在 Integer 的操作上引入了一个新功能来节省内存和提高性能。整型对象通过使用相同的对象引用实现了缓存和重用。</p>\n<blockquote>\n<p>适用于整数值区间-128 至 +127。</p>\n<p>只适用于自动装箱。使用构造函数创建对象不适用。</p>\n</blockquote>\n<h3> 增强 for 循环</h3>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>会抛出<code>ConcurrentModificationException</code>异常。</p>\n<p>Iterator 是工作在一个独立的线程中，并且拥有一个 mutex 锁。 Iterator 被创建之后会建立一个指向原来对象的单链索引表，当原来的对象数量发生变化时，这个索引表的内容不会同步改变，所以当索引指针往后移动的时候就找不到要迭代的对象，所以按照 fail-fast 原则 Iterator 会马上抛出<code>java.util.ConcurrentModificationException</code>异常。</p>\n<p>所以 <code>Iterator</code> 在工作的时候是不允许被迭代的对象被改变的。但你可以使用 <code>Iterator</code> 本身的方法<code>remove()</code>来删除对象，<code>Iterator.remove()</code> 方法会在删除当前迭代对象的同时维护索引的一致性。</p>\n<h2> 总结</h2>\n<p>前面介绍了 12 种 Java 中常用的语法糖。所谓语法糖就是提供给开发人员便于开发的一种语法而已。但是这种语法只有开发人员认识。要想被执行，需要进行解糖，即转成 JVM 认识的语法。当我们把语法糖解糖之后，你就会发现其实我们日常使用的这些方便的语法，其实都是一些其他更简单的语法构成的。</p>\n<p>有了这些语法糖，我们在日常开发的时候可以大大提升效率，但是同时也要避过度使用。使用之前最好了解下原理，避免掉坑。</p>\n",
      "image": "https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/basis/syntactic-sugar/image-20220818175953954.png",
      "date_published": "2022-08-18T12:45:01.000Z",
      "date_modified": "2023-01-29T11:22:15.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "权限系统设计详解",
      "url": "https://javaguide.cn/system-design/security/design-of-authority-system.html",
      "id": "https://javaguide.cn/system-design/security/design-of-authority-system.html",
      "summary": "作者：转转技术团队 原文：https://mp.weixin.qq.com/s/ONMuELjdHYa0yQceTj01Iw 老权限系统的问题与现状 转转公司在过去并没有一个统一的权限管理系统，权限管理由各业务自行研发或是使用其他业务的权限系统，权限管理的不统一带来了不少问题： 各业务重复造轮子，维护成本高 各系统只解决部分场景问题，方案不够通用，新项目选型时没有可靠的权限管理方案 缺乏统一的日志管理与审批流程，在授权信息追溯上十分困难",
      "content_html": "<blockquote>\n<p>作者：转转技术团队</p>\n<p>原文：https://mp.weixin.qq.com/s/ONMuELjdHYa0yQceTj01Iw</p>\n</blockquote>\n<h2> 老权限系统的问题与现状</h2>\n<p>转转公司在过去并没有一个统一的权限管理系统，权限管理由各业务自行研发或是使用其他业务的权限系统，权限管理的不统一带来了不少问题：</p>\n<ol>\n<li>各业务重复造轮子，维护成本高</li>\n<li>各系统只解决部分场景问题，方案不够通用，新项目选型时没有可靠的权限管理方案</li>\n<li>缺乏统一的日志管理与审批流程，在授权信息追溯上十分困难</li>\n</ol>\n<p>基于上述问题，去年底公司启动建设转转统一权限系统，目标是开发一套灵活、易用、安全的权限管理系统，供各业务使用。</p>\n<h2> 业界权限系统的设计方式</h2>\n<p>目前业界主流的权限模型有两种，下面分别介绍下：</p>\n<ul>\n<li><strong>基于角色的访问控制（RBAC）</strong></li>\n<li><strong>基于属性的访问控制（ABAC）</strong></li>\n</ul>\n<h3> RBAC 模型</h3>\n<p><strong>基于角色的访问控制（Role-Based Access Control，简称 RBAC）</strong> 指的是通过用户的角色（Role）授权其相关权限，实现了灵活的访问控制，相比直接授予用户权限，要更加简单、高效、可扩展。</p>\n<p>一个用户可以拥有若干角色，每一个角色又可以被分配若干权限这样，就构造成“用户-角色-权限” 的授权模型。在这种模型中，用户与角色、角色与权限之间构成了多对多的关系。</p>\n<p>用一个图来描述如下：</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/system-design/security/design-of-authority-system/rbac.png\" alt=\"RBAC 权限模型示意图\"></p>\n<p>当使用 <code>RBAC模型</code> 时，通过分析用户的实际情况，基于共同的职责和需求，授予他们不同角色。这种 <code>用户 -&gt; 角色 -&gt; 权限</code> 间的关系，让我们可以不用再单独管理单个用户权限，用户从授予的角色里面获取所需的权限。</p>\n<p>以一个简单的场景（Gitlab 的权限系统）为例，用户系统中有 <code>Admin</code>、<code>Maintainer</code>、<code>Operator</code> 三种角色，这三种角色分别具备不同的权限，比如只有 <code>Admin</code> 具备创建代码仓库、删除代码仓库的权限，其他的角色都不具备。我们授予某个用户 <code>Admin</code> 这个角色，他就具备了 <strong>创建代码仓库</strong> 和 <strong>删除代码仓库</strong> 这两个权限。</p>\n<p>通过 <code>RBAC模型</code> ，当存在多个用户拥有相同权限时，我们只需要创建好拥有该权限的角色，然后给不同的用户分配不同的角色，后续只需要修改角色的权限，就能自动修改角色内所有用户的权限。</p>\n<h3> ABAC 模型</h3>\n<p><strong>基于属性的访问控制（Attribute-Based Access Control，简称 ABAC）</strong> 是一种比 <code>RBAC模型</code> 更加灵活的授权模型，它的原理是通过各种属性来动态判断一个操作是否可以被允许。这个模型在云系统中使用的比较多，比如 AWS，阿里云等。</p>\n<p>考虑下面这些场景的权限控制：</p>\n<ol>\n<li>授权某个人具体某本书的编辑权限</li>\n<li>当一个文档的所属部门跟用户的部门相同时，用户可以访问这个文档</li>\n<li>当用户是一个文档的拥有者并且文档的状态是草稿，用户可以编辑这个文档</li>\n<li>早上九点前禁止 A 部门的人访问 B 系统</li>\n<li>在除了上海以外的地方禁止以管理员身份访问 A 系统</li>\n<li>用户对 2022-06-07 之前创建的订单有操作权限</li>\n</ol>\n<p>可以发现上述的场景通过 <code>RBAC模型</code> 很难去实现，因为 <code>RBAC模型</code> 仅仅描述了用户可以做什么操作，但是操作的条件，以及操作的数据，<code>RBAC模型</code> 本身是没有这些限制的。但这恰恰是 <code>ABAC模型</code> 的长处，<code>ABAC模型</code> 的思想是基于用户、访问的数据的属性、以及各种环境因素去动态计算用户是否有权限进行操作。</p>\n<h4> ABAC 模型的原理</h4>\n<p>在 <code>ABAC模型</code> 中，一个操作是否被允许是基于对象、资源、操作和环境信息共同动态计算决定的。</p>\n<ul>\n<li><strong>对象</strong>：对象是当前请求访问资源的用户。用户的属性包括 ID，个人资源，角色，部门和组织成员身份等</li>\n<li><strong>资源</strong>：资源是当前用户要访问的资产或对象，例如文件，数据，服务器，甚至 API</li>\n<li><strong>操作</strong>：操作是用户试图对资源进行的操作。常见的操作包括“读取”，“写入”，“编辑”，“复制”和“删除”</li>\n<li><strong>环境</strong>：环境是每个访问请求的上下文。环境属性包含访问的时间和位置，对象的设备，通信协议和加密强度等</li>\n</ul>\n<p>在 <code>ABAC模型</code> 的决策语句的执行过程中，决策引擎会根据定义好的决策语句，结合对象、资源、操作、环境等因素动态计算出决策结果。每当发生访问请求时，<code>ABAC模型</code> 决策系统都会分析属性值是否与已建立的策略匹配。如果有匹配的策略，访问请求就会被通过。</p>\n<h2> 新权限系统的设计思想</h2>\n<p>结合转转的业务现状，<code>RBAC模型</code> 满足了转转绝大部分业务场景，并且开发成本远低于 <code>ABAC模型</code> 的权限系统，所以新权限系统选择了基于 <code>RBAC模型</code> 来实现。对于实在无法满足的业务系统，我们选择了暂时性不支持，这样可以保障新权限系统的快速落地，更快的让业务使用起来。</p>\n<p>标准的 <code>RBAC模型</code> 是完全遵守 <code>用户 -&gt; 角色 -&gt; 权限</code> 这个链路的，也就是用户的权限完全由他所拥有的角色来控制，但是这样会有一个缺点，就是给用户加权限必须新增一个角色，导致实际操作起来效率比较低。所以我们在 <code>RBAC模型</code> 的基础上，新增了给用户直接增加权限的能力，也就是说既可以给用户添加角色，也可以给用户直接添加权限。最终用户的权限是由拥有的角色和权限点组合而成。</p>\n<p><strong>新权限系统的权限模型</strong>：用户最终权限 = 用户拥有的角色带来的权限 + 用户独立配置的权限，两者取并集。</p>\n<p>新权限系统方案如下图 ：</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/system-design/security/design-of-authority-system/new-authority-system-design.png\" alt=\"新权限系统方案\"></p>\n<ul>\n<li>首先，将集团所有的用户（包括外部用户），通过 <strong>统一登录与注册</strong> 功能实现了统一管理，同时与公司的组织架构信息模块打通，实现了同一个人员在所有系统中信息的一致，这也为后续基于组织架构进行权限管理提供了可行性。</li>\n<li>其次，因为新权限系统需要服务集团所有业务，所以需要支持多系统权限管理。用户进行权限管理前，需要先选择相应的系统，然后配置该系统的 <strong>菜单权限</strong> 和 <strong>数据权限</strong> 信息，建立好系统的各个权限点。<em>PS：菜单权限和数据权限的具体说明，下文会详细介绍。</em></li>\n<li>最后，创建该系统下的不同角色，给不同角色配置好权限点。比如店长角色，拥有店员操作权限、本店数据查看权限等，配置好这个角色后，后续只需要给店长增加这个角色，就可以让他拥有对应的权限。</li>\n</ul>\n<p>完成上述配置后，就可以进行用户的权限管理了。有两种方式可以给用户加权限：</p>\n<ol>\n<li>先选用户，然后添加权限。该方式可以给用户添加任意角色或是菜单/数据权限点。</li>\n<li>先选择角色，然后关联用户。该方式只可给用户添加角色，不能单独添加菜单/数据权限点。</li>\n</ol>\n<p>这两种方式的具体设计方案，后文会详细说明。</p>\n<h3> 权限系统自身的权限管理</h3>\n<p>对于权限系统来说，首先需要设计好系统自身的权限管理，也就是需要管理好 ”谁可以进入权限系统，谁可以管理其他系统的权限“，对于权限系统自身的用户，会分为三类：</p>\n<ol>\n<li><strong>超级管理员</strong>：拥有权限系统的全部操作权限，可以进行系统自身的任何操作，也可以管理接入权限的应用系统的管理操作。</li>\n<li><strong>权限操作用户</strong>：拥有至少一个已接入的应用系统的超级管理员角色的用户。该用户能进行的操作限定在所拥有的应用系统权限范围内。权限操作用户是一种身份，无需分配，而是根据规则自动获得的。</li>\n<li><strong>普通用户</strong>：普通用户也可以认为是一种身份，除去上述 2 类人，其余的都为普通用户。他们只能申请接入系统以及访问权限申请页面。</li>\n</ol>\n<h3> 权限类型的定义</h3>\n<p>新权限系统中，我们把权限分为两大类，分别是 ：</p>\n<ul>\n<li><strong>菜单功能权限</strong>：包括系统的目录导航、菜单的访问权限，以及按钮和 API 操作的权限</li>\n<li><strong>数据权限</strong>：包括定义数据的查询范围权限，在不同系统中，通常叫做 “组织”、”站点“等，在新权限系统中，统一称作 ”组织“ 来管理数据权限</li>\n</ul>\n<h3> 默认角色的分类</h3>\n<p>每个系统中设计了三个默认角色，用来满足基本的权限管理需求，分别如下：</p>\n<ul>\n<li><strong>超级管理员</strong>：该角色拥有该系统的全部权限，可以修改系统的角色权限等配置，可以给其他用户授权。</li>\n<li><strong>系统管理员</strong>：该角色拥有给其他用户授权以及修改系统的角色权限等配置能力，但角色本身不具有任何权限。</li>\n<li><strong>授权管理员</strong>：该角色拥有给其他用户授权的能力。但是授权的范围不超出自己所拥有的权限。</li>\n</ul>\n<blockquote>\n<p>举个栗子：授权管理员 A 可以给 B 用户添加权限，但添加的范围 小于等于 A 用户已拥有的权限。</p>\n</blockquote>\n<p>经过这么区分，把 <strong>拥有权限</strong> 和 <strong>拥有授权能力</strong> ，这两部分给分隔开来，可以满足所有的权限控制的场景。</p>\n<h2> 新权限系统的核心模块设计</h2>\n<p>上面介绍了新权限系统的整体设计思想，接下来分别介绍下核心模块的设计</p>\n<h3> 系统/菜单/数据权限管理</h3>\n<p>把一个新系统接入权限系统有下列步骤：</p>\n<ol>\n<li>创建系统</li>\n<li>配置菜单功能权限</li>\n<li>配置数据权限（可选）</li>\n<li>创建系统的角色</li>\n</ol>\n<p>其中，1、2、3 的步骤，都是在系统管理模块完成，具体流程如下图:</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/system-design/security/design-of-authority-system/new-authority-system-design-access-flow-chart.png\" alt=\"系统接入流程图\"></p>\n<p>用户可以对系统的基本信息进行增删改查的操作，不同系统之间通过 <code>系统编码</code> 作为唯一区分。同时 <code>系统编码</code> 也会用作于菜单和数据权限编码的前缀，通过这样的设计保证权限编码全局唯一性。</p>\n<p>例如系统的编码为 <code>test_online</code>，那么该系统的菜单编码格式便为 <code>test_online:m_xxx</code>。</p>\n<p>系统管理界面设计如下：</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/system-design/security/design-of-authority-system/new-authority-system-management-interface.png\" alt=\"系统管理界面设计\"></p>\n<h4> 菜单管理</h4>\n<p>新权限系统首先对菜单进行了分类，分别是 <code>目录</code>、<code>菜单</code> 和 <code>操作</code>，示意如下图</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/system-design/security/design-of-authority-system/new-authority-system-menu.png\" alt=\"菜单管理界面\"></p>\n<p>它们分别代表的含义是：</p>\n<ul>\n<li><strong>目录</strong> ：指的是应用系统中最顶部的一级目录，通常在系统 Logo 的右边</li>\n<li><strong>菜单</strong> ：指的是应用系统左侧的多层级菜单，通常在系统 Logo 的下面，也是最常用的菜单结构</li>\n<li><strong>操作</strong> ：指页面中的按钮、接口等一系列可以定义为操作或页面元素的部分。</li>\n</ul>\n<p>菜单管理界面设计如下：</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/system-design/security/design-of-authority-system/new-authority-system-menu-management-interface.png\" alt=\"菜单管理界面设计\"></p>\n<p>菜单权限数据的使用，也提供两种方式：</p>\n<ul>\n<li><strong>动态菜单模式</strong> ：这种模式下，菜单的增删完全由权限系统接管。也就是说在权限系统增加菜单，应用系统会同步增加。这种模式好处是修改菜单无需项目上线。</li>\n<li><strong>静态菜单模式</strong> ：菜单的增删由应用系统的前端控制，权限系统只控制访问权限。这种模式下，权限系统只能标识出用户是否拥有当前菜单的权限，而具体的显示控制是由前端根据权限数据来决定。</li>\n</ul>\n<h3> 角色与用户管理</h3>\n<p>角色与用户管理都是可以直接改变用户权限的核心模块，整个设计思路如下图：</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/system-design/security/design-of-authority-system/role-and-user-management.png\" alt=\"角色与用户管理模块设计\"></p>\n<p>这个模块设计重点是需要考虑到批量操作。无论是通过角色关联用户，还是给用户批量增加/删除/重置权限，批量操作的场景都是系统需要设计好的。</p>\n<h3> 权限申请</h3>\n<p>除了给其他用户添加权限外，新权限系统同时支持了用户自主申请权限。这个模块除了常规的审批流（申请、审批、查看）等，有一个比较特别的功能，就是如何让用户能选对自己要的权限。所以在该模块的设计上，除了直接选择角色外，还支持通过菜单/数据权限点，反向选择角色，如下图：</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/system-design/security/design-of-authority-system/permission-application.png\" alt=\"权限申请界面\"></p>\n<h3> 操作日志</h3>\n<p>系统操作日志会分为两大类：</p>\n<ol>\n<li><strong>操作流水日志</strong> ：用户可看、可查的关键操作日志</li>\n<li><strong>服务 Log 日志</strong> ：系统服务运行过程中产生的 Log 日志,其中，服务 Log 日志信息量大于操作流水日志，但是不方便搜索查看。所以权限系统需要提供操作流水日志功能。</li>\n</ol>\n<p>在新权限系统中，用户所有的操作可以分为三类，分别为新增、更新、删除。所有的模块也可枚举，例如用户管理、角色管理、菜单管理等。明确这些信息后，那么一条日志就可以抽象为：什么人(Who)在什么时间(When)对哪些人(Target)的哪些模块做了哪些操作。\n这样把所有的记录都入库，就可以方便的进行日志的查看和筛选了。</p>\n<h2> 总结与展望</h2>\n<p>至此，新权限系统的核心设计思路与模块都已介绍完成，新系统在转转内部有大量的业务接入使用，权限管理相比以前方便了许多。权限系统作为每家公司的一个基础系统，灵活且完备的设计可以助力日后业务的发展更加高效。</p>\n<p>后续两篇：</p>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/hFTDckfxhSnoM_McP18Vkg\" target=\"_blank\" rel=\"noopener noreferrer\">转转统一权限系统的设计与实现（后端实现篇）</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/a_P4JAwxgunhfmJvpBnWYA\" target=\"_blank\" rel=\"noopener noreferrer\">转转统一权限系统的设计与实现（前端实现篇）</a></li>\n</ul>\n<h2> 参考</h2>\n<ul>\n<li>选择合适的权限模型：https://docs.authing.cn/v2/guides/access-control/choose-the-right-access-control-model.html</li>\n</ul>\n",
      "image": "https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/system-design/security/design-of-authority-system/rbac.png",
      "date_published": "2022-08-15T07:12:39.000Z",
      "date_modified": "2022-08-21T05:04:07.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "系统设计"
      ]
    },
    {
      "title": "应用层常见协议总结（应用层）",
      "url": "https://javaguide.cn/cs-basics/network/application-layer-protocol.html",
      "id": "https://javaguide.cn/cs-basics/network/application-layer-protocol.html",
      "summary": "HTTP:超文本传输协议 超文本传输协议（HTTP，HyperText Transfer Protocol) 主要是为 Web 浏览器与 Web 服务器之间的通信而设计的。当我们使用浏览器浏览网页的时候，我们网页就是通过 HTTP 请求进行加载的，整个过程如下图所示。 HTTP 协是基于 TCP协议，发送 HTTP 请求之前首先要建立 TCP 连接也就是要经历 3 次握手。目前使用的 HTTP 协议大部分都是 1.1。在 1.1 的协议里面，默认是开启了 Keep-Alive 的，这样的话建立的连接就可以在多次请求中被复用了。",
      "content_html": "<h2> HTTP:超文本传输协议</h2>\n<p><strong>超文本传输协议（HTTP，HyperText Transfer Protocol)</strong> 主要是为 Web 浏览器与 Web 服务器之间的通信而设计的。当我们使用浏览器浏览网页的时候，我们网页就是通过 HTTP 请求进行加载的，整个过程如下图所示。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/450px-HTTP-Header.png\" alt=\"\"></p>\n<p>HTTP 协是基于 TCP协议，发送 HTTP 请求之前首先要建立 TCP 连接也就是要经历 3 次握手。目前使用的 HTTP 协议大部分都是 1.1。在 1.1 的协议里面，默认是开启了 Keep-Alive 的，这样的话建立的连接就可以在多次请求中被复用了。</p>\n<p>另外， HTTP 协议是”无状态”的协议，它无法记录客户端用户的状态，一般我们都是通过 Session 来记录客户端用户的状态。</p>\n<h2> SMTP:简单邮件传输(发送)协议</h2>\n<p><strong>简单邮件传输(发送)协议（SMTP，Simple Mail Transfer Protocol）</strong> 基于 TCP 协议，用来发送电子邮件。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/network/what-is-smtp.png\" alt=\"SMTP 协议\"></p>\n<p>注意⚠️：<strong>接受邮件的协议不是 SMTP 而是 POP3 协议。</strong></p>\n<p>SMTP 协议这块涉及的内容比较多，下面这两个问题比较重要：</p>\n<ol>\n<li>电子邮件的发送过程</li>\n<li>如何判断邮箱是真正存在的？</li>\n</ol>\n<p><strong>电子邮件的发送过程？</strong></p>\n<p>比如我的邮箱是“dabai@cszhinan.com”，我要向“xiaoma@qq.com”发送邮件，整个过程可以简单分为下面几步：</p>\n<ol>\n<li>通过 <strong>SMTP</strong>  协议，我将我写好的邮件交给163邮箱服务器（邮局）。</li>\n<li>163邮箱服务器发现我发送的邮箱是qq邮箱，然后它使用 SMTP协议将我的邮件转发到 qq邮箱服务器。</li>\n<li>qq邮箱服务器接收邮件之后就通知邮箱为“xiaoma@qq.com”的用户来收邮件，然后用户就通过 <strong>POP3/IMAP</strong> 协议将邮件取出。</li>\n</ol>\n<p><strong>如何判断邮箱是真正存在的？</strong></p>\n<p>很多场景(比如邮件营销)下面我们需要判断我们要发送的邮箱地址是否真的存在，这个时候我们可以利用 SMTP 协议来检测：</p>\n<ol>\n<li>查找邮箱域名对应的  SMTP 服务器地址</li>\n<li>尝试与服务器建立连接</li>\n<li>连接成功后尝试向需要验证的邮箱发送邮件</li>\n<li>根据返回结果判定邮箱地址的真实性</li>\n</ol>\n<p>推荐几个在线邮箱是否有效检测工具：</p>\n<ol>\n<li>https://verify-email.org/</li>\n<li>http://tool.chacuo.net/mailverify</li>\n<li>https://www.emailcamel.com/</li>\n</ol>\n<h2> POP3/IMAP:邮件接收的协议</h2>\n<p>这两个协议没必要多做阐述，只需要了解 <strong>POP3 和 IMAP 两者都是负责邮件接收的协议</strong>即可。另外，需要注意不要将这两者和 SMTP 协议搞混淆了。<strong>SMTP 协议只负责邮件的发送，真正负责接收的协议是POP3/IMAP。</strong></p>\n<p>IMAP 协议相比于POP3更新一点，为用户提供的可选功能也更多一点,几乎所有现代电子邮件客户端和服务器都支持IMAP。大部分网络邮件服务提供商都支持POP3和IMAP。</p>\n<h2> FTP:文件传输协议</h2>\n<p><strong>FTP 协议</strong> 主要提供文件传输服务，基于 TCP 实现可靠的传输。使用 FTP 传输文件的好处是可以屏蔽操作系统和文件存储方式。</p>\n<p>FTP 是基于客户—服务器（C/S）模型而设计的，在客户端与 FTP 服务器之间建立两个连接。如果我们要基于 FTP 协议开发一个文件传输的软件的话，首先需要搞清楚 FTP 的原理。关于 FTP 的原理，很多书籍上已经描述的非常详细了：</p>\n<blockquote>\n<p>FTP 的独特的优势同时也是与其它客户服务器程序最大的不同点就在于它在两台通信的主机之间使用了两条 TCP 连接（其它客户服务器应用程序一般只有一条 TCP 连接）：</p>\n<ol>\n<li>控制连接：用于传送控制信息（命令和响应）</li>\n<li>数据连接：用于数据传送；</li>\n</ol>\n<p>这种将命令和数据分开传送的思想大大提高了 FTP 的效率。</p>\n</blockquote>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/计算机网络总结/ftp.png\" alt=\"FTP工作过程\"></p>\n<h2> Telnet:远程登陆协议</h2>\n<p><strong>Telnet 协议</strong> 通过一个终端登陆到其他服务器，建立在可靠的传输协议 TCP 之上。Telnet 协议的最大缺点之一是所有数据（包括用户名和密码）均以明文形式发送，这有潜在的安全风险。这就是为什么如今很少使用Telnet并被一种称为SSH的非常安全的协议所取代的主要原因。</p>\n<h2> SSH:安全的网络传输协议</h2>\n<p><strong>SSH（ Secure Shell）</strong> 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH  建立在可靠的传输协议 TCP 之上。</p>\n<p><strong>Telnet 和 SSH 之间的主要区别在于 SSH 协议会对传输的数据进行加密保证数据安全性。</strong></p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/计算机网络总结/TCP和UDP.png\" alt=\"TCP和UDP\"></p>\n",
      "image": "https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/450px-HTTP-Header.png",
      "date_published": "2022-08-14T09:10:17.000Z",
      "date_modified": "2022-08-21T11:15:56.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "计算机基础"
      ]
    },
    {
      "title": "TCP 传输可靠性保障（传输层）",
      "url": "https://javaguide.cn/cs-basics/network/tcp-reliability-guarantee.html",
      "id": "https://javaguide.cn/cs-basics/network/tcp-reliability-guarantee.html",
      "summary": "TCP 如何保证传输的可靠性？ 基于数据块传输 ：应用数据被分割成 TCP 认为最适合发送的数据块，再传输给网络层，数据块被称为报文段或段。 对失序数据包重新排序以及去重：TCP 为了保证不发生丢包，就给每个包一个序列号，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据就可以实现数据包去重。 校验和 : TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。 超时重传 : 当发送方发送数据之后，它启动一个定时器，等待目的端确认收到这个报文段。接收端实体对已成功收到的包发回一个相应的确认信息（ACK）。如果发送端实体在合理的往返时延（RTT）内未收到确认消息，那么对应的数据包就被假设为已丢失并进行重传。 流量控制 : TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议（TCP 利用滑动窗口实现流量控制）。 拥塞控制 : 当网络拥塞时，减少数据的发送。",
      "content_html": "<h2> TCP 如何保证传输的可靠性？</h2>\n<ol>\n<li><strong>基于数据块传输</strong> ：应用数据被分割成 TCP 认为最适合发送的数据块，再传输给网络层，数据块被称为报文段或段。</li>\n<li><strong>对失序数据包重新排序以及去重</strong>：TCP 为了保证不发生丢包，就给每个包一个序列号，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据就可以实现数据包去重。</li>\n<li><strong>校验和</strong> : TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li>\n<li><strong>超时重传</strong> : 当发送方发送数据之后，它启动一个定时器，等待目的端确认收到这个报文段。接收端实体对已成功收到的包发回一个相应的确认信息（ACK）。如果发送端实体在合理的往返时延（RTT）内未收到确认消息，那么对应的数据包就被假设为<a href=\"https://zh.wikipedia.org/wiki/%E4%B8%A2%E5%8C%85\" target=\"_blank\" rel=\"noopener noreferrer\">已丢失</a>并进行重传。</li>\n<li><strong>流量控制</strong> : TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议（TCP 利用滑动窗口实现流量控制）。</li>\n<li><strong>拥塞控制</strong> : 当网络拥塞时，减少数据的发送。</li>\n</ol>\n<h2> TCP 如何实现流量控制？</h2>\n<p><strong>TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。</strong> 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p>\n<p><strong>为什么需要流量控制?</strong> 这是因为双方在通信的时候，发送方的速率与接收方的速率是不一定相等，如果发送方的发送速率太快，会导致接收方处理不过来。如果接收方处理不过来的话，就只能把处理不过来的数据存在 <strong>接收缓冲区(Receiving Buffers)</strong> 里（失序的数据包也会被存放在缓存区里）。如果缓存区满了发送方还在狂发数据的话，接收方只能把收到的数据包丢掉。出现丢包问题的同时又疯狂浪费着珍贵的网络资源。因此，我们需要控制发送方的发送速率，让接收方与发送方处于一种动态平衡才好。</p>\n<p>这里需要注意的是（常见误区）：</p>\n<ul>\n<li>发送端不等同于客户端</li>\n<li>接收端不等同于服务端</li>\n</ul>\n<p>TCP 为全双工(Full-Duplex, FDX)通信，双方可以进行双向通信，客户端和服务端既可能是发送端又可能是服务端。因此，两端各有一个发送缓冲区与接收缓冲区，两端都各自维护一个发送窗口和一个接收窗口。接收窗口大小取决于应用、系统、硬件的限制（TCP传输速率不能大于应用的数据处理速率）。通信双方的发送窗口和接收窗口的要求相同</p>\n<p><strong>TCP 发送窗口可以划分成四个部分</strong> ：</p>\n<ol>\n<li>已经发送并且确认的TCP段（已经发送并确认）；</li>\n<li>已经发送但是没有确认的TCP段（已经发送未确认）；</li>\n<li>未发送但是接收方准备接收的TCP段（可以发送）；</li>\n<li>未发送并且接收方也并未准备接受的TCP段（不可发送）。</li>\n</ol>\n<p><strong>TCP发送窗口结构图示</strong> ：</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/network/tcp-send-window.png\" alt=\"TCP发送窗口结构\"></p>\n<ul>\n<li><strong>SND.WND</strong> ：发送窗口。</li>\n<li><strong>SND.UNA</strong>：Send Unacknowledged 指针，指向发送窗口的第一个字节。</li>\n<li><strong>SND.NXT</strong>：Send Next 指针，指向可用窗口的第一个字节。</li>\n</ul>\n<p><strong>可用窗口大小</strong> =  <code>SND.UNA + SND.WND - SND.NXT</code> 。</p>\n<p><strong>TCP 接收窗口可以划分成三个部分</strong> ：</p>\n<ol>\n<li>已经接收并且已经确认的 TCP 段（已经接收并确认）；</li>\n<li>等待接收且允许发送方发送 TCP 段（可以接收未确认）；</li>\n<li>不可接收且不允许发送方发送TCP段（不可接收）。</li>\n</ol>\n<p><strong>TCP 接收窗口结构图示</strong> ：</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/network/tcp-receive-window.png\" alt=\"TCP接收窗口结构\"></p>\n<p><strong>接收窗口的大小是根据接收端处理数据的速度动态调整的。</strong> 如果接收端读取数据快，接收窗口可能会扩大。 否则，它可能会缩小。</p>\n<p>另外，这里的滑动窗口大小只是为了演示使用，实际窗口大小通常会远远大于这个值。</p>\n<h2> TCP 的拥塞控制是怎么实现的？</h2>\n<p>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/network/tcp-congestion-control.png\" alt=\"TCP的拥塞控制\"></p>\n<p>为了进行拥塞控制，TCP 发送方要维持一个 <strong>拥塞窗口(cwnd)</strong> 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</p>\n<p>TCP 的拥塞控制采用了四种算法，即 <strong>慢开始</strong> 、 <strong>拥塞避免</strong> 、<strong>快重传</strong> 和 <strong>快恢复</strong>。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。</p>\n<ul>\n<li><strong>慢开始：</strong> 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd 初始值为 1，每经过一个传播轮次，cwnd 加倍。</li>\n<li><strong>拥塞避免：</strong> 拥塞避免算法的思路是让拥塞窗口 cwnd 缓慢增大，即每经过一个往返时间 RTT 就把发送方的 cwnd 加 1.</li>\n<li><strong>快重传与快恢复：</strong> 在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。 　当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。</li>\n</ul>\n<h2> ARQ 协议了解吗?</h2>\n<p><strong>自动重传请求</strong>（Automatic Repeat-reQuest，ARQ）是 OSI 模型中数据链路层和传输层的错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认信息（Acknowledgements，就是我们常说的 ACK），它通常会重新发送，直到收到确认或者重试超过一定的次数。</p>\n<p>ARQ 包括停止等待 ARQ 协议和连续 ARQ 协议。</p>\n<h3> 停止等待 ARQ 协议</h3>\n<p>停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认（回复 ACK）。如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组；</p>\n<p>在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认。</p>\n<p><strong>1) 无差错情况:</strong></p>\n<p>发送方发送分组,接收方在规定时间内收到,并且回复确认.发送方再次发送。</p>\n<p><strong>2) 出现差错情况（超时重传）:</strong></p>\n<p>停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为 <strong>自动重传请求 ARQ</strong> 。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。</p>\n<p><strong>3) 确认丢失和确认迟到</strong></p>\n<ul>\n<li><strong>确认丢失</strong> ：确认消息在传输过程丢失。当 A 发送 M1 消息，B 收到后，B 向 A 发送了一个 M1 确认消息，但却在传输过程中丢失。而 A 并不知道，在超时计时过后，A 重传 M1 消息，B 再次收到该消息后采取以下两点措施：1. 丢弃这个重复的 M1 消息，不向上层交付。 2. 向 A 发送确认消息。（不会认为已经发送过了，就不再发送。A 能重传，就证明 B 的确认消息丢失）。</li>\n<li><strong>确认迟到</strong> ：确认消息在传输过程中迟到。A 发送 M1 消息，B 收到并发送确认。在超时时间内没有收到确认消息，A 重传 M1 消息，B 仍然收到并继续发送确认消息（B 收到了 2 份 M1）。此时 A 收到了 B 第二次发送的确认消息。接着发送其他数据。过了一会，A 收到了 B 第一次发送的对 M1 的确认消息（A 也收到了 2 份确认消息）。处理如下：1. A 收到重复的确认后，直接丢弃。2. B 收到重复的 M1 后，也直接丢弃重复的 M1。</li>\n</ul>\n<h3> 连续 ARQ 协议</h3>\n<p>连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。</p>\n<p><strong>优点：</strong> 信道利用率高，容易实现，即使确认丢失，也不必重传。</p>\n<p><strong>缺点：</strong> 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5 条 消息，中间第三条丢失（3 号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。</p>\n<h2> Reference</h2>\n<ol>\n<li>《计算机网络（第 7 版）》</li>\n<li>《图解 HTTP》</li>\n<li><a href=\"https://www.9tut.com/tcp-and-udp-tutorial\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.9tut.com/tcp-and-udp-tutorial</a></li>\n<li><a href=\"https://github.com/wolverinn/Waking-Up/blob/master/Computer%20Network.md\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/wolverinn/Waking-Up/blob/master/Computer%20Network.md</a></li>\n<li>TCP Flow Control—<a href=\"https://www.brianstorti.com/tcp-flow-control/\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.brianstorti.com/tcp-flow-control/</a></li>\n<li>TCP 流量控制(Flow Control)：https://notfalse.net/24/tcp-flow-control</li>\n<li>TCP之滑动窗口原理 : https://cloud.tencent.com/developer/article/1857363</li>\n</ol>\n",
      "image": "https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/network/tcp-send-window.png",
      "date_published": "2022-08-14T09:10:17.000Z",
      "date_modified": "2023-02-14T08:37:37.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "计算机基础"
      ]
    },
    {
      "title": "《计算机网络》（谢希仁）内容总结",
      "url": "https://javaguide.cn/cs-basics/network/computer-network-xiexiren-summary.html",
      "id": "https://javaguide.cn/cs-basics/network/computer-network-xiexiren-summary.html",
      "summary": "本文是我在大二学习计算机网络期间整理， 大部分内容都来自于谢希仁老师的《计算机网络》第七版 这本书。为了内容更容易理解，我对之前的整理进行了一波重构，并配上了一些相关的示意图便于理解。",
      "content_html": "<p>本文是我在大二学习计算机网络期间整理， 大部分内容都来自于谢希仁老师的<a href=\"https://www.elias.ltd/usr/local/etc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E7%AC%AC7%E7%89%88%EF%BC%89%E8%B0%A2%E5%B8%8C%E4%BB%81.pdf\" target=\"_blank\" rel=\"noopener noreferrer\">《计算机网络》第七版 </a>这本书。为了内容更容易理解，我对之前的整理进行了一波重构，并配上了一些相关的示意图便于理解。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/network/computer-network-xiexiren.png\" alt=\"\"></p>\n<p>相关问题：<a href=\"https://www.zhihu.com/question/327872966\" target=\"_blank\" rel=\"noopener noreferrer\">如何评价谢希仁的计算机网络（第七版）？ - 知乎</a>  。</p>\n<h2> 1. 计算机网络概述</h2>\n<h3> 1.1. 基本术语</h3>\n<ol>\n<li><strong>结点 （node）</strong> ：网络中的结点可以是计算机，集线器，交换机或路由器等。</li>\n<li><strong>链路（link ）</strong> : 从一个结点到另一个结点的一段物理线路。中间没有任何其他交点。</li>\n<li><strong>主机（host）</strong> ：连接在因特网上的计算机。</li>\n<li><strong>ISP（Internet Service Provider）</strong> ：因特网服务提供者（提供商）。</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/b83f6951e3f8f4bcde5b227257d603a8.png\" alt=\"ISP (Internet Service Provider) Definition\"></p>\n<ol start=\"5\">\n<li><strong>IXP（Internet eXchange Point）</strong> ： 互联网交换点 IXP 的主要作用就是允许两个网络直接相连并交换分组，而不需要再通过第三个网络来转发分组。</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/7a9568a9e94001fc110801addc8c4ec0.png\" alt=\"IXP Traffic Levels During the Stratos Skydive — RIPE Labs\"></p>\n<p style=\"text-align:center;font-size:13px;color:gray\">https://labs.ripe.net/Members/fergalc/ixp-traffic-during-stratos-skydive</p>\n<ol start=\"6\">\n<li><strong>RFC(Request For Comments)</strong> ：意思是“请求评议”，包含了关于 Internet 几乎所有的重要的文字资料。</li>\n<li><strong>广域网 WAN（Wide Area Network）</strong> ：任务是通过长距离运送主机发送的数据。</li>\n<li><strong>城域网 MAN（Metropolitan Area Network）</strong>：用来将多个局域网进行互连。</li>\n<li><strong>局域网 LAN（Local Area Network）</strong> ： 学校或企业大多拥有多个互连的局域网。</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/25a5789f8e18995c649f2f864d51e7a9.png\" alt=\"MAN &amp; WMAN | Red de área metropolitana, Redes informaticas, Par trenzado\"></p>\n<p style=\"text-align:center;font-size:13px;color:gray\">http://conexionesmanwman.blogspot.com/</p>\n<ol start=\"10\">\n<li><strong>个人区域网 PAN（Personal Area Network）</strong> ：在个人工作的地方把属于个人使用的电子设备用无线技术连接起来的网络 。</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/5c99dd6011439b1fab6cd2fece155dd5.png\" alt=\"Advantages and disadvantages of personal area network (PAN) - IT Release\"></p>\n<p style=\"text-align:center;font-size:13px;color:gray\">https://www.itrelease.com/2018/07/advantages-and-disadvantages-of-personal-area-network-pan/</p>\n<ol start=\"12\">\n<li><strong>分组（packet ）</strong> ：因特网中传送的数据单元。由首部 header 和数据段组成。分组又称为包，首部可称为包头。</li>\n<li><strong>存储转发（store and forward ）</strong> ：路由器收到一个分组，先检查分组是否正确，并过滤掉冲突包错误。确定包正确后，取出目的地址，通过查找表找到想要发送的输出端口地址，然后将该包发送出去。</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/20201025142342169.gif#pic_center\" alt=\"\"></p>\n<ol start=\"14\">\n<li><strong>带宽（bandwidth）</strong> ：在计算机网络中，表示在单位时间内从网络中的某一点到另一点所能通过的“最高数据率”。常用来表示网络的通信线路所能传送数据的能力。单位是“比特每秒”，记为 b/s。</li>\n<li><strong>吞吐量（throughput ）</strong> ：表示在单位时间内通过某个网络（或信道、接口）的数据量。吞吐量更经常地用于对现实世界中的网络的一种测量，以便知道实际上到底有多少数据量能够通过网络。吞吐量受网络的带宽或网络的额定速率的限制。</li>\n</ol>\n<h3> 1.2. 重要知识点总结</h3>\n<ol>\n<li><strong>计算机网络（简称网络）把许多计算机连接在一起，而互联网把许多网络连接在一起，是网络的网络。</strong></li>\n<li>小写字母 i 开头的 internet（互联网）是通用名词，它泛指由多个计算机网络相互连接而成的网络。在这些网络之间的通信协议（即通信规则）可以是任意的。大写字母 I 开头的 Internet（互联网）是专用名词，它指全球最大的，开放的，由众多网络相互连接而成的特定的互联网，并采用 TCP/IP 协议作为通信规则，其前身为 ARPANET。Internet 的推荐译名为因特网，现在一般流行称为互联网。</li>\n<li>路由器是实现分组交换的关键构件，其任务是转发收到的分组，这是网络核心部分最重要的功能。分组交换采用存储转发技术，表示把一个报文（要发送的整块数据）分为几个分组后再进行传送。在发送报文之前，先把较长的报文划分成为一个个更小的等长数据段。在每个数据端的前面加上一些由必要的控制信息组成的首部后，就构成了一个分组。分组又称为包。分组是在互联网中传送的数据单元，正是由于分组的头部包含了诸如目的地址和源地址等重要控制信息，每一个分组才能在互联网中独立的选择传输路径，并正确地交付到分组传输的终点。</li>\n<li>互联网按工作方式可划分为边缘部分和核心部分。主机在网络的边缘部分，其作用是进行信息处理。由大量网络和连接这些网络的路由器组成核心部分，其作用是提供连通性和交换。</li>\n<li>计算机通信是计算机中进程（即运行着的程序）之间的通信。计算机网络采用的通信方式是客户-服务器方式（C/S 方式）和对等连接方式（P2P 方式）。</li>\n<li>客户和服务器都是指通信中所涉及的应用进程。客户是服务请求方，服务器是服务提供方。</li>\n<li>按照作用范围的不同，计算机网络分为广域网 WAN，城域网 MAN，局域网 LAN，个人区域网 PAN。</li>\n<li><strong>计算机网络最常用的性能指标是：速率，带宽，吞吐量，时延（发送时延，处理时延，排队时延），时延带宽积，往返时间和信道利用率。</strong></li>\n<li>网络协议即协议，是为进行网络中的数据交换而建立的规则。计算机网络的各层以及其协议集合，称为网络的体系结构。</li>\n<li><strong>五层体系结构由应用层，运输层，网络层（网际层），数据链路层，物理层组成。运输层最主要的协议是 TCP 和 UDP 协议，网络层最重要的协议是 IP 协议。</strong></li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/2020102514243717.png#pic_center\" alt=\"s\"></p>\n<p>下面的内容会介绍计算机网络的五层体系结构：<strong>物理层+数据链路层+网络层（网际层）+运输层+应用层</strong>。</p>\n<h2> 2. 物理层（Physical Layer）</h2>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/4749289d6e152bab1c8a8ccfc946a797.png\" alt=\"物理层\"></p>\n<h3> 2.1. 基本术语</h3>\n<ol>\n<li><strong>数据（data）</strong> :运送消息的实体。</li>\n<li><strong>信号（signal）</strong> ：数据的电气的或电磁的表现。或者说信号是适合在传输介质上传输的对象。</li>\n<li><strong>码元（ code）</strong> ：在使用时间域（或简称为时域）的波形来表示数字信号时，代表不同离散数值的基本波形。</li>\n<li><strong>单工（simplex ）</strong> : 只能有一个方向的通信而没有反方向的交互。</li>\n<li><strong>半双工（half duplex ）</strong> ：通信的双方都可以发送信息，但不能双方同时发送(当然也就不能同时接收)。</li>\n<li><strong>全双工（full duplex）</strong> : 通信的双方可以同时发送和接收信息。</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/c5be4756d2d6f46cbb6d785d5b86faf1.png\" alt=\"\"></p>\n<ol start=\"7\">\n<li><strong>失真</strong>：失去真实性，主要是指接受到的信号和发送的信号不同，有磨损和衰减。影响失真程度的因素：1.码元传输速率 2.信号传输距离 3.噪声干扰 4.传输媒体质量</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/aef3aac72e86c1ee6ccb8a91647f656c.png\" alt=\"\"></p>\n<ol start=\"8\">\n<li><strong>奈氏准则</strong> : 在任何信道中，码元的传输的效率是有上限的，传输速率超过此上限，就会出现严重的码间串扰问题，使接收端对码元的判决（即识别）成为不可能。</li>\n<li><strong>香农定理</strong> ：在带宽受限且有噪声的信道中，为了不产生误差，信息的数据传输速率有上限值。</li>\n<li><strong>基带信号（baseband signal）</strong> : 来自信源的信号。指没有经过调制的数字信号或模拟信号。</li>\n<li><strong>带通（频带）信号（bandpass signal）</strong> ：把基带信号经过载波调制后，把信号的频率范围搬移到较高的频段以便在信道中传输（即仅在一段频率范围内能够通过信道），这里调制过后的信号就是带通信号。</li>\n<li><strong>调制（modulation ）</strong> : 对信号源的信息进行处理后加到载波信号上，使其变为适合在信道传输的形式的过程。</li>\n<li><strong>信噪比（signal-to-noise ratio ）</strong> : 指信号的平均功率和噪声的平均功率之比，记为 S/N。信噪比（dB）=10*log10（S/N）。</li>\n<li><strong>信道复用（channel multiplexing ）</strong> ：指多个用户共享同一个信道。（并不一定是同时）。</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/a4889adaad3314f882e2cfab5f382064.png\" alt=\"信道复用技术\"></p>\n<ol start=\"15\">\n<li><strong>比特率（bit rate ）</strong> ：单位时间（每秒）内传送的比特数。</li>\n<li><strong>波特率（baud rate）</strong> ：单位时间载波调制状态改变的次数。针对数据信号对载波的调制速率。</li>\n<li><strong>复用（multiplexing）</strong> ：共享信道的方法。</li>\n<li><strong>ADSL（Asymmetric Digital Subscriber Line ）</strong> ：非对称数字用户线。</li>\n<li><strong>光纤同轴混合网（HFC 网）</strong> :在目前覆盖范围很广的有线电视网的基础上开发的一种居民宽带接入网</li>\n</ol>\n<h3> 2.2. 重要知识点总结</h3>\n<ol>\n<li><strong>物理层的主要任务就是确定与传输媒体接口有关的一些特性，如机械特性，电气特性，功能特性，过程特性。</strong></li>\n<li>一个数据通信系统可划分为三大部分，即源系统，传输系统，目的系统。源系统包括源点（或源站，信源）和发送器，目的系统包括接收器和终点。</li>\n<li><strong>通信的目的是传送消息。如话音，文字，图像等都是消息，数据是运送消息的实体。信号则是数据的电气或电磁的表现。</strong></li>\n<li>根据信号中代表消息的参数的取值方式不同，信号可分为模拟信号（或连续信号）和数字信号（或离散信号）。在使用时间域（简称时域）的波形表示数字信号时，代表不同离散数值的基本波形称为码元。</li>\n<li>根据双方信息交互的方式，通信可划分为单向通信（或单工通信），双向交替通信（或半双工通信），双向同时通信（全双工通信）。</li>\n<li>来自信源的信号称为基带信号。信号要在信道上传输就要经过调制。调制有基带调制和带通调制之分。最基本的带通调制方法有调幅，调频和调相。还有更复杂的调制方法，如正交振幅调制。</li>\n<li>要提高数据在信道上的传递速率，可以使用更好的传输媒体，或使用先进的调制技术。但数据传输速率不可能任意被提高。</li>\n<li>传输媒体可分为两大类，即导引型传输媒体（双绞线，同轴电缆，光纤）和非导引型传输媒体（无线，红外，大气激光）。</li>\n<li>为了有效利用光纤资源，在光纤干线和用户之间广泛使用无源光网络 PON。无源光网络无需配备电源，其长期运营成本和管理成本都很低。最流行的无源光网络是以太网无源光网络 EPON 和吉比特无源光网络 GPON。</li>\n</ol>\n<h3> 2.3. 补充</h3>\n<h4> 2.3.1. 物理层主要做啥？</h4>\n<p>物理层主要做的事情就是 <strong>透明地传送比特流</strong>。也可以将物理层的主要任务描述为确定与传输媒体的接口的一些特性，即：机械特性（接口所用接线器的一些物理属性如形状和尺寸），电气特性（接口电缆的各条线上出现的电压的范围），功能特性（某条线上出现的某一电平的电压的意义），过程特性（对于不同功能的各种可能事件的出现顺序）。</p>\n<p><strong>物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。</strong> 现有的计算机网络中的硬件设备和传输媒体的种类非常繁多，而且通信手段也有许多不同的方式。物理层的作用正是尽可能地屏蔽掉这些传输媒体和通信手段的差异，使物理层上面的数据链路层感觉不到这些差异，这样就可以使数据链路层只考虑完成本层的协议和服务，而不必考虑网络的具体传输媒体和通信手段是什么。</p>\n<h4> 2.3.2. 几种常用的信道复用技术</h4>\n<ol>\n<li><strong>频分复用(FDM)</strong> ：所有用户在同样的时间占用不同的带宽资源。</li>\n<li><strong>时分复用（TDM）</strong> ：所有用户在不同的时间占用同样的频带宽度（分时不分频）。</li>\n<li><strong>统计时分复用 (Statistic TDM)</strong> ：改进的时分复用，能够明显提高信道的利用率。</li>\n<li><strong>码分复用(CDM)</strong> ： 用户使用经过特殊挑选的不同码型，因此各用户之间不会造成干扰。这种系统发送的信号有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现。</li>\n<li><strong>波分复用( WDM)</strong> ：波分复用就是光的频分复用。</li>\n</ol>\n<h4> 2.3.3. 几种常用的宽带接入技术，主要是 ADSL 和 FTTx</h4>\n<p>用户到互联网的宽带接入方法有非对称数字用户线 ADSL（用数字技术对现有的模拟电话线进行改造，而不需要重新布线。ADSL 的快速版本是甚高速数字用户线 VDSL。），光纤同轴混合网 HFC（是在目前覆盖范围很广的有线电视网的基础上开发的一种居民宽带接入网）和 FTTx（即光纤到······）。</p>\n<h2> 3. 数据链路层（Data Link Layer）</h2>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/java-guide-blog/2-data-link-layer.svg\" alt=\"数据链路层\"></p>\n<h3> 3.1. 基本术语</h3>\n<ol>\n<li><strong>链路（link）</strong> ：一个结点到相邻结点的一段物理链路。</li>\n<li><strong>数据链路（data link）</strong> ：把实现控制数据运输的协议的硬件和软件加到链路上就构成了数据链路。</li>\n<li><strong>循环冗余检验 CRC（Cyclic Redundancy Check）</strong> ：为了保证数据传输的可靠性，CRC 是数据链路层广泛使用的一种检错技术。</li>\n<li><strong>帧（frame）</strong> ：一个数据链路层的传输单元，由一个数据链路层首部和其携带的封包所组成协议数据单元。</li>\n<li><strong>MTU（Maximum Transfer Uint ）</strong> ：最大传送单元。帧的数据部分的的长度上限。</li>\n<li><strong>误码率 BER（Bit Error Rate ）</strong> ：在一段时间内，传输错误的比特占所传输比特总数的比率。</li>\n<li><strong>PPP（Point-to-Point Protocol ）</strong> ：点对点协议。即用户计算机和 ISP 进行通信时所使用的数据链路层协议。以下是 PPP 帧的示意图：\n<img src=\"https://img-blog.csdnimg.cn/img_convert/298dbdeb16f98cec02c3954d8d95c1d6.png\" alt=\"PPP\"></li>\n<li><strong>MAC 地址（Media Access Control 或者 Medium Access Control）</strong> ：意译为媒体访问控制，或称为物理地址、硬件地址，用来定义网络设备的位置。在 OSI 模型中，第三层网络层负责 IP 地址，第二层数据链路层则负责 MAC 地址。因此一个主机会有一个 MAC 地址，而每个网络位置会有一个专属于它的 IP 地址 。地址是识别某个系统的重要标识符，“名字指出我们所要寻找的资源，地址指出资源所在的地方，路由告诉我们如何到达该处。”</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/002b2e6e45d66e805008fafc310afef0.png\" alt=\"ARP (Address Resolution Protocol) explained\"></p>\n<ol start=\"9\">\n<li><strong>网桥（bridge）</strong> ：一种用于数据链路层实现中继，连接两个或多个局域网的网络互连设备。</li>\n<li><strong>交换机（switch ）</strong> ：广义的来说，交换机指的是一种通信系统中完成信息交换的设备。这里工作在数据链路层的交换机指的是交换式集线器，其实质是一个多接口的网桥</li>\n</ol>\n<h3> 3.2. 重要知识点总结</h3>\n<ol>\n<li>链路是从一个结点到相邻结点的一段物理链路，数据链路则在链路的基础上增加了一些必要的硬件（如网络适配器）和软件（如协议的实现）</li>\n<li>数据链路层使用的主要是<strong>点对点信道</strong>和<strong>广播信道</strong>两种。</li>\n<li>数据链路层传输的协议数据单元是帧。数据链路层的三个基本问题是：<strong>封装成帧</strong>，<strong>透明传输</strong>和<strong>差错检测</strong></li>\n<li><strong>循环冗余检验 CRC</strong> 是一种检错方法，而帧检验序列 FCS 是添加在数据后面的冗余码</li>\n<li><strong>点对点协议 PPP</strong> 是数据链路层使用最多的一种协议，它的特点是：简单，只检测差错而不去纠正差错，不使用序号，也不进行流量控制，可同时支持多种网络层协议</li>\n<li>PPPoE 是为宽带上网的主机使用的链路层协议</li>\n<li><strong>局域网的优点是：具有广播功能，从一个站点可方便地访问全网；便于系统的扩展和逐渐演变；提高了系统的可靠性，可用性和生存性。</strong></li>\n<li>计算机与外接局域网通信需要通过通信适配器（或网络适配器），它又称为网络接口卡或网卡。<strong>计算器的硬件地址就在适配器的 ROM 中</strong>。</li>\n<li>以太网采用的无连接的工作方式，对发送的数据帧不进行编号，也不要求对方发回确认。目的站收到有差错帧就把它丢掉，其他什么也不做</li>\n<li>以太网采用的协议是具有冲突检测的<strong>载波监听多点接入 CSMA/CD</strong>。协议的特点是：<strong>发送前先监听，边发送边监听，一旦发现总线上出现了碰撞，就立即停止发送。然后按照退避算法等待一段随机时间后再次发送。</strong> 因此，每一个站点在自己发送数据之后的一小段时间内，存在着遭遇碰撞的可能性。以太网上的各站点平等地争用以太网信道</li>\n<li>以太网的适配器具有过滤功能，它只接收单播帧，广播帧和多播帧。</li>\n<li>使用集线器可以在物理层扩展以太网（扩展后的以太网仍然是一个网络）</li>\n</ol>\n<h3> 3.3. 补充</h3>\n<ol>\n<li>数据链路层的点对点信道和广播信道的特点，以及这两种信道所使用的协议（PPP 协议以及 CSMA/CD 协议）的特点</li>\n<li>数据链路层的三个基本问题：<strong>封装成帧</strong>，<strong>透明传输</strong>，<strong>差错检测</strong></li>\n<li>以太网的 MAC 层硬件地址</li>\n<li>适配器，转发器，集线器，网桥，以太网交换机的作用以及适用场合</li>\n</ol>\n<h2> 4. 网络层（Network Layer）</h2>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/fbf78bdcf3db11526ac1a234a8b98234.png\" alt=\"网络层\"></p>\n<h3> 4.1. 基本术语</h3>\n<ol>\n<li><strong>虚电路（Virtual Circuit）</strong> : 在两个终端设备的逻辑或物理端口之间，通过建立的双向的透明传输通道。虚电路表示这只是一条逻辑上的连接，分组都沿着这条逻辑连接按照存储转发方式传送，而并不是真正建立了一条物理连接。</li>\n<li><strong>IP（Internet Protocol ）</strong> : 网际协议 IP 是 TCP/IP 体系中两个最主要的协议之一，是 TCP/IP 体系结构网际层的核心。配套的有 ARP，RARP，ICMP，IGMP。</li>\n<li><strong>ARP（Address Resolution Protocol）</strong> : 地址解析协议。地址解析协议 ARP 把 IP 地址解析为硬件地址。</li>\n<li><strong>ICMP（Internet Control Message Protocol ）</strong> ：网际控制报文协议 （ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告）。</li>\n<li><strong>子网掩码（subnet mask ）</strong> ：它是一种用来指明一个 IP 地址的哪些位标识的是主机所在的子网以及哪些位标识的是主机的位掩码。子网掩码不能单独存在，它必须结合 IP 地址一起使用。</li>\n<li><strong>CIDR（ Classless Inter-Domain Routing ）</strong>：无分类域间路由选择 （特点是消除了传统的 A 类、B 类和 C 类地址以及划分子网的概念，并使用各种长度的“网络前缀”(network-prefix)来代替分类地址中的网络号和子网号）。</li>\n<li><strong>默认路由（default route）</strong> ：当在路由表中查不到能到达目的地址的路由时，路由器选择的路由。默认路由还可以减小路由表所占用的空间和搜索路由表所用的时间。</li>\n<li><strong>路由选择算法（Virtual Circuit）</strong> ：路由选择协议的核心部分。因特网采用自适应的，分层次的路由选择协议。</li>\n</ol>\n<h3> 4.2. 重要知识点总结</h3>\n<ol>\n<li><strong>TCP/IP 协议中的网络层向上只提供简单灵活的，无连接的，尽最大努力交付的数据报服务。网络层不提供服务质量的承诺，不保证分组交付的时限所传送的分组可能出错，丢失，重复和失序。进程之间通信的可靠性由运输层负责</strong></li>\n<li>在互联网的交付有两种，一是在本网络直接交付不用经过路由器，另一种是和其他网络的间接交付，至少经过一个路由器，但最后一次一定是直接交付</li>\n<li>分类的 IP 地址由网络号字段（指明网络）和主机号字段（指明主机）组成。网络号字段最前面的类别指明 IP 地址的类别。IP 地址是一种分等级的地址结构。IP 地址管理机构分配 IP 地址时只分配网络号，主机号由得到该网络号的单位自行分配。路由器根据目的主机所连接的网络号来转发分组。一个路由器至少连接到两个网络，所以一个路由器至少应当有两个不同的 IP 地址</li>\n<li>IP 数据报分为首部和数据两部分。首部的前一部分是固定长度，共 20 字节，是所有 IP 数据包必须具有的（源地址，目的地址，总长度等重要地段都固定在首部）。一些长度可变的可选字段固定在首部的后面。IP 首部中的生存时间给出了 IP 数据报在互联网中所能经过的最大路由器数。可防止 IP 数据报在互联网中无限制的兜圈子。</li>\n<li><strong>地址解析协议 ARP 把 IP 地址解析为硬件地址。ARP 的高速缓存可以大大减少网络上的通信量。因为这样可以使主机下次再与同样地址的主机通信时，可以直接从高速缓存中找到所需要的硬件地址而不需要再去以广播方式发送 ARP 请求分组</strong></li>\n<li>无分类域间路由选择 CIDR 是解决目前 IP 地址紧缺的一个好办法。CIDR 记法在 IP 地址后面加上斜线“/”，然后写上前缀所占的位数。前缀（或网络前缀）用来指明网络，前缀后面的部分是后缀，用来指明主机。CIDR 把前缀都相同的连续的 IP 地址组成一个“CIDR 地址块”，IP 地址分配都以 CIDR 地址块为单位。</li>\n<li>网际控制报文协议是 IP 层的协议。ICMP 报文作为 IP 数据报的数据，加上首部后组成 IP 数据报发送出去。使用 ICMP 数据报并不是为了实现可靠传输。ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告。ICMP 报文的种类有两种，即 ICMP 差错报告报文和 ICMP 询问报文。</li>\n<li><strong>要解决 IP 地址耗尽的问题，最根本的办法是采用具有更大地址空间的新版本 IP 协议-IPv6。</strong> IPv6 所带来的变化有 ① 更大的地址空间（采用 128 位地址）② 灵活的首部格式 ③ 改进的选项 ④ 支持即插即用 ⑤ 支持资源的预分配 ⑥IPv6 的首部改为 8 字节对齐。</li>\n<li><strong>虚拟专用网络 VPN 利用公用的互联网作为本机构专用网之间的通信载体。VPN 内使用互联网的专用地址。一个 VPN 至少要有一个路由器具有合法的全球 IP 地址，这样才能和本系统的另一个 VPN 通过互联网进行通信。所有通过互联网传送的数据都需要加密。</strong></li>\n<li>MPLS 的特点是：① 支持面向连接的服务质量 ② 支持流量工程，平衡网络负载 ③ 有效的支持虚拟专用网 VPN。MPLS 在入口节点给每一个 IP 数据报打上固定长度的“标记”，然后根据标记在第二层（链路层）用硬件进行转发（在标记交换路由器中进行标记交换），因而转发速率大大加快。</li>\n</ol>\n<h2> 5. 传输层（Transport Layer）</h2>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/09eb87a29bed99775ef5bde5eb216971.png\" alt=\"传输层\"></p>\n<h3> 5.1. 基本术语</h3>\n<ol>\n<li><strong>进程（process）</strong> ：指计算机中正在运行的程序实体。</li>\n<li><strong>应用进程互相通信</strong> ：一台主机的进程和另一台主机中的一个进程交换数据的过程（另外注意通信真正的端点不是主机而是主机中的进程，也就是说端到端的通信是应用进程之间的通信）。</li>\n<li><strong>传输层的复用与分用</strong> ：复用指发送方不同的进程都可以通过同一个运输层协议传送数据。分用指接收方的运输层在剥去报文的首部后能把这些数据正确的交付到目的应用进程。</li>\n<li><strong>TCP（Transmission Control Protocol）</strong> ：传输控制协议。</li>\n<li><strong>UDP（User Datagram Protocol）</strong> ：用户数据报协议。</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/2bd5bf90676c338864807ade87b7bdea.png\" alt=\"TCP和UDP\"></p>\n<ol start=\"6\">\n<li><strong>端口（port）</strong> ：端口的目的是为了确认对方机器的哪个进程在与自己进行交互，比如 MSN 和 QQ 的端口不同，如果没有端口就可能出现 QQ 进程和 MSN 交互错误。端口又称协议端口号。</li>\n<li><strong>停止等待协议（stop-and-wait）</strong> ：指发送方每发送完一个分组就停止发送，等待对方确认，在收到确认之后在发送下一个分组。</li>\n<li><strong>流量控制</strong> : 就是让发送方的发送速率不要太快，既要让接收方来得及接收，也不要使网络发生拥塞。</li>\n<li><strong>拥塞控制</strong> ：防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。</li>\n</ol>\n<h3> 5.2. 重要知识点总结</h3>\n<ol>\n<li><strong>运输层提供应用进程之间的逻辑通信，也就是说，运输层之间的通信并不是真正在两个运输层之间直接传输数据。运输层向应用层屏蔽了下面网络的细节（如网络拓补，所采用的路由选择协议等），它使应用进程之间看起来好像两个运输层实体之间有一条端到端的逻辑通信信道。</strong></li>\n<li><strong>网络层为主机提供逻辑通信，而运输层为应用进程之间提供端到端的逻辑通信。</strong></li>\n<li>运输层的两个重要协议是用户数据报协议 UDP 和传输控制协议 TCP。按照 OSI 的术语，两个对等运输实体在通信时传送的数据单位叫做运输协议数据单元 TPDU（Transport Protocol Data Unit）。但在 TCP/IP 体系中，则根据所使用的协议是 TCP 或 UDP，分别称之为 TCP 报文段或 UDP 用户数据报。</li>\n<li><strong>UDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 确是一种最有效的工作方式。 TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的传输服务，难以避免地增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。</strong></li>\n<li>硬件端口是不同硬件设备进行交互的接口，而软件端口是应用层各种协议进程与运输实体进行层间交互的一种地址。UDP 和 TCP 的首部格式中都有源端口和目的端口这两个重要字段。当运输层收到 IP 层交上来的运输层报文时，就能够根据其首部中的目的端口号把数据交付应用层的目的应用层。（两个进程之间进行通信不光要知道对方 IP 地址而且要知道对方的端口号(为了找到对方计算机中的应用进程)）</li>\n<li>运输层用一个 16 位端口号标志一个端口。端口号只有本地意义，它只是为了标志计算机应用层中的各个进程在和运输层交互时的层间接口。在互联网的不同计算机中，相同的端口号是没有关联的。协议端口号简称端口。虽然通信的终点是应用进程，但只要把所发送的报文交到目的主机的某个合适端口，剩下的工作（最后交付目的进程）就由 TCP 和 UDP 来完成。</li>\n<li>运输层的端口号分为服务器端使用的端口号（0˜1023 指派给熟知端口，1024˜49151 是登记端口号）和客户端暂时使用的端口号（49152˜65535）</li>\n<li><strong>UDP 的主要特点是 ① 无连接 ② 尽最大努力交付 ③ 面向报文 ④ 无拥塞控制 ⑤ 支持一对一，一对多，多对一和多对多的交互通信 ⑥ 首部开销小（只有四个字段：源端口，目的端口，长度和检验和）</strong></li>\n<li><strong>TCP 的主要特点是 ① 面向连接 ② 每一条 TCP 连接只能是一对一的 ③ 提供可靠交付 ④ 提供全双工通信 ⑤ 面向字节流</strong></li>\n<li><strong>TCP 用主机的 IP 地址加上主机上的端口号作为 TCP 连接的端点。这样的端点就叫做套接字（socket）或插口。套接字用（IP 地址：端口号）来表示。每一条 TCP 连接唯一地被通信两端的两个端点所确定。</strong></li>\n<li>停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</li>\n<li>为了提高传输效率，发送方可以不使用低效率的停止等待协议，而是采用流水线传输。流水线传输就是发送方可连续发送多个分组，不必每发完一个分组就停下来等待对方确认。这样可使信道上一直有数据不间断的在传送。这种传输方式可以明显提高信道利用率。</li>\n<li>停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为自动重传请求 ARQ。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。连续 ARQ 协议可提高信道利用率。发送维持一个发送窗口，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组位置的所有分组都已经正确收到了。</li>\n<li>TCP 报文段的前 20 个字节是固定的，其后有 40 字节长度的可选字段。如果加入可选字段后首部长度不是 4 的整数倍字节，需要在再在之后用 0 填充。因此，TCP 首部的长度取值为 20+4n 字节,最长为 60 字节。</li>\n<li><strong>TCP 使用滑动窗口机制。发送窗口里面的序号表示允许发送的序号。发送窗口后沿的后面部分表示已发送且已收到确认，而发送窗口前沿的前面部分表示不允许发送。发送窗口后沿的变化情况有两种可能，即不动（没有收到新的确认）和前移（收到了新的确认）。发送窗口的前沿通常是不断向前移动的。一般来说，我们总是希望数据传输更快一些。但如果发送方把数据发送的过快，接收方就可能来不及接收，这就会造成数据的丢失。所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。</strong></li>\n<li>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</li>\n<li><strong>为了进行拥塞控制，TCP 发送方要维持一个拥塞窗口 cwnd 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</strong></li>\n<li><strong>TCP 的拥塞控制采用了四种算法，即慢开始，拥塞避免，快重传和快恢复。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。</strong></li>\n<li>运输连接的三个阶段，即：连接建立，数据传送和连接释放。</li>\n<li><strong>主动发起 TCP 连接建立的应用进程叫做客户，而被动等待连接建立的应用进程叫做服务器。TCP 连接采用三报文握手机制。服务器要确认用户的连接请求，然后客户要对服务器的确认进行确认。</strong></li>\n<li>TCP 的连接释放采用四报文握手机制。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送时，则发送连接释放通知，对方确认后就完全关闭了 TCP 连接</li>\n</ol>\n<h3> 5.3. 补充（重要）</h3>\n<p>以下知识点需要重点关注：</p>\n<ol>\n<li>端口和套接字的意义</li>\n<li>UDP 和 TCP 的区别以及两者的应用场景</li>\n<li>在不可靠的网络上实现可靠传输的工作原理，停止等待协议和 ARQ 协议</li>\n<li>TCP 的滑动窗口，流量控制，拥塞控制和连接管理</li>\n<li>TCP 的三次握手，四次挥手机制</li>\n</ol>\n<h2> 6. 应用层（Application Layer）</h2>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/3ff57c0632bc7f4017723b1d1b7d3a52.png\" alt=\"应用层\"></p>\n<h3> 6.1. 基本术语</h3>\n<ol>\n<li><strong>域名系统（DNS）</strong> ：域名系统（DNS，Domain Name System）将人类可读的域名 (例如，www.baidu.com) 转换为机器可读的 IP 地址 (例如，220.181.38.148)。我们可以将其理解为专为互联网设计的电话薄。</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/6af26a3293530061785df50e70d53e07.png\" alt=\"\"></p>\n<p style=\"text-align:right;font-size:12px\">https://www.seobility.net/en/wiki/HTTP_headers</p>\n<ol start=\"2\">\n<li><strong>文件传输协议（FTP）</strong> ：FTP 是 File Transfer Protocol（文件传输协议）的英文简称，而中文简称为“文传协议”。用于 Internet 上的控制文件的双向传输。同时，它也是一个应用程序（Application）。基于不同的操作系统有不同的 FTP 应用程序，而所有这些应用程序都遵守同一种协议以传输文件。在 FTP 的使用当中，用户经常遇到两个概念：\"下载\"（Download）和\"上传\"（Upload）。 \"下载\"文件就是从远程主机拷贝文件至自己的计算机上；\"上传\"文件就是将文件从自己的计算机中拷贝至远程主机上。用 Internet 语言来说，用户可通过客户机程序向（从）远程主机上传（下载）文件。</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/3f1abf8adba4aa317eca69c489e3db23.png\" alt=\"FTP工作过程\"></p>\n<ol start=\"3\">\n<li><strong>简单文件传输协议（TFTP）</strong> ：TFTP（Trivial File Transfer Protocol,简单文件传输协议）是 TCP/IP 协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。端口号为 69。</li>\n<li><strong>远程终端协议（TELNET）</strong> ：Telnet 协议是 TCP/IP 协议族中的一员，是 Internet 远程登陆服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的能力。在终端使用者的电脑上使用 telnet 程序，用它连接到服务器。终端使用者可以在 telnet 程序中输入命令，这些命令会在服务器上运行，就像直接在服务器的控制台上输入一样。可以在本地就能控制服务器。要开始一个 telnet 会话，必须输入用户名和密码来登录服务器。Telnet 是常用的远程控制 Web 服务器的方法。</li>\n<li><strong>万维网（WWW）</strong> ：WWW 是环球信息网的缩写，（亦作“Web”、“WWW”、“'W3'”，英文全称为“World Wide Web”），中文名字为“万维网”，\"环球网\"等，常简称为 Web。分为 Web 客户端和 Web 服务器程序。WWW 可以让 Web 客户端（常用浏览器）访问浏览 Web 服务器上的页面。是一个由许多互相链接的超文本组成的系统，通过互联网访问。在这个系统中，每个有用的事物，称为一样“资源”；并且由一个全局“统一资源标识符”（URI）标识；这些资源通过超文本传输协议（Hypertext Transfer Protocol）传送给用户，而后者通过点击链接来获得资源。万维网联盟（英语：World Wide Web Consortium，简称 W3C），又称 W3C 理事会。1994 年 10 月在麻省理工学院（MIT）计算机科学实验室成立。万维网联盟的创建者是万维网的发明者蒂姆·伯纳斯-李。万维网并不等同互联网，万维网只是互联网所能提供的服务其中之一，是靠着互联网运行的一项服务。</li>\n<li><strong>万维网的大致工作工程：</strong></li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/735f55501e81898aa61b8032f7dbcb73.png\" alt=\"万维网的大致工作工程\"></p>\n<ol start=\"7\">\n<li><strong>统一资源定位符（URL）</strong> ：统一资源定位符是对可以从互联网上得到的资源的位置和访问方法的一种简洁的表示，是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的 URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。</li>\n<li><strong>超文本传输协议（HTTP）</strong> ：超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的 WWW 文件都必须遵守这个标准。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。1960 年美国人 Ted Nelson 构思了一种通过计算机处理文本信息的方法，并称之为超文本（hypertext）,这成为了 HTTP 超文本传输协议标准架构的发展根基。</li>\n</ol>\n<p>HTTP 协议的本质就是一种浏览器与服务器之间约定好的通信格式。HTTP 的原理如下图所示：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/b273efef5f2388e26414135672b00295.png\" alt=\"\"></p>\n<ol start=\"10\">\n<li><strong>代理服务器（Proxy Server）</strong> ： 代理服务器（Proxy Server）是一种网络实体，它又称为万维网高速缓存。 代理服务器把最近的一些请求和响应暂存在本地磁盘中。当新请求到达时，若代理服务器发现这个请求与暂时存放的的请求相同，就返回暂存的响应，而不需要按 URL 的地址再次去互联网访问该资源。代理服务器可在客户端或服务器工作，也可以在中间系统工作。</li>\n<li><strong>简单邮件传输协议(SMTP)</strong> : SMTP（Simple Mail Transfer Protocol）即简单邮件传输协议,它是一组用于由源地址到目的地址传送邮件的规则，由它来控制信件的中转方式。 SMTP 协议属于 TCP/IP 协议簇，它帮助每台计算机在发送或中转信件时找到下一个目的地。 通过 SMTP 协议所指定的服务器,就可以把 E-mail 寄到收信人的服务器上了，整个过程只要几分钟。SMTP 服务器则是遵循 SMTP 协议的发送邮件服务器，用来发送或中转发出的电子邮件。</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/b16da4d4fea63de5fce53f54973967d7.png\" alt=\"一个电子邮件被发送的过程\"></p>\n<p style=\"text-align:right;font-size:12px\">https://www.campaignmonitor.com/resources/knowledge-base/what-is-the-code-that-makes-bcc-or-cc-operate-in-an-email/</p>\n<ol start=\"11\">\n<li><strong>搜索引擎</strong> :搜索引擎（Search Engine）是指根据一定的策略、运用特定的计算机程序从互联网上搜集信息，在对信息进行组织和处理后，为用户提供检索服务，将用户检索相关的信息展示给用户的系统。搜索引擎包括全文索引、目录索引、元搜索引擎、垂直搜索引擎、集合式搜索引擎、门户搜索引擎与免费链接列表等。</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/68fe865a9d87de361c45f4a42d624035.png\" alt=\"搜索引擎\"></p>\n<ol start=\"12\">\n<li><strong>垂直搜索引擎</strong> ：垂直搜索引擎是针对某一个行业的专业搜索引擎，是搜索引擎的细分和延伸，是对网页库中的某类专门的信息进行一次整合，定向分字段抽取出需要的数据进行处理后再以某种形式返回给用户。垂直搜索是相对通用搜索引擎的信息量大、查询不准确、深度不够等提出来的新的搜索引擎服务模式，通过针对某一特定领域、某一特定人群或某一特定需求提供的有一定价值的信息和相关服务。其特点就是“专、精、深”，且具有行业色彩，相比较通用搜索引擎的海量信息无序化，垂直搜索引擎则显得更加专注、具体和深入。</li>\n<li><strong>全文索引</strong> :全文索引技术是目前搜索引擎的关键技术。试想在 1M 大小的文件中搜索一个词，可能需要几秒，在 100M 的文件中可能需要几十秒，如果在更大的文件中搜索那么就需要更大的系统开销，这样的开销是不现实的。所以在这样的矛盾下出现了全文索引技术，有时候有人叫倒排文档技术。</li>\n<li><strong>目录索引</strong> ：目录索引（ search index/directory)，顾名思义就是将网站分门别类地存放在相应的目录中，因此用户在查询信息时，可选择关键词搜索，也可按分类目录逐层查找。</li>\n</ol>\n<h3> 6.2. 重要知识点总结</h3>\n<ol>\n<li>文件传输协议（FTP）使用 TCP 可靠的运输服务。FTP 使用客户服务器方式。一个 FTP 服务器进程可以同时为多个用户提供服务。在进行文件传输时，FTP 的客户和服务器之间要先建立两个并行的 TCP 连接:控制连接和数据连接。实际用于传输文件的是数据连接。</li>\n<li>万维网客户程序与服务器之间进行交互使用的协议是超文本传输协议 HTTP。HTTP 使用 TCP 连接进行可靠传输。但 HTTP 本身是无连接、无状态的。HTTP/1.1 协议使用了持续连接（分为非流水线方式和流水线方式）</li>\n<li>电子邮件把邮件发送到收件人使用的邮件服务器，并放在其中的收件人邮箱中，收件人可随时上网到自己使用的邮件服务器读取，相当于电子邮箱。</li>\n<li>一个电子邮件系统有三个重要组成构件：用户代理、邮件服务器、邮件协议（包括邮件发送协议，如 SMTP，和邮件读取协议，如 POP3 和 IMAP）。用户代理和邮件服务器都要运行这些协议。</li>\n</ol>\n<h3> 6.3. 补充（重要）</h3>\n<p>以下知识点需要重点关注：</p>\n<ol>\n<li>应用层的常见协议（重点关注 HTTP 协议）</li>\n<li>域名系统-从域名解析出 IP 地址</li>\n<li>访问一个网站大致的过程</li>\n<li>系统调用和应用编程接口概念</li>\n</ol>\n",
      "image": "https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/network/computer-network-xiexiren.png",
      "date_published": "2022-08-13T15:23:13.000Z",
      "date_modified": "2022-10-13T07:37:00.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "计算机基础"
      ]
    },
    {
      "title": "TCP 三次握手和四次挥手（传输层）",
      "url": "https://javaguide.cn/cs-basics/network/tcp-connection-and-disconnection.html",
      "id": "https://javaguide.cn/cs-basics/network/tcp-connection-and-disconnection.html",
      "summary": "为了准确无误地把数据送达目标处，TCP 协议采用了三次握手策略。 建立连接-TCP 三次握手 建立一个 TCP 连接需要“三次握手”，缺一不可 ： 一次握手:客户端发送带有 SYN（SEQ=x） 标志的数据包 -&gt; 服务端，然后客户端进入 SYN_SEND 状态，等待服务器的确认； 二次握手:服务端发送带有 SYN+ACK(SEQ=y,ACK=x+1) 标志的数据包 –&gt; 客户端,然后服务端进入 SYN_RECV 状态 三次握手:客户端发送带有 ACK(ACK=y+1) 标志的数据包 –&gt; 服务端，然后客户端和服务器端都进入ESTABLISHED 状态，完成TCP三次握手。",
      "content_html": "<p>为了准确无误地把数据送达目标处，TCP 协议采用了三次握手策略。</p>\n<h2> 建立连接-TCP 三次握手</h2>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/network/tcp-shakes-hands-three-times.png\" alt=\"TCP 三次握手图解\"></p>\n<p>建立一个 TCP 连接需要“三次握手”，缺一不可 ：</p>\n<ul>\n<li><strong>一次握手</strong>:客户端发送带有 SYN（SEQ=x） 标志的数据包 -&gt; 服务端，然后客户端进入 <strong>SYN_SEND</strong> 状态，等待服务器的确认；</li>\n<li><strong>二次握手</strong>:服务端发送带有 SYN+ACK(SEQ=y,ACK=x+1) 标志的数据包 –&gt; 客户端,然后服务端进入 <strong>SYN_RECV</strong> 状态</li>\n<li><strong>三次握手</strong>:客户端发送带有 ACK(ACK=y+1) 标志的数据包 –&gt; 服务端，然后客户端和服务器端都进入<strong>ESTABLISHED</strong> 状态，完成TCP三次握手。</li>\n</ul>\n<p><strong>当建立了 3 次握手之后，客户端和服务端就可以传输数据啦！</strong></p>\n<h3> 为什么要三次握手?</h3>\n<p>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。</p>\n<ol>\n<li><strong>第一次握手</strong> ：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常</li>\n<li><strong>第二次握手</strong> ：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常</li>\n<li><strong>第三次握手</strong> ：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常</li>\n</ol>\n<p>三次握手就能确认双方收发功能都正常，缺一不可。</p>\n<p>更详细的解答可以看这个：<a href=\"https://www.zhihu.com/question/24853633/answer/115173386\" target=\"_blank\" rel=\"noopener noreferrer\">TCP 为什么是三次握手，而不是两次或四次？ - 车小胖的回答 - 知乎</a>  。</p>\n<h3> 第2次握手传回了ACK，为什么还要传回SYN？</h3>\n<p>服务端传回发送端所发送的 ACK 是为了告诉客户端：“我接收到的信息确实就是你所发送的信号了”，这表明从客户端到服务端的通信是正常的。回传 SYN 则是为了建立并确认从服务端到客户端的通信。</p>\n<blockquote>\n<p>SYN 同步序列编号(Synchronize Sequence Numbers) 是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement）消息响应。这样在客户机和服务器之间才能建立起可靠的 TCP 连接，数据才可以在客户机和服务器之间传递。</p>\n</blockquote>\n<h2> 断开连接-TCP 四次挥手</h2>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/network/tcp-waves-four-times.png\" alt=\"TCP 四次挥手图解\"></p>\n<p>断开一个 TCP 连接则需要“四次挥手”，缺一不可 ：</p>\n<ol>\n<li><strong>第一次挥手</strong> ：客户端发送一个 FIN（SEQ=X） 标志的数据包-&gt;服务端，用来关闭客户端到服务器的数据传送。然后，客户端进入 <strong>FIN-WAIT-1</strong> 状态。</li>\n<li><strong>第二次挥手</strong> ：服务器收到这个 FIN（SEQ=X） 标志的数据包，它发送一个 ACK （SEQ=X+1）标志的数据包-&gt;客户端 。然后，此时服务端进入<strong>CLOSE-WAIT</strong>状态，客户端进入<strong>FIN-WAIT-2</strong>状态。</li>\n<li><strong>第三次挥手</strong> ：服务端关闭与客户端的连接并发送一个 FIN (SEQ=y)标志的数据包-&gt;客户端请求关闭连接，然后，服务端进入<strong>LAST-ACK</strong>状态。</li>\n<li><strong>第四次挥手</strong> ：客户端发送 ACK (SEQ=y+1)标志的数据包-&gt;服务端并且进入<strong>TIME-WAIT</strong>状态，服务端在收到 ACK (SEQ=y+1)标志的数据包后进入 CLOSE 状态。此时，如果客户端等待 <strong>2MSL</strong> 后依然没有收到回复，就证明服务端已正常关闭，随后，客户端也可以关闭连接了。</li>\n</ol>\n<p><strong>只要四次挥手没有结束，客户端和服务端就可以继续传输数据！</strong></p>\n<h3> 为什么要四次挥手？</h3>\n<p>TCP是全双工通信，可以双向传输数据。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 TCP 连接。</p>\n<p>举个例子：A 和 B 打电话，通话即将结束后。</p>\n<ol>\n<li><strong>第一次挥手</strong> ： A 说“我没啥要说的了”</li>\n<li><strong>第二次挥手</strong> ：B 回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话</li>\n<li><strong>第三次挥手</strong> ：于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”</li>\n<li><strong>第四次挥手</strong> ：A 回答“知道了”，这样通话才算结束。</li>\n</ol>\n<h3> 为什么不能把服务器发送的 ACK 和 FIN 合并起来，变成三次挥手？</h3>\n<p>因为服务器收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复 ACK，表示接收到了断开连接的请求。等到数据发完之后再发 FIN，断开服务器到客户端的数据传送。</p>\n<h3> 如果第二次挥手时服务器的 ACK 没有送达客户端，会怎样？</h3>\n<p>客户端没有收到 ACK 确认，会重新发送 FIN 请求。</p>\n<h3> 为什么第四次挥手客户端需要等待 2*MSL（报文段最长寿命）时间后才进入 CLOSED 状态？</h3>\n<p>第四次挥手时，客户端发送给服务器的 ACK 有可能丢失，如果服务端因为某些原因而没有收到 ACK 的话，服务端就会重发 FIN，如果客户端在 2*MSL 的时间内收到了 FIN，就会重新发送 ACK 并再次等待 2MSL，防止 Server 没有收到 ACK 而不断重发 FIN。</p>\n<blockquote>\n<p><strong>MSL(Maximum Segment Lifetime)</strong> : 一个片段在网络中最大的存活时间，2MSL 就是一个发送和一个回复所需的最大时间。如果直到 2MSL，Client 都没有再次收到 FIN，那么 Client 推断 ACK 已经被成功接收，则结束 TCP 连接。</p>\n</blockquote>\n<h2> 参考</h2>\n<ul>\n<li>\n<p>《计算机网络（第 7 版）》</p>\n</li>\n<li>\n<p>《图解 HTTP》</p>\n</li>\n<li>\n<p>TCP and UDP Tutorial：https://www.9tut.com/tcp-and-udp-tutorial</p>\n</li>\n</ul>\n",
      "image": "https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/network/tcp-shakes-hands-three-times.png",
      "date_published": "2022-08-13T14:50:48.000Z",
      "date_modified": "2023-02-14T08:37:37.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "计算机基础"
      ]
    },
    {
      "title": "JMM（Java 内存模型）详解",
      "url": "https://javaguide.cn/java/concurrent/jmm.html",
      "id": "https://javaguide.cn/java/concurrent/jmm.html",
      "summary": "JMM(Java内存模型)主要定义了对于一个共享变量，当另一个线程对这个共享变量执行写操作后，这个线程对这个共享变量的可见性。 要想理解透彻 JMM（Java 内存模型），我们先要从 CPU 缓存模型和指令重排序 说起！ 从 CPU 缓存模型说起 为什么要弄一个 CPU 高速缓存呢？ 类比我们开发网站后台系统使用的缓存（比如 Redis）是为了解决程序处理速度和访问常规关系型数据库速度不对等的问题。 CPU 缓存则是为了解决 CPU 处理速度和内存处理速度不对等的问题。",
      "content_html": "<p>JMM(Java内存模型)主要定义了对于一个共享变量，当另一个线程对这个共享变量执行写操作后，这个线程对这个共享变量的可见性。</p>\n<p>要想理解透彻 JMM（Java 内存模型），我们先要从 <strong>CPU 缓存模型和指令重排序</strong> 说起！</p>\n<h2> 从 CPU 缓存模型说起</h2>\n<p><strong>为什么要弄一个 CPU 高速缓存呢？</strong> 类比我们开发网站后台系统使用的缓存（比如 Redis）是为了解决程序处理速度和访问常规关系型数据库速度不对等的问题。 <strong>CPU 缓存则是为了解决 CPU 处理速度和内存处理速度不对等的问题。</strong></p>\n<p>我们甚至可以把 <strong>内存看作外存的高速缓存</strong>，程序运行的时候我们把外存的数据复制到内存，由于内存的处理速度远远高于外存，这样提高了处理速度。</p>\n<p>总结：<strong>CPU Cache 缓存的是内存数据用于解决 CPU 处理速度和内存不匹配的问题，内存缓存的是硬盘数据用于解决硬盘访问速度过慢的问题。</strong></p>\n<p>为了更好地理解，我画了一个简单的 CPU Cache 示意图如下所示。</p>\n<blockquote>\n<p><strong>🐛 修正（参见： <a href=\"https://github.com/Snailclimb/JavaGuide/issues/1848\" target=\"_blank\" rel=\"noopener noreferrer\">issue#1848</a>）</strong>：对 CPU 缓存模型绘图不严谨的地方进行完善。</p>\n</blockquote>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/concurrent/cpu-cache.png\" alt=\"CPU 缓存模型示意图\"></p>\n<p>现代的 CPU Cache 通常分为三层，分别叫 L1,L2,L3 Cache。有些 CPU 可能还有 L4 Cache，这里不做讨论，并不常见</p>\n<p><strong>CPU Cache 的工作方式：</strong> 先复制一份数据到 CPU Cache 中，当 CPU 需要用到的时候就可以直接从 CPU Cache 中读取数据，当运算完成后，再将运算得到的数据写回 Main Memory 中。但是，这样存在 <strong>内存缓存不一致性的问题</strong> ！比如我执行一个 i++ 操作的话，如果两个线程同时执行的话，假设两个线程从 CPU Cache 中读取的 i=1，两个线程做了 1++ 运算完之后再写回 Main Memory 之后 i=2，而正确结果应该是 i=3。</p>\n<p><strong>CPU 为了解决内存缓存不一致性问题可以通过制定缓存一致协议（比如 <a href=\"https://zh.wikipedia.org/wiki/MESI%E5%8D%8F%E8%AE%AE\" target=\"_blank\" rel=\"noopener noreferrer\">MESI 协议</a>）或者其他手段来解决。</strong> 这个缓存一致性协议指的是在 CPU 高速缓存与主内存交互的时候需要遵守的原则和规范。不同的 CPU 中，使用的缓存一致性协议通常也会有所不同。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/concurrent/cpu-cache-protocol.png\" alt=\"缓存一致性协议\"></p>\n<p>我们的程序运行在操作系统之上，操作系统屏蔽了底层硬件的操作细节，将各种硬件资源虚拟化。于是，操作系统也就同样需要解决内存缓存不一致性问题。</p>\n<p>操作系统通过 <strong>内存模型（Memory Model）</strong> 定义一系列规范来解决这个问题。无论是 Windows 系统，还是 Linux 系统，它们都有特定的内存模型。</p>\n<h2> 指令重排序</h2>\n<p>说完了 CPU 缓存模型，我们再来看看另外一个比较重要的概念 <strong>指令重排序</strong> 。</p>\n<p>为了提升执行速度/性能，计算机在执行程序代码的时候，会对指令进行重排序。</p>\n<p><strong>什么是指令重排序？</strong> 简单来说就是系统在执行代码的时候并不一定是按照你写的代码的顺序依次执行。</p>\n<p>常见的指令重排序有下面 2 种情况：</p>\n<ul>\n<li><strong>编译器优化重排</strong> ：编译器（包括 JVM、JIT 编译器等）在不改变单线程程序语义的前提下，重新安排语句的执行顺序。</li>\n<li><strong>指令并行重排</strong> ：现代处理器采用了指令级并行技术(Instruction-Level Parallelism，ILP)来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li>\n</ul>\n<p>另外，内存系统也会有“重排序”，但又不是真正意义上的重排序。在 JMM 里表现为主存和本地内存的内容可能不一致，进而导致程序在多线程下执行可能出现问题。</p>\n<p>Java 源代码会经历 <strong>编译器优化重排 —&gt; 指令并行重排 —&gt; 内存系统重排</strong> 的过程，最终才变成操作系统可执行的指令序列。</p>\n<p><strong>指令重排序可以保证串行语义一致，但是没有义务保证多线程间的语义也一致</strong> ，所以在多线程下，指令重排序可能会导致一些问题。</p>\n<p>编译器和处理器的指令重排序的处理方式不一样。对于编译器，通过禁止特定类型的编译器重排序的方式来禁止重排序。对于处理器，通过插入内存屏障（Memory Barrier，或有时叫做内存栅栏，Memory Fence）的方式来禁止特定类型的处理器重排序。指令并行重排和内存系统重排都属于是处理器级别的指令重排序。</p>\n<blockquote>\n<p>内存屏障（Memory Barrier，或有时叫做内存栅栏，Memory Fence）是一种 CPU 指令，用来禁止处理器指令发生重排序（像屏障一样），从而保障指令执行的有序性。另外，为了达到屏障的效果，它也会使处理器写入、读取值之前，将主内存的值写入高速缓存，清空无效队列，从而保障变量的可见性。</p>\n</blockquote>\n<h2> JMM(Java Memory Model)</h2>\n<h3> 什么是 JMM？为什么需要 JMM？</h3>\n<p>Java 是最早尝试提供内存模型的编程语言。由于早期内存模型存在一些缺陷（比如非常容易削弱编译器的优化能力），从 Java5 开始，Java 开始使用新的内存模型 <a href=\"http://www.cs.umd.edu/~pugh/java/memoryModel/CommunityReview.pdf\" target=\"_blank\" rel=\"noopener noreferrer\">《JSR-133：Java Memory Model and Thread Specification》</a> 。</p>\n<p>一般来说，编程语言也可以直接复用操作系统层面的内存模型。不过，不同的操作系统内存模型不同。如果直接复用操作系统层面的内存模型，就可能会导致同样一套代码换了一个操作系统就无法执行了。Java 语言是跨平台的，它需要自己提供一套内存模型以屏蔽系统差异。</p>\n<p>这只是 JMM 存在的其中一个原因。实际上，对于 Java 来说，你可以把 JMM 看作是 Java 定义的并发编程相关的一组规范，除了抽象了线程和主内存之间的关系之外，其还规定了从 Java 源代码到 CPU 可执行指令的这个转化过程要遵守哪些和并发相关的原则和规范，其主要目的是为了简化多线程编程，增强程序可移植性的。</p>\n<p><strong>为什么要遵守这些并发相关的原则和规范呢？</strong> 这是因为并发编程下，像 CPU 多级缓存和指令重排这类设计可能会导致程序运行出现一些问题。就比如说我们上面提到的指令重排序就可能会让多线程程序的执行出现问题，为此，JMM 抽象了 happens-before 原则（后文会详细介绍到）来解决这个指令重排序问题。</p>\n<p>JMM 说白了就是定义了一些规范来解决这些问题，开发者可以利用这些规范更方便地开发多线程程序。对于 Java 开发者说，你不需要了解底层原理，直接使用并发相关的一些关键字和类（比如 <code>volatile</code>、<code>synchronized</code>、各种 <code>Lock</code>）即可开发出并发安全的程序。</p>\n<h3> JMM 是如何抽象线程和主内存之间的关系？</h3>\n<p><strong>Java 内存模型（JMM）</strong> 抽象了线程和主内存之间的关系，就比如说线程之间的共享变量必须存储在主内存中。</p>\n<p>在 JDK1.2 之前，Java 的内存模型实现总是从 <strong>主存</strong> （即共享内存）读取变量，是不需要进行特别的注意的。而在当前的 Java 内存模型下，线程可以把变量保存 <strong>本地内存</strong> （比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成数据的不一致。</p>\n<p>这和我们上面讲到的 CPU 缓存模型非常相似。</p>\n<p><strong>什么是主内存？什么是本地内存？</strong></p>\n<ul>\n<li><strong>主内存</strong> ：所有线程创建的实例对象都存放在主内存中，不管该实例对象是成员变量还是方法中的本地变量(也称局部变量)</li>\n<li><strong>本地内存</strong> ：每个线程都有一个私有的本地内存来存储共享变量的副本，并且，每个线程只能访问自己的本地内存，无法访问其他线程的本地内存。本地内存是 JMM 抽象出来的一个概念，存储了主内存中的共享变量副本。</li>\n</ul>\n<p>Java 内存模型的抽象示意图如下：</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/concurrent/jmm.png\" alt=\"JMM(Java 内存模型)\"></p>\n<p>从上图来看，线程 1 与线程 2 之间如果要进行通信的话，必须要经历下面 2 个步骤：</p>\n<ol>\n<li>线程 1 把本地内存中修改过的共享变量副本的值同步到主内存中去。</li>\n<li>线程 2 到主存中读取对应的共享变量的值。</li>\n</ol>\n<p>也就是说，JMM 为共享变量提供了可见性的保障。</p>\n<p>不过，多线程下，对主内存中的一个共享变量进行操作有可能诱发线程安全问题。举个例子：</p>\n<ol>\n<li>线程 1 和线程 2 分别对同一个共享变量进行操作，一个执行修改，一个执行读取。</li>\n<li>线程 2 读取到的是线程 1 修改之前的值还是修改后的值并不确定，都有可能，因为线程 1 和线程 2 都是先将共享变量从主内存拷贝到对应线程的工作内存中。</li>\n</ol>\n<p>关于主内存与工作内存直接的具体交互协议，即一个变量如何从主内存拷贝到工作内存，如何从工作内存同步到主内存之间的实现细节，Java 内存模型定义来以下八种同步操作（了解即可，无需死记硬背）：</p>\n<ul>\n<li><strong>锁定（lock）</strong>: 作用于主内存中的变量，将他标记为一个线程独享变量。</li>\n<li><strong>解锁（unlock）</strong>: 作用于主内存中的变量，解除变量的锁定状态，被解除锁定状态的变量才能被其他线程锁定。</li>\n<li><strong>read（读取）</strong>：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的 load 动作使用。</li>\n<li><strong>load(载入)</strong>：把 read 操作从主内存中得到的变量值放入工作内存的变量的副本中。</li>\n<li><strong>use(使用)</strong>：把工作内存中的一个变量的值传给执行引擎，每当虚拟机遇到一个使用到变量的指令时都会使用该指令。</li>\n<li><strong>assign（赋值）</strong>：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li>\n<li><strong>store（存储）</strong>：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的 write 操作使用。</li>\n<li><strong>write（写入）</strong>：作用于主内存的变量，它把 store 操作从工作内存中得到的变量的值放入主内存的变量中。</li>\n</ul>\n<p>除了这 8 种同步操作之外，还规定了下面这些同步规则来保证这些同步操作的正确执行（了解即可，无需死记硬背）：</p>\n<ul>\n<li>不允许一个线程无原因地（没有发生过任何 assign 操作）把数据从线程的工作内存同步回主内存中。</li>\n<li>一个新的变量只能在主内存中 “诞生”，不允许在工作内存中直接使用一个未被初始化（load 或 assign）的变量，换句话说就是对一个变量实施 use 和 store 操作之前，必须先执行过了 assign 和 load 操作。</li>\n<li>一个变量在同一个时刻只允许一条线程对其进行 lock 操作，但 lock 操作可以被同一条线程重复执行多次，多次执行 lock 后，只有执行相同次数的 unlock 操作，变量才会被解锁。</li>\n<li>如果对一个变量执行 lock 操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行 load 或 assign 操作初始化变量的值。</li>\n<li>如果一个变量事先没有被 lock 操作锁定，则不允许对它执行 unlock 操作，也不允许去 unlock 一个被其他线程锁定住的变量。</li>\n<li>......</li>\n</ul>\n<h3> Java 内存区域和 JMM 有何区别？</h3>\n<p>这是一个比较常见的问题，很多初学者非常容易搞混。 <strong>Java 内存区域和内存模型是完全不一样的两个东西</strong> ：</p>\n<ul>\n<li>JVM 内存结构和 Java 虚拟机的运行时区域相关，定义了 JVM 在运行时如何分区存储程序数据，就比如说堆主要用于存放对象实例。</li>\n<li>Java 内存模型和 Java 的并发编程相关，抽象了线程和主内存之间的关系就比如说线程之间的共享变量必须存储在主内存中，规定了从 Java 源代码到 CPU 可执行指令的这个转化过程要遵守哪些和并发相关的原则和规范，其主要目的是为了简化多线程编程，增强程序可移植性的。</li>\n</ul>\n<h3> happens-before 原则是什么？</h3>\n<p>happens-before 这个概念最早诞生于 Leslie Lamport 于 1978 年发表的论文<a href=\"https://lamport.azurewebsites.net/pubs/time-clocks.pdf\" target=\"_blank\" rel=\"noopener noreferrer\">《Time，Clocks and the Ordering of Events in a Distributed System》</a>。在这篇论文中，Leslie Lamport 提出了<a href=\"https://writings.sh/post/logical-clocks\" target=\"_blank\" rel=\"noopener noreferrer\">逻辑时钟</a>的概念，这也成了第一个逻辑时钟算法 。在分布式环境中，通过一系列规则来定义逻辑时钟的变化，从而能通过逻辑时钟来对分布式系统中的事件的先后顺序进行判断。<strong>逻辑时钟并不度量时间本身，仅区分事件发生的前后顺序，其本质就是定义了一种 happens-before 关系。</strong></p>\n<p>上面提到的 happens-before 这个概念诞生的背景并不是重点，简单了解即可。</p>\n<p>JSR 133 引入了 happens-before 这个概念来描述两个操作之间的内存可见性。</p>\n<p><strong>为什么需要 happens-before 原则？</strong> happens-before 原则的诞生是为了程序员和编译器、处理器之间的平衡。程序员追求的是易于理解和编程的强内存模型，遵守既定规则编码即可。编译器和处理器追求的是较少约束的弱内存模型，让它们尽己所能地去优化性能，让性能最大化。happens-before 原则的设计思想其实非常简单：</p>\n<ul>\n<li>为了对编译器和处理器的约束尽可能少，只要不改变程序的执行结果（单线程程序和正确执行的多线程程序），编译器和处理器怎么进行重排序优化都行。</li>\n<li>对于会改变程序执行结果的重排序，JMM 要求编译器和处理器必须禁止这种重排序。</li>\n</ul>\n<p>下面这张是 《Java 并发编程的艺术》这本书中的一张 JMM 设计思想的示意图，非常清晰。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/concurrent/image-20220731155332375.png\" alt=\"\"></p>\n<p>了解了 happens-before 原则的设计思想，我们再来看看 JSR-133 对 happens-before 原则的定义：</p>\n<ul>\n<li>如果一个操作 happens-before 另一个操作，那么第一个操作的执行结果将对第二个操作可见，并且第一个操作的执行顺序排在第二个操作之前。</li>\n<li>两个操作之间存在 happens-before 关系，并不意味着 Java 平台的具体实现必须要按照 happens-before 关系指定的顺序来执行。如果重排序之后的执行结果，与按 happens-before 关系来执行的结果一致，那么 JMM 也允许这样的重排序。</li>\n</ul>\n<p>我们看下面这段代码：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>1 happens-before 2</li>\n<li>2 happens-before 3</li>\n<li>1 happens-before 3</li>\n</ul>\n<p>虽然 1 happens-before 2，但对 1 和 2 进行重排序不会影响代码的执行结果，所以 JMM 是允许编译器和处理器执行这种重排序的。但 1 和 2 必须是在 3 执行之前，也就是说 1,2 happens-before 3 。</p>\n<p><strong>happens-before 原则表达的意义其实并不是一个操作发生在另外一个操作的前面，虽然这从程序员的角度上来说也并无大碍。更准确地来说，它更想表达的意义是前一个操作的结果对于后一个操作是可见的，无论这两个操作是否在同一个线程里。</strong></p>\n<p>举个例子：操作 1 happens-before 操作 2，即使操作 1 和操作 2 不在同一个线程内，JMM 也会保证操作 1 的结果对操作 2 是可见的。</p>\n<h3> happens-before 常见规则有哪些？谈谈你的理解？</h3>\n<p>happens-before 的规则就 8 条，说多不多，重点了解下面列举的 5 条即可。全记是不可能的，很快就忘记了，意义不大，随时查阅即可。</p>\n<ol>\n<li><strong>程序顺序规则</strong> ：一个线程内，按照代码顺序，书写在前面的操作 happens-before 于书写在后面的操作；</li>\n<li><strong>解锁规则</strong> ：解锁 happens-before 于加锁；</li>\n<li><strong>volatile 变量规则</strong> ：对一个 volatile 变量的写操作 happens-before 于后面对这个 volatile 变量的读操作。说白了就是对 volatile 变量的写操作的结果对于发生于其后的任何操作都是可见的。</li>\n<li><strong>传递规则</strong> ：如果 A happens-before B，且 B happens-before C，那么 A happens-before C；</li>\n<li><strong>线程启动规则</strong> ：Thread 对象的 <code>start()</code>方法 happens-before 于此线程的每一个动作。</li>\n</ol>\n<p>如果两个操作不满足上述任意一个 happens-before 规则，那么这两个操作就没有顺序的保障，JVM 可以对这两个操作进行重排序。</p>\n<h3> happens-before 和 JMM 什么关系？</h3>\n<p>happens-before 与 JMM 的关系用《Java 并发编程的艺术》这本书中的一张图就可以非常好的解释清楚。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/concurrent/image-20220731084604667.png\" alt=\"happens-before 与 JMM 的关系\"></p>\n<h2> 再看并发编程三个重要特性</h2>\n<h3> 原子性</h3>\n<p>一次操作或者多次操作，要么所有的操作全部都得到执行并且不会受到任何因素的干扰而中断，要么都不执行。</p>\n<p>在 Java 中，可以借助<code>synchronized</code> 、各种 <code>Lock</code> 以及各种原子类实现原子性。</p>\n<p><code>synchronized</code> 和各种 <code>Lock</code> 可以保证任一时刻只有一个线程访问该代码块，因此可以保障原子性。各种原子类是利用 CAS (compare and swap) 操作（可能也会用到 <code>volatile</code>或者<code>final</code>关键字）来保证原子操作。</p>\n<h3> 可见性</h3>\n<p>当一个线程对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值。</p>\n<p>在 Java 中，可以借助<code>synchronized</code> 、<code>volatile</code> 以及各种 <code>Lock</code> 实现可见性。</p>\n<p>如果我们将变量声明为 <code>volatile</code> ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。</p>\n<h3> 有序性</h3>\n<p>由于指令重排序问题，代码的执行顺序未必就是编写代码时候的顺序。</p>\n<p>我们上面讲重排序的时候也提到过：</p>\n<blockquote>\n<p><strong>指令重排序可以保证串行语义一致，但是没有义务保证多线程间的语义也一致</strong> ，所以在多线程下，指令重排序可能会导致一些问题。</p>\n</blockquote>\n<p>在 Java 中，<code>volatile</code> 关键字可以禁止指令进行重排序优化。</p>\n<h2> 总结</h2>\n<ul>\n<li>Java 是最早尝试提供内存模型的语言，其主要目的是为了简化多线程编程，增强程序可移植性的。</li>\n<li>CPU 可以通过制定缓存一致协议（比如 <a href=\"https://zh.wikipedia.org/wiki/MESI%E5%8D%8F%E8%AE%AE\" target=\"_blank\" rel=\"noopener noreferrer\">MESI 协议</a>）来解决内存缓存不一致性问题。</li>\n<li>为了提升执行速度/性能，计算机在执行程序代码的时候，会对指令进行重排序。 简单来说就是系统在执行代码的时候并不一定是按照你写的代码的顺序依次执行。<strong>指令重排序可以保证串行语义一致，但是没有义务保证多线程间的语义也一致</strong> ，所以在多线程下，指令重排序可能会导致一些问题。</li>\n<li>你可以把 JMM 看作是 Java 定义的并发编程相关的一组规范，除了抽象了线程和主内存之间的关系之外，其还规定了从 Java 源代码到 CPU 可执行指令的这个转化过程要遵守哪些和并发相关的原则和规范，其主要目的是为了简化多线程编程，增强程序可移植性的。</li>\n<li>JSR 133 引入了 happens-before 这个概念来描述两个操作之间的内存可见性。</li>\n</ul>\n<h2> 参考</h2>\n<ul>\n<li>《Java 并发编程的艺术》第三章 Java 内存模型</li>\n<li>《深入浅出 Java 多线程》：http://concurrent.redspider.group/RedSpider.html</li>\n<li>Java 内存访问重排序的研究：https://tech.meituan.com/2014/09/23/java-memory-reordering.html</li>\n<li>嘿，同学，你要的 Java 内存模型 (JMM) 来了：https://xie.infoq.cn/article/739920a92d0d27e2053174ef2</li>\n<li>JSR 133 (Java Memory Model) FAQ：https://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html</li>\n</ul>\n",
      "image": "https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/concurrent/cpu-cache.png",
      "date_published": "2022-08-04T13:00:03.000Z",
      "date_modified": "2023-01-17T15:20:48.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "RabbitMQ常见面试题总结",
      "url": "https://javaguide.cn/high-performance/message-queue/rabbitmq-questions.html",
      "id": "https://javaguide.cn/high-performance/message-queue/rabbitmq-questions.html",
      "summary": "本篇文章由 JavaGuide 收集自网络，原出处不明。 RabbitMQ 是什么？ RabbitMQ 是一个在 AMQP（Advanced Message Queuing Protocol ）基础上实现的，可复用的企业消息系统。它可以用于大型软件系统各个模块之间的高效通信，支持高并发，支持可扩展。它支持多种客户端如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP等，支持AJAX，持久化，用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。",
      "content_html": "<blockquote>\n<p>本篇文章由 JavaGuide 收集自网络，原出处不明。</p>\n</blockquote>\n<h2> RabbitMQ 是什么？</h2>\n<p>RabbitMQ 是一个在 AMQP（Advanced Message Queuing Protocol ）基础上实现的，可复用的企业消息系统。它可以用于大型软件系统各个模块之间的高效通信，支持高并发，支持可扩展。它支持多种客户端如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP等，支持AJAX，持久化，用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。</p>\n<p>RabbitMQ是使用Erlang编写的一个开源的消息队列，本身支持很多的协议：AMQP，XMPP, SMTP, STOMP，也正是如此，使的它变的非常重量级，更适合于企业级的开发。它同时实现了一个Broker构架，这意味着消息在发送给客户端时先在中心队列排队，对路由(Routing)、负载均衡(Load balance)或者数据持久化都有很好的支持。</p>\n<p>PS:也可能直接问什么是消息队列？消息队列就是一个使用队列来通信的组件。</p>\n<h2> RabbitMQ 特点?</h2>\n<ul>\n<li><strong>可靠性</strong>: RabbitMQ 使用一些机制来保证可靠性， 如持久化、传输确认及发布确认等。</li>\n<li><strong>灵活的路由</strong> : 在消息进入队列之前，通过交换器来路由消息。对于典型的路由功能， RabbitMQ 己经提供了一些内置的交换器来实现。针对更复杂的路由功能，可以将多个 交换器绑定在一起， 也可以通过插件机制来实现自己的交换器。</li>\n<li><strong>扩展性</strong>: 多个 RabbitMQ 节点可以组成一个集群，也可以根据实际业务情况动态地扩展 集群中节点。</li>\n<li><strong>高可用性</strong> : 队列可以在集群中的机器上设置镜像，使得在部分节点出现问题的情况下队 列仍然可用。</li>\n<li><strong>多种协议</strong>: RabbitMQ 除了原生支持 AMQP 协议，还支持 STOMP， MQTT 等多种消息 中间件协议。</li>\n<li><strong>多语言客户端</strong> :RabbitMQ 几乎支持所有常用语言，比如 Java、 Python、 Ruby、 PHP、 C#、 JavaScript 等。</li>\n<li><strong>管理界面</strong> : RabbitMQ 提供了一个易用的用户界面，使得用户可以监控和管理消息、集 群中的节点等。</li>\n<li><strong>插件机制</strong> : RabbitMQ 提供了许多插件 ， 以实现从多方面进行扩展，当然也可以编写自 己的插件。</li>\n</ul>\n<h2> AMQP 是什么?</h2>\n<p>RabbitMQ 就是 AMQP 协议的 <code>Erlang</code> 的实现(当然 RabbitMQ 还支持 <code>STOMP2</code>、 <code>MQTT3</code> 等协议 ) AMQP 的模型架构 和 RabbitMQ 的模型架构是一样的，生产者将消息发送给交换器，交换器和队列绑定 。</p>\n<p>RabbitMQ 中的交换器、交换器类型、队列、绑定、路由键等都是遵循的 AMQP 协议中相 应的概念。目前 RabbitMQ 最新版本默认支持的是 AMQP 0-9-1。</p>\n<p><strong>AMQP 协议的三层</strong> ：</p>\n<ul>\n<li><strong>Module Layer</strong>:协议最高层，主要定义了一些客户端调用的命令，客户端可以用这些命令实现自己的业务逻辑。</li>\n<li><strong>Session Layer</strong>:中间层，主要负责客户端命令发送给服务器，再将服务端应答返回客户端，提供可靠性同步机制和错误处理。</li>\n<li><strong>TransportLayer</strong>:最底层，主要传输二进制数据流，提供帧的处理、信道服用、错误检测和数据表示等。</li>\n</ul>\n<p><strong>AMQP 模型的三大组件</strong> ：</p>\n<ul>\n<li><strong>交换器 (Exchange)</strong> ：消息代理服务器中用于把消息路由到队列的组件。</li>\n<li><strong>队列 (Queue)</strong> ：用来存储消息的数据结构，位于硬盘或内存中。</li>\n<li><strong>绑定 (Binding)</strong> ：一套规则，告知交换器消息应该将消息投递给哪个队列。</li>\n</ul>\n<h2> <strong>说说生产者 Producer 和消费者 Consumer?</strong></h2>\n<p><strong>生产者</strong> :</p>\n<ul>\n<li>消息生产者，就是投递消息的一方。</li>\n<li>消息一般包含两个部分：消息体（<code>payload</code>)和标签(<code>Label</code>)。</li>\n</ul>\n<p><strong>消费者</strong> ：</p>\n<ul>\n<li>消费消息，也就是接收消息的一方。</li>\n<li>消费者连接到 RabbitMQ 服务器，并订阅到队列上。消费消息时只消费消息体，丢弃标签。</li>\n</ul>\n<h2> 说说 Broker 服务节点、Queue 队列、Exchange 交换器？</h2>\n<ul>\n<li><strong>Broker</strong> ： 可以看做 RabbitMQ 的服务节点。一般请下一个 Broker 可以看做一个 RabbitMQ 服务器。</li>\n<li><strong>Queue</strong> :RabbitMQ 的内部对象，用于存储消息。多个消费者可以订阅同一队列，这时队列中的消息会被平摊（轮询）给多个消费者进行处理。</li>\n<li><strong>Exchange</strong> : 生产者将消息发送到交换器，由交换器将消息路由到一个或者多个队列中。当路由不到时，或返回给生产者或直接丢弃。</li>\n</ul>\n<h2> 什么是死信队列？如何导致的？</h2>\n<p>DLX，全称为 <code>Dead-Letter-Exchange</code>，死信交换器，死信邮箱。当消息在一个队列中变成死信 (<code>dead message</code>) 之后，它能被重新被发送到另一个交换器中，这个交换器就是 DLX，绑定 DLX 的队列就称之为死信队列。</p>\n<p><strong>导致的死信的几种原因</strong>：</p>\n<ul>\n<li>消息被拒（<code>Basic.Reject /Basic.Nack</code>) 且 <code>requeue = false</code>。</li>\n<li>消息 TTL 过期。</li>\n<li>队列满了，无法再添加。</li>\n</ul>\n<h2> 什么是延迟队列？RabbitMQ 怎么实现延迟队列？</h2>\n<p>延迟队列指的是存储对应的延迟消息，消息被发送以后，并不想让消费者立刻拿到消息，而是等待特定时间后，消费者才能拿到这个消息进行消费。</p>\n<p>RabbitMQ本身是没有延迟队列的，要实现延迟消息，一般有两种方式：</p>\n<ol>\n<li>通过RabbitMQ本身队列的特性来实现，需要使用RabbitMQ的死信交换机（Exchange）和消息的存活时间TTL（Time To Live）。</li>\n<li>在RabbitMQ 3.5.7及以上的版本提供了一个插件（rabbitmq-delayed-message-exchange）来实现延迟队列功能。同时，插件依赖Erlang/OPT 18.0及以上。</li>\n</ol>\n<p>也就是说，AMQP 协议以及RabbitMQ本身没有直接支持延迟队列的功能，但是可以通过TTL和DLX模拟出延迟队列的功能。</p>\n<h2> 什么是优先级队列？</h2>\n<p>RabbitMQ 自 V3.5.0 有优先级队列实现，优先级高的队列会先被消费。</p>\n<p>可以通过<code>x-max-priority</code>参数来实现优先级队列。不过，当消费速度大于生产速度且 Broker 没有堆积的情况下，优先级显得没有意义。</p>\n<h2> RabbitMQ 有哪些工作模式？</h2>\n<ul>\n<li>简单模式</li>\n<li>work 工作模式</li>\n<li>pub/sub 发布订阅模式</li>\n<li>Routing 路由模式</li>\n<li>Topic 主题模式</li>\n</ul>\n<h2> RabbitMQ 消息怎么传输？</h2>\n<p>由于 TCP 链接的创建和销毁开销较大，且并发数受系统资源限制，会造成性能瓶颈，所以 RabbitMQ 使用信道的方式来传输数据。信道（Channel）是生产者、消费者与 RabbitMQ 通信的渠道，信道是建立在 TCP 链接上的虚拟链接，且每条 TCP 链接上的信道数量没有限制。就是说 RabbitMQ 在一条 TCP 链接上建立成百上千个信道来达到多个线程处理，这个 TCP 被多个线程共享，每个信道在 RabbitMQ 都有唯一的 ID，保证了信道私有性，每个信道对应一个线程使用。</p>\n<h2> <strong>如何保证消息的可靠性？</strong></h2>\n<p>消息到 MQ 的过程中搞丢，MQ 自己搞丢，MQ 到消费过程中搞丢。</p>\n<ul>\n<li>生产者到 RabbitMQ：事务机制和 Confirm 机制，注意：事务机制和 Confirm 机制是互斥的，两者不能共存，会导致 RabbitMQ 报错。</li>\n<li>RabbitMQ 自身：持久化、集群、普通模式、镜像模式。</li>\n<li>RabbitMQ 到消费者：basicAck 机制、死信队列、消息补偿机制。</li>\n</ul>\n<h2> 如何保证 RabbitMQ 消息的顺序性？</h2>\n<ul>\n<li>拆分多个 queue(消息队列)，每个 queue(消息队列) 一个 consumer(消费者)，就是多一些 queue (消息队列)而已，确实是麻烦点；</li>\n<li>或者就一个 queue (消息队列)但是对应一个 consumer(消费者)，然后这个 consumer(消费者)内部用内存队列做排队，然后分发给底层不同的 worker 来处理。</li>\n</ul>\n<h2> 如何保证 RabbitMQ 高可用的？</h2>\n<p>RabbitMQ 是比较有代表性的，因为是基于主从（非分布式）做高可用性的，我们就以 RabbitMQ 为例子讲解第一种 MQ 的高可用性怎么实现。RabbitMQ 有三种模式：单机模式、普通集群模式、镜像集群模式。</p>\n<p><strong>单机模式</strong></p>\n<p>Demo 级别的，一般就是你本地启动了玩玩儿的?，没人生产用单机模式。</p>\n<p><strong>普通集群模式</strong></p>\n<p>意思就是在多台机器上启动多个 RabbitMQ 实例，每个机器启动一个。你创建的 queue，只会放在一个 RabbitMQ 实例上，但是每个实例都同步 queue 的元数据（元数据可以认为是 queue 的一些配置信息，通过元数据，可以找到 queue 所在实例）。</p>\n<p>你消费的时候，实际上如果连接到了另外一个实例，那么那个实例会从 queue 所在实例上拉取数据过来。这方案主要是提高吞吐量的，就是说让集群中多个节点来服务某个 queue 的读写操作。</p>\n<p><strong>镜像集群模式</strong></p>\n<p>这种模式，才是所谓的 RabbitMQ 的高可用模式。跟普通集群模式不一样的是，在镜像集群模式下，你创建的 queue，无论元数据还是 queue 里的消息都会存在于多个实例上，就是说，每个 RabbitMQ 节点都有这个 queue 的一个完整镜像，包含 queue 的全部数据的意思。然后每次你写消息到 queue 的时候，都会自动把消息同步到多个实例的 queue 上。RabbitMQ 有很好的管理控制台，就是在后台新增一个策略，这个策略是镜像集群模式的策略，指定的时候是可以要求数据同步到所有节点的，也可以要求同步到指定数量的节点，再次创建 queue 的时候，应用这个策略，就会自动将数据同步到其他的节点上去了。</p>\n<p>这样的好处在于，你任何一个机器宕机了，没事儿，其它机器（节点）还包含了这个 queue 的完整数据，别的 consumer 都可以到其它节点上去消费数据。坏处在于，第一，这个性能开销也太大了吧，消息需要同步到所有机器上，导致网络带宽压力和消耗很重！RabbitMQ 一个 queue 的数据都是放在一个节点里的，镜像集群下，也是每个节点都放这个 queue 的完整数据。</p>\n<h2> 如何解决消息挤压问题？</h2>\n<p><strong>临时紧急扩容</strong>。先修复 consumer 的问题，确保其恢复消费速度，然后将现有 consumer 都停掉。新建一个 topic，partition 是原来的 10 倍，临时建立好原先 10 倍的 queue 数量。然后写一个临时的分发数据的 consumer 程序，这个程序部署上去消费积压的数据，消费之后不做耗时的处理，直接均匀轮询写入临时建立好的 10 倍数量的 queue。接着临时征用 10 倍的机器来部署 consumer，每一批 consumer 消费一个临时 queue 的数据。这种做法相当于是临时将 queue 资源和 consumer 资源扩大 10 倍，以正常的 10 倍速度来消费数据。等快速消费完积压数据之后，得恢复原先部署的架构，重新用原先的 consumer 机器来消费消息。</p>\n<h2> 如何解决消息队列的延时以及过期失效问题？</h2>\n<p>RabbtiMQ 是可以设置过期时间的，也就是 TTL。如果消息在 queue 中积压超过一定的时间就会被 RabbitMQ 给清理掉，这个数据就没了。那这就是第二个坑了。这就不是说数据会大量积压在 mq 里，而是大量的数据会直接搞丢。我们可以采取一个方案，就是批量重导，这个我们之前线上也有类似的场景干过。就是大量积压的时候，我们当时就直接丢弃数据了，然后等过了高峰期以后，比如大家一起喝咖啡熬夜到晚上 12 点以后，用户都睡觉了。这个时候我们就开始写程序，将丢失的那批数据，写个临时程序，一点一点的查出来，然后重新灌入 mq 里面去，把白天丢的数据给他补回来。也只能是这样了。假设 1 万个订单积压在 mq 里面，没有处理，其中 1000 个订单都丢了，你只能手动写程序把那 1000 个订单给查出来，手动发到 mq 里去再补一次。</p>\n",
      "date_published": "2022-08-02T10:06:55.000Z",
      "date_modified": "2023-03-04T08:23:47.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "高性能"
      ]
    },
    {
      "title": "有了 HTTP 协议，为什么还要有 RPC ？",
      "url": "https://javaguide.cn/distributed-system/rpc/http_rpc.html",
      "id": "https://javaguide.cn/distributed-system/rpc/http_rpc.html",
      "summary": "本文来自小白debug投稿，原文：https://juejin.cn/post/7121882245605883934 。 我想起了我刚工作的时候，第一次接触 RPC 协议，当时就很懵，我 HTTP 协议用的好好的，为什么还要用 RPC 协议？ 于是就到网上去搜。 不少解释显得非常官方，我相信大家在各种平台上也都看到过，解释了又好像没解释，都在用一个我们不认识的概念去解释另外一个我们不认识的概念，懂的人不需要看，不懂的人看了还是不懂。",
      "content_html": "<blockquote>\n<p>本文来自<a href=\"https://juejin.cn/user/4001878057422087\" target=\"_blank\" rel=\"noopener noreferrer\">小白debug</a>投稿，原文：https://juejin.cn/post/7121882245605883934 。</p>\n</blockquote>\n<p>我想起了我刚工作的时候，第一次接触 RPC 协议，当时就很懵，我 HTTP 协议用的好好的，为什么还要用 RPC 协议？</p>\n<p>于是就到网上去搜。</p>\n<p>不少解释显得非常官方，我相信大家在各种平台上也都看到过，解释了又好像没解释，都在<strong>用一个我们不认识的概念去解释另外一个我们不认识的概念</strong>，懂的人不需要看，不懂的人看了还是不懂。</p>\n<p>这种看了，又好像没看的感觉，云里雾里的很难受，<strong>我懂</strong>。</p>\n<p>为了避免大家有强烈的<strong>审丑疲劳</strong>，今天我们来尝试重新换个方式讲一讲。</p>\n<h2> 从 TCP 聊起</h2>\n<p>作为一个程序员，假设我们需要在 A 电脑的进程发一段数据到 B 电脑的进程，我们一般会在代码里使用 socket 进行编程。</p>\n<p>这时候，我们可选项一般也就<strong>TCP 和 UDP 二选一。TCP 可靠，UDP 不可靠。</strong> 除非是马总这种神级程序员（早期 QQ 大量使用 UDP），否则，只要稍微对可靠性有些要求，普通人一般无脑选 TCP 就对了。</p>\n<p>类似下面这样。</p>\n<div class=\"language-ini line-numbers-mode\" data-ext=\"ini\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>其中<code>SOCK_STREAM</code>，是指使用<strong>字节流</strong>传输数据，说白了就是<strong>TCP 协议</strong>。</p>\n<p>在定义了 socket 之后，我们就可以愉快的对这个 socket 进行操作，比如用<code>bind()</code>绑定 IP 端口，用<code>connect()</code>发起建连。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/distributed-system/rpc/f410977cda814d32b0eff3645c385a8a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp.png\" alt=\"握手建立连接流程\"></p>\n<p>在连接建立之后，我们就可以使用<code>send()</code>发送数据，<code>recv()</code>接收数据。</p>\n<p>光这样一个纯裸的 TCP 连接，就可以做到收发数据了，那是不是就够了？</p>\n<p>不行，这么用会有问题。</p>\n<h2> 使用纯裸 TCP 会有什么问题</h2>\n<p>八股文常背，TCP 是有三个特点，<strong>面向连接</strong>、<strong>可靠</strong>、基于<strong>字节流</strong>。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/distributed-system/rpc/acb4508111cb47d8a3df6734d04818bc~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp.png\" alt=\"TCP是什么\"></p>\n<p>这三个特点真的概括的 <strong>非常精辟</strong> ，这个八股文我们没白背。</p>\n<p>每个特点展开都能聊一篇文章，而今天我们需要关注的是 <strong>基于字节流</strong> 这一点。</p>\n<p>字节流可以理解为一个双向的通道里流淌的二进制数据，也就是 <strong>01 串</strong> 。纯裸 TCP 收发的这些 01 串之间是 <strong>没有任何边界</strong> 的，你根本不知道到哪个地方才算一条完整消息。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/distributed-system/rpc/b82d4fcdd0c4491e979856c93c1750d7~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp.png\" alt=\"01二进制字节流\"></p>\n<p>正因为这个没有任何边界的特点，所以当我们选择使用 TCP 发送 <strong>\"夏洛\"和\"特烦恼\"</strong> 的时候，接收端收到的就是 <strong>\"夏洛特烦恼\"</strong> ，这时候接收端没发区分你是想要表达 <strong>\"夏洛\"+\"特烦恼\"</strong> 还是 <strong>\"夏洛特\"+\"烦恼\"</strong> 。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/distributed-system/rpc/4e120d0f1152419585565f693e744a3a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp.png\" alt=\"消息对比\"></p>\n<p>这就是所谓的 <strong>粘包问题</strong>，之前也写过一篇专门的<a href=\"https://mp.weixin.qq.com/s/0-YBxU1cSbDdzcZEZjmQYA\" target=\"_blank\" rel=\"noopener noreferrer\">文章</a>聊过这个问题。</p>\n<p>说这个的目的是为了告诉大家，纯裸 TCP 是不能直接拿来用的，你需要在这个基础上加入一些 <strong>自定义的规则</strong> ，用于区分 <strong>消息边界</strong> 。</p>\n<p>于是我们会把每条要发送的数据都包装一下，比如加入 <strong>消息头</strong> ，消息头里写清楚一个完整的包长度是多少，根据这个长度可以继续接收数据，截取出来后它们就是我们真正要传输的 <strong>消息体</strong> 。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/distributed-system/rpc/cb29659d4907446e9f70551c44c6369f~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp.png\" alt=\"消息边界长度标志\"></p>\n<p>而这里头提到的 <strong>消息头</strong> ，还可以放各种东西，比如消息体是否被压缩过和消息体格式之类的，只要上下游都约定好了，互相都认就可以了，这就是所谓的 <strong>协议。</strong></p>\n<p>每个使用 TCP 的项目都可能会定义一套类似这样的协议解析标准，他们可能 <strong>有区别，但原理都类似</strong>。</p>\n<p><strong>于是基于 TCP，就衍生了非常多的协议，比如 HTTP 和 RPC。</strong></p>\n<h2> HTTP 和 RPC</h2>\n<h3> RPC 其实是一种调用方式</h3>\n<p>我们回过头来看网络的分层图。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/distributed-system/rpc/04b603b5bd2443209233deea87816161~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp.png\" alt=\"四层网络协议\"></p>\n<p><strong>TCP 是传输层的协议</strong> ，而基于 TCP 造出来的 HTTP 和各类 RPC 协议，它们都只是定义了不同消息格式的 <strong>应用层协议</strong> 而已。</p>\n<p><strong>HTTP</strong>（<strong>H</strong>yper <strong>T</strong>ext <strong>T</strong>ransfer <strong>P</strong>rotocol）协议又叫做 <strong>超文本传输协议</strong> 。我们用的比较多，平时上网在浏览器上敲个网址就能访问网页，这里用到的就是 HTTP 协议。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/distributed-system/rpc/8f07a5d1c72a4c4fa811c6c3b5aadd3d~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp.png\" alt=\"HTTP调用\"></p>\n<p>而 <strong>RPC</strong>（<strong>R</strong>emote <strong>P</strong>rocedure <strong>C</strong>all）又叫做 <strong>远程过程调用</strong>，它本身并不是一个具体的协议，而是一种 <strong>调用方式</strong> 。</p>\n<p>举个例子，我们平时调用一个 <strong>本地方法</strong> 就像下面这样。</p>\n<div class=\"language-ini line-numbers-mode\" data-ext=\"ini\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>如果现在这不是个本地方法，而是个<strong>远端服务器</strong>暴露出来的一个方法<code>remoteFunc</code>，如果我们还能像调用本地方法那样去调用它，这样就可以<strong>屏蔽掉一些网络细节</strong>，用起来更方便，岂不美哉？</p>\n<div class=\"language-ini line-numbers-mode\" data-ext=\"ini\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/distributed-system/rpc/761da6c30af244e19b1c44075d8b4254~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp.png\" alt=\"RPC可以像调用本地方法那样调用远端方法\"></p>\n<p>基于这个思路，大佬们造出了非常多款式的 RPC 协议，比如比较有名的<code>gRPC</code>，<code>thrift</code>。</p>\n<p>值得注意的是，虽然大部分 RPC 协议底层使用 TCP，但实际上 <strong>它们不一定非得使用 TCP，改用 UDP 或者 HTTP，其实也可以做到类似的功能。</strong></p>\n<p>到这里，我们回到文章标题的问题。</p>\n<h3> 那既然有 RPC 了，为什么还要有 HTTP 呢？</h3>\n<p>其实，TCP 是 <strong>70 年</strong> 代出来的协议，而 HTTP 是 <strong>90 年代</strong> 才开始流行的。而直接使用裸 TCP 会有问题，可想而知，这中间这么多年有多少自定义的协议，而这里面就有 <strong>80 年代</strong> 出来的<code>RPC</code>。</p>\n<p>所以我们该问的不是 <strong>既然有 HTTP 协议为什么要有 RPC</strong> ，而是 <strong>为什么有 RPC 还要有 HTTP 协议?</strong></p>\n<p>现在电脑上装的各种联网软件，比如 xx 管家，xx 卫士，它们都作为客户端（Client） 需要跟服务端（Server） 建立连接收发消息，此时都会用到应用层协议，在这种 Client/Server (C/S) 架构下，它们可以使用自家造的 RPC 协议，因为它只管连自己公司的服务器就 ok 了。</p>\n<p>但有个软件不同，浏览器（Browser） ，不管是 Chrome 还是 IE，它们不仅要能访问自家公司的<strong>服务器（Server）</strong> ，还需要访问其他公司的网站服务器，因此它们需要有个统一的标准，不然大家没法交流。于是，HTTP 就是那个时代用于统一 <strong>Browser/Server (B/S)</strong> 的协议。</p>\n<p>也就是说在多年以前，<strong>HTTP 主要用于 B/S 架构，而 RPC 更多用于 C/S 架构。但现在其实已经没分那么清了，B/S 和 C/S 在慢慢融合。</strong> 很多软件同时支持多端，比如某度云盘，既要支持<strong>网页版</strong>，还要支持<strong>手机端和 PC 端</strong>，如果通信协议都用 HTTP 的话，那服务器只用同一套就够了。而 RPC 就开始退居幕后，一般用于公司内部集群里，各个微服务之间的通讯。</p>\n<p>那这么说的话，<strong>都用 HTTP 得了，还用什么 RPC？</strong></p>\n<p>仿佛又回到了文章开头的样子，那这就要从它们之间的区别开始说起。</p>\n<h3> HTTP 和 RPC 有什么区别</h3>\n<p>我们来看看 RPC 和 HTTP 区别比较明显的几个点。</p>\n<h4> 服务发现</h4>\n<p>首先要向某个服务器发起请求，你得先建立连接，而建立连接的前提是，你得知道 <strong>IP 地址和端口</strong> 。这个找到服务对应的 IP 端口的过程，其实就是 <strong>服务发现</strong>。</p>\n<p>在 <strong>HTTP</strong> 中，你知道服务的域名，就可以通过 <strong>DNS 服务</strong> 去解析得到它背后的 IP 地址，默认 <strong>80 端口</strong>。</p>\n<p>而 <strong>RPC</strong> 的话，就有些区别，一般会有专门的中间服务去保存服务名和 IP 信息，比如 <strong>Consul、Etcd、Nacos、ZooKeeper，甚至是 Redis</strong>。想要访问某个服务，就去这些中间服务去获得 IP 和端口信息。由于 DNS 也是服务发现的一种，所以也有基于 DNS 去做服务发现的组件，比如 <strong>CoreDNS</strong>。</p>\n<p>可以看出服务发现这一块，两者是有些区别，但不太能分高低。</p>\n<h4> 底层连接形式</h4>\n<p>以主流的 <strong>HTTP1.1</strong> 协议为例，其默认在建立底层 TCP 连接之后会一直保持这个连接（<strong>keep alive</strong>），之后的请求和响应都会复用这条连接。</p>\n<p>而 <strong>RPC</strong> 协议，也跟 HTTP 类似，也是通过建立 TCP 长链接进行数据交互，但不同的地方在于，RPC 协议一般还会再建个 <strong>连接池</strong>，在请求量大的时候，建立多条连接放在池内，要发数据的时候就从池里取一条连接出来，用完放回去，下次再复用，可以说非常环保。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/distributed-system/rpc/72fcad064c9e4103a11f1a2d579f79b2~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp.png\" alt=\"connection_pool\"></p>\n<p>由于连接池有利于提升网络请求性能，所以不少编程语言的网络库里都会给 HTTP 加个连接池，比如 Go 就是这么干的。</p>\n<p>可以看出这一块两者也没太大区别，所以也不是关键。</p>\n<h4> 传输的内容</h4>\n<p>基于 TCP 传输的消息，说到底，无非都是 <strong>消息头 Header 和消息体 Body。</strong></p>\n<p><strong>Header</strong> 是用于标记一些特殊信息，其中最重要的是 <strong>消息体长度</strong>。</p>\n<p><strong>Body</strong> 则是放我们真正需要传输的内容，而这些内容只能是二进制 01 串，毕竟计算机只认识这玩意。所以 TCP 传字符串和数字都问题不大，因为字符串可以转成编码再变成 01 串，而数字本身也能直接转为二进制。但结构体呢，我们得想个办法将它也转为二进制 01 串，这样的方案现在也有很多现成的，比如 <strong>JSON，Protocol Buffers (Protobuf)</strong> 。</p>\n<p>这个将结构体转为二进制数组的过程就叫 <strong>序列化</strong> ，反过来将二进制数组复原成结构体的过程叫 <strong>反序列化</strong>。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/distributed-system/rpc/d501dfc6f764430188ce61fda0f3e5d9~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp.png\" alt=\"序列化和反序列化\"></p>\n<p>对于主流的 HTTP1.1，虽然它现在叫超文本协议，支持音频视频，但 HTTP 设计 初是用于做网页文本展示的，所以它传的内容以字符串为主。Header 和 Body 都是如此。在 Body 这块，它使用 <strong>JSON</strong> 来 <strong>序列化</strong> 结构体数据。</p>\n<p>我们可以随便截个图直观看下。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/distributed-system/rpc/04e8a79ddb7247759df23f1132c01655~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp.png\" alt=\"HTTP报文\"></p>\n<p>可以看到这里面的内容非常多的冗余，显得非常啰嗦。最明显的，像 Header 里的那些信息，其实如果我们约定好头部的第几位是 <code>Content-Type</code>，就不需要每次都真的把 <code>Content-Type</code> 这个字段都传过来，类似的情况其实在 Body 的 JSON 结构里也特别明显。</p>\n<p>而 RPC，因为它定制化程度更高，可以采用体积更小的 Protobuf 或其他序列化协议去保存结构体数据，同时也不需要像 HTTP 那样考虑各种浏览器行为，比如 302 重定向跳转啥的。<strong>因此性能也会更好一些，这也是在公司内部微服务中抛弃 HTTP，选择使用 RPC 的最主要原因。</strong></p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/distributed-system/rpc/284c26bb7f2848889d1d9b95cf49decb~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp.png\" alt=\"HTTP原理\"></p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/distributed-system/rpc/edb050d383c644e895e505253f1c4d90~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp.png\" alt=\"RPC原理\"></p>\n<p>当然上面说的 HTTP，其实 <strong>特指的是现在主流使用的 HTTP1.1</strong>，<code>HTTP2</code>在前者的基础上做了很多改进，所以 <strong>性能可能比很多 RPC 协议还要好</strong>，甚至连<code>gRPC</code>底层都直接用的<code>HTTP2</code>。</p>\n<p>那么问题又来了。</p>\n<h3> 为什么既然有了 HTTP2，还要有 RPC 协议？</h3>\n<p>这个是由于 HTTP2 是 2015 年出来的。那时候很多公司内部的 RPC 协议都已经跑了好些年了，基于历史原因，一般也没必要去换了。</p>\n<h2> 总结</h2>\n<ul>\n<li>纯裸 TCP 是能收发数据，但它是个无边界的数据流，上层需要定义消息格式用于定义 <strong>消息边界</strong> 。于是就有了各种协议，HTTP 和各类 RPC 协议就是在 TCP 之上定义的应用层协议。</li>\n<li><strong>RPC 本质上不算是协议，而是一种调用方式</strong>，而像 gRPC 和 Thrift 这样的具体实现，才是协议，它们是实现了 RPC 调用的协议。目的是希望程序员能像调用本地方法那样去调用远端的服务方法。同时 RPC 有很多种实现方式，<strong>不一定非得基于 TCP 协议</strong>。</li>\n<li>从发展历史来说，<strong>HTTP 主要用于 B/S 架构，而 RPC 更多用于 C/S 架构。但现在其实已经没分那么清了，B/S 和 C/S 在慢慢融合。</strong> 很多软件同时支持多端，所以对外一般用 HTTP 协议，而内部集群的微服务之间则采用 RPC 协议进行通讯。</li>\n<li>RPC 其实比 HTTP 出现的要早，且比目前主流的 HTTP1.1 性能要更好，所以大部分公司内部都还在使用 RPC。</li>\n<li><strong>HTTP2.0</strong> 在 <strong>HTTP1.1</strong> 的基础上做了优化，性能可能比很多 RPC 协议都要好，但由于是这几年才出来的，所以也不太可能取代掉 RPC。</li>\n</ul>\n",
      "image": "https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/distributed-system/rpc/f410977cda814d32b0eff3645c385a8a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp.png",
      "date_published": "2022-08-02T06:41:11.000Z",
      "date_modified": "2022-08-02T06:41:11.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "分布式"
      ]
    },
    {
      "title": "Java 并发常见面试题总结（下）",
      "url": "https://javaguide.cn/java/concurrent/java-concurrent-questions-03.html",
      "id": "https://javaguide.cn/java/concurrent/java-concurrent-questions-03.html",
      "summary": "ThreadLocal ThreadLocal 有什么用？ 通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。如果想实现每一个线程都有自己的专属本地变量该如何解决呢？ JDK 中自带的ThreadLocal类正是为了解决这样的问题。 ThreadLocal类主要解决的就是让每个线程绑定自己的值，可以将ThreadLocal类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。",
      "content_html": "<h2> ThreadLocal</h2>\n<h3> ThreadLocal 有什么用？</h3>\n<p>通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。<strong>如果想实现每一个线程都有自己的专属本地变量该如何解决呢？</strong></p>\n<p>JDK 中自带的<code>ThreadLocal</code>类正是为了解决这样的问题。 <strong><code>ThreadLocal</code>类主要解决的就是让每个线程绑定自己的值，可以将<code>ThreadLocal</code>类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。</strong></p>\n<p>如果你创建了一个<code>ThreadLocal</code>变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是<code>ThreadLocal</code>变量名的由来。他们可以使用 <code>get()</code> 和 <code>set()</code> 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。</p>\n<p>再举个简单的例子：两个人去宝屋收集宝物，这两个共用一个袋子的话肯定会产生争执，但是给他们两个人每个人分配一个袋子的话就不会出现这样的问题。如果把这两个人比作线程的话，那么 ThreadLocal 就是用来避免这两个线程竞争的。</p>\n<h3> 如何使用 ThreadLocal？</h3>\n<p>相信看了上面的解释，大家已经搞懂 <code>ThreadLocal</code> 类是个什么东西了。下面简单演示一下如何在项目中实际使用 <code>ThreadLocal</code> 。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出结果 :</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>从输出中可以看出，虽然 <code>Thread-0</code> 已经改变了 <code>formatter</code> 的值，但 <code>Thread-1</code> 默认格式化值与初始化值相同，其他线程也一样。</p>\n<p>上面有一段代码用到了创建 <code>ThreadLocal</code> 变量的那段代码用到了 Java8 的知识，它等于下面这段代码，如果你写了下面这段代码的话，IDEA 会提示你转换为 Java8 的格式(IDEA 真的不错！)。因为 ThreadLocal 类在 Java 8 中扩展，使用一个新的方法<code>withInitial()</code>，将 Supplier 功能接口作为参数。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> ThreadLocal 原理了解吗？</h3>\n<p>从 <code>Thread</code>类源代码入手。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>从上面<code>Thread</code>类 源代码可以看出<code>Thread</code> 类中有一个 <code>threadLocals</code> 和 一个 <code>inheritableThreadLocals</code> 变量，它们都是 <code>ThreadLocalMap</code> 类型的变量,我们可以把 <code>ThreadLocalMap</code> 理解为<code>ThreadLocal</code> 类实现的定制化的 <code>HashMap</code>。默认情况下这两个变量都是 null，只有当前线程调用 <code>ThreadLocal</code> 类的 <code>set</code>或<code>get</code>方法时才创建它们，实际上调用这两个方法的时候，我们调用的是<code>ThreadLocalMap</code>类对应的 <code>get()</code>、<code>set()</code>方法。</p>\n<p><code>ThreadLocal</code>类的<code>set()</code>方法</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>通过上面这些内容，我们足以通过猜测得出结论：<strong>最终的变量是放在了当前线程的 <code>ThreadLocalMap</code> 中，并不是存在 <code>ThreadLocal</code> 上，<code>ThreadLocal</code> 可以理解为只是<code>ThreadLocalMap</code>的封装，传递了变量值。</strong> <code>ThrealLocal</code> 类中可以通过<code>Thread.currentThread()</code>获取到当前线程对象后，直接通过<code>getMap(Thread t)</code>可以访问到该线程的<code>ThreadLocalMap</code>对象。</p>\n<p><strong>每个<code>Thread</code>中都具备一个<code>ThreadLocalMap</code>，而<code>ThreadLocalMap</code>可以存储以<code>ThreadLocal</code>为 key ，Object 对象为 value 的键值对。</strong></p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>比如我们在同一个线程中声明了两个 <code>ThreadLocal</code> 对象的话， <code>Thread</code>内部都是使用仅有的那个<code>ThreadLocalMap</code> 存放数据的，<code>ThreadLocalMap</code>的 key 就是 <code>ThreadLocal</code>对象，value 就是 <code>ThreadLocal</code> 对象调用<code>set</code>方法设置的值。</p>\n<p><code>ThreadLocal</code> 数据结构如下图所示：</p>\n<p><img src=\"https://pics-cloud.oss-cn-beijing.aliyuncs.com/threadlocal-data-structur.png\" alt=\"ThreadLocal 数据结构\"></p>\n<p><code>ThreadLocalMap</code>是<code>ThreadLocal</code>的静态内部类。</p>\n<p><img src=\"https://pics-cloud.oss-cn-beijing.aliyuncs.com/thread-local-inner-class.png\" alt=\"ThreadLocal内部类\"></p>\n<h3> ThreadLocal 内存泄露问题是怎么导致的？</h3>\n<p><code>ThreadLocalMap</code> 中使用的 key 为 <code>ThreadLocal</code> 的弱引用，而 value 是强引用。所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。</p>\n<p>这样一来，<code>ThreadLocalMap</code> 中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。<code>ThreadLocalMap</code> 实现中已经考虑了这种情况，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法的时候，会清理掉 key 为 null 的记录。使用完 <code>ThreadLocal</code>方法后 最好手动调用<code>remove()</code>方法</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>弱引用介绍：</strong></p>\n<blockquote>\n<p>如果一个对象只具有弱引用，那就类似于<strong>可有可无的生活用品</strong>。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</p>\n<p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p>\n</blockquote>\n<h2> 线程池</h2>\n<h3> 什么是线程池?</h3>\n<p>顾名思义，线程池就是管理一系列线程的资源池。当有任务要处理时，直接从线程池中获取线程来处理，处理完之后线程并不会立即被销毁，而是等待下一个任务。</p>\n<h3> 为什么要用线程池？</h3>\n<p>池化技术想必大家已经屡见不鲜了，线程池、数据库连接池、Http 连接池等等都是对这个思想的应用。池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。</p>\n<p><strong>线程池</strong>提供了一种限制和管理资源（包括执行一个任务）的方式。 每个<strong>线程池</strong>还维护一些基本统计信息，例如已完成任务的数量。</p>\n<p>这里借用《Java 并发编程的艺术》提到的来说一下<strong>使用线程池的好处</strong>：</p>\n<ul>\n<li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>\n<li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li>\n<li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>\n</ul>\n<h3> 如何创建线程池？</h3>\n<p><strong>方式一：通过<code>ThreadPoolExecutor</code>构造函数来创建（推荐）。</strong></p>\n<p></p>\n<p><strong>方式二：通过 <code>Executor</code> 框架的工具类 <code>Executors</code> 来创建。</strong></p>\n<p>我们可以创建多种类型的 <code>ThreadPoolExecutor</code>：</p>\n<ul>\n<li><strong><code>FixedThreadPool</code></strong> ： 该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</li>\n<li><strong><code>SingleThreadExecutor</code>：</strong> 该方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</li>\n<li><strong><code>CachedThreadPool</code>：</strong> 该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。</li>\n<li><strong><code>ScheduledThreadPool</code></strong> ：该返回一个用来在给定的延迟后运行任务或者定期执行任务的线程池。</li>\n</ul>\n<p>对应 <code>Executors</code> 工具类中的方法如图所示：</p>\n<p><img src=\"https://pics-cloud.oss-cn-beijing.aliyuncs.com/executors-inner-threadpool.png\" alt=\"\"></p>\n<h3> 为什么不推荐使用内置线程池？</h3>\n<p>在《阿里巴巴 Java 开发手册》“并发处理”这一章节，明确指出线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。</p>\n<p><strong>为什么呢？</strong></p>\n<blockquote>\n<p>使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源开销，解决资源不足的问题。如果不使用线程池，有可能会造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。</p>\n</blockquote>\n<p>另外，《阿里巴巴 Java 开发手册》中强制线程池不允许使用 <code>Executors</code> 去创建，而是通过 <code>ThreadPoolExecutor</code> 构造函数的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险</p>\n<p><code>Executors</code> 返回线程池对象的弊端如下(后文会详细介绍到)：</p>\n<ul>\n<li><strong><code>FixedThreadPool</code> 和 <code>SingleThreadExecutor</code></strong> ： 使用的是无界的 <code>LinkedBlockingQueue</code>，任务队列最大长度为 <code>Integer.MAX_VALUE</code>,可能堆积大量的请求，从而导致 OOM。</li>\n<li><strong><code>CachedThreadPool</code></strong> ：使用的是同步队列 <code>SynchronousQueue</code>, 允许创建的线程数量为 <code>Integer.MAX_VALUE</code> ，可能会创建大量线程，从而导致 OOM。</li>\n<li><strong><code>ScheduledThreadPool</code> 和 <code>SingleThreadScheduledExecutor</code></strong> : 使用的无界的延迟阻塞队列<code>DelayedWorkQueue</code>，任务队列最大长度为 <code>Integer.MAX_VALUE</code>,可能堆积大量的请求，从而导致 OOM。</li>\n</ul>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 线程池常见参数有哪些？如何解释？</h3>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong><code>ThreadPoolExecutor</code> 3 个最重要的参数：</strong></p>\n<ul>\n<li><strong><code>corePoolSize</code> :</strong> 任务队列未达到队列容量时，最大可以同时运行的线程数量。</li>\n<li><strong><code>maximumPoolSize</code> :</strong> 任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li>\n<li><strong><code>workQueue</code>:</strong> 新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li>\n</ul>\n<p><code>ThreadPoolExecutor</code>其他常见参数 :</p>\n<ul>\n<li><strong><code>keepAliveTime</code></strong>:线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>才会被回收销毁；</li>\n<li><strong><code>unit</code></strong> : <code>keepAliveTime</code> 参数的时间单位。</li>\n<li><strong><code>threadFactory</code></strong> :executor 创建新线程的时候会用到。</li>\n<li><strong><code>handler</code></strong> :饱和策略。关于饱和策略下面单独介绍一下。</li>\n</ul>\n<p>下面这张图可以加深你对线程池中各个参数的相互关系的理解（图片来源：《Java 性能调优实战》）：</p>\n<p><img src=\"https://pics-cloud.oss-cn-beijing.aliyuncs.com/线程池各个参数之间的关系.png\" alt=\"线程池各个参数的关系\"></p>\n<h3> 线程池的饱和策略有哪些？</h3>\n<p>如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时，<code>ThreadPoolTaskExecutor</code> 定义一些策略:</p>\n<ul>\n<li><strong><code>ThreadPoolExecutor.AbortPolicy</code>：</strong> 抛出 <code>RejectedExecutionException</code>来拒绝新任务的处理。</li>\n<li><strong><code>ThreadPoolExecutor.CallerRunsPolicy</code>：</strong> 调用执行自己的线程运行任务，也就是直接在调用<code>execute</code>方法的线程中运行(<code>run</code>)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。</li>\n<li><strong><code>ThreadPoolExecutor.DiscardPolicy</code>：</strong> 不处理新任务，直接丢弃掉。</li>\n<li><strong><code>ThreadPoolExecutor.DiscardOldestPolicy</code>：</strong> 此策略将丢弃最早的未处理的任务请求。</li>\n</ul>\n<p>举个例子： Spring 通过 <code>ThreadPoolTaskExecutor</code> 或者我们直接通过 <code>ThreadPoolExecutor</code> 的构造函数创建线程池的时候，当我们不指定 <code>RejectedExecutionHandler</code> 饱和策略的话来配置线程池的时候默认使用的是 <code>ThreadPoolExecutor.AbortPolicy</code>。在默认情况下，<code>ThreadPoolExecutor</code> 将抛出 <code>RejectedExecutionException</code> 来拒绝新来的任务 ，这代表你将丢失对这个任务的处理。 对于可伸缩的应用程序，建议使用 <code>ThreadPoolExecutor.CallerRunsPolicy</code>。当最大池被填满时，此策略为我们提供可伸缩队列。（这个直接查看 <code>ThreadPoolExecutor</code> 的构造函数源码就可以看出，比较简单的原因，这里就不贴代码了）</p>\n<h3> 线程池常用的阻塞队列有哪些？</h3>\n<p>新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</p>\n<p>不同的线程池会选用不同的阻塞队列，我们可以结合内置线程池来分析。</p>\n<ul>\n<li>容量为 <code>Integer.MAX_VALUE</code> 的 <code>LinkedBlockingQueue</code>（无界队列）：<code>FixedThreadPool</code> 和 <code>SingleThreadExector</code> 。由于队列永远不会被放满，因此<code>FixedThreadPool</code>最多只能创建核心线程数的线程。</li>\n<li><code>SynchronousQueue</code>（同步队列） ：<code>CachedThreadPool</code> 。<code>SynchronousQueue</code> 没有容量，不存储元素，目的是保证对于提交的任务，如果有空闲线程，则使用空闲线程来处理；否则新建一个线程来处理任务。也就是说，<code>CachedThreadPool</code> 的最大线程数是 <code>Integer.MAX_VALUE</code> ，可以理解为线程数是可以无限扩展的，可能会创建大量线程，从而导致 OOM。</li>\n<li><code>DelayedWorkQueue</code>（延迟阻塞队列）：<code>ScheduledThreadPool</code> 和 <code>SingleThreadScheduledExecutor</code> 。<code>DelayedWorkQueue</code> 的内部元素并不是按照放入的时间排序，而是会按照延迟的时间长短对任务进行排序，内部采用的是“堆”的数据结构，可以保证每次出队的任务都是当前队列中执行时间最靠前的。<code>DelayedWorkQueue</code> 添加元素满了之后会自动扩容原来容量的 1/2，即永远不会阻塞，最大扩容可达 <code>Integer.MAX_VALUE</code>，所以最多只能创建核心线程数的线程。</li>\n</ul>\n<h3> 线程池处理任务的流程了解吗？</h3>\n<p><img src=\"https://pics-cloud.oss-cn-beijing.aliyuncs.com/线程池处理流程.png\" alt=\"图解线程池实现原理\"></p>\n<ol>\n<li>如果当前运行的线程数小于核心线程数，那么就会新建一个线程来执行任务。</li>\n<li>如果当前运行的线程数等于或大于核心线程数，但是小于最大线程数，那么就把该任务放入到任务队列里等待执行。</li>\n<li>如果向任务队列投放任务失败（任务队列已经满了），但是当前运行的线程数是小于最大线程数的，就新建一个线程来执行任务。</li>\n<li>如果当前运行的线程数已经等同于最大线程数了，新建线程将会使当前运行的线程超出最大线程数，那么当前任务会被拒绝，饱和策略会调用<code>RejectedExecutionHandler.rejectedExecution()</code>方法。</li>\n</ol>\n<h3> 如何给线程池命名？</h3>\n<p>初始化线程池的时候需要显示命名（设置线程池名称前缀），有利于定位问题。</p>\n<p>默认情况下创建的线程名字类似 <code>pool-1-thread-n</code> 这样的，没有业务含义，不利于我们定位问题。</p>\n<p>给线程池里的线程命名通常有下面两种方式：</p>\n<p>**1、利用 guava 的 <code>ThreadFactoryBuilder</code> **</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>2、自己实现 <code>ThreadFactor</code>。</strong></p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 如何设定线程池的大小？</h3>\n<p>很多人甚至可能都会觉得把线程池配置过大一点比较好！我觉得这明显是有问题的。就拿我们生活中非常常见的一例子来说：<strong>并不是人多就能把事情做好，增加了沟通交流成本。你本来一件事情只需要 3 个人做，你硬是拉来了 6 个人，会提升做事效率嘛？我想并不会。</strong> 线程数量过多的影响也是和我们分配多少人做事情一样，对于多线程这个场景来说主要是增加了<strong>上下文切换</strong>成本。不清楚什么是上下文切换的话，可以看我下面的介绍。</p>\n<blockquote>\n<p>上下文切换：</p>\n<p>多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。<strong>任务从保存到再加载的过程就是一次上下文切换</strong>。</p>\n<p>上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。</p>\n<p>Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。</p>\n</blockquote>\n<p>类比于实现世界中的人类通过合作做某件事情，我们可以肯定的一点是线程池大小设置过大或者过小都会有问题，合适的才是最好。</p>\n<ul>\n<li>如果我们设置的线程池数量太小的话，如果同一时间有大量任务/请求需要处理，可能会导致大量的请求/任务在任务队列中排队等待执行，甚至会出现任务队列满了之后任务/请求无法处理的情况，或者大量任务堆积在任务队列导致 OOM。这样很明显是有问题的，CPU 根本没有得到充分利用。</li>\n<li>如果我们设置线程数量太大，大量线程可能会同时在争取 CPU 资源，这样会导致大量的上下文切换，从而增加线程的执行时间，影响了整体执行效率。</li>\n</ul>\n<p>有一个简单并且适用面比较广的公式：</p>\n<ul>\n<li><strong>CPU 密集型任务(N+1)：</strong> 这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1。比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。</li>\n<li><strong>I/O 密集型任务(2N)：</strong> 这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。</li>\n</ul>\n<p><strong>如何判断是 CPU 密集任务还是 IO 密集任务？</strong></p>\n<p>CPU 密集型简单理解就是利用 CPU 计算能力的任务比如你在内存中对大量数据进行排序。但凡涉及到网络读取，文件读取这类都是 IO 密集型，这类任务的特点是 CPU 计算耗费时间相比于等待 IO 操作完成的时间来说很少，大部分时间都花在了等待 IO 操作完成上。</p>\n<blockquote>\n<p>🌈 拓展一下（参见：<a href=\"https://github.com/Snailclimb/JavaGuide/issues/1737\" target=\"_blank\" rel=\"noopener noreferrer\">issue#1737</a>）：</p>\n<p>线程数更严谨的计算的方法应该是：<code>最佳线程数 = N（CPU 核心数）∗（1+WT（线程等待时间）/ST（线程计算时间））</code>，其中 <code>WT（线程等待时间）=线程运行总时间 - ST（线程计算时间）</code>。</p>\n<p>线程等待时间所占比例越高，需要越多线程。线程计算时间所占比例越高，需要越少线程。</p>\n<p>我们可以通过 JDK 自带的工具 VisualVM 来查看 <code>WT/ST</code> 比例。</p>\n<p>CPU 密集型任务的 <code>WT/ST</code> 接近或者等于 0，因此， 线程数可以设置为 N（CPU 核心数）∗（1+0）= N，和我们上面说的 N（CPU 核心数）+1 差不多。</p>\n<p>IO 密集型任务下，几乎全是线程等待时间，从理论上来说，你就可以将线程数设置为 2N（按道理来说，WT/ST 的结果应该比较大，这里选择 2N 的原因应该是为了避免创建过多线程吧）。</p>\n</blockquote>\n<p>公示也只是参考，具体还是要根据项目实际线上运行情况来动态调整。我在后面介绍的美团的线程池参数动态配置这种方案就非常不错，很实用！</p>\n<h3> 如何动态修改线程池的参数？</h3>\n<p>美团技术团队在<a href=\"https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html\" target=\"_blank\" rel=\"noopener noreferrer\">《Java 线程池实现原理及其在美团业务中的实践》</a>这篇文章中介绍到对线程池参数实现可自定义配置的思路和方法。</p>\n<p>美团技术团队的思路是主要对线程池的核心参数实现自定义可配置。这三个核心参数是：</p>\n<ul>\n<li><strong><code>corePoolSize</code> :</strong> 核心线程数线程数定义了最小可以同时运行的线程数量。</li>\n<li><strong><code>maximumPoolSize</code> :</strong> 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li>\n<li><strong><code>workQueue</code>:</strong> 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li>\n</ul>\n<p><strong>为什么是这三个参数？</strong></p>\n<p>我在<a href=\"https://javaguide.cn/java/concurrent/java-thread-pool-summary.html\" target=\"_blank\" rel=\"noopener noreferrer\">Java 线程池详解</a> 这篇文章中就说过这三个参数是 <code>ThreadPoolExecutor</code> 最重要的参数，它们基本决定了线程池对于任务的处理策略。</p>\n<p><strong>如何支持参数动态配置？</strong> 且看 <code>ThreadPoolExecutor</code> 提供的下面这些方法。</p>\n<p><img src=\"https://pics-cloud.oss-cn-beijing.aliyuncs.com/threadpoolexecutor-methods.png\" alt=\"\"></p>\n<p>格外需要注意的是<code>corePoolSize</code>， 程序运行期间的时候，我们调用 <code>setCorePoolSize（）</code>这个方法的话，线程池会首先判断当前工作线程数是否大于<code>corePoolSize</code>，如果大于的话就会回收工作线程。</p>\n<p>另外，你也看到了上面并没有动态指定队列长度的方法，美团的方式是自定义了一个叫做 <code>ResizableCapacityLinkedBlockIngQueue</code> 的队列（主要就是把<code>LinkedBlockingQueue</code>的 capacity 字段的 final 关键字修饰给去掉了，让它变为可变的）。</p>\n<p>最终实现的可动态修改线程池参数效果如下。👏👏👏</p>\n<p><img src=\"https://pics-cloud.oss-cn-beijing.aliyuncs.com/meituan-dynamically-configuring-thread-pool-parameters.png\" alt=\"动态配置线程池参数最终效果\"></p>\n<p>还没看够？推荐 why 神的<a href=\"https://mp.weixin.qq.com/s/9HLuPcoWmTqAeFKa1kj-_A\" target=\"_blank\" rel=\"noopener noreferrer\">如何设置线程池参数？美团给出了一个让面试官虎躯一震的回答。</a>这篇文章，深度剖析，很不错哦！</p>\n<p>如果我们的项目也想要实现这种效果的话，可以借助现成的开源项目：</p>\n<ul>\n<li><strong><a href=\"https://github.com/opengoofy/hippo4j\" target=\"_blank\" rel=\"noopener noreferrer\">Hippo-4</a></strong> ：一款强大的动态线程池框架，解决了传统线程池使用存在的一些痛点比如线程池参数没办法动态修改、不支持运行时变量的传递、无法执行优雅关闭。除了支持动态修改线程池参数、线程池任务传递上下文，还支持通知报警、运行监控等开箱即用的功能。</li>\n<li><strong><a href=\"https://github.com/dromara/dynamic-tp\" target=\"_blank\" rel=\"noopener noreferrer\">Dynamic TP</a></strong> ：轻量级动态线程池，内置监控告警功能，集成三方中间件线程池管理，基于主流配置中心（已支持Nacos、Apollo，Zookeeper、Consul、Etcd，可通过SPI自定义实现）。</li>\n</ul>\n<h2> Future</h2>\n<h3> Future 类有什么用？</h3>\n<p><code>Future</code> 类是异步思想的典型运用，主要用在一些需要执行耗时任务的场景，避免程序一直原地等待耗时任务执行完成，执行效率太低。具体来说是这样的：当我们执行某一耗时的任务时，可以将这个耗时任务交给一个子线程去异步执行，同时我们可以干点其他事情，不用傻傻等待耗时任务执行完成。等我们的事情干完后，我们再通过 <code>Future</code> 类获取到耗时任务的执行结果。这样一来，程序的执行效率就明显提高了。</p>\n<p>这其实就是多线程中经典的 <strong>Future 模式</strong>，你可以将其看作是一种设计模式，核心思想是异步调用，主要用在多线程领域，并非 Java 语言独有。</p>\n<p>在 Java 中，<code>Future</code> 类只是一个泛型接口，位于 <code>java.util.concurrent</code> 包下，其中定义了 5 个方法，主要包括下面这 4 个功能：</p>\n<ul>\n<li>取消任务；</li>\n<li>判断任务是否被取消;</li>\n<li>判断任务是否已经执行完成;</li>\n<li>获取任务执行结果。</li>\n</ul>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>简单理解就是：我有一个任务，提交给了 <code>Future</code> 来处理。任务执行期间我自己可以去做任何想做的事情。并且，在这期间我还可以取消任务以及获取任务的执行状态。一段时间之后，我就可以 <code>Future</code> 那里直接取出任务执行结果。</p>\n<h3> Callable 和 Future 有什么关系？</h3>\n<p>我们可以通过 <code>FutureTask</code> 来理解 <code>Callable</code> 和 <code>Future</code> 之间的关系。</p>\n<p><code>FutureTask</code> 提供了 <code>Future</code> 接口的基本实现，常用来封装 <code>Callable</code> 和 <code>Runnable</code>，具有取消任务、查看任务是否执行完成以及获取任务执行结果的方法。<code>ExecutorService.submit()</code> 方法返回的其实就是 <code>Future</code> 的实现类 <code>FutureTask</code> 。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>FutureTask</code> 不光实现了 <code>Future</code>接口，还实现了<code>Runnable</code> 接口，因此可以作为任务直接被线程执行。</p>\n<p><img src=\"https://pics-cloud.oss-cn-beijing.aliyuncs.com/completablefuture-class-diagram.jpeg\" alt=\"\"></p>\n<p><code>FutureTask</code> 有两个构造函数，可传入 <code>Callable</code> 或者 <code>Runnable</code> 对象。实际上，传入 <code>Runnable</code> 对象也会在方法内部转换为<code>Callable</code> 对象。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>FutureTask</code>相当于对<code>Callable</code> 进行了封装，管理着任务执行的情况，存储了 <code>Callable</code> 的 <code>call</code> 方法的任务执行结果。</p>\n<h3> CompletableFuture 类有什么用？</h3>\n<p><code>Future</code> 在实际使用过程中存在一些局限性比如不支持异步任务的编排组合、获取计算结果的 <code>get()</code> 方法为阻塞调用。</p>\n<p>Java 8 才被引入<code>CompletableFuture</code> 类可以解决<code>Future</code> 的这些缺陷。<code>CompletableFuture</code> 除了提供了更为好用和强大的 <code>Future</code> 特性之外，还提供了函数式编程、异步任务编排组合（可以将多个异步任务串联起来，组成一个完整的链式调用）等能力。</p>\n<p>下面我们来简单看看 <code>CompletableFuture</code> 类的定义。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>可以看到，<code>CompletableFuture</code> 同时实现了 <code>Future</code> 和 <code>CompletionStage</code> 接口。</p>\n<p><img src=\"https://pics-cloud.oss-cn-beijing.aliyuncs.com/completablefuture-class-diagram.jpeg\" alt=\"\"></p>\n<p><code>CompletionStage</code> 接口描述了一个异步计算的阶段。很多计算可以分成多个阶段或步骤，此时可以通过它将所有步骤组合起来，形成异步计算的流水线。</p>\n<p><code>CompletionStage</code> 接口中的方法比较多，<code>CompletableFuture</code> 的函数式能力就是这个接口赋予的。从这个接口的方法参数你就可以发现其大量使用了 Java8 引入的函数式编程。</p>\n<p><img src=\"https://pics-cloud.oss-cn-beijing.aliyuncs.com/202303072309185.png\" alt=\"\"></p>\n<h2> AQS</h2>\n<h3> AQS 是什么？</h3>\n<p>AQS 的全称为 <code>AbstractQueuedSynchronizer</code> ，翻译过来的意思就是抽象队列同步器。这个类在 <code>java.util.concurrent.locks</code> 包下面。</p>\n<p><img src=\"https://pics-cloud.oss-cn-beijing.aliyuncs.com/AQS.png\" alt=\"\"></p>\n<p>AQS 就是一个抽象类，主要用来构建锁和同步器。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>AQS 为构建锁和同步器提供了一些通用功能的是实现，因此，使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的 <code>ReentrantLock</code>，<code>Semaphore</code>，其他的诸如 <code>ReentrantReadWriteLock</code>，<code>SynchronousQueue</code>等等皆是基于 AQS 的。</p>\n<h3> AQS 的原理是什么？</h3>\n<p>AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 <strong>CLH 队列锁</strong> 实现的，即将暂时获取不到锁的线程加入到队列中。</p>\n<p>CLH(Craig,Landin,and Hagersten) 队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点（Node）来实现锁的分配。在 CLH 同步队列中，一个节点表示一个线程，它保存着线程的引用（thread）、 当前节点在队列中的状态（waitStatus）、前驱节点（prev）、后继节点（next）。</p>\n<p>CLH 队列结构如下图所示：</p>\n<p><img src=\"https://pics-cloud.oss-cn-beijing.aliyuncs.com/202303072310786.png\" alt=\"\"></p>\n<p>AQS(<code>AbstractQueuedSynchronizer</code>)的核心原理图（图源<a href=\"https://www.cnblogs.com/waterystone/p/4920797.html\" target=\"_blank\" rel=\"noopener noreferrer\">Java 并发之 AQS 详解</a>）如下：</p>\n<p><img src=\"https://pics-cloud.oss-cn-beijing.aliyuncs.com/202303072310833.png\" alt=\"\"></p>\n<p>AQS 使用 <strong>int 成员变量 <code>state</code> 表示同步状态</strong>，通过内置的 <strong>线程等待队列</strong> 来完成获取资源线程的排队工作。</p>\n<p><code>state</code> 变量由 <code>volatile</code> 修饰，用于展示当前临界资源的获锁情况。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>另外，状态信息 <code>state</code> 可以通过 <code>protected</code> 类型的<code>getState()</code>、<code>setState()</code>和<code>compareAndSetState()</code> 进行操作。并且，这几个方法都是 <code>final</code> 修饰的，在子类中无法被重写。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>以 <code>ReentrantLock</code> 为例，<code>state</code> 初始值为 0，表示未锁定状态。A 线程 <code>lock()</code> 时，会调用 <code>tryAcquire()</code> 独占该锁并将 <code>state+1</code> 。此后，其他线程再 <code>tryAcquire()</code> 时就会失败，直到 A 线程 <code>unlock()</code> 到 <code>state=</code>0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A 线程自己是可以重复获取此锁的（<code>state</code> 会累加），这就是可重入的概念。但要注意，获取多少次就要释放多少次，这样才能保证 state 是能回到零态的。</p>\n<p>再以 <code>CountDownLatch</code> 以例，任务分为 N 个子线程去执行，<code>state</code> 也初始化为 N（注意 N 要与线程个数一致）。这 N 个子线程是并行执行的，每个子线程执行完后<code>countDown()</code> 一次，state 会 CAS(Compare and Swap) 减 1。等到所有子线程都执行完后(即 <code>state=0</code> )，会 <code>unpark()</code> 主调用线程，然后主调用线程就会从 <code>await()</code> 函数返回，继续后余动作。</p>\n<h3> Semaphore 有什么用？</h3>\n<p><code>synchronized</code> 和 <code>ReentrantLock</code> 都是一次只允许一个线程访问某个资源，而<code>Semaphore</code>(信号量)可以用来控制同时访问特定资源的线程数量。</p>\n<p>Semaphore 的使用简单，我们这里假设有 N(N&gt;5) 个线程来获取 <code>Semaphore</code> 中的共享资源，下面的代码表示同一时刻 N 个线程中只有 5 个线程能获取到共享资源，其他线程都会阻塞，只有获取到共享资源的线程才能执行。等到有线程释放了共享资源，其他阻塞的线程才能获取到。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>当初始的资源个数为 1 的时候，<code>Semaphore</code> 退化为排他锁。</p>\n<p><code>Semaphore</code> 有两种模式：。</p>\n<ul>\n<li><strong>公平模式：</strong> 调用 <code>acquire()</code> 方法的顺序就是获取许可证的顺序，遵循 FIFO；</li>\n<li><strong>非公平模式：</strong> 抢占式的。</li>\n</ul>\n<p><code>Semaphore</code> 对应的两个构造方法如下：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>这两个构造方法，都必须提供许可的数量，第二个构造方法可以指定是公平模式还是非公平模式，默认非公平模式。</strong></p>\n<p><code>Semaphore</code> 通常用于那些资源有明确访问数量限制的场景比如限流（仅限于单机模式，实际项目中推荐使用 Redis +Lua 来做限流）。</p>\n<h3> Semaphore 的原理是什么？</h3>\n<p><code>Semaphore</code> 是共享锁的一种实现，它默认构造 AQS 的 <code>state</code> 值为 <code>permits</code>，你可以将 <code>permits</code> 的值理解为许可证的数量，只有拿到许可证的线程才能执行。</p>\n<p>调用<code>semaphore.acquire()</code> ，线程尝试获取许可证，如果 <code>state &gt;= 0</code> 的话，则表示可以获取成功。如果获取成功的话，使用 CAS 操作去修改 <code>state</code> 的值 <code>state=state-1</code>。如果 <code>state&lt;0</code> 的话，则表示许可证数量不足。此时会创建一个 Node 节点加入阻塞队列，挂起当前线程。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>调用<code>semaphore.release();</code> ，线程尝试释放许可证，并使用 CAS 操作去修改 <code>state</code> 的值 <code>state=state+1</code>。释放许可证成功之后，同时会唤醒同步队列中的一个线程。被唤醒的线程会重新尝试去修改 <code>state</code> 的值 <code>state=state-1</code> ，如果 <code>state&gt;=0</code> 则获取令牌成功，否则重新进入阻塞队列，挂起线程。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> CountDownLatch 有什么用？</h3>\n<p><code>CountDownLatch</code> 允许 <code>count</code> 个线程阻塞在一个地方，直至所有线程的任务都执行完毕。</p>\n<p><code>CountDownLatch</code> 是一次性的，计数器的值只能在构造方法中初始化一次，之后没有任何机制再次对其设置值，当 <code>CountDownLatch</code> 使用完毕后，它不能再次被使用。</p>\n<h3> CountDownLatch 的原理是什么？</h3>\n<p><code>CountDownLatch</code> 是共享锁的一种实现,它默认构造 AQS 的 <code>state</code> 值为 <code>count</code>。当线程使用 <code>countDown()</code> 方法时,其实使用了<code>tryReleaseShared</code>方法以 CAS 的操作来减少 <code>state</code>,直至 <code>state</code> 为 0 。当调用 <code>await()</code> 方法的时候，如果 <code>state</code> 不为 0，那就证明任务还没有执行完毕，<code>await()</code> 方法就会一直阻塞，也就是说 <code>await()</code> 方法之后的语句不会被执行。然后，<code>CountDownLatch</code> 会自旋 CAS 判断 <code>state == 0</code>，如果 <code>state == 0</code> 的话，就会释放所有等待的线程，<code>await()</code> 方法之后的语句得到执行。</p>\n<h3> 用过 CountDownLatch 么？什么场景下用的？</h3>\n<p><code>CountDownLatch</code> 的作用就是 允许 count 个线程阻塞在一个地方，直至所有线程的任务都执行完毕。之前在项目中，有一个使用多线程读取多个文件处理的场景，我用到了 <code>CountDownLatch</code> 。具体场景是下面这样的：</p>\n<p>我们要读取处理 6 个文件，这 6 个任务都是没有执行顺序依赖的任务，但是我们需要返回给用户的时候将这几个文件的处理的结果进行统计整理。</p>\n<p>为此我们定义了一个线程池和 count 为 6 的<code>CountDownLatch</code>对象 。使用线程池处理读取任务，每一个线程处理完之后就将 count-1，调用<code>CountDownLatch</code>对象的 <code>await()</code>方法，直到所有文件读取完之后，才会接着执行后面的逻辑。</p>\n<p>伪代码是下面这样的：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>有没有可以改进的地方呢？</strong></p>\n<p>可以使用 <code>CompletableFuture</code> 类来改进！Java8 的 <code>CompletableFuture</code> 提供了很多对多线程友好的方法，使用它可以很方便地为我们编写多线程程序，什么异步、串行、并行或者等待所有线程执行完任务什么的都非常方便。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面的代码还可以继续优化，当任务过多的时候，把每一个 task 都列出来不太现实，可以考虑通过循环来添加任务。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> CyclicBarrier 有什么用？</h3>\n<p><code>CyclicBarrier</code> 和 <code>CountDownLatch</code> 非常类似，它也可以实现线程间的技术等待，但是它的功能比 <code>CountDownLatch</code> 更加复杂和强大。主要应用场景和 <code>CountDownLatch</code> 类似。</p>\n<blockquote>\n<p><code>CountDownLatch</code> 的实现是基于 AQS 的，而 <code>CycliBarrier</code> 是基于 <code>ReentrantLock</code>(<code>ReentrantLock</code> 也属于 AQS 同步器)和 <code>Condition</code> 的。</p>\n</blockquote>\n<p><code>CyclicBarrier</code> 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是：让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。</p>\n<h3> CyclicBarrier 的原理是什么？</h3>\n<p><code>CyclicBarrier</code> 内部通过一个 <code>count</code> 变量作为计数器，<code>count</code> 的初始值为 <code>parties</code> 属性的初始化值，每当一个线程到了栅栏这里了，那么就将计数器减 1。如果 count 值为 0 了，表示这是这一代最后一个线程到达栅栏，就尝试执行我们构造方法中输入的任务。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>下面我们结合源码来简单看看。</p>\n<p>1、<code>CyclicBarrier</code> 默认的构造方法是 <code>CyclicBarrier(int parties)</code>，其参数表示屏障拦截的线程数量，每个线程调用 <code>await()</code> 方法告诉 <code>CyclicBarrier</code> 我已经到达了屏障，然后当前线程被阻塞。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>其中，<code>parties</code> 就代表了有拦截的线程的数量，当拦截的线程数量达到这个值的时候就打开栅栏，让所有线程通过。</p>\n<p>2、当调用 <code>CyclicBarrier</code> 对象调用 <code>await()</code> 方法时，实际上调用的是 <code>dowait(false, 0L)</code>方法。 <code>await()</code> 方法就像树立起一个栅栏的行为一样，将线程挡住了，当拦住的线程数量达到 <code>parties</code> 的值时，栅栏才会打开，线程才得以通过执行。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>dowait(false, 0L)</code>方法源码分析如下：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 参考</h2>\n<ul>\n<li>《深入理解 Java 虚拟机》</li>\n<li>《实战 Java 高并发程序设计》</li>\n<li>带你了解下 SynchronousQueue（并发队列专题）：https://juejin.cn/post/7031196740128768037</li>\n<li>阻塞队列 — DelayedWorkQueue 源码分析：https://zhuanlan.zhihu.com/p/310621485</li>\n<li>Java多线程（三）——FutureTask/CompletableFuture：https://www.cnblogs.com/iwehdio/p/14285282.html</li>\n<li>Java 并发之 AQS 详解：https://www.cnblogs.com/waterystone/p/4920797.html</li>\n<li>Java 并发包基石-AQS 详解：https://www.cnblogs.com/chengxiao/archive/2017/07/24/7141160.html</li>\n</ul>\n",
      "image": "https://pics-cloud.oss-cn-beijing.aliyuncs.com/threadlocal-data-structur.png",
      "date_published": "2022-07-30T10:58:06.000Z",
      "date_modified": "2023-03-07T15:11:05.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "Java SPI 机制详解",
      "url": "https://javaguide.cn/java/basis/spi.html",
      "id": "https://javaguide.cn/java/basis/spi.html",
      "summary": "本文来自 Kingshion 投稿。欢迎更多朋友参与到 JavaGuide 的维护工作，这是一件非常有意义的事情。详细信息请看：JavaGuide 贡献指南 。",
      "content_html": "<blockquote>\n<p>本文来自 <a href=\"https://github.com/jjx0708\" target=\"_blank\" rel=\"noopener noreferrer\">Kingshion</a> 投稿。欢迎更多朋友参与到 JavaGuide 的维护工作，这是一件非常有意义的事情。详细信息请看：<a href=\"https://javaguide.cn/javaguide/contribution-guideline.html\" target=\"_blank\" rel=\"noopener noreferrer\">JavaGuide 贡献指南</a> 。</p>\n</blockquote>\n<p>在面向对象的设计原则中，一般推荐模块之间基于接口编程，通常情况下调用方模块是不会感知到被调用方模块的内部具体实现。一旦代码里面涉及具体实现类，就违反了开闭原则。如果需要替换一种实现，就需要修改代码。</p>\n<p>为了实现在模块装配的时候不用在程序里面动态指明，这就需要一种服务发现机制。Java SPI 就是提供了这样一个机制：<strong>为某个接口寻找服务实现的机制。这有点类似 IoC 的思想，将装配的控制权移交到了程序之外。</strong></p>\n<h2> SPI 介绍</h2>\n<h3> 何谓 SPI?</h3>\n<p>SPI 即 Service Provider Interface ，字面意思就是：“服务提供者的接口”，我的理解是：专门提供给服务提供者或者扩展框架功能的开发者去使用的一个接口。</p>\n<p>SPI 将服务接口和具体的服务实现分离开来，将服务调用方和服务实现者解耦，能够提升程序的扩展性、可维护性。修改或者替换服务实现并不需要修改调用方。</p>\n<p>很多框架都使用了 Java 的 SPI 机制，比如：Spring 框架、数据库加载驱动、日志接口、以及 Dubbo 的扩展实现等等。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/basis/spi/22e1830e0b0e4115a882751f6c417857tplv-k3u1fbpfcp-zoom-1.jpeg\" alt=\"\"></p>\n<h3> SPI 和 API 有什么区别？</h3>\n<p><strong>那 SPI 和 API 有啥区别？</strong></p>\n<p>说到 SPI 就不得不说一下 API 了，从广义上来说它们都属于接口，而且很容易混淆。下面先用一张图说明一下：</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/basis/spi/1ebd1df862c34880bc26b9d494535b3dtplv-k3u1fbpfcp-watermark.png\" alt=\"\"></p>\n<p>一般模块之间都是通过通过接口进行通讯，那我们在服务调用方和服务实现方（也称服务提供者）之间引入一个“接口”。</p>\n<p>当实现方提供了接口和实现，我们可以通过调用实现方的接口从而拥有实现方给我们提供的能力，这就是 API ，这种接口和实现都是放在实现方的。</p>\n<p>当接口存在于调用方这边时，就是 SPI ，由接口调用方确定接口规则，然后由不同的厂商去根据这个规则对这个接口进行实现，从而提供服务。</p>\n<p>举个通俗易懂的例子：公司 H 是一家科技公司，新设计了一款芯片，然后现在需要量产了，而市面上有好几家芯片制造业公司，这个时候，只要 H 公司指定好了这芯片生产的标准（定义好了接口标准），那么这些合作的芯片公司（服务提供者）就按照标准交付自家特色的芯片（提供不同方案的实现，但是给出来的结果是一样的）。</p>\n<h2> 实战演示</h2>\n<p>SLF4J （Simple Logging Facade for Java）是 Java 的一个日志门面（接口），其具体实现有几种，比如：Logback、Log4j、Log4j2 等等，而且还可以切换，在切换日志具体实现的时候我们是不需要更改项目代码的，只需要在 Maven 依赖里面修改一些 pom 依赖就好了。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/basis/spi/image-20220723213306039-165858318917813.png\" alt=\"\"></p>\n<p>这就是依赖 SPI 机制实现的，那我们接下来就实现一个简易版本的日志框架。</p>\n<h3> Service Provider Interface</h3>\n<p>新建一个 Java 项目 <code>service-provider-interface</code> 目录结构如下：（注意直接新建 Java 项目就好了，不用新建 Maven 项目，Maven 项目会涉及到一些编译配置，如果有私服的话，直接 deploy 会比较方便，但是没有的话，在过程中可能会遇到一些奇怪的问题。）</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>新建 <code>Logger</code> 接口，这个就是 SPI ， 服务提供者接口，后面的服务提供者就要针对这个接口进行实现。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>接下来就是 <code>LoggerService</code> 类，这个主要是为服务使用者（调用方）提供特定功能的。这个类也是实现 Java SPI 机制的关键所在，如果存在疑惑的话可以先往后面继续看。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>新建 <code>Main</code> 类（服务使用者，调用方），启动程序查看结果。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>程序结果：</p>\n<blockquote>\n<p>info 中没有发现 Logger 服务提供者\ndebug 中没有发现 Logger 服务提供者</p>\n</blockquote>\n<p>此时我们只是空有接口，并没有为 <code>Logger</code> 接口提供任何的实现，所以输出结果中没有按照预期打印相应的结果。</p>\n<p>你可以使用命令或者直接使用 IDEA 将整个程序直接打包成 jar 包。</p>\n<h3> Service Provider</h3>\n<p>接下来新建一个项目用来实现 <code>Logger</code> 接口</p>\n<p>新建项目 <code>service-provider</code> 目录结构如下：</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>新建 <code>Logback</code> 类</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>将 <code>service-provider-interface</code> 的 jar 导入项目中。</p>\n<p>新建 lib 目录，然后将 jar 包拷贝过来，再添加到项目中。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/basis/spi/523d5e25198444d3b112baf68ce49daetplv-k3u1fbpfcp-watermark.png\" alt=\"\"></p>\n<p>再点击 OK 。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/basis/spi/f4ba0aa71e9b4d509b9159892a220850tplv-k3u1fbpfcp-watermark.png\" alt=\"\"></p>\n<p>接下来就可以在项目中导入 jar 包里面的一些类和方法了，就像 JDK 工具类导包一样的。</p>\n<p>实现 <code>Logger</code> 接口，在 <code>src</code> 目录下新建 <code>META-INF/services</code> 文件夹，然后新建文件 <code>edu.jiangxuan.up.spi.Logger</code> （SPI 的全类名），文件里面的内容是：<code>edu.jiangxuan.up.spi.service.Logback</code> （Logback 的全类名，即 SPI 的实现类的包名 + 类名）。</p>\n<p><strong>这是 JDK SPI 机制 ServiceLoader 约定好的标准。</strong></p>\n<p>这里先大概解释一下：Java 中的 SPI 机制就是在每次类加载的时候会先去找到 class 相对目录下的 <code>META-INF</code> 文件夹下的 services 文件夹下的文件，将这个文件夹下面的所有文件先加载到内存中，然后根据这些文件的文件名和里面的文件内容找到相应接口的具体实现类，找到实现类后就可以通过反射去生成对应的对象，保存在一个 list 列表里面，所以可以通过迭代或者遍历的方式拿到对应的实例对象，生成不同的实现。</p>\n<p>所以会提出一些规范要求：文件名一定要是接口的全类名，然后里面的内容一定要是实现类的全类名，实现类可以有多个，直接换行就好了，多个实现类的时候，会一个一个的迭代加载。</p>\n<p>接下来同样将 <code>service-provider</code> 项目打包成 jar 包，这个 jar 包就是服务提供方的实现。通常我们导入 maven 的 pom 依赖就有点类似这种，只不过我们现在没有将这个 jar 包发布到 maven 公共仓库中，所以在需要使用的地方只能手动的添加到项目中。</p>\n<h3> 效果展示</h3>\n<p>为了更直观的展示效果，我这里再新建一个专门用来测试的工程项目：<code>java-spi-test</code></p>\n<p>然后先导入 <code>Logger</code> 的接口 jar 包，再导入具体的实现类的 jar 包。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/basis/spi/image-20220723215812708-165858469599214.png\" alt=\"\"></p>\n<p>新建 Main 方法测试：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>运行结果如下：</p>\n<blockquote>\n<p>Logback info 打印日志：你好\nLogback debug 打印日志：测试 Java SPI 机制</p>\n</blockquote>\n<p>说明导入 jar 包中的实现类生效了。</p>\n<p>如果我们不导入具体的实现类的 jar 包，那么此时程序运行的结果就会是：</p>\n<blockquote>\n<p>info 中没有发现 Logger 服务提供者\ndebug 中没有发现 Logger 服务提供者</p>\n</blockquote>\n<p>通过使用 SPI 机制，可以看出服务（<code>LoggerService</code>）和 服务提供者两者之间的耦合度非常低，如果说我们想要换一种实现，那么其实只需要修改 <code>service-provider</code> 项目中针对 <code>Logger</code> 接口的具体实现就可以了，只需要换一个 jar 包即可，也可以有在一个项目里面有多个实现，这不就是 SLF4J 原理吗？</p>\n<p>如果某一天需求变更了，此时需要将日志输出到消息队列，或者做一些别的操作，这个时候完全不需要更改 Logback 的实现，只需要新增一个服务实现（service-provider）可以通过在本项目里面新增实现也可以从外部引入新的服务实现 jar 包。我们可以在服务(LoggerService)中选择一个具体的 服务实现(service-provider) 来完成我们需要的操作。</p>\n<p>那么接下来我们具体来说说 Java SPI 工作的重点原理—— <strong>ServiceLoader</strong> 。</p>\n<h2> ServiceLoader</h2>\n<h3> ServiceLoader 具体实现</h3>\n<p>想要使用 Java 的 SPI 机制是需要依赖 <code>ServiceLoader</code> 来实现的，那么我们接下来看看 <code>ServiceLoader</code> 具体是怎么做的：</p>\n<p><code>ServiceLoader</code> 是 JDK 提供的一个工具类， 位于<code>package java.util;</code>包下。</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>这是 JDK 官方给的注释：<strong>一种加载服务实现的工具。</strong></p>\n<p>再往下看，我们发现这个类是一个 <code>final</code> 类型的，所以是不可被继承修改，同时它实现了 <code>Iterable</code> 接口。之所以实现了迭代器，是为了方便后续我们能够通过迭代的方式得到对应的服务实现。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>可以看到一个熟悉的常量定义：</p>\n<p><code>private static final String PREFIX = \"META-INF/services/\";</code></p>\n<p>下面是 <code>load</code> 方法：可以发现 <code>load</code> 方法支持两种重载后的入参；</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>根据代码的调用顺序，在 <code>reload()</code> 方法中是通过一个内部类 <code>LazyIterator</code> 实现的。先继续往下面看。</p>\n<p><code>ServiceLoader</code> 实现了 <code>Iterable</code> 接口的方法后，具有了迭代的能力，在这个 <code>iterator</code> 方法被调用时，首先会在 <code>ServiceLoader</code> 的 <code>Provider</code> 缓存中进行查找，如果缓存中没有命中那么则在 <code>LazyIterator</code> 中进行查找。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在调用 <code>LazyIterator</code> 时，具体实现如下：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>可能很多人看这个会觉得有点复杂，没关系，我这边实现了一个简单的 <code>ServiceLoader</code> 的小模型，流程和原理都是保持一致的，可以先从自己实现一个简易版本的开始学：</p>\n<h3> 自己实现一个 ServiceLoader</h3>\n<p>我先把代码贴出来：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>关键信息基本已经通过代码注释描述出来了，</p>\n<p>主要的流程就是：</p>\n<ol>\n<li>通过 URL 工具类从 jar 包的 <code>/META-INF/services</code> 目录下面找到对应的文件，</li>\n<li>读取这个文件的名称找到对应的 spi 接口，</li>\n<li>通过 <code>InputStream</code> 流将文件里面的具体实现类的全类名读取出来，</li>\n<li>根据获取到的全类名，先判断跟 spi 接口是否为同一类型，如果是的，那么就通过反射的机制构造对应的实例对象，</li>\n<li>将构造出来的实例对象添加到 <code>Providers</code> 的列表中。</li>\n</ol>\n<h2> 总结</h2>\n<p>其实不难发现，SPI 机制的具体实现本质上还是通过反射完成的。即：<strong>我们按照规定将要暴露对外使用的具体实现类在 <code>META-INF/services/</code> 文件下声明。</strong></p>\n<p>另外，SPI 机制在很多框架中都有应用：Spring 框架的基本原理也是类似的反射。还有 Dubbo 框架提供同样的 SPI 扩展机制，只不过 Dubbo 和 spring 框架中的 SPI 机制具体实现方式跟咱们今天学得这个有些细微的区别，不过整体的原理都是一致的，相信大家通过对 JDK 中 SPI 机制的学习，能够一通百通，加深对其他高深框的理解。</p>\n<p>通过 SPI 机制能够大大地提高接口设计的灵活性，但是 SPI 机制也存在一些缺点，比如：</p>\n<ol>\n<li>遍历加载所有的实现类，这样效率还是相对较低的；</li>\n<li>当多个 <code>ServiceLoader</code> 同时 <code>load</code> 时，会有并发问题。</li>\n</ol>\n",
      "image": "https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/basis/spi/22e1830e0b0e4115a882751f6c417857tplv-k3u1fbpfcp-zoom-1.jpeg",
      "date_published": "2022-07-24T09:10:58.000Z",
      "date_modified": "2022-10-07T15:17:29.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "Redis常见面试题总结(下)",
      "url": "https://javaguide.cn/database/redis/redis-questions-02.html",
      "id": "https://javaguide.cn/database/redis/redis-questions-02.html",
      "summary": "Redis 事务 如何使用 Redis 事务？ Redis 可以通过 MULTI，EXEC，DISCARD 和 WATCH 等命令来实现事务(transaction)功能。 &gt; MULTI OK &gt; SET PROJECT \"JavaGuide\" QUEUED &gt; GET PROJECT QUEUED &gt; EXEC 1) OK 2) \"JavaGuide\"",
      "content_html": "<h2> Redis 事务</h2>\n<h3> 如何使用 Redis 事务？</h3>\n<p>Redis 可以通过 <strong><code>MULTI</code>，<code>EXEC</code>，<code>DISCARD</code> 和 <code>WATCH</code></strong> 等命令来实现事务(transaction)功能。</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><a href=\"https://redis.io/commands/multi\" target=\"_blank\" rel=\"noopener noreferrer\"><code>MULTI</code></a> 命令后可以输入多个命令，Redis 不会立即执行这些命令，而是将它们放到队列，当调用了 <a href=\"https://redis.io/commands/exec\" target=\"_blank\" rel=\"noopener noreferrer\"><code>EXEC</code></a> 命令后，再执行所有的命令。</p>\n<p>这个过程是这样的：</p>\n<ol>\n<li>开始事务（<code>MULTI</code>）；</li>\n<li>命令入队(批量操作 Redis 的命令，先进先出（FIFO）的顺序执行)；</li>\n<li>执行事务(<code>EXEC</code>)。</li>\n</ol>\n<p>你也可以通过 <a href=\"https://redis.io/commands/discard\" target=\"_blank\" rel=\"noopener noreferrer\"><code>DISCARD</code></a> 命令取消一个事务，它会清空事务队列中保存的所有命令。</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>你可以通过<a href=\"https://redis.io/commands/watch\" target=\"_blank\" rel=\"noopener noreferrer\"><code>WATCH</code></a> 命令监听指定的 Key，当调用 <code>EXEC</code> 命令执行事务时，如果一个被 <code>WATCH</code> 命令监视的 Key 被 <strong>其他客户端/Session</strong> 修改的话，整个事务都不会被执行。</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>不过，如果 <strong>WATCH</strong> 与 <strong>事务</strong> 在同一个 Session 里，并且被 <strong>WATCH</strong> 监视的 Key 被修改的操作发生在事务内部，这个事务是可以被执行成功的（相关 issue ：<a href=\"https://github.com/Snailclimb/JavaGuide/issues/1714\" target=\"_blank\" rel=\"noopener noreferrer\">WATCH 命令碰到 MULTI 命令时的不同效果</a>）。</p>\n<p>事务内部修改 WATCH 监视的 Key：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>事务外部修改 WATCH 监视的 Key：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>Redis 官网相关介绍 <a href=\"https://redis.io/topics/transactions\" target=\"_blank\" rel=\"noopener noreferrer\">https://redis.io/topics/transactions</a> 如下：</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/redis-transactions.png\" alt=\"Redis 事务\"></p>\n<h3> Redis 事务支持原子性吗？</h3>\n<p>Redis 的事务和我们平时理解的关系型数据库的事务不同。我们知道事务具有四大特性： <strong>1. 原子性</strong>，<strong>2. 隔离性</strong>，<strong>3. 持久性</strong>，<strong>4. 一致性</strong>。</p>\n<ol>\n<li><strong>原子性（Atomicity）：</strong> 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li>\n<li><strong>隔离性（Isolation）：</strong> 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li>\n<li><strong>持久性（Durability）：</strong> 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li>\n<li><strong>一致性（Consistency）：</strong> 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；</li>\n</ol>\n<p>Redis 事务在运行错误的情况下，除了执行过程中出现错误的命令外，其他命令都能正常执行。并且，Redis 事务是不支持回滚（roll back）操作的。因此，Redis 事务其实是不满足原子性的（而且不满足持久性）。</p>\n<p>Redis 官网也解释了自己为啥不支持回滚。简单来说就是 Redis 开发者们觉得没必要支持回滚，这样更简单便捷并且性能更好。Redis 开发者觉得即使命令执行错误也应该在开发过程中就被发现而不是生产过程中。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/redis-rollback.png\" alt=\"Redis 为什么不支持回滚\"></p>\n<p>你可以将 Redis 中的事务就理解为 ：<strong>Redis 事务提供了一种将多个命令请求打包的功能。然后，再按顺序执行打包的所有命令，并且不会被中途打断。</strong></p>\n<p>除了不满足原子性之外，事务中的每条命令都会与 Redis 服务器进行网络交互，这是比较浪费资源的行为。明明一次批量执行多个命令就可以了，这种操作实在是看不懂。</p>\n<p>因此，Redis 事务是不建议在日常开发中使用的。</p>\n<p><strong>相关 issue</strong> :</p>\n<ul>\n<li><a href=\"https://github.com/Snailclimb/JavaGuide/issues/452\" target=\"_blank\" rel=\"noopener noreferrer\">issue452: 关于 Redis 事务不满足原子性的问题</a> 。</li>\n<li><a href=\"https://github.com/Snailclimb/JavaGuide/issues/491\" target=\"_blank\" rel=\"noopener noreferrer\">Issue491:关于 redis 没有事务回滚？</a></li>\n</ul>\n<h3> 如何解决 Redis 事务的缺陷？</h3>\n<p>Redis 从 2.6 版本开始支持执行 Lua 脚本，它的功能和事务非常类似。我们可以利用 Lua 脚本来批量执行多条 Redis 命令，这些 Redis 命令会被提交到 Redis 服务器一次性执行完成，大幅减小了网络开销。</p>\n<p>一段 Lua 脚本可以视作一条命令执行，一段 Lua 脚本执行过程中不会有其他脚本或 Redis 命令同时执行，保证了操作不会被其他指令插入或打扰。</p>\n<p>不过，如果 Lua 脚本运行时出错并中途结束，出错之后的命令是不会被执行的。并且，出错之前执行的命令是无法被撤销的，无法实现类似关系型数据库执行失败可以回滚的那种原子性效果。因此， <strong>严格来说的话，通过 Lua 脚本来批量执行 Redis 命令实际也是不完全满足原子性的。</strong></p>\n<p>如果想要让 Lua 脚本中的命令全部执行，必须保证语句语法和命令都是对的。</p>\n<p>另外，Redis 7.0 新增了 <a href=\"https://redis.io/docs/manual/programmability/functions-intro/\" target=\"_blank\" rel=\"noopener noreferrer\">Redis functions</a> 特性，你可以将 Redis functions 看作是比 Lua 更强大的脚本。</p>\n<h2> Redis 性能优化</h2>\n<h3> Redis bigkey</h3>\n<h4> 什么是 bigkey？</h4>\n<p>简单来说，如果一个 key 对应的 value 所占用的内存比较大，那这个 key 就可以看作是 bigkey。具体多大才算大呢？有一个不是特别精确的参考标准：string 类型的 value 超过 10 kb，复合类型的 value 包含的元素超过 5000 个（对于复合类型的 value 来说，不一定包含的元素越多，占用的内存就越多）。</p>\n<h4> bigkey 有什么危害？</h4>\n<p>除了会消耗更多的内存空间，bigkey 对性能也会有比较大的影响。</p>\n<p>因此，我们应该尽量避免写入 bigkey！</p>\n<h4> 如何发现 bigkey？</h4>\n<p><strong>1、使用 Redis 自带的 <code>--bigkeys</code> 参数来查找。</strong></p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>从这个命令的运行结果，我们可以看出：这个命令会扫描(Scan) Redis 中的所有 key ，会对 Redis 的性能有一点影响。并且，这种方式只能找出每种数据结构 top 1 bigkey（占用内存最大的 string 数据类型，包含元素最多的复合数据类型）。</p>\n<p><strong>2、分析 RDB 文件</strong></p>\n<p>通过分析 RDB 文件来找出 big key。这种方案的前提是你的 Redis 采用的是 RDB 持久化。</p>\n<p>网上有现成的代码/工具可以直接拿来使用：</p>\n<ul>\n<li><a href=\"https://github.com/sripathikrishnan/redis-rdb-tools\" target=\"_blank\" rel=\"noopener noreferrer\">redis-rdb-tools</a> ：Python 语言写的用来分析 Redis 的 RDB 快照文件用的工具</li>\n<li><a href=\"https://github.com/weiyanwei412/rdb_bigkeys\" target=\"_blank\" rel=\"noopener noreferrer\">rdb_bigkeys</a> : Go 语言写的用来分析 Redis 的 RDB 快照文件用的工具，性能更好。</li>\n</ul>\n<h3> 大量 key 集中过期问题</h3>\n<p>我在上面提到过：对于过期 key，Redis 采用的是 <strong>定期删除+惰性/懒汉式删除</strong> 策略。</p>\n<p>定期删除执行过程中，如果突然遇到大量过期 key 的话，客户端请求必须等待定期清理过期 key 任务线程执行完成，因为这个这个定期任务线程是在 Redis 主线程中执行的。这就导致客户端请求没办法被及时处理，响应速度会比较慢。</p>\n<p>如何解决呢？下面是两种常见的方法：</p>\n<ol>\n<li>给 key 设置随机过期时间。</li>\n<li>开启 lazy-free（惰性删除/延迟释放） 。lazy-free 特性是 Redis 4.0 开始引入的，指的是让 Redis 采用异步方式延迟释放 key 使用的内存，将该操作交给单独的子线程处理，避免阻塞主线程。</li>\n</ol>\n<p>个人建议不管是否开启 lazy-free，我们都尽量给 key 设置随机过期时间。</p>\n<h3> 使用批量操作减少网络传输</h3>\n<p>一个 Redis 命令的执行可以简化为以下 4 步：</p>\n<ol>\n<li>发送命令</li>\n<li>命令排队</li>\n<li>命令执行</li>\n<li>返回结果</li>\n</ol>\n<p>其中，第 1 步和第 4 步耗费时间之和称为 <strong>Round Trip Time (RTT,往返时间)</strong> ，也就是数据在网络上传输的时间。</p>\n<p><strong>使用批量操作可以减少网络传输次数，进而有效减小网络开销，大幅减少 RTT。</strong></p>\n<h4> 原生批量操作命令</h4>\n<p>Redis 中有一些原生支持批量操作的命令，比如：</p>\n<ul>\n<li><code>mget</code>(获取一个或多个指定 key 的值)、<code>mset</code>(设置一个或多个指定 key 的值)、</li>\n<li><code>hmget</code>(获取指定哈希表中一个或者多个指定字段的值)、<code>hmset</code>(同时将一个或多个 field-value 对设置到指定哈希表中)、</li>\n<li><code>sadd</code>（向指定集合添加一个或多个元素）</li>\n<li>......</li>\n</ul>\n<p>不过，在 Redis 官方提供的分片集群解决方案 Redis Cluster 下，使用这些原生批量操作命令可能会存在一些小问题需要解决。就比如说 <code>mget</code> 无法保证所有的 key 都在同一个 <strong>hash slot</strong>（哈希槽）上，<code>mget</code>可能还是需要多次网络传输，原子操作也无法保证了。不过，相较于非批量操作，还是可以节省不少网络传输次数。</p>\n<p>整个步骤的简化版如下（通常由 Redis 客户端实现，无需我们自己再手动实现）：</p>\n<ol>\n<li>找到 key 对应的所有 hash slot；</li>\n<li>分别向对应的 Redis 节点发起 <code>mget</code> 请求获取数据；</li>\n<li>等待所有请求执行结束，重新组装结果数据，保持跟入参 key 的顺序一致，然后返回结果。</li>\n</ol>\n<p>如果想要解决这个多次网络传输的问题，比较常用的办法是自己维护 key 与 slot 的关系。不过这样不太灵活，虽然带来了性能提升，但同样让系统复杂性提升。</p>\n<blockquote>\n<p>Redis Cluster 并没有使用一致性哈希，采用的是 <strong>哈希槽分区</strong> ，每一个键值对都属于一个 <strong>hash slot</strong>（哈希槽） 。当客户端发送命令请求的时候，需要先根据 key 通过上面的计算公示找到的对应的哈希槽，然后再查询哈希槽和节点的映射关系，即可找到目标 Redis 节点。</p>\n<p>我在 <a href=\"https://javaguide.cn/database/redis/redis-cluster.html\" target=\"_blank\" rel=\"noopener noreferrer\">Redis 集群详解（付费）</a> 这篇文章中详细介绍了 Redis Cluster 这部分的内容，感兴趣地可以看看。</p>\n</blockquote>\n<h4> pipeline</h4>\n<p>对于不支持批量操作的命令，我们可以利用 <strong>pipeline（流水线)</strong> 将一批 Redis 命令封装成一组，这些 Redis 命令会被一次性提交到 Redis 服务器，只需要一次网络传输。不过，需要注意控制一次批量操作的 <strong>元素个数</strong>(例如 500 以内，实际也和元素字节数有关)，避免网络传输的数据量过大。</p>\n<p>与<code>mget</code>、<code>mset</code>等原生批量操作命令一样，pipeline 同样在 Redis Cluster 上使用会存在一些小问题。原因类似，无法保证所有的 key 都在同一个 <strong>hash slot</strong>（哈希槽）上。如果想要使用的话，客户端需要自己维护 key 与 slot 的关系。</p>\n<p>原生批量操作命令和 pipeline 的是有区别的，使用的时候需要注意：</p>\n<ul>\n<li>原生批量操作命令是原子操作，pipeline 是非原子操作；</li>\n<li>pipeline 可以打包不同的命令，原生批量操作命令不可以；</li>\n<li>原生批量操作命令是 Redis 服务端支持实现的，而 pipeline 需要服务端和客户端的共同实现。</li>\n</ul>\n<p>另外，pipeline 不适用于执行顺序有依赖关系的一批命令。就比如说，你需要将前一个命令的结果给后续的命令使用，pipeline 就没办法满足你的需求了。对于这种需求，我们可以使用 <strong>Lua 脚本</strong> 。</p>\n<h4> Lua 脚本</h4>\n<p>Lua 脚本同样支持批量操作多条命令。一段 Lua 脚本可以视作一条命令执行，可以看作是原子操作。一段 Lua 脚本执行过程中不会有其他脚本或 Redis 命令同时执行，保证了操作不会被其他指令插入或打扰，这是 pipeline 所不具备的。</p>\n<p>并且，Lua 脚本中支持一些简单的逻辑处理比如使用命令读取值并在 Lua 脚本中进行处理，这同样是 pipeline 所不具备的。</p>\n<p>不过， Redis Cluster 下 Lua 脚本的原子操作也无法保证了，原因同样是无法保证所有的 key 都在同一个 <strong>hash slot</strong>（哈希槽）上。</p>\n<h2> Redis 生产问题</h2>\n<h3> 缓存穿透</h3>\n<h4> 什么是缓存穿透？</h4>\n<p>缓存穿透说简单点就是大量请求的 key 是不合理的，<strong>根本不存在于缓存中，也不存在于数据库中</strong> 。这就导致这些请求直接到了数据库上，根本没有经过缓存这一层，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/redis-cache-penetration.png\" alt=\"缓存穿透\"></p>\n<p>举个例子：某个黑客故意制造一些非法的 key 发起大量请求，导致大量请求落到数据库，结果数据库上也没有查到对应的数据。也就是说这些请求最终都落到了数据库上，对数据库造成了巨大的压力。</p>\n<h4> 有哪些解决办法？</h4>\n<p>最基本的就是首先做好参数校验，一些不合法的参数请求直接抛出异常信息返回给客户端。比如查询的数据库 id 不能小于 0、传入的邮箱格式不对的时候直接返回错误消息给客户端等等。</p>\n<p><strong>1）缓存无效 key</strong></p>\n<p>如果缓存和数据库都查不到某个 key 的数据就写一个到 Redis 中去并设置过期时间，具体命令如下： <code>SET key value EX 10086</code> 。这种方式可以解决请求的 key 变化不频繁的情况，如果黑客恶意攻击，每次构建不同的请求 key，会导致 Redis 中缓存大量无效的 key 。很明显，这种方案并不能从根本上解决此问题。如果非要用这种方式来解决穿透问题的话，尽量将无效的 key 的过期时间设置短一点比如 1 分钟。</p>\n<p>另外，这里多说一嘴，一般情况下我们是这样设计 key 的： <code>表名:列名:主键名:主键值</code> 。</p>\n<p>如果用 Java 代码展示的话，差不多是下面这样的：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>2）布隆过滤器</strong></p>\n<p>布隆过滤器是一个非常神奇的数据结构，通过它我们可以非常方便地判断一个给定数据是否存在于海量数据中。我们需要的就是判断 key 是否合法，有没有感觉布隆过滤器就是我们想要找的那个“人”。</p>\n<p>具体是这样做的：把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。</p>\n<p>加入布隆过滤器之后的缓存处理流程图如下。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/redis-cache-penetration-bloom-filter.png\" alt=\"加入布隆过滤器之后的缓存处理流程图\"></p>\n<p>但是，需要注意的是布隆过滤器可能会存在误判的情况。总结来说就是： <strong>布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。</strong></p>\n<p><em>为什么会出现误判的情况呢? 我们还要从布隆过滤器的原理来说！</em></p>\n<p>我们先来看一下，<strong>当一个元素加入布隆过滤器中的时候，会进行哪些操作：</strong></p>\n<ol>\n<li>使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。</li>\n<li>根据得到的哈希值，在位数组中把对应下标的值置为 1。</li>\n</ol>\n<p>我们再来看一下，<strong>当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行哪些操作：</strong></p>\n<ol>\n<li>对给定元素再次进行相同的哈希计算；</li>\n<li>得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。</li>\n</ol>\n<p>然后，一定会出现这样一种情况：<strong>不同的字符串可能哈希出来的位置相同。</strong> （可以适当增加位数组大小或者调整我们的哈希函数来降低概率）</p>\n<p>更多关于布隆过滤器的内容可以看我的这篇原创：<a href=\"https://javaguide.cn/cs-basics/data-structure/bloom-filter/\" target=\"_blank\" rel=\"noopener noreferrer\">《不了解布隆过滤器？一文给你整的明明白白！》</a> ，强烈推荐，个人感觉网上应该找不到总结的这么明明白白的文章了。</p>\n<h3> 缓存击穿</h3>\n<h4> 什么是缓存击穿？</h4>\n<p>缓存击穿中，请求的 key 对应的是 <strong>热点数据</strong> ，该数据 <strong>存在于数据库中，但不存在于缓存中（通常是因为缓存中的那份数据已经过期）</strong> 。这就可能会导致瞬时大量的请求直接打到了数据库上，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/redis-cache-breakdown.png\" alt=\"缓存击穿\"></p>\n<p>举个例子 ：秒杀进行过程中，缓存中的某个秒杀商品的数据突然过期，这就导致瞬时大量对该商品的请求直接落到数据库上，对数据库造成了巨大的压力。</p>\n<h4> 有哪些解决办法？</h4>\n<ul>\n<li>设置热点数据永不过期或者过期时间比较长。</li>\n<li>针对热点数据提前预热，将其存入缓存中并设置合理的过期时间比如秒杀场景下的数据在秒杀结束之前不过期。</li>\n<li>请求数据库写数据到缓存之前，先获取互斥锁，保证只有一个请求会落到数据库上，减少数据库的压力。</li>\n</ul>\n<h4> 缓存穿透和缓存击穿有什么区别？</h4>\n<p>缓存穿透中，请求的 key 既不存在于缓存中，也不存在于数据库中。</p>\n<p>缓存击穿中，请求的 key 对应的是 <strong>热点数据</strong> ，该数据 <strong>存在于数据库中，但不存在于缓存中（通常是因为缓存中的那份数据已经过期）</strong> 。</p>\n<h3> 缓存雪崩</h3>\n<h4> 什么是缓存雪崩？</h4>\n<p>我发现缓存雪崩这名字起的有点意思，哈哈。</p>\n<p>实际上，缓存雪崩描述的就是这样一个简单的场景：<strong>缓存在同一时间大面积的失效，导致大量的请求都直接落到了数据库上，对数据库造成了巨大的压力。</strong> 这就好比雪崩一样，摧枯拉朽之势，数据库的压力可想而知，可能直接就被这么多请求弄宕机了。</p>\n<p>另外，缓存服务宕机也会导致缓存雪崩现象，导致所有的请求都落到了数据库上。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/redis-cache-avalanche.png\" alt=\"缓存雪崩\"></p>\n<p>举个例子 ：数据库中的大量数据在同一时间过期，这个时候突然有大量的请求需要访问这些过期的数据。这就导致大量的请求直接落到数据库上，对数据库造成了巨大的压力。</p>\n<h4> 有哪些解决办法？</h4>\n<p><strong>针对 Redis 服务不可用的情况：</strong></p>\n<ol>\n<li>采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。</li>\n<li>限流，避免同时处理大量的请求。</li>\n</ol>\n<p><strong>针对热点缓存失效的情况：</strong></p>\n<ol>\n<li>设置不同的失效时间比如随机设置缓存的失效时间。</li>\n<li>缓存永不失效（不太推荐，实用性太差）。</li>\n<li>设置二级缓存。</li>\n</ol>\n<h4> 缓存雪崩和缓存击穿有什么区别？</h4>\n<p>缓存雪崩和缓存击穿比较像，但缓存雪崩导致的原因是缓存中的大量或者所有数据失效，缓存击穿导致的原因主要是某个热点数据不存在与缓存中（通常是因为缓存中的那份数据已经过期）。</p>\n<h3> 如何保证缓存和数据库数据的一致性？</h3>\n<p>细说的话可以扯很多，但是我觉得其实没太大必要（小声 BB：很多解决方案我也没太弄明白）。我个人觉得引入缓存之后，如果为了短时间的不一致性问题，选择让系统设计变得更加复杂的话，完全没必要。</p>\n<p>下面单独对 <strong>Cache Aside Pattern（旁路缓存模式）</strong> 来聊聊。</p>\n<p>Cache Aside Pattern 中遇到写请求是这样的：更新 DB，然后直接删除 cache 。</p>\n<p>如果更新数据库成功，而删除缓存这一步失败的情况的话，简单说两个解决方案：</p>\n<ol>\n<li><strong>缓存失效时间变短（不推荐，治标不治本）</strong> ：我们让缓存数据的过期时间变短，这样的话缓存就会从数据库中加载数据。另外，这种解决办法对于先操作缓存后操作数据库的场景不适用。</li>\n<li><strong>增加 cache 更新重试机制（常用）</strong>： 如果 cache 服务当前不可用导致缓存删除失败的话，我们就隔一段时间进行重试，重试次数可以自己定。如果多次重试还是失败的话，我们可以把当前更新失败的 key 存入队列中，等缓存服务可用之后，再将缓存中对应的 key 删除即可。</li>\n</ol>\n<p>相关文章推荐：<a href=\"https://mp.weixin.qq.com/s?__biz=MzIyOTYxNDI5OA==&amp;mid=2247487312&amp;idx=1&amp;sn=fa19566f5729d6598155b5c676eee62d&amp;chksm=e8beb8e5dfc931f3e35655da9da0b61c79f2843101c130cf38996446975014f958a6481aacf1&amp;scene=178&amp;cur_album_id=1699766580538032128#rd\" target=\"_blank\" rel=\"noopener noreferrer\">缓存和数据库一致性问题，看这篇就够了 - 水滴与银弹</a></p>\n<h2> Redis 集群</h2>\n<p><strong>Redis Sentinel</strong> ：</p>\n<ol>\n<li>什么是 Sentinel？ 有什么用？</li>\n<li>Sentinel 如何检测节点是否下线？主观下线与客观下线的区别?</li>\n<li>Sentinel 是如何实现故障转移的？</li>\n<li>为什么建议部署多个 sentinel 节点（哨兵集群）？</li>\n<li>Sentinel 如何选择出新的 master（选举机制）?</li>\n<li>如何从 Sentinel 集群中选择出 Leader ？</li>\n<li>Sentinel 可以防止脑裂吗？</li>\n</ol>\n<p><strong>Redis Cluster</strong> ：</p>\n<ol>\n<li>为什么需要 Redis Cluster？解决了什么问题？有什么优势？</li>\n<li>Redis Cluster 是如何分片的？</li>\n<li>为什么 Redis Cluster 的哈希槽是 16384 个?</li>\n<li>如何确定给定 key 的应该分布到哪个哈希槽中？</li>\n<li>Redis Cluster 支持重新分配哈希槽吗？</li>\n<li>Redis Cluster 扩容缩容期间可以提供服务吗？</li>\n<li>Redis Cluster 中的节点是怎么进行通信的？</li>\n</ol>\n<p><strong>参考答案</strong> ：<a href=\"https://javaguide.cn/database/redis/redis-cluster.html\" target=\"_blank\" rel=\"noopener noreferrer\">Redis 集群详解（付费）</a>。</p>\n<h2> Redis 使用规范</h2>\n<p>实际使用 Redis 的过程中，我们尽量要准守一些常见的规范，比如：</p>\n<ol>\n<li>使用连接池：避免频繁创建关闭客户端连接。</li>\n<li>尽量不使用 O(n)指令，使用 O(N)命令时要关注 N 的数量 ：例如 <code>hgetall</code>、<code>lrange</code>、<code>smembers</code>、<code>zrange</code>、<code>sinter</code> 、<code>sunion</code> 命令并非不能使用，但是需要明确 N 的值。有遍历的需求可以使用 <code>hscan</code>、<code>sscan</code>、<code>zscan</code> 代替。</li>\n<li>使用批量操作减少网络传输 ：原生批量操作命令（比如 <code>mget</code>、<code>mset</code>等等）、pipeline、Lua 脚本。</li>\n<li>尽量不适用 Redis 事务：Redis 事务实现的功能比较鸡肋，可以使用 Lua 脚本代替。</li>\n<li>禁止长时间开启 monitor：对性能影响比较大。</li>\n<li>控制 key 的生命周期：避免 Redis 中存放了太多不经常被访问的数据。</li>\n<li>......</li>\n</ol>\n<p>相关文章推荐 ：<a href=\"https://developer.aliyun.com/article/531067\" target=\"_blank\" rel=\"noopener noreferrer\">阿里云 Redis 开发规范</a> 。</p>\n<h2> 参考</h2>\n<ul>\n<li>《Redis 开发与运维》</li>\n<li>《Redis 设计与实现》</li>\n<li>Redis Transactions : https://redis.io/docs/manual/transactions/ 。</li>\n</ul>\n",
      "image": "https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/redis-transactions.png",
      "date_published": "2022-07-20T14:27:00.000Z",
      "date_modified": "2023-03-01T06:30:18.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "数据库"
      ]
    },
    {
      "title": "Redis 5 种基本数据结构详解",
      "url": "https://javaguide.cn/database/redis/redis-data-structures-01.html",
      "id": "https://javaguide.cn/database/redis/redis-data-structures-01.html",
      "summary": "Redis 共有 5 种基本数据结构：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）。 这 5 种数据结构是直接提供给用户使用的，是数据的保存形式，其底层实现主要依赖这 8 种数据结构：简单动态字符串（SDS）、LinkedList（双向链表）、Hash Table（哈希表）、SkipList（跳跃表）、Intset（整数集合）、ZipList（压缩列表）、QuickList（快速列表）。 Redis 基本数据结构的底层数据结构实现如下： String List Hash Set Zset SDS LinkedList/ZipList/QuickList Hash Table、ZipList ZipList、Intset ZipList、SkipList",
      "content_html": "<p>Redis 共有 5 种基本数据结构：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）。</p>\n<p>这 5 种数据结构是直接提供给用户使用的，是数据的保存形式，其底层实现主要依赖这 8 种数据结构：简单动态字符串（SDS）、LinkedList（双向链表）、Hash Table（哈希表）、SkipList（跳跃表）、Intset（整数集合）、ZipList（压缩列表）、QuickList（快速列表）。</p>\n<p>Redis 基本数据结构的底层数据结构实现如下：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">String</th>\n<th style=\"text-align:left\">List</th>\n<th style=\"text-align:left\">Hash</th>\n<th style=\"text-align:left\">Set</th>\n<th style=\"text-align:left\">Zset</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">SDS</td>\n<td style=\"text-align:left\">LinkedList/ZipList/QuickList</td>\n<td style=\"text-align:left\">Hash Table、ZipList</td>\n<td style=\"text-align:left\">ZipList、Intset</td>\n<td style=\"text-align:left\">ZipList、SkipList</td>\n</tr>\n</tbody>\n</table>\n<p>Redis 3.2 之前，List 底层实现是 LinkedList 或者 ZipList。 Redis 3.2 之后，引入了 LinkedList 和 ZipList 的结合 QuickList，List 的底层实现变为 QuickList。</p>\n<p>你可以在 Redis 官网上找到 Redis 数据结构非常详细的介绍：</p>\n<ul>\n<li><a href=\"https://redis.com/redis-enterprise/data-structures/\" target=\"_blank\" rel=\"noopener noreferrer\">Redis Data Structures</a></li>\n<li><a href=\"https://redis.io/docs/manual/data-types/data-types-tutorial/\" target=\"_blank\" rel=\"noopener noreferrer\">Redis Data types tutorial</a></li>\n</ul>\n<p>未来随着 Redis 新版本的发布，可能会有新的数据结构出现，通过查阅 Redis 官网对应的介绍，你总能获取到最靠谱的信息。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/image-20220720181630203.png\" alt=\"\"></p>\n<h2> String（字符串）</h2>\n<h3> 介绍</h3>\n<p>String 是 Redis 中最简单同时也是最常用的一个数据结构。</p>\n<p>String 是一种二进制安全的数据结构，可以用来存储任何类型的数据比如字符串、整数、浮点数、图片（图片的 base64 编码或者解码或者图片的路径）、序列化后的对象。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/image-20220719124403897.png\" alt=\"\"></p>\n<p>虽然 Redis 是用 C 语言写的，但是 Redis 并没有使用 C 的字符串表示，而是自己构建了一种 <strong>简单动态字符串</strong>（Simple Dynamic String，<strong>SDS</strong>）。相比于 C 的原生字符串，Redis 的 SDS 不光可以保存文本数据还可以保存二进制数据，并且获取字符串长度复杂度为 O(1)（C 字符串为 O(N)）,除此之外，Redis 的 SDS API 是安全的，不会造成缓冲区溢出。</p>\n<h3> 常用命令</h3>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>介绍</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>SET key value</td>\n<td>设置指定 key 的值</td>\n</tr>\n<tr>\n<td>SETNX key value</td>\n<td>只有在 key 不存在时设置 key 的值</td>\n</tr>\n<tr>\n<td>GET key</td>\n<td>获取指定 key 的值</td>\n</tr>\n<tr>\n<td>MSET key1 value1 key2 value2 …</td>\n<td>设置一个或多个指定 key 的值</td>\n</tr>\n<tr>\n<td>MGET key1 key2 ...</td>\n<td>获取一个或多个指定 key 的值</td>\n</tr>\n<tr>\n<td>STRLEN key</td>\n<td>返回 key 所储存的字符串值的长度</td>\n</tr>\n<tr>\n<td>INCR key</td>\n<td>将 key 中储存的数字值增一</td>\n</tr>\n<tr>\n<td>DECR key</td>\n<td>将 key 中储存的数字值减一</td>\n</tr>\n<tr>\n<td>EXISTS key</td>\n<td>判断指定 key 是否存在</td>\n</tr>\n<tr>\n<td>DEL key（通用）</td>\n<td>删除指定的 key</td>\n</tr>\n<tr>\n<td>EXPIRE key seconds（通用）</td>\n<td>给指定 key 设置过期时间</td>\n</tr>\n</tbody>\n</table>\n<p>更多 Redis String 命令以及详细使用指南，请查看 Redis 官网对应的介绍：https://redis.io/commands/?group=string 。</p>\n<p><strong>基本操作</strong> ：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>批量设置</strong> ：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>计数器（字符串的内容为整数的时候可以使用）：</strong></p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>设置过期时间（默认为永不过期）</strong>：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 应用场景</h3>\n<p><strong>需要存储常规数据的场景</strong></p>\n<ul>\n<li>举例 ：缓存 session、token、图片地址、序列化后的对象(相比较于 Hash 存储更节省内存)。</li>\n<li>相关命令 ： <code>SET</code>、<code>GET</code>。</li>\n</ul>\n<p><strong>需要计数的场景</strong></p>\n<ul>\n<li>举例 ：用户单位时间的请求数（简单限流可以用到）、页面单位时间的访问数。</li>\n<li>相关命令 ：<code>SET</code>、<code>GET</code>、 <code>INCR</code>、<code>DECR</code> 。</li>\n</ul>\n<p><strong>分布式锁</strong></p>\n<p>利用 <code>SETNX key value</code> 命令可以实现一个最简易的分布式锁（存在一些缺陷，通常不建议这样实现分布式锁）。</p>\n<h2> List（列表）</h2>\n<h3> 介绍</h3>\n<p>Redis 中的 List 其实就是链表数据结构的实现。我在 <a href=\"https://javaguide.cn/cs-basics/data-structure/linear-data-structure.html\" target=\"_blank\" rel=\"noopener noreferrer\">线性数据结构 :数组、链表、栈、队列</a> 这篇文章中详细介绍了链表这种数据结构，我这里就不多做介绍了。</p>\n<p>许多高级编程语言都内置了链表的实现比如 Java 中的 <code>LinkedList</code>，但是 C 语言并没有实现链表，所以 Redis 实现了自己的链表数据结构。Redis 的 List 的实现为一个 <strong>双向链表</strong>，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/image-20220719124413287.png\" alt=\"\"></p>\n<h3> 常用命令</h3>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>介绍</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>RPUSH key value1 value2 ...</td>\n<td>在指定列表的尾部（右边）添加一个或多个元素</td>\n</tr>\n<tr>\n<td>LPUSH key value1 value2 ...</td>\n<td>在指定列表的头部（左边）添加一个或多个元素</td>\n</tr>\n<tr>\n<td>LSET key index value</td>\n<td>将指定列表索引 index 位置的值设置为 value</td>\n</tr>\n<tr>\n<td>LPOP key</td>\n<td>移除并获取指定列表的第一个元素(最左边)</td>\n</tr>\n<tr>\n<td>RPOP key</td>\n<td>移除并获取指定列表的最后一个元素(最右边)</td>\n</tr>\n<tr>\n<td>LLEN key</td>\n<td>获取列表元素数量</td>\n</tr>\n<tr>\n<td>LRANGE key start end</td>\n<td>获取列表 start 和 end 之间 的元素</td>\n</tr>\n</tbody>\n</table>\n<p>更多 Redis List 命令以及详细使用指南，请查看 Redis 官网对应的介绍：https://redis.io/commands/?group=list 。</p>\n<p><strong>通过 <code>RPUSH/LPOP</code> 或者 <code>LPUSH/RPOP</code>实现队列</strong> ：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>通过 <code>RPUSH/RPOP</code>或者<code>LPUSH/LPOP</code> 实现栈</strong> ：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>我专门画了一个图方便大家理解 <code>RPUSH</code> , <code>LPOP</code> , <code>lpush</code> , <code>RPOP</code> 命令：</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/redis-list.png\" alt=\"\"></p>\n<p><strong>通过 <code>LRANGE</code> 查看对应下标范围的列表元素</strong> ：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>通过 <code>LRANGE</code> 命令，你可以基于 List 实现分页查询，性能非常高！</p>\n<p><strong>通过 <code>LLEN</code> 查看链表长度</strong> ：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 应用场景</h3>\n<p><strong>信息流展示</strong></p>\n<ul>\n<li>举例 ：最新文章、最新动态。</li>\n<li>相关命令 ： <code>LPUSH</code>、<code>LRANGE</code>。</li>\n</ul>\n<p><strong>消息队列</strong></p>\n<p>Redis List 数据结构可以用来做消息队列，只是功能过于简单且存在很多缺陷，不建议这样做。</p>\n<p>相对来说，Redis 5.0 新增加的一个数据结构 <code>Stream</code> 更适合做消息队列一些，只是功能依然非常简陋。和专业的消息队列相比，还是有很多欠缺的地方比如消息丢失和堆积问题不好解决。</p>\n<h2> Hash（哈希）</h2>\n<h3> 介绍</h3>\n<p>Redis 中的 Hash 是一个 String 类型的 field-value（键值对） 的映射表，特别适合用于存储对象，后续操作的时候，你可以直接修改这个对象中的某些字段的值。</p>\n<p>Hash 类似于 JDK1.8 前的 <code>HashMap</code>，内部实现也差不多(数组 + 链表)。不过，Redis 的 Hash 做了更多优化。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/image-20220719124421703.png\" alt=\"\"></p>\n<h3> 常用命令</h3>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>介绍</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>HSET key field value</td>\n<td>设置指定哈希表中指定字段的值</td>\n</tr>\n<tr>\n<td>HSETNX key field value</td>\n<td>只有指定字段不存在时设置指定字段的值</td>\n</tr>\n<tr>\n<td>HMSET key field1 value1 field2 value2 ...</td>\n<td>同时将一个或多个 field-value (域-值)对设置到指定哈希表中</td>\n</tr>\n<tr>\n<td>HGET key field</td>\n<td>获取指定哈希表中指定字段的值</td>\n</tr>\n<tr>\n<td>HMGET key field1 field2 ...</td>\n<td>获取指定哈希表中一个或者多个指定字段的值</td>\n</tr>\n<tr>\n<td>HGETALL key</td>\n<td>获取指定哈希表中所有的键值对</td>\n</tr>\n<tr>\n<td>HEXISTS key field</td>\n<td>查看指定哈希表中指定的字段是否存在</td>\n</tr>\n<tr>\n<td>HDEL key field1 field2 ...</td>\n<td>删除一个或多个哈希表字段</td>\n</tr>\n<tr>\n<td>HLEN key</td>\n<td>获取指定哈希表中字段的数量</td>\n</tr>\n<tr>\n<td>HINCRBY key field increment</td>\n<td>对指定哈希中的指定字段做运算操作（正数为加，负数为减）</td>\n</tr>\n</tbody>\n</table>\n<p>更多 Redis Hash 命令以及详细使用指南，请查看 Redis 官网对应的介绍：https://redis.io/commands/?group=hash 。</p>\n<p><strong>模拟对象数据存储</strong> ：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 应用场景</h3>\n<p><strong>对象数据存储场景</strong></p>\n<ul>\n<li>举例 ：用户信息、商品信息、文章信息、购物车信息。</li>\n<li>相关命令 ：<code>HSET</code> （设置单个字段的值）、<code>HMSET</code>（设置多个字段的值）、<code>HGET</code>（获取单个字段的值）、<code>HMGET</code>（获取多个字段的值）。</li>\n</ul>\n<h2> Set（集合）</h2>\n<h3> 介绍</h3>\n<p>Redis 中的 Set 类型是一种无序集合，集合中的元素没有先后顺序但都唯一，有点类似于 Java 中的 <code>HashSet</code> 。当你需要存储一个列表数据，又不希望出现重复数据时，Set 是一个很好的选择，并且 Set 提供了判断某个元素是否在一个 Set 集合内的重要接口，这个也是 List 所不能提供的。</p>\n<p>你可以基于 Set 轻易实现交集、并集、差集的操作，比如你可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。这样的话，Set 可以非常方便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/image-20220719124430264.png\" alt=\"\"></p>\n<h3> 常用命令</h3>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>介绍</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>SADD key member1 member2 ...</td>\n<td>向指定集合添加一个或多个元素</td>\n</tr>\n<tr>\n<td>SMEMBERS key</td>\n<td>获取指定集合中的所有元素</td>\n</tr>\n<tr>\n<td>SCARD key</td>\n<td>获取指定集合的元素数量</td>\n</tr>\n<tr>\n<td>SISMEMBER key member</td>\n<td>判断指定元素是否在指定集合中</td>\n</tr>\n<tr>\n<td>SINTER key1 key2 ...</td>\n<td>获取给定所有集合的交集</td>\n</tr>\n<tr>\n<td>SINTERSTORE destination key1 key2 ...</td>\n<td>将给定所有集合的交集存储在 destination 中</td>\n</tr>\n<tr>\n<td>SUNION key1 key2 ...</td>\n<td>获取给定所有集合的并集</td>\n</tr>\n<tr>\n<td>SUNIONSTORE destination key1 key2 ...</td>\n<td>将给定所有集合的并集存储在 destination 中</td>\n</tr>\n<tr>\n<td>SDIFF key1 key2 ...</td>\n<td>获取给定所有集合的差集</td>\n</tr>\n<tr>\n<td>SDIFFSTORE destination key1 key2 ...</td>\n<td>将给定所有集合的差集存储在 destination 中</td>\n</tr>\n<tr>\n<td>SPOP key count</td>\n<td>随机移除并获取指定集合中一个或多个元素</td>\n</tr>\n<tr>\n<td>SRANDMEMBER key count</td>\n<td>随机获取指定集合中指定数量的元素</td>\n</tr>\n</tbody>\n</table>\n<p>更多 Redis Set 命令以及详细使用指南，请查看 Redis 官网对应的介绍：https://redis.io/commands/?group=set 。</p>\n<p><strong>基本操作</strong> ：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li><code>mySet</code> : <code>value1</code>、<code>value2</code> 。</li>\n<li><code>mySet2</code> ： <code>value2</code> 、<code>value3</code> 。</li>\n</ul>\n<p><strong>求交集</strong> ：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>求并集</strong> ：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>求差集</strong> ：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 应用场景</h3>\n<p><strong>需要存放的数据不能重复的场景</strong></p>\n<ul>\n<li>举例：网站 UV 统计（数据量巨大的场景还是 <code>HyperLogLog</code>更适合一些）、文章点赞、动态点赞等场景。</li>\n<li>相关命令：<code>SCARD</code>（获取集合数量） 。</li>\n</ul>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/image-20220719073733851.png\" alt=\"\"></p>\n<p><strong>需要获取多个数据源交集、并集和差集的场景</strong></p>\n<ul>\n<li>举例 ：共同好友(交集)、共同粉丝(交集)、共同关注(交集)、好友推荐（差集）、音乐推荐（差集） 、订阅号推荐（差集+交集） 等场景。</li>\n<li>相关命令：<code>SINTER</code>（交集）、<code>SINTERSTORE</code> （交集）、<code>SUNION</code> （并集）、<code>SUNIONSTORE</code>（并集）、<code>SDIFF</code>（差集）、<code>SDIFFSTORE</code> （差集）。</li>\n</ul>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/image-20220719074543513.png\" alt=\"\"></p>\n<p><strong>需要随机获取数据源中的元素的场景</strong></p>\n<ul>\n<li>举例 ：抽奖系统、随机。</li>\n<li>相关命令：<code>SPOP</code>（随机获取集合中的元素并移除，适合不允许重复中奖的场景）、<code>SRANDMEMBER</code>（随机获取集合中的元素，适合允许重复中奖的场景）。</li>\n</ul>\n<h2> Sorted Set（有序集合）</h2>\n<h3> 介绍</h3>\n<p>Sorted Set 类似于 Set，但和 Set 相比，Sorted Set 增加了一个权重参数 <code>score</code>，使得集合中的元素能够按 <code>score</code> 进行有序排列，还可以通过 <code>score</code> 的范围来获取元素的列表。有点像是 Java 中 <code>HashMap</code> 和 <code>TreeSet</code> 的结合体。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/image-20220719124437791.png\" alt=\"\"></p>\n<h3> 常用命令</h3>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>介绍</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ZADD key score1 member1 score2 member2 ...</td>\n<td>向指定有序集合添加一个或多个元素</td>\n</tr>\n<tr>\n<td>ZCARD KEY</td>\n<td>获取指定有序集合的元素数量</td>\n</tr>\n<tr>\n<td>ZSCORE key member</td>\n<td>获取指定有序集合中指定元素的 score 值</td>\n</tr>\n<tr>\n<td>ZINTERSTORE destination numkeys key1 key2 ...</td>\n<td>将给定所有有序集合的交集存储在 destination 中，对相同元素对应的 score 值进行 SUM 聚合操作，numkeys 为集合数量</td>\n</tr>\n<tr>\n<td>ZUNIONSTORE destination numkeys key1 key2 ...</td>\n<td>求并集，其它和 ZINTERSTORE 类似</td>\n</tr>\n<tr>\n<td>ZDIFF destination numkeys key1 key2 ...</td>\n<td>求差集，其它和 ZINTERSTORE 类似</td>\n</tr>\n<tr>\n<td>ZRANGE key start end</td>\n<td>获取指定有序集合 start 和 end 之间的元素（score 从低到高）</td>\n</tr>\n<tr>\n<td>ZREVRANGE key start end</td>\n<td>获取指定有序集合 start 和 end 之间的元素（score 从高到底）</td>\n</tr>\n<tr>\n<td>ZREVRANK key member</td>\n<td>获取指定有序集合中指定元素的排名(score 从大到小排序)</td>\n</tr>\n</tbody>\n</table>\n<p>更多 Redis Sorted Set 命令以及详细使用指南，请查看 Redis 官网对应的介绍：https://redis.io/commands/?group=sorted-set 。</p>\n<p><strong>基本操作</strong> ：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li><code>myZset</code> : <code>value1</code>(2.0)、<code>value2</code>(1.0) 。</li>\n<li><code>myZset2</code> ： <code>value2</code> （4.0）、<code>value3</code>(3.0) 。</li>\n</ul>\n<p><strong>获取指定元素的排名</strong> ：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>求交集</strong> ：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>求并集</strong> ：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>求差集</strong> ：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 应用场景</h3>\n<p><strong>需要随机获取数据源中的元素根据某个权重进行排序的场景</strong></p>\n<ul>\n<li>举例 ：各种排行榜比如直播间送礼物的排行榜、朋友圈的微信步数排行榜、王者荣耀中的段位排行榜、话题热度排行榜等等。</li>\n<li>相关命令 ：<code>ZRANGE</code> (从小到大排序) 、 <code>ZREVRANGE</code> （从大到小排序）、<code>ZREVRANK</code> (指定元素排名)。</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/2021060714195385.png\" alt=\"\"></p>\n<p><a href=\"https://www.yuque.com/docs/share/f37fc804-bfe6-4b0d-b373-9c462188fec7\" target=\"_blank\" rel=\"noopener noreferrer\">《Java 面试指北》</a> 的「技术面试题篇」就有一篇文章详细介绍如何使用 Sorted Set 来设计制作一个排行榜。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/image-20220719071115140.png\" alt=\"\"></p>\n<p><strong>需要存储的数据有优先级或者重要程度的场景</strong> 比如优先级任务队列。</p>\n<ul>\n<li>举例 ：优先级任务队列。</li>\n<li>相关命令 ：<code>ZRANGE</code> (从小到大排序) 、 <code>ZREVRANGE</code> （从大到小排序）、<code>ZREVRANK</code> (指定元素排名)。</li>\n</ul>\n<h2> 参考</h2>\n<ul>\n<li>Redis Data Structures ：https://redis.com/redis-enterprise/data-structures/ 。</li>\n<li>Redis Commands ： https://redis.io/commands/ 。</li>\n<li>Redis Data types tutorial：https://redis.io/docs/manual/data-types/data-types-tutorial/ 。</li>\n<li>Redis 存储对象信息是用 Hash 还是 String : https://segmentfault.com/a/1190000040032006</li>\n</ul>\n",
      "image": "https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/image-20220720181630203.png",
      "date_published": "2022-07-20T07:08:15.000Z",
      "date_modified": "2022-12-03T03:14:20.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "数据库"
      ]
    },
    {
      "title": "Redis 3 种特殊数据结构详解",
      "url": "https://javaguide.cn/database/redis/redis-data-structures-02.html",
      "id": "https://javaguide.cn/database/redis/redis-data-structures-02.html",
      "summary": "除了 5 种基本的数据结构之外，Redis 还支持 3 种特殊的数据结构 ：Bitmap、HyperLogLog、GEO。 Bitmap 介绍 Bitmap 存储的是连续的二进制数字（0 和 1），通过 Bitmap, 只需要一个 bit 位来表示某个元素对应的值或者状态，key 就是对应元素本身 。我们知道 8 个 bit 可以组成一个 byte，所以 Bitmap 本身会极大的节省储存空间。 你可以将 Bitmap 看作是一个存储二进制数字（0 和 1）的数组，数组中每个元素的下标叫做 offset（偏移量）。",
      "content_html": "<p>除了 5 种基本的数据结构之外，Redis 还支持 3 种特殊的数据结构 ：Bitmap、HyperLogLog、GEO。</p>\n<h2> Bitmap</h2>\n<h3> 介绍</h3>\n<p>Bitmap 存储的是连续的二进制数字（0 和 1），通过 Bitmap, 只需要一个 bit 位来表示某个元素对应的值或者状态，key 就是对应元素本身 。我们知道 8 个 bit 可以组成一个 byte，所以 Bitmap 本身会极大的节省储存空间。</p>\n<p>你可以将 Bitmap 看作是一个存储二进制数字（0 和 1）的数组，数组中每个元素的下标叫做 offset（偏移量）。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/image-20220720194154133.png\" alt=\"\"></p>\n<h3> 常用命令</h3>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>介绍</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>SETBIT key offset value</td>\n<td>设置指定 offset 位置的值</td>\n</tr>\n<tr>\n<td>GETBIT key offset</td>\n<td>获取指定 offset 位置的值</td>\n</tr>\n<tr>\n<td>BITCOUNT key start end</td>\n<td>获取 start 和 end 之前值为 1 的元素个数</td>\n</tr>\n<tr>\n<td>BITOP operation destkey key1 key2 ...</td>\n<td>对一个或多个 Bitmap 进行运算，可用运算符有 AND, OR, XOR 以及 NOT</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Bitmap 基本操作演示</strong> ：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 应用场景</h3>\n<p><strong>需要保存状态信息（0/1 即可表示）的场景</strong></p>\n<ul>\n<li>举例 ：用户签到情况、活跃用户情况、用户行为统计（比如是否点赞过某个视频）。</li>\n<li>相关命令 ：<code>SETBIT</code>、<code>GETBIT</code>、<code>BITCOUNT</code>、<code>BITOP</code>。</li>\n</ul>\n<h2> HyperLogLog</h2>\n<h3> 介绍</h3>\n<p>HyperLogLog 是一种有名的基数计数概率算法 ，基于 LogLog Counting(LLC)优化改进得来，并不是 Redis 特有的，Redis 只是实现了这个算法并提供了一些开箱即用的 API。</p>\n<p>Redis 提供的 HyperLogLog 占用空间非常非常小，只需要 12k 的空间就能存储接近<code>2^64</code>个不同元素。这是真的厉害，这就是数学的魅力么！并且，Redis 对 HyperLogLog 的存储结构做了优化，采用两种方式计数：</p>\n<ul>\n<li><strong>稀疏矩阵</strong> ：计数较少的时候，占用空间很小。</li>\n<li><strong>稠密矩阵</strong> ：计数达到某个阈值的时候，占用 12k 的空间。</li>\n</ul>\n<p>Redis 官方文档中有对应的详细说明：</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/image-20220721091424563.png\" alt=\"\"></p>\n<p>基数计数概率算法为了节省内存并不会直接存储元数据，而是通过一定的概率统计方法预估基数值（集合中包含元素的个数）。因此， HyperLogLog 的计数结果并不是一个精确值，存在一定的误差（标准误差为 <code>0.81%</code> 。）。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/image-20220720194154133.png\" alt=\"\"></p>\n<p>HyperLogLog 的使用非常简单，但原理非常复杂。HyperLogLog 的原理以及在 Redis 中的实现可以看这篇文章：<a href=\"https://juejin.cn/post/6844903785744056333\" target=\"_blank\" rel=\"noopener noreferrer\">HyperLogLog 算法的原理讲解以及 Redis 是如何应用它的</a> 。</p>\n<p>再推荐一个可以帮助理解 HyperLogLog 原理的工具：<a href=\"http://content.research.neustar.biz/blog/hll.html\" target=\"_blank\" rel=\"noopener noreferrer\">Sketch of the Day: HyperLogLog — Cornerstone of a Big Data Infrastructure</a> 。</p>\n<h3> 常用命令</h3>\n<p>HyperLogLog 相关的命令非常少，最常用的也就 3 个。</p>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>介绍</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>PFADD key element1 element2 ...</td>\n<td>添加一个或多个元素到 HyperLogLog 中</td>\n</tr>\n<tr>\n<td>PFCOUNT key1 key2</td>\n<td>获取一个或者多个 HyperLogLog 的唯一计数。</td>\n</tr>\n<tr>\n<td>PFMERGE destkey sourcekey1 sourcekey2 ...</td>\n<td>将多个 HyperLogLog 合并到 destkey 中，destkey 会结合多个源，算出对应的唯一计数。</td>\n</tr>\n</tbody>\n</table>\n<p><strong>HyperLogLog 基本操作演示</strong> ：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 应用场景</h3>\n<p><strong>数量量巨大（百万、千万级别以上）的计数场景</strong></p>\n<ul>\n<li>举例 ：热门网站每日/每周/每月访问 ip 数统计、热门帖子 uv 统计、</li>\n<li>相关命令 ：<code>PFADD</code>、<code>PFCOUNT</code> 。</li>\n</ul>\n<h2> Geospatial index</h2>\n<h3> 介绍</h3>\n<p>Geospatial index（地理空间索引，简称 GEO） 主要用于存储地理位置信息，基于 Sorted Set 实现。</p>\n<p>通过 GEO 我们可以轻松实现两个位置距离的计算、获取指定位置附近的元素等功能。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/image-20220720194359494.png\" alt=\"\"></p>\n<h3> 常用命令</h3>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>介绍</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>GEOADD key longitude1 latitude1 member1 ...</td>\n<td>添加一个或多个元素对应的经纬度信息到 GEO 中</td>\n</tr>\n<tr>\n<td>GEOPOS key member1 member2 ...</td>\n<td>返回给定元素的经纬度信息</td>\n</tr>\n<tr>\n<td>GEODIST key member1 member2 M/KM/FT/MI</td>\n<td>返回两个给定元素之间的距离</td>\n</tr>\n<tr>\n<td>GEORADIUS key longitude latitude radius distance</td>\n<td>获取指定位置附近 distance 范围内的其他元素，支持 ASC(由近到远)、DESC（由远到近）、Count(数量) 等参数</td>\n</tr>\n<tr>\n<td>GEORADIUSBYMEMBER key member radius distance</td>\n<td>类似于 GEORADIUS 命令，只是参照的中心点是 GEO 中的元素</td>\n</tr>\n</tbody>\n</table>\n<p><strong>基本操作</strong> ：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>通过 Redis 可视化工具查看 <code>personLocation</code> ，果不其然，底层就是 Sorted Set。</p>\n<p>GEO 中存储的地理位置信息的经纬度数据通过 GeoHash 算法转换成了一个整数，这个整数作为 Sorted Set 的 score(权重参数)使用。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/image-20220721201545147.png\" alt=\"\"></p>\n<p><strong>获取指定位置范围内的其他元素</strong> ：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>GEORADIUS</code> 命令的底层原理解析可以看看阿里的这篇文章：<a href=\"https://juejin.cn/post/6844903966061363207\" target=\"_blank\" rel=\"noopener noreferrer\">Redis 到底是怎么实现“附近的人”这个功能的呢？</a> 。</p>\n<p><strong>移除元素</strong> ：</p>\n<p>GEO 底层是 Sorted Set ，你可以对 GEO 使用 Sorted Set 相关的命令。</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 应用场景</h3>\n<p><strong>需要管理使用地理空间数据的场景</strong></p>\n<ul>\n<li>举例：附近的人。</li>\n<li>相关命令: <code>GEOADD</code>、<code>GEORADIUS</code>、<code>GEORADIUSBYMEMBER</code> 。</li>\n</ul>\n<h2> 参考</h2>\n<ul>\n<li>Redis Data Structures ：https://redis.com/redis-enterprise/data-structures/ 。</li>\n<li>《Redis 深度历险：核心原理与应用实践》1.6 四两拨千斤——HyperLogLog</li>\n<li>布隆过滤器,位图,HyperLogLog：https://hogwartsrico.github.io/2020/06/08/BloomFilter-HyperLogLog-BitMap/index.html</li>\n</ul>\n",
      "image": "https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/image-20220720194154133.png",
      "date_published": "2022-07-20T07:08:15.000Z",
      "date_modified": "2022-12-03T03:14:20.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "数据库"
      ]
    },
    {
      "title": "Java 魔法类 Unsafe 详解",
      "url": "https://javaguide.cn/java/basis/unsafe.html",
      "id": "https://javaguide.cn/java/basis/unsafe.html",
      "summary": "本文整理完善自下面这两篇优秀的文章： Java魔法类：Unsafe 应用解析 - 美团技术团队 -2019 Java 双刃剑之 Unsafe 类详解 - 码农参上 - 2021",
      "content_html": "<blockquote>\n<p>本文整理完善自下面这两篇优秀的文章：</p>\n<ul>\n<li><a href=\"https://tech.meituan.com/2019/02/14/talk-about-java-magic-class-unsafe.html\" target=\"_blank\" rel=\"noopener noreferrer\">Java魔法类：Unsafe 应用解析 - 美团技术团队 -2019</a></li>\n<li><a href=\"https://xie.infoq.cn/article/8b6ed4195e475bfb32dacc5cb\" target=\"_blank\" rel=\"noopener noreferrer\">Java 双刃剑之 Unsafe 类详解 - 码农参上 - 2021</a></li>\n</ul>\n</blockquote>\n<p>阅读过 JUC 源码的同学，一定会发现很多并发工具类都调用了一个叫做 <code>Unsafe</code> 的类。</p>\n<p>那这个类主要是用来干什么的呢？有什么使用场景呢？这篇文章就带你搞清楚！</p>\n<h2> Unsafe 介绍</h2>\n<p><code>Unsafe</code> 是位于 <code>sun.misc</code> 包下的一个类，主要提供一些用于执行低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等，这些方法在提升 Java 运行效率、增强 Java 语言底层资源操作能力方面起到了很大的作用。但由于 <code>Unsafe</code> 类使 Java 语言拥有了类似 C 语言指针一样操作内存空间的能力，这无疑也增加了程序发生相关指针问题的风险。在程序中过度、不正确使用 <code>Unsafe</code> 类会使得程序出错的概率变大，使得 Java 这种安全的语言变得不再“安全”，因此对 <code>Unsafe</code> 的使用一定要慎重。</p>\n<p>另外，<code>Unsafe</code> 提供的这些功能的实现需要依赖本地方法（Native Method）。你可以将本地方法看作是 Java 中使用其他编程语言编写的方法。本地方法使用 <strong><code>native</code></strong> 关键字修饰，Java 代码中只是声明方法头，具体的实现则交给 <strong>本地代码</strong>。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/basis/unsafe/image-20220717115231125.png\" alt=\"\"></p>\n<p><strong>为什么要使用本地方法呢？</strong></p>\n<ol>\n<li>需要用到 Java 中不具备的依赖于操作系统的特性，Java 在实现跨平台的同时要实现对底层的控制，需要借助其他语言发挥作用。</li>\n<li>对于其他语言已经完成的一些现成功能，可以使用 Java 直接调用。</li>\n<li>程序对时间敏感或对性能要求非常高时，有必要使用更加底层的语言，例如 C/C++甚至是汇编。</li>\n</ol>\n<p>在 JUC 包的很多并发工具类在实现并发机制时，都调用了本地方法，通过它们打破了 Java 运行时的界限，能够接触到操作系统底层的某些功能。对于同一本地方法，不同的操作系统可能会通过不同的方式来实现，但是对于使用者来说是透明的，最终都会得到相同的结果。</p>\n<h2> Unsafe 创建</h2>\n<p><code>sun.misc.Unsafe</code> 部分源码如下：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>Unsafe</code> 类为一单例实现，提供静态方法 <code>getUnsafe</code> 获取 <code>Unsafe</code>实例。这个看上去貌似可以用来获取 <code>Unsafe</code> 实例。但是，当我们直接调用这个静态方法的时候，会抛出 <code>SecurityException</code> 异常：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>为什么 <code>public static</code> 方法无法被直接调用呢？</strong></p>\n<p>这是因为在<code>getUnsafe</code>方法中，会对调用者的<code>classLoader</code>进行检查，判断当前类是否由<code>Bootstrap classLoader</code>加载，如果不是的话那么就会抛出一个<code>SecurityException</code>异常。也就是说，只有启动类加载器加载的类才能够调用 Unsafe 类中的方法，来防止这些方法在不可信的代码中被调用。</p>\n<p><strong>为什么要对 Unsafe 类进行这么谨慎的使用限制呢?</strong></p>\n<p><code>Unsafe</code> 提供的功能过于底层（如直接访问系统内存资源、自主管理内存资源等），安全隐患也比较大，使用不当的话，很容易出现很严重的问题。</p>\n<p><strong>如若想使用 <code>Unsafe</code> 这个类的话，应该如何获取其实例呢？</strong></p>\n<p>这里介绍两个可行的方案。</p>\n<p>1、利用反射获得 Unsafe 类中已经实例化完成的单例对象 <code>theUnsafe</code> 。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>2、从<code>getUnsafe</code>方法的使用限制条件出发，通过 Java 命令行命令<code>-Xbootclasspath/a</code>把调用 Unsafe 相关方法的类 A 所在 jar 包路径追加到默认的 bootstrap 路径中，使得 A 被引导类加载器加载，从而通过<code>Unsafe.getUnsafe</code>方法安全的获取 Unsafe 实例。</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> Unsafe 功能</h2>\n<p>概括的来说，<code>Unsafe</code> 类实现功能可以被分为下面 8 类：</p>\n<ol>\n<li>内存操作</li>\n<li>内存屏障</li>\n<li>对象操作</li>\n<li>数据操作</li>\n<li>CAS 操作</li>\n<li>线程调度</li>\n<li>Class 操作</li>\n<li>系统信息</li>\n</ol>\n<h3> 内存操作</h3>\n<h4> 介绍</h4>\n<p>如果你是一个写过 C 或者 C++ 的程序员，一定对内存操作不会陌生，而在 Java 中是不允许直接对内存进行操作的，对象内存的分配和回收都是由 JVM 自己实现的。但是在 <code>Unsafe</code> 中，提供的下列接口可以直接进行内存操作：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>使用下面的代码进行测试：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>先看结果输出：</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>分析一下运行结果，首先使用<code>allocateMemory</code>方法申请 4 字节长度的内存空间，调用<code>setMemory</code>方法向每个字节写入内容为<code>byte</code>类型的 1，当使用 Unsafe 调用<code>getInt</code>方法时，因为一个<code>int</code>型变量占 4 个字节，会一次性读取 4 个字节，组成一个<code>int</code>的值，对应的十进制结果为 16843009。</p>\n<p>你可以通过下图理解这个过程：</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/basis/unsafe/image-20220717144344005.png\" alt=\"\"></p>\n<p>在代码中调用<code>reallocateMemory</code>方法重新分配了一块 8 字节长度的内存空间，通过比较<code>addr</code>和<code>addr3</code>可以看到和之前申请的内存地址是不同的。在代码中的第二个 for 循环里，调用<code>copyMemory</code>方法进行了两次内存的拷贝，每次拷贝内存地址<code>addr</code>开始的 4 个字节，分别拷贝到以<code>addr3</code>和<code>addr3+4</code>开始的内存空间上：</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/basis/unsafe/image-20220717144354582.png\" alt=\"\"></p>\n<p>拷贝完成后，使用<code>getLong</code>方法一次性读取 8 个字节，得到<code>long</code>类型的值为 72340172838076673。</p>\n<p>需要注意，通过这种方式分配的内存属于 堆外内存 ，是无法进行垃圾回收的，需要我们把这些内存当做一种资源去手动调用<code>freeMemory</code>方法进行释放，否则会产生内存泄漏。通用的操作内存方式是在<code>try</code>中执行对内存的操作，最终在<code>finally</code>块中进行内存的释放。</p>\n<p><strong>为什么要使用堆外内存？</strong></p>\n<ul>\n<li>对垃圾回收停顿的改善。由于堆外内存是直接受操作系统管理而不是 JVM，所以当我们使用堆外内存时，即可保持较小的堆内内存规模。从而在 GC 时减少回收停顿对于应用的影响。</li>\n<li>提升程序 I/O 操作的性能。通常在 I/O 通信过程中，会存在堆内内存到堆外内存的数据拷贝操作，对于需要频繁进行内存间数据拷贝且生命周期较短的暂存数据，都建议存储到堆外内存。</li>\n</ul>\n<h4> 典型应用</h4>\n<p><code>DirectByteBuffer</code> 是 Java 用于实现堆外内存的一个重要类，通常用在通信过程中做缓冲池，如在 Netty、MINA 等 NIO 框架中应用广泛。<code>DirectByteBuffer</code> 对于堆外内存的创建、使用、销毁等逻辑均由 Unsafe 提供的堆外内存 API 来实现。</p>\n<p>下图为 <code>DirectByteBuffer</code> 构造函数，创建 <code>DirectByteBuffer</code> 的时候，通过 <code>Unsafe.allocateMemory</code> 分配内存、<code>Unsafe.setMemory</code> 进行内存初始化，而后构建 <code>Cleaner</code> 对象用于跟踪 <code>DirectByteBuffer</code> 对象的垃圾回收，以实现当 <code>DirectByteBuffer</code> 被垃圾回收时，分配的堆外内存一起被释放。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 内存屏障</h3>\n<h4> 介绍</h4>\n<p>在介绍内存屏障前，需要知道编译器和 CPU 会在保证程序输出结果一致的情况下，会对代码进行重排序，从指令优化角度提升性能。而指令重排序可能会带来一个不好的结果，导致 CPU 的高速缓存和内存中数据的不一致，而内存屏障（<code>Memory Barrier</code>）就是通过阻止屏障两边的指令重排序从而避免编译器和硬件的不正确优化情况。</p>\n<p>在硬件层面上，内存屏障是 CPU 为了防止代码进行重排序而提供的指令，不同的硬件平台上实现内存屏障的方法可能并不相同。在 Java8 中，引入了 3 个内存屏障的函数，它屏蔽了操作系统底层的差异，允许在代码中定义、并统一由 JVM 来生成内存屏障指令，来实现内存屏障的功能。</p>\n<p><code>Unsafe</code> 中提供了下面三个内存屏障相关方法：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>内存屏障可以看做对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作。以<code>loadFence</code>方法为例，它会禁止读操作重排序，保证在这个屏障之前的所有读操作都已经完成，并且将缓存数据设为无效，重新从主存中进行加载。</p>\n<p>看到这估计很多小伙伴们会想到<code>volatile</code>关键字了，如果在字段上添加了<code>volatile</code>关键字，就能够实现字段在多线程下的可见性。基于读内存屏障，我们也能实现相同的功能。下面定义一个线程方法，在线程中去修改<code>flag</code>标志位，注意这里的<code>flag</code>是没有被<code>volatile</code>修饰的：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在主线程的<code>while</code>循环中，加入内存屏障，测试是否能够感知到<code>flag</code>的修改变化：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>运行结果：</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>而如果删掉上面代码中的<code>loadFence</code>方法，那么主线程将无法感知到<code>flag</code>发生的变化，会一直在<code>while</code>中循环。可以用图来表示上面的过程：</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/basis/unsafe/image-20220717144703446.png\" alt=\"\"></p>\n<p>了解 Java 内存模型（<code>JMM</code>）的小伙伴们应该清楚，运行中的线程不是直接读取主内存中的变量的，只能操作自己工作内存中的变量，然后同步到主内存中，并且线程的工作内存是不能共享的。上面的图中的流程就是子线程借助于主内存，将修改后的结果同步给了主线程，进而修改主线程中的工作空间，跳出循环。</p>\n<h4> 典型应用</h4>\n<p>在 Java 8 中引入了一种锁的新机制——<code>StampedLock</code>，它可以看成是读写锁的一个改进版本。<code>StampedLock</code> 提供了一种乐观读锁的实现，这种乐观读锁类似于无锁的操作，完全不会阻塞写线程获取写锁，从而缓解读多写少时写线程“饥饿”现象。由于 <code>StampedLock</code> 提供的乐观读锁不阻塞写线程获取读锁，当线程共享变量从主内存 load 到线程工作内存时，会存在数据不一致问题。</p>\n<p>为了解决这个问题，<code>StampedLock</code> 的 <code>validate</code> 方法会通过 <code>Unsafe</code> 的 <code>loadFence</code> 方法加入一个 <code>load</code> 内存屏障。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 对象操作</h3>\n<h4> 介绍</h4>\n<p><strong>对象属性</strong></p>\n<p>对象成员属性的内存偏移量获取，以及字段属性值的修改，在上面的例子中我们已经测试过了。除了前面的<code>putInt</code>、<code>getInt</code>方法外，Unsafe 提供了全部 8 种基础数据类型以及<code>Object</code>的<code>put</code>和<code>get</code>方法，并且所有的<code>put</code>方法都可以越过访问权限，直接修改内存中的数据。阅读 openJDK 源码中的注释发现，基础数据类型和<code>Object</code>的读写稍有不同，基础数据类型是直接操作的属性值（<code>value</code>），而<code>Object</code>的操作则是基于引用值（<code>reference value</code>）。下面是<code>Object</code>的读写方法：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>除了对象属性的普通读写外，<code>Unsafe</code> 还提供了 <strong>volatile 读写</strong>和<strong>有序写入</strong>方法。<code>volatile</code>读写方法的覆盖范围与普通读写相同，包含了全部基础数据类型和<code>Object</code>类型，以<code>int</code>类型为例：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>相对于普通读写来说，<code>volatile</code>读写具有更高的成本，因为它需要保证可见性和有序性。在执行<code>get</code>操作时，会强制从主存中获取属性值，在使用<code>put</code>方法设置属性值时，会强制将值更新到主存中，从而保证这些变更对其他线程是可见的。</p>\n<p>有序写入的方法有以下三个：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>有序写入的成本相对<code>volatile</code>较低，因为它只保证写入时的有序性，而不保证可见性，也就是一个线程写入的值不能保证其他线程立即可见。为了解决这里的差异性，需要对内存屏障的知识点再进一步进行补充，首先需要了解两个指令的概念：</p>\n<ul>\n<li><code>Load</code>：将主内存中的数据拷贝到处理器的缓存中</li>\n<li><code>Store</code>：将处理器缓存的数据刷新到主内存中</li>\n</ul>\n<p>顺序写入与<code>volatile</code>写入的差别在于，在顺序写时加入的内存屏障类型为<code>StoreStore</code>类型，而在<code>volatile</code>写入时加入的内存屏障是<code>StoreLoad</code>类型，如下图所示：</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/basis/unsafe/image-20220717144834132.png\" alt=\"\"></p>\n<p>在有序写入方法中，使用的是<code>StoreStore</code>屏障，该屏障确保<code>Store1</code>立刻刷新数据到内存，这一操作先于<code>Store2</code>以及后续的存储指令操作。而在<code>volatile</code>写入中，使用的是<code>StoreLoad</code>屏障，该屏障确保<code>Store1</code>立刻刷新数据到内存，这一操作先于<code>Load2</code>及后续的装载指令，并且，<code>StoreLoad</code>屏障会使该屏障之前的所有内存访问指令，包括存储指令和访问指令全部完成之后，才执行该屏障之后的内存访问指令。</p>\n<p>综上所述，在上面的三类写入方法中，在写入效率方面，按照<code>put</code>、<code>putOrder</code>、<code>putVolatile</code>的顺序效率逐渐降低。</p>\n<p><strong>对象实例化</strong></p>\n<p>使用 <code>Unsafe</code> 的 <code>allocateInstance</code> 方法，允许我们使用非常规的方式进行对象的实例化，首先定义一个实体类，并且在构造函数中对其成员变量进行赋值操作：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>分别基于构造函数、反射以及 <code>Unsafe</code> 方法的不同方式创建对象进行比较：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>打印结果分别为 1、1、0，说明通过<code>allocateInstance</code>方法创建对象过程中，不会调用类的构造方法。使用这种方式创建对象时，只用到了<code>Class</code>对象，所以说如果想要跳过对象的初始化阶段或者跳过构造器的安全检查，就可以使用这种方法。在上面的例子中，如果将 A 类的构造函数改为<code>private</code>类型，将无法通过构造函数和反射创建对象，但<code>allocateInstance</code>方法仍然有效。</p>\n<h4> 典型应用</h4>\n<ul>\n<li><strong>常规对象实例化方式</strong>：我们通常所用到的创建对象的方式，从本质上来讲，都是通过 new 机制来实现对象的创建。但是，new 机制有个特点就是当类只提供有参的构造函数且无显示声明无参构造函数时，则必须使用有参构造函数进行对象构造，而使用有参构造函数时，必须传递相应个数的参数才能完成对象实例化。</li>\n<li><strong>非常规的实例化方式</strong>：而 Unsafe 中提供 allocateInstance 方法，仅通过 Class 对象就可以创建此类的实例对象，而且不需要调用其构造函数、初始化代码、JVM 安全检查等。它抑制修饰符检测，也就是即使构造器是 private 修饰的也能通过此方法实例化，只需提类对象即可创建相应的对象。由于这种特性，allocateInstance 在 java.lang.invoke、Objenesis（提供绕过类构造器的对象生成方式）、Gson（反序列化时用到）中都有相应的应用。</li>\n</ul>\n<h3> 数组操作</h3>\n<h4> 介绍</h4>\n<p><code>arrayBaseOffset</code> 与 <code>arrayIndexScale</code> 这两个方法配合起来使用，即可定位数组中每个元素在内存中的位置。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 典型应用</h4>\n<p>这两个与数据操作相关的方法，在 <code>java.util.concurrent.atomic</code> 包下的 <code>AtomicIntegerArray</code>（可以实现对 <code>Integer</code> 数组中每个元素的原子性操作）中有典型的应用，如下图 <code>AtomicIntegerArray</code> 源码所示，通过 <code>Unsafe</code> 的 <code>arrayBaseOffset</code> 、<code>arrayIndexScale</code> 分别获取数组首元素的偏移地址 <code>base</code> 及单个元素大小因子 <code>scale</code> 。后续相关原子性操作，均依赖于这两个值进行数组中元素的定位，如下图二所示的 <code>getAndAdd</code> 方法即通过 <code>checkedByteOffset</code> 方法获取某数组元素的偏移地址，而后通过 CAS 实现原子性操作。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/basis/unsafe/image-20220717144927257.png\" alt=\"\"></p>\n<h3> CAS 操作</h3>\n<h4> 介绍</h4>\n<p>这部分主要为 CAS 相关操作的方法。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>什么是 CAS?</strong> CAS 即比较并替换（Compare And Swap)，是实现并发算法时常用到的一种技术。CAS 操作包含三个操作数——内存位置、预期原值及新值。执行 CAS 操作的时候，将内存位置的值与预期原值比较，如果相匹配，那么处理器会自动将该位置值更新为新值，否则，处理器不做任何操作。我们都知道，CAS 是一条 CPU 的原子指令（cmpxchg 指令），不会造成所谓的数据不一致问题，<code>Unsafe</code> 提供的 CAS 方法（如 <code>compareAndSwapXXX</code>）底层实现即为 CPU 指令 <code>cmpxchg</code> 。</p>\n<h4> 典型应用</h4>\n<p>在 JUC 包的并发工具类中大量地使用了 CAS 操作，像在前面介绍<code>synchronized</code>和<code>AQS</code>的文章中也多次提到了 CAS，其作为乐观锁在并发工具类中广泛发挥了作用。在 <code>Unsafe</code> 类中，提供了<code>compareAndSwapObject</code>、<code>compareAndSwapInt</code>、<code>compareAndSwapLong</code>方法来实现的对<code>Object</code>、<code>int</code>、<code>long</code>类型的 CAS 操作。以<code>compareAndSwapInt</code>方法为例：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>参数中<code>o</code>为需要更新的对象，<code>offset</code>是对象<code>o</code>中整形字段的偏移量，如果这个字段的值与<code>expected</code>相同，则将字段的值设为<code>x</code>这个新值，并且此更新是不可被中断的，也就是一个原子操作。下面是一个使用<code>compareAndSwapInt</code>的例子：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>运行代码会依次输出：</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>在上面的例子中，使用两个线程去修改<code>int</code>型属性<code>a</code>的值，并且只有在<code>a</code>的值等于传入的参数<code>x</code>减一时，才会将<code>a</code>的值变为<code>x</code>，也就是实现对<code>a</code>的加一的操作。流程如下所示：</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/basis/unsafe/image-20220717144939826.png\" alt=\"\"></p>\n<p>需要注意的是，在调用<code>compareAndSwapInt</code>方法后，会直接返回<code>true</code>或<code>false</code>的修改结果，因此需要我们在代码中手动添加自旋的逻辑。在<code>AtomicInteger</code>类的设计中，也是采用了将<code>compareAndSwapInt</code>的结果作为循环条件，直至修改成功才退出死循环的方式来实现的原子性的自增操作。</p>\n<h3> 线程调度</h3>\n<h4> 介绍</h4>\n<p><code>Unsafe</code> 类中提供了<code>park</code>、<code>unpark</code>、<code>monitorEnter</code>、<code>monitorExit</code>、<code>tryMonitorEnter</code>方法进行线程调度。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>方法 <code>park</code>、<code>unpark</code> 即可实现线程的挂起与恢复，将一个线程进行挂起是通过 <code>park</code> 方法实现的，调用 <code>park</code> 方法后，线程将一直阻塞直到超时或者中断等条件出现；<code>unpark</code> 可以终止一个挂起的线程，使其恢复正常。</p>\n<p>此外，<code>Unsafe</code> 源码中<code>monitor</code>相关的三个方法已经被标记为<code>deprecated</code>，不建议被使用：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>monitorEnter</code>方法用于获得对象锁，<code>monitorExit</code>用于释放对象锁，如果对一个没有被<code>monitorEnter</code>加锁的对象执行此方法，会抛出<code>IllegalMonitorStateException</code>异常。<code>tryMonitorEnter</code>方法尝试获取对象锁，如果成功则返回<code>true</code>，反之返回<code>false</code>。</p>\n<h4> 典型应用</h4>\n<p>Java 锁和同步器框架的核心类 <code>AbstractQueuedSynchronizer</code> (AQS)，就是通过调用<code>LockSupport.park()</code>和<code>LockSupport.unpark()</code>实现线程的阻塞和唤醒的，而 <code>LockSupport</code> 的 <code>park</code> 、<code>unpark</code> 方法实际是调用 <code>Unsafe</code> 的 <code>park</code> 、<code>unpark</code> 方式实现的。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>LockSupport</code> 的<code>park</code>方法调用了 <code>Unsafe</code> 的<code>park</code>方法来阻塞当前线程，此方法将线程阻塞后就不会继续往后执行，直到有其他线程调用<code>unpark</code>方法唤醒当前线程。下面的例子对 <code>Unsafe</code> 的这两个方法进行测试：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>程序输出为：</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>程序运行的流程也比较容易看懂，子线程开始运行后先进行睡眠，确保主线程能够调用<code>park</code>方法阻塞自己，子线程在睡眠 5 秒后，调用<code>unpark</code>方法唤醒主线程，使主线程能继续向下执行。整个流程如下图所示：</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/basis/unsafe/image-20220717144950116.png\" alt=\"\"></p>\n<h3> Class 操作</h3>\n<h4> 介绍</h4>\n<p><code>Unsafe</code> 对<code>Class</code>的相关操作主要包括类加载和静态变量的操作方法。</p>\n<p><strong>静态属性读取相关的方法</strong></p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>创建一个包含静态属性的类，进行测试：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>运行结果：</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>在 <code>Unsafe</code> 的对象操作中，我们学习了通过<code>objectFieldOffset</code>方法获取对象属性偏移量并基于它对变量的值进行存取，但是它不适用于类中的静态属性，这时候就需要使用<code>staticFieldOffset</code>方法。在上面的代码中，只有在获取<code>Field</code>对象的过程中依赖到了<code>Class</code>，而获取静态变量的属性时不再依赖于<code>Class</code>。</p>\n<p>在上面的代码中首先创建一个<code>User</code>对象，这是因为如果一个类没有被实例化，那么它的静态属性也不会被初始化，最后获取的字段属性将是<code>null</code>。所以在获取静态属性前，需要调用<code>shouldBeInitialized</code>方法，判断在获取前是否需要初始化这个类。如果删除创建 User 对象的语句，运行结果会变为：</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p><strong>使用<code>defineClass</code>方法允许程序在运行时动态地创建一个类</strong></p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>在实际使用过程中，可以只传入字节数组、起始字节的下标以及读取的字节长度，默认情况下，类加载器（<code>ClassLoader</code>）和保护域（<code>ProtectionDomain</code>）来源于调用此方法的实例。下面的例子中实现了反编译生成后的 class 文件的功能：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在上面的代码中，首先读取了一个<code>class</code>文件并通过文件流将它转化为字节数组，之后使用<code>defineClass</code>方法动态的创建了一个类，并在后续完成了它的实例化工作，流程如下图所示，并且通过这种方式创建的类，会跳过 JVM 的所有安全检查。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/basis/unsafe/image-20220717145000710.png\" alt=\"\"></p>\n<p>除了<code>defineClass</code>方法外，Unsafe 还提供了一个<code>defineAnonymousClass</code>方法：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>使用该方法可以用来动态的创建一个匿名类，在<code>Lambda</code>表达式中就是使用 ASM 动态生成字节码，然后利用该方法定义实现相应的函数式接口的匿名类。在 JDK 15 发布的新特性中，在隐藏类（<code>Hidden classes</code>）一条中，指出将在未来的版本中弃用 <code>Unsafe</code> 的<code>defineAnonymousClass</code>方法。</p>\n<h4> 典型应用</h4>\n<p>Lambda 表达式实现需要依赖 <code>Unsafe</code> 的 <code>defineAnonymousClass</code> 方法定义实现相应的函数式接口的匿名类。</p>\n<h3> 系统信息</h3>\n<h4> 介绍</h4>\n<p>这部分包含两个获取系统相关信息的方法。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 典型应用</h4>\n<p>这两个方法的应用场景比较少，在<code>java.nio.Bits</code>类中，在使用<code>pageCount</code>计算所需的内存页的数量时，调用了<code>pageSize</code>方法获取内存页的大小。另外，在使用<code>copySwapMemory</code>方法拷贝内存时，调用了<code>addressSize</code>方法，检测 32 位系统的情况。</p>\n<h2> 总结</h2>\n<p>在本文中，我们首先介绍了 <code>Unsafe</code> 的基本概念、工作原理，并在此基础上，对它的 API 进行了说明与实践。相信大家通过这一过程，能够发现 <code>Unsafe</code> 在某些场景下，确实能够为我们提供编程中的便利。但是回到开头的话题，在使用这些便利时，确实存在着一些安全上的隐患，在我看来，一项技术具有不安全因素并不可怕，可怕的是它在使用过程中被滥用。尽管之前有传言说会在 Java9 中移除 <code>Unsafe</code> 类，不过它还是照样已经存活到了 Java16。按照存在即合理的逻辑，只要使用得当，它还是能给我们带来不少的帮助，因此最后还是建议大家，在使用 <code>Unsafe</code> 的过程中一定要做到使用谨慎使用、避免滥用。</p>\n",
      "image": "https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/basis/unsafe/image-20220717115231125.png",
      "date_published": "2022-07-17T07:13:30.000Z",
      "date_modified": "2022-10-12T02:25:34.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "单元测试到底是什么？应该怎么做？",
      "url": "https://javaguide.cn/system-design/basis/unit-test.html",
      "id": "https://javaguide.cn/system-design/basis/unit-test.html",
      "summary": "本文重构完善自谈谈为什么写单元测试 - 键盘男 - 2016这篇文章。 何谓单元测试？ 维基百科是这样介绍单元测试的： 在计算机编程中，单元测试（Unit Testing）是针对程序模块（软件设计的最小单位）进行的正确性检验测试工作。 程序单元是应用的 最小可测试部件 。在过程化编程中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类（超类）、抽象类、或者派生类（子类）中的方法。",
      "content_html": "<blockquote>\n<p>本文重构完善自<a href=\"https://www.jianshu.com/p/fa41fb80d2b8\" target=\"_blank\" rel=\"noopener noreferrer\">谈谈为什么写单元测试 - 键盘男 - 2016</a>这篇文章。</p>\n</blockquote>\n<h2> 何谓单元测试？</h2>\n<p>维基百科是这样介绍单元测试的：</p>\n<blockquote>\n<p>在计算机编程中，单元测试（Unit Testing）是针对程序模块（软件设计的最小单位）进行的正确性检验测试工作。</p>\n<p>程序单元是应用的 <strong>最小可测试部件</strong> 。在过程化编程中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类（超类）、抽象类、或者派生类（子类）中的方法。</p>\n</blockquote>\n<p>由于每个单元有独立的逻辑，在做单元测试时，为了隔离外部依赖，确保这些依赖不影响验证逻辑，我们经常会用到 Fake、Stub 与 Mock 。</p>\n<p>关于 Fake、Mock 与 Stub 这几个概念的解读，可以看看这篇文章：<a href=\"https://zhuanlan.zhihu.com/p/26942686\" target=\"_blank\" rel=\"noopener noreferrer\">测试中 Fakes、Mocks 以及 Stubs 概念明晰 - 王下邀月熊 - 2018</a> 。</p>\n<h2> 为什么需要单元测试？</h2>\n<h3> 为重构保驾护航</h3>\n<p>我在<a href=\"/system-design/basis/refactoring.html\" target=\"blank\">重构</a>这篇文章中这样写到：</p>\n<blockquote>\n<p>单元测试可以为重构提供信心，降低重构的成本。我们要像重视生产代码那样，重视单元测试。</p>\n</blockquote>\n<p>每个开发者都会经历重构，重构后把代码改坏了的情况并不少见，很可能你只是修改了一个很简单的方法就导致系统出现了一个比较严重的错误。</p>\n<p>如果有了单元测试的话，就不会存在这个隐患了。写完一个类，把单元测试写了，确保这个类逻辑正确；写第二个类，单元测试.....写 100 个类，道理一样，每个类做到第一点“保证逻辑正确性”，100 个类拼在一起肯定不出问题。你大可以放心一边重构，一边运行 APP；而不是整体重构完，提心吊胆地 run。</p>\n<h3> 提高代码质量</h3>\n<p>由于每个单元有独立的逻辑，做单元测试时需要隔离外部依赖，确保这些依赖不影响验证逻辑。因为要把各种依赖分离，单元测试会促进工程进行组件拆分，整理工程依赖关系，更大程度减少代码耦合。这样写出来的代码，更好维护，更好扩展，从而提高代码质量。</p>\n<h3> 减少 bug</h3>\n<p>一个机器，由各种细小的零件组成，如果其中某件零件坏了，机器运行故障。必须保证每个零件都按设计图要求的规格，机器才能正常运行。</p>\n<p>一个可单元测试的工程，会把业务、功能分割成规模更小、有独立的逻辑部件，称为单元。单元测试的目标，就是保证各个单元的逻辑正确性。单元测试保障工程各个“零件”按“规格”（需求）执行，从而保证整个“机器”（项目）运行正确，最大限度减少 bug。</p>\n<h3> 快速定位 bug</h3>\n<p>如果程序有 bug，我们运行一次全部单元测试，找到不通过的测试，可以很快地定位对应的执行代码。修复代码后，运行对应的单元测试；如还不通过，继续修改，运行测试.....直到<strong>测试通过</strong>。</p>\n<h3> 持续集成依赖单元测试</h3>\n<p>持续集成需要依赖单元测试，当持续集成服务自动构建新代码之后，会自动运行单元测试来发现代码错误。</p>\n<h2> 谁逼你写单元测试？</h2>\n<h3> 领导要求</h3>\n<p>有些经验丰富的领导，或多或少都会要求团队写单元测试。对于有一定工作经验的队友，这要求挺合理；对于经验尚浅的、毕业生，恐怕要死要活了，连代码都写不好，还要写单元测试，are you kidding me？</p>\n<p>培训新人单元测试用法，是一项艰巨的任务。新人代码风格未形成，也不知道单元测试多重要，强制单元测试会让他们感到困惑，没办法按自己思路写代码。</p>\n<h3> 大牛都写单元测试</h3>\n<p>国外很多家喻户晓的开源项目，都有大量单元测试。例如，<a href=\"https://link.jianshu.com?t=https://github.com/square/retrofit/tree/master/retrofit/src/test/java/retrofit2\" target=\"_blank\" rel=\"noopener noreferrer\">retrofit</a>、<a href=\"https://link.jianshu.com?t=https://github.com/square/okhttp/tree/master/okhttp-tests/src/test/java/okhttp3\" target=\"_blank\" rel=\"noopener noreferrer\">okhttp</a>、<a href=\"https://link.jianshu.com?t=https://github.com/JakeWharton/butterknife/tree/master/butterknife-compiler/src/test/java/butterknife\" target=\"_blank\" rel=\"noopener noreferrer\">butterknife</a>.... 国外大牛都写单元测试，我们也写吧！</p>\n<p>很多读者都有这种想法，一开始满腔热血。当真要对自己项目单元测试时，便困难重重，很大原因是项目对单元测试不友好。最后只能对一些不痛不痒的工具类做单元测试，久而久之，当初美好愿望也不了了之。</p>\n<h3> 保住面子</h3>\n<p>都是有些许年经验的老鸟，还天天被测试同学追 bug，好意思么？花多一点时间写单元测试，确保没低级 bug，还能彰显大牛风范，何乐而不为？</p>\n<h3> 心虚</h3>\n<p>笔者也是个不太相信自己代码的人，总觉得哪里会突然冒出莫名其妙的 bug，也怕别人不小心改了自己的代码（被害妄想症），新版本上线提心吊胆......花点时间写单元测试，有事没事跑一下测试，确保原逻辑没问题，至少能睡安稳一点。</p>\n<h2> TDD 测试驱动开发</h2>\n<h3> 何谓 TDD？</h3>\n<p>TDD 即 Test-Driven Development（ 测试驱动开发），这是敏捷开发的一项核心实践和技术，也是一种设计方法论。</p>\n<p>TDD 原理是开发功能代码之前，先编写测试用例代码，然后针对测试用例编写功能代码，使其能够通过。</p>\n<p>TDD 的节奏：“红 - 绿 - 重构”。</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/09/7f/090e1fc6aff08b4aa66376f776c2337f.png\" alt=\"\"></p>\n<p>由于 TDD 对开发人员要求非常高，跟传统开发思维不一样，因此实施起来相当困难。</p>\n<p>TDD 在很多人眼中是不实用的，一来他们并不理解测试“驱动”开发的含义，但更重要的是，他们很少会做任务分解。而任务分解是做好 TDD 的关键点。只有把任务分解到可以测试的地步，才能够有针对性地写测试。</p>\n<h3> TDD 优缺点分析</h3>\n<p>测试驱动开发有好处也有坏处。因为每个测试用例都是根据需求来的，或者说把一个大需求分解成若干小需求编写测试用例，所以测试用例写出来后，开发者写的执行代码，必须满足测试用例。如果测试不通过，则修改执行代码，直到测试用例通过。</p>\n<p><strong>优点</strong> ：</p>\n<ol>\n<li>帮你整理需求，梳理思路；</li>\n<li>帮你设计出更合理的接口（空想的话很容易设计出屎）；</li>\n<li>减小代码出现 bug 的概率；</li>\n<li>提高开发效率（前提是正确且熟练使用 TDD）。</li>\n</ol>\n<p><strong>缺点</strong> ：</p>\n<ol>\n<li>能用好 TDD 的人非常少，看似简单，实则门槛很高；</li>\n<li>投入开发资源（时间和精力）通常会更多；</li>\n<li>由于测试用例在未进行代码设计前写；很有可能限制开发者对代码整体设计；</li>\n<li>可能引起开发人员不满情绪，我觉得这点很严重，毕竟不是人人都喜欢单元测试，尽管单元测试会带给我们相当多的好处。</li>\n</ol>\n<p>相关阅读：<a href=\"https://zhuanlan.zhihu.com/p/24997923\" target=\"_blank\" rel=\"noopener noreferrer\">如何用正确的姿势打开 TDD？ - 陈天 - 2017</a>  。</p>\n<h2> 总结</h2>\n<p>单元测试确实会带给你相当多的好处，但不是立刻体验出来。正如买重疾保险，交了很多保费，没病没痛，十几年甚至几十年都用不上，最好就是一辈子用不上理赔，身体健康最重要。单元测试也一样，写了可以买个放心，对代码的一种保障，有 bug 尽快测出来，没 bug 就最好，总不能说“写那么多单元测试，结果测不出 bug，浪费时间”吧？</p>\n<p>以下是个人对单元测试一些建议：</p>\n<blockquote>\n<ul>\n<li>越重要的代码，越要写单元测试；</li>\n<li>代码做不到单元测试，多思考如何改进，而不是放弃；</li>\n<li>边写业务代码，边写单元测试，而不是完成整个新功能后再写；</li>\n<li>多思考如何改进、简化测试代码。</li>\n<li>测试代码需要随着生产代码的演进而重构或者修改，如果测试不能保持整洁，只会越来越难修改。</li>\n</ul>\n</blockquote>\n<p>作为一名经验丰富的程序员，写单元测试更多的是<strong>对自己的代码负责</strong>。有测试用例的代码，别人更容易看懂，以后别人接手你的代码时，也可能放心做改动。</p>\n<p><strong>多敲代码实践，多跟有单元测试经验的工程师交流</strong>，你会发现写单元测试获得的收益会更多。</p>\n",
      "image": "https://static001.geekbang.org/resource/image/09/7f/090e1fc6aff08b4aa66376f776c2337f.png",
      "date_published": "2022-07-16T13:03:16.000Z",
      "date_modified": "2023-01-26T12:28:12.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "代码质量"
      ]
    },
    {
      "title": "Java IO基础知识总结",
      "url": "https://javaguide.cn/java/io/io-basis.html",
      "id": "https://javaguide.cn/java/io/io-basis.html",
      "summary": "IO 流简介 IO 即 Input/Output，输入和输出。数据输入到计算机内存的过程即输入，反之输出到外部存储（比如数据库，文件，远程主机）的过程即输出。数据传输过程类似于水流，因此称为 IO 流。IO 流在 Java 中分为输入流和输出流，而根据数据的处理方式又分为字节流和字符流。 Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。 InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。 OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。",
      "content_html": "<h2> IO 流简介</h2>\n<p>IO 即 <code>Input/Output</code>，输入和输出。数据输入到计算机内存的过程即输入，反之输出到外部存储（比如数据库，文件，远程主机）的过程即输出。数据传输过程类似于水流，因此称为 IO 流。IO 流在 Java 中分为输入流和输出流，而根据数据的处理方式又分为字节流和字符流。</p>\n<p>Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。</p>\n<ul>\n<li><code>InputStream</code>/<code>Reader</code>: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li>\n<li><code>OutputStream</code>/<code>Writer</code>: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li>\n</ul>\n<h2> 字节流</h2>\n<h3> InputStream（字节输入流）</h3>\n<p><code>InputStream</code>用于从源头（通常是文件）读取数据（字节信息）到内存中，<code>java.io.InputStream</code>抽象类是所有字节输入流的父类。</p>\n<p><code>InputStream</code> 常用方法 ：</p>\n<ul>\n<li><code>read()</code> ：返回输入流中下一个字节的数据。返回的值介于 0 到 255 之间。如果未读取任何字节，则代码返回 <code>-1</code> ，表示文件结束。</li>\n<li><code>read(byte b[ ])</code> : 从输入流中读取一些字节存储到数组 <code>b</code> 中。如果数组 <code>b</code> 的长度为零，则不读取。如果没有可用字节读取，返回 <code>-1</code>。如果有可用字节读取，则最多读取的字节数最多等于 <code>b.length</code> ， 返回读取的字节数。这个方法等价于 <code>read(b, 0, b.length)</code>。</li>\n<li><code>read(byte b[], int off, int len)</code> ：在<code>read(byte b[ ])</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字节数）。</li>\n<li><code>skip(long n)</code> ：忽略输入流中的 n 个字节 ,返回实际忽略的字节数。</li>\n<li><code>available()</code> ：返回输入流中可以读取的字节数。</li>\n<li><code>close()</code> ：关闭输入流释放相关的系统资源。</li>\n</ul>\n<p>从 Java 9 开始，<code>InputStream</code> 新增加了多个实用的方法：</p>\n<ul>\n<li><code>readAllBytes()</code> ：读取输入流中的所有字节，返回字节数组。</li>\n<li><code>readNBytes(byte[] b, int off, int len)</code> ：阻塞直到读取 <code>len</code> 个字节。</li>\n<li><code>transferTo(OutputStream out)</code> ： 将所有字节从一个输入流传递到一个输出流。</li>\n</ul>\n<p><code>FileInputStream</code> 是一个比较常用的字节输入流对象，可直接指定文件路径，可以直接读取单字节数据，也可以读取至字节数组中。</p>\n<p><code>FileInputStream</code> 代码示例：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>input.txt</code> 文件内容：</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/image-20220419155214614.png\" alt=\"\"></p>\n<p>输出：</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>不过，一般我们是不会直接单独使用 <code>FileInputStream</code> ，通常会配合 <code>BufferedInputStream</code>（字节缓冲输入流，后文会讲到）来使用。</p>\n<p>像下面这段代码在我们的项目中就比较常见，我们通过 <code>readAllBytes()</code> 读取输入流所有字节并将其直接赋值给一个 <code>String</code> 对象。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>DataInputStream</code> 用于读取指定类型数据，不能单独使用，必须结合 <code>FileInputStream</code> 。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>ObjectInputStream</code> 用于从输入流中读取 Java 对象（反序列化），<code>ObjectOutputStream</code> 用于将对象写入到输出流(序列化)。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>另外，用于序列化和反序列化的类必须实现 <code>Serializable</code> 接口，对象中如果有属性不想被序列化，使用 <code>transient</code> 修饰。</p>\n<h3> OutputStream（字节输出流）</h3>\n<p><code>OutputStream</code>用于将数据（字节信息）写入到目的地（通常是文件），<code>java.io.OutputStream</code>抽象类是所有字节输出流的父类。</p>\n<p><code>OutputStream</code> 常用方法 ：</p>\n<ul>\n<li><code>write(int b)</code> ：将特定字节写入输出流。</li>\n<li><code>write(byte b[ ])</code> : 将数组<code>b</code> 写入到输出流，等价于 <code>write(b, 0, b.length)</code> 。</li>\n<li><code>write(byte[] b, int off, int len)</code> : 在<code>write(byte b[ ])</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字节数）。</li>\n<li><code>flush()</code> ：刷新此输出流并强制写出所有缓冲的输出字节。</li>\n<li><code>close()</code> ：关闭输出流释放相关的系统资源。</li>\n</ul>\n<p><code>FileOutputStream</code> 是最常用的字节输出流对象，可直接指定文件路径，可以直接输出单字节数据，也可以输出指定的字节数组。</p>\n<p><code>FileOutputStream</code> 代码示例：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>运行结果：</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/image-20220419155514392.png\" alt=\"\"></p>\n<p>类似于 <code>FileInputStream</code>，<code>FileOutputStream</code> 通常也会配合 <code>BufferedOutputStream</code>（字节缓冲输出流，后文会讲到）来使用。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong><code>DataOutputStream</code></strong> 用于写入指定类型数据，不能单独使用，必须结合 <code>FileOutputStream</code></p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>ObjectInputStream</code> 用于从输入流中读取 Java 对象（<code>ObjectInputStream</code>,反序列化），<code>ObjectOutputStream</code>将对象写入到输出流(<code>ObjectOutputStream</code>，序列化)。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 字符流</h2>\n<p>不管是文件读写还是网络发送接收，信息的最小存储单元都是字节。 <strong>那为什么 I/O 流操作要分为字节流操作和字符流操作呢？</strong></p>\n<p>个人认为主要有两点原因：</p>\n<ul>\n<li>字符流是由 Java 虚拟机将字节转换得到的，这个过程还算是比较耗时。</li>\n<li>如果我们不知道编码类型就很容易出现乱码问题。</li>\n</ul>\n<p>乱码问题这个很容易就可以复现，我们只需要将上面提到的 <code>FileInputStream</code> 代码示例中的 <code>input.txt</code> 文件内容改为中文即可，原代码不需要改动。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/image-20220419154632551.png\" alt=\"\"></p>\n<p>输出：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>可以很明显地看到读取出来的内容已经变成了乱码。</p>\n<p>因此，I/O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。</p>\n<p>字符流默认采用的是 <code>Unicode</code> 编码，我们可以通过构造方法自定义编码。顺便分享一下之前遇到的笔试题：常用字符编码所占字节数？<code>utf8</code> :英文占 1 字节，中文占 3 字节，<code>unicode</code>：任何字符都占 2 个字节，<code>gbk</code>：英文占 1 字节，中文占 2 字节。</p>\n<h3> Reader（字符输入流）</h3>\n<p><code>Reader</code>用于从源头（通常是文件）读取数据（字符信息）到内存中，<code>java.io.Reader</code>抽象类是所有字符输入流的父类。</p>\n<p><code>Reader</code> 用于读取文本， <code>InputStream</code> 用于读取原始字节。</p>\n<p><code>Reader</code> 常用方法 ：</p>\n<ul>\n<li><code>read()</code> : 从输入流读取一个字符。</li>\n<li><code>read(char[] cbuf)</code> : 从输入流中读取一些字符，并将它们存储到字符数组 <code>cbuf</code>中，等价于 <code>read(cbuf, 0, cbuf.length)</code> 。</li>\n<li><code>read(char[] cbuf, int off, int len)</code> ：在<code>read(char[] cbuf)</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字符数）。</li>\n<li><code>skip(long n)</code> ：忽略输入流中的 n 个字符 ,返回实际忽略的字符数。</li>\n<li><code>close()</code> : 关闭输入流并释放相关的系统资源。</li>\n</ul>\n<p><code>InputStreamReader</code> 是字节流转换为字符流的桥梁，其子类 <code>FileReader</code> 是基于该基础上的封装，可以直接操作字符文件。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>FileReader</code> 代码示例：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>input.txt</code> 文件内容：</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/image-20220419154632551.png\" alt=\"\"></p>\n<p>输出：</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> Writer（字符输出流）</h3>\n<p><code>Writer</code>用于将数据（字符信息）写入到目的地（通常是文件），<code>java.io.Writer</code>抽象类是所有字符输出流的父类。</p>\n<p><code>Writer</code> 常用方法 ：</p>\n<ul>\n<li><code>write(int c)</code> : 写入单个字符。</li>\n<li><code>write(char[] cbuf)</code> ：写入字符数组 <code>cbuf</code>，等价于<code>write(cbuf, 0, cbuf.length)</code>。</li>\n<li><code>write(char[] cbuf, int off, int len)</code> ：在<code>write(char[] cbuf)</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字符数）。</li>\n<li><code>write(String str)</code> ：写入字符串，等价于 <code>write(str, 0, str.length())</code> 。</li>\n<li><code>write(String str, int off, int len)</code> ：在<code>write(String str)</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字符数）。</li>\n<li><code>append(CharSequence csq)</code> ：将指定的字符序列附加到指定的 <code>Writer</code> 对象并返回该 <code>Writer</code> 对象。</li>\n<li><code>append(char c)</code> ：将指定的字符附加到指定的 <code>Writer</code> 对象并返回该 <code>Writer</code> 对象。</li>\n<li><code>flush()</code> ：刷新此输出流并强制写出所有缓冲的输出字符。</li>\n<li><code>close()</code>:关闭输出流释放相关的系统资源。</li>\n</ul>\n<p><code>OutputStreamWriter</code> 是字符流转换为字节流的桥梁，其子类 <code>FileWriter</code> 是基于该基础上的封装，可以直接将字符写入到文件。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>FileWriter</code> 代码示例：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出结果：</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/image-20220419155802288.png\" alt=\"\"></p>\n<h2> 字节缓冲流</h2>\n<p>IO 操作是很消耗性能的，缓冲流将数据加载至缓冲区，一次性读取/写入多个字节，从而避免频繁的 IO 操作，提高流的传输效率。</p>\n<p>字节缓冲流这里采用了装饰器模式来增强 <code>InputStream</code> 和<code>OutputStream</code>子类对象的功能。</p>\n<p>举个例子，我们可以通过 <code>BufferedInputStream</code>（字节缓冲输入流）来增强 <code>FileInputStream</code> 的功能。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>字节流和字节缓冲流的性能差别主要体现在我们使用两者的时候都是调用 <code>write(int b)</code> 和 <code>read()</code> 这两个一次只读取一个字节的方法的时候。由于字节缓冲流内部有缓冲区（字节数组），因此，字节缓冲流会先将读取到的字节存放在缓存区，大幅减少 IO 次数，提高读取效率。</p>\n<p>我使用 <code>write(int b)</code> 和 <code>read()</code> 方法，分别通过字节流和字节缓冲流复制一个 <code>524.9 mb</code> 的 PDF 文件耗时对比如下：</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>两者耗时差别非常大，缓冲流耗费的时间是字节流的 1/165。</p>\n<p>测试代码如下:</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果是调用 <code>read(byte b[])</code> 和 <code>write(byte b[], int off, int len)</code> 这两个写入一个字节数组的方法的话，只要字节数组的大小合适，两者的性能差距其实不大，基本可以忽略。</p>\n<p>这次我们使用 <code>read(byte b[])</code> 和 <code>write(byte b[], int off, int len)</code> 方法，分别通过字节流和字节缓冲流复制一个 524.9 mb 的 PDF 文件耗时对比如下：</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>两者耗时差别不是很大，缓冲流的性能要略微好一点点。</p>\n<p>测试代码如下：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> BufferedInputStream（字节缓冲输入流）</h3>\n<p><code>BufferedInputStream</code> 从源头（通常是文件）读取数据（字节信息）到内存的过程中不会一个字节一个字节的读取，而是会先将读取到的字节存放在缓存区，并从内部缓冲区中单独读取字节。这样大幅减少了 IO 次数，提高了读取效率。</p>\n<p><code>BufferedInputStream</code> 内部维护了一个缓冲区，这个缓冲区实际就是一个字节数组，通过阅读 <code>BufferedInputStream</code> 源码即可得到这个结论。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>缓冲区的大小默认为 <strong>8192</strong> 字节，当然了，你也可以通过 <code>BufferedInputStream(InputStream in, int size)</code> 这个构造方法来指定缓冲区的大小。</p>\n<h3> BufferedOutputStream（字节缓冲输出流）</h3>\n<p><code>BufferedOutputStream</code> 将数据（字节信息）写入到目的地（通常是文件）的过程中不会一个字节一个字节的写入，而是会先将要写入的字节存放在缓存区，并从内部缓冲区中单独写入字节。这样大幅减少了 IO 次数，提高了读取效率</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>类似于 <code>BufferedInputStream</code> ，<code>BufferedOutputStream</code> 内部也维护了一个缓冲区，并且，这个缓存区的大小也是 <strong>8192</strong> 字节。</p>\n<h2> 字符缓冲流</h2>\n<p><code>BufferedReader</code> （字符缓冲输入流）和 <code>BufferedWriter</code>（字符缓冲输出流）类似于 <code>BufferedInputStream</code>（字节缓冲输入流）和<code>BufferedOutputStream</code>（字节缓冲输入流），内部都维护了一个字节数组作为缓冲区。不过，前者主要是用来操作字符信息。</p>\n<h2> 打印流</h2>\n<p>下面这段代码大家经常使用吧？</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>System.out</code> 实际是用于获取一个 <code>PrintStream</code> 对象，<code>print</code>方法实际调用的是 <code>PrintStream</code> 对象的 <code>write</code> 方法。</p>\n<p><code>PrintStream</code> 属于字节打印流，与之对应的是 <code>PrintWriter</code> （字符打印流）。<code>PrintStream</code> 是 <code>OutputStream</code> 的子类，<code>PrintWriter</code> 是 <code>Writer</code> 的子类。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 随机访问流</h2>\n<p>这里要介绍的随机访问流指的是支持随意跳转到文件的任意位置进行读写的 <code>RandomAccessFile</code> 。</p>\n<p><code>RandomAccessFile</code> 的构造方法如下，我们可以指定 <code>mode</code>（读写模式）。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>读写模式主要有下面四种：</p>\n<ul>\n<li><code>r</code> : 只读模式。</li>\n<li><code>rw</code>: 读写模式</li>\n<li><code>rws</code>: 相对于 <code>rw</code>，<code>rws</code> 同步更新对“文件的内容”或“元数据”的修改到外部存储设备。</li>\n<li><code>rwd</code> : 相对于 <code>rw</code>，<code>rwd</code> 同步更新对“文件的内容”的修改到外部存储设备。</li>\n</ul>\n<p>文件内容指的是文件中实际保存的数据，元数据则是用来描述文件属性比如文件的大小信息、创建和修改时间。</p>\n<p><code>RandomAccessFile</code> 中有一个文件指针用来表示下一个将要被写入或者读取的字节所处的位置。我们可以通过 <code>RandomAccessFile</code> 的 <code>seek(long pos)</code> 方法来设置文件指针的偏移量（距文件开头 <code>pos</code> 个字节处）。如果想要获取文件指针当前的位置的话，可以使用 <code>getFilePointer()</code> 方法。</p>\n<p><code>RandomAccessFile</code> 代码示例：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>input.txt</code> 文件内容：</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/image-20220421162050158.png\" alt=\"\"></p>\n<p>输出：</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>input.txt</code> 文件内容变为 <code>ABCDEFGHIJK</code> 。</p>\n<p><code>RandomAccessFile</code> 的 <code>write</code> 方法在写入对象的时候如果对应的位置已经有数据的话，会将其覆盖掉。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>假设运行上面这段程序之前 <code>input.txt</code> 文件内容变为 <code>ABCD</code> ，运行之后则变为 <code>HIJK</code> 。</p>\n<p><code>RandomAccessFile</code> 比较常见的一个应用就是实现大文件的 <strong>断点续传</strong> 。何谓断点续传？简单来说就是上传文件中途暂停或失败（比如遇到网络问题）之后，不需要重新上传，只需要上传那些未成功上传的文件分片即可。分片（先将文件切分成多个文件分片）上传是断点续传的基础。</p>\n<p><code>RandomAccessFile</code> 可以帮助我们合并文件分片，示例代码如下：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20210609164749122.png\" alt=\"\"></p>\n<p>我在<a href=\"https://javaguide.cn/zhuanlan/java-mian-shi-zhi-bei.html\" target=\"_blank\" rel=\"noopener noreferrer\">《Java 面试指北》</a>中详细介绍了大文件的上传问题。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/image-20220428104115362.png\" alt=\"\"></p>\n<p><code>RandomAccessFile</code> 的实现依赖于 <code>FileDescriptor</code> (文件描述符) 和 <code>FileChannel</code> （内存映射文件）。</p>\n",
      "image": "https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/image-20220419155214614.png",
      "date_published": "2022-07-16T10:32:46.000Z",
      "date_modified": "2023-02-08T17:21:07.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "Java IO设计模式总结",
      "url": "https://javaguide.cn/java/io/io-design-patterns.html",
      "id": "https://javaguide.cn/java/io/io-design-patterns.html",
      "summary": "这篇文章我们简单来看看我们从 IO 中能够学习到哪些设计模式的应用。 装饰器模式 装饰器（Decorator）模式 可以在不改变原有对象的情况下拓展其功能。 装饰器模式通过组合替代继承来扩展原始类的功能，在一些继承关系比较复杂的场景（IO 这一场景各种类的继承关系就比较复杂）更加实用。 对于字节流来说， FilterInputStream （对应输入流）和FilterOutputStream（对应输出流）是装饰器模式的核心，分别用于增强 InputStream 和OutputStream子类对象的功能。",
      "content_html": "<p>这篇文章我们简单来看看我们从 IO 中能够学习到哪些设计模式的应用。</p>\n<h2> 装饰器模式</h2>\n<p><strong>装饰器（Decorator）模式</strong> 可以在不改变原有对象的情况下拓展其功能。</p>\n<p>装饰器模式通过组合替代继承来扩展原始类的功能，在一些继承关系比较复杂的场景（IO 这一场景各种类的继承关系就比较复杂）更加实用。</p>\n<p>对于字节流来说， <code>FilterInputStream</code> （对应输入流）和<code>FilterOutputStream</code>（对应输出流）是装饰器模式的核心，分别用于增强 <code>InputStream</code> 和<code>OutputStream</code>子类对象的功能。</p>\n<p>我们常见的<code>BufferedInputStream</code>(字节缓冲输入流)、<code>DataInputStream</code> 等等都是<code>FilterInputStream</code> 的子类，<code>BufferedOutputStream</code>（字节缓冲输出流）、<code>DataOutputStream</code>等等都是<code>FilterOutputStream</code>的子类。</p>\n<p>举个例子，我们可以通过 <code>BufferedInputStream</code>（字节缓冲输入流）来增强 <code>FileInputStream</code> 的功能。</p>\n<p><code>BufferedInputStream</code> 构造函数如下：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>可以看出，<code>BufferedInputStream</code> 的构造函数其中的一个参数就是 <code>InputStream</code> 。</p>\n<p><code>BufferedInputStream</code> 代码示例：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这个时候，你可以会想了：<strong>为啥我们直接不弄一个<code>BufferedFileInputStream</code>（字符缓冲文件输入流）呢？</strong></p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>如果 <code>InputStream</code>的子类比较少的话，这样做是没问题的。不过， <code>InputStream</code>的子类实在太多，继承关系也太复杂了。如果我们为每一个子类都定制一个对应的缓冲输入流，那岂不是太麻烦了。</p>\n<p>如果你对 IO 流比较熟悉的话，你会发现<code>ZipInputStream</code> 和<code>ZipOutputStream</code> 还可以分别增强 <code>BufferedInputStream</code> 和 <code>BufferedOutputStream</code> 的能力。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>ZipInputStream</code> 和<code>ZipOutputStream</code> 分别继承自<code>InflaterInputStream</code> 和<code>DeflaterOutputStream</code>。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这也是装饰器模式很重要的一个特征，那就是可以对原始类嵌套使用多个装饰器。</p>\n<p>为了实现这一效果，装饰器类需要跟原始类继承相同的抽象类或者实现相同的接口。上面介绍到的这些 IO 相关的装饰类和原始类共同的父类是 <code>InputStream</code> 和<code>OutputStream</code>。</p>\n<p>对于字符流来说，<code>BufferedReader</code> 可以用来增加 <code>Reader</code> （字符输入流）子类的功能，<code>BufferedWriter</code> 可以用来增加 <code>Writer</code> （字符输出流）子类的功能。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>IO 流中的装饰器模式应用的例子实在是太多了，不需要特意记忆，完全没必要哈！搞清了装饰器模式的核心之后，你在使用的时候自然就会知道哪些地方运用到了装饰器模式。</p>\n<h2> 适配器模式</h2>\n<p><strong>适配器（Adapter Pattern）模式</strong> 主要用于接口互不兼容的类的协调工作，你可以将其联想到我们日常经常使用的电源适配器。</p>\n<p>适配器模式中存在被适配的对象或者类称为 <strong>适配者(Adaptee)</strong> ，作用于适配者的对象或者类称为<strong>适配器(Adapter)</strong> 。适配器分为对象适配器和类适配器。类适配器使用继承关系来实现，对象适配器使用组合关系来实现。</p>\n<p>IO 流中的字符流和字节流的接口不同，它们之间可以协调工作就是基于适配器模式来做的，更准确点来说是对象适配器。通过适配器，我们可以将字节流对象适配成一个字符流对象，这样我们可以直接通过字节流对象来读取或者写入字符数据。</p>\n<p><code>InputStreamReader</code> 和 <code>OutputStreamWriter</code> 就是两个适配器(Adapter)， 同时，它们两个也是字节流和字符流之间的桥梁。<code>InputStreamReader</code> 使用 <code>StreamDecoder</code> （流解码器）对字节进行解码，<strong>实现字节流到字符流的转换，</strong> <code>OutputStreamWriter</code> 使用<code>StreamEncoder</code>（流编码器）对字符进行编码，实现字符流到字节流的转换。</p>\n<p><code>InputStream</code> 和 <code>OutputStream</code> 的子类是被适配者， <code>InputStreamReader</code> 和 <code>OutputStreamWriter</code>是适配器。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>java.io.InputStreamReader</code> 部分源码：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>java.io.OutputStreamWriter</code> 部分源码：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>适配器模式和装饰器模式有什么区别呢？</strong></p>\n<p><strong>装饰器模式</strong> 更侧重于动态地增强原始类的功能，装饰器类需要跟原始类继承相同的抽象类或者实现相同的接口。并且，装饰器模式支持对原始类嵌套使用多个装饰器。</p>\n<p><strong>适配器模式</strong> 更侧重于让接口不兼容而不能交互的类可以一起工作，当我们调用适配器对应的方法时，适配器内部会调用适配者类或者和适配类相关的类的方法，这个过程透明的。就比如说 <code>StreamDecoder</code> （流解码器）和<code>StreamEncoder</code>（流编码器）就是分别基于 <code>InputStream</code> 和 <code>OutputStream</code> 来获取 <code>FileChannel</code>对象并调用对应的 <code>read</code> 方法和 <code>write</code> 方法进行字节数据的读取和写入。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>适配器和适配者两者不需要继承相同的抽象类或者实现相同的接口。</p>\n<p>另外，<code>FutureTask</code> 类使用了适配器模式，<code>Executors</code> 的内部类 <code>RunnableAdapter</code> 实现属于适配器，用于将 <code>Runnable</code> 适配成 <code>Callable</code>。</p>\n<p><code>FutureTask</code>参数包含 <code>Runnable</code> 的一个构造方法：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>Executors</code>中对应的方法和适配器：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 工厂模式</h2>\n<p>工厂模式用于创建对象，NIO 中大量用到了工厂模式，比如 <code>Files</code> 类的 <code>newInputStream</code> 方法用于创建 <code>InputStream</code> 对象（静态工厂）、 <code>Paths</code> 类的 <code>get</code> 方法创建 <code>Path</code> 对象（静态工厂）、<code>ZipFileSystem</code> 类（<code>sun.nio</code>包下的类，属于 <code>java.nio</code> 相关的一些内部实现）的 <code>getPath</code> 的方法创建 <code>Path</code> 对象（简单工厂）。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 观察者模式</h2>\n<p>NIO 中的文件目录监听服务使用到了观察者模式。</p>\n<p>NIO 中的文件目录监听服务基于 <code>WatchService</code> 接口和 <code>Watchable</code> 接口。<code>WatchService</code> 属于观察者，<code>Watchable</code> 属于被观察者。</p>\n<p><code>Watchable</code> 接口定义了一个用于将对象注册到 <code>WatchService</code>（监控服务） 并绑定监听事件的方法 <code>register</code> 。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>WatchService</code> 用于监听文件目录的变化，同一个 <code>WatchService</code> 对象能够监听多个文件目录。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>Path</code> 类 <code>register</code> 方法的第二个参数 <code>events</code> （需要监听的事件）为可变长参数，也就是说我们可以同时监听多种事件。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>常用的监听事件有 3 种：</p>\n<ul>\n<li><code>StandardWatchEventKinds.ENTRY_CREATE</code> ：文件创建。</li>\n<li><code>StandardWatchEventKinds.ENTRY_DELETE</code> : 文件删除。</li>\n<li><code>StandardWatchEventKinds.ENTRY_MODIFY</code> : 文件修改。</li>\n</ul>\n<p><code>register</code> 方法返回 <code>WatchKey</code> 对象，通过<code>WatchKey</code> 对象可以获取事件的具体信息比如文件目录下是创建、删除还是修改了文件、创建、删除或者修改的文件的具体名称是什么。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>WatchService</code> 内部是通过一个 daemon thread（守护线程）采用定期轮询的方式来检测文件的变化，简化后的源码如下所示。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 参考</h2>\n<ul>\n<li>Patterns in Java APIs：http://cecs.wright.edu/~tkprasad/courses/ceg860/paper/node26.html</li>\n<li>装饰器模式：通过剖析 Java IO 类库源码学习装饰器模式：https://time.geekbang.org/column/article/204845</li>\n<li>sun.nio 包是什么，是 java 代码么？ - RednaxelaFX https://www.zhihu.com/question/29237781/answer/43653953</li>\n</ul>\n",
      "date_published": "2022-07-16T10:32:46.000Z",
      "date_modified": "2023-02-06T07:04:21.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "Java IO模型详解",
      "url": "https://javaguide.cn/java/io/io-model.html",
      "id": "https://javaguide.cn/java/io/io-model.html",
      "summary": "IO 模型这块确实挺难理解的，需要太多计算机底层知识。写这篇文章用了挺久，就非常希望能把我所知道的讲出来吧!希望朋友们能有收获！为了写这篇文章，还翻看了一下《UNIX 网络编程》这本书，太难了，我滴乖乖！心痛~ 个人能力有限。如果文章有任何需要补充/完善/修改的地方，欢迎在评论区指出，共同进步！ 前言 I/O 一直是很多小伙伴难以理解的一个知识点，这篇文章我会将我所理解的 I/O 讲给你听，希望可以对你有所帮助。 I/O 何为 I/O? I/O（Input/Outpu） 即输入／输出 。",
      "content_html": "<p>IO 模型这块确实挺难理解的，需要太多计算机底层知识。写这篇文章用了挺久，就非常希望能把我所知道的讲出来吧!希望朋友们能有收获！为了写这篇文章，还翻看了一下《UNIX 网络编程》这本书，太难了，我滴乖乖！心痛~</p>\n<p><em>个人能力有限。如果文章有任何需要补充/完善/修改的地方，欢迎在评论区指出，共同进步！</em></p>\n<h2> 前言</h2>\n<p>I/O 一直是很多小伙伴难以理解的一个知识点，这篇文章我会将我所理解的 I/O 讲给你听，希望可以对你有所帮助。</p>\n<h2> I/O</h2>\n<h3> 何为 I/O?</h3>\n<p>I/O（<strong>I</strong>nput/<strong>O</strong>utpu） 即<strong>输入／输出</strong> 。</p>\n<p><strong>我们先从计算机结构的角度来解读一下 I/O。</strong></p>\n<p>根据冯.诺依曼结构，计算机结构分为 5 大部分：运算器、控制器、存储器、输入设备、输出设备。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190624122126398.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9pcy1jbG91ZC5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70\" alt=\"冯诺依曼体系结构\"></p>\n<p>输入设备（比如键盘）和输出设备（比如显示器）都属于外部设备。网卡、硬盘这种既可以属于输入设备，也可以属于输出设备。</p>\n<p>输入设备向计算机输入数据，输出设备接收计算机输出的数据。</p>\n<p><strong>从计算机结构的视角来看的话， I/O 描述了计算机系统与外部设备之间通信的过程。</strong></p>\n<p><strong>我们再先从应用程序的角度来解读一下 I/O。</strong></p>\n<p>根据大学里学到的操作系统相关的知识：为了保证操作系统的稳定性和安全性，一个进程的地址空间划分为 <strong>用户空间（User space）</strong> 和 <strong>内核空间（Kernel space ）</strong> 。</p>\n<p>像我们平常运行的应用程序都是运行在用户空间，只有内核空间才能进行系统态级别的资源有关的操作，比如文件管理、进程通信、内存管理等等。也就是说，我们想要进行 IO 操作，一定是要依赖内核空间的能力。</p>\n<p>并且，用户空间的程序不能直接访问内核空间。</p>\n<p>当想要执行 IO 操作时，由于没有执行这些操作的权限，只能发起系统调用请求操作系统帮忙完成。</p>\n<p>因此，用户进程想要执行 IO 操作的话，必须通过 <strong>系统调用</strong> 来间接访问内核空间</p>\n<p>我们在平常开发过程中接触最多的就是 <strong>磁盘 IO（读写文件）</strong> 和 <strong>网络 IO（网络请求和响应）</strong>。</p>\n<p><strong>从应用程序的视角来看的话，我们的应用程序对操作系统的内核发起 IO 调用（系统调用），操作系统负责的内核执行具体的 IO 操作。也就是说，我们的应用程序实际上只是发起了 IO 操作的调用而已，具体 IO 的执行是由操作系统的内核来完成的。</strong></p>\n<p>当应用程序发起 I/O 调用后，会经历两个步骤：</p>\n<ol>\n<li>内核等待 I/O 设备准备好数据</li>\n<li>内核将数据从内核空间拷贝到用户空间。</li>\n</ol>\n<h3> 有哪些常见的 IO 模型?</h3>\n<p>UNIX 系统下， IO 模型一共有 5 种： <strong>同步阻塞 I/O</strong>、<strong>同步非阻塞 I/O</strong>、<strong>I/O 多路复用</strong>、<strong>信号驱动 I/O</strong> 和<strong>异步 I/O</strong>。</p>\n<p>这也是我们经常提到的 5 种 IO 模型。</p>\n<h2> Java 中 3 种常见 IO 模型</h2>\n<h3> BIO (Blocking I/O)</h3>\n<p><strong>BIO 属于同步阻塞 IO 模型</strong> 。</p>\n<p>同步阻塞 IO 模型中，应用程序发起 read 调用后，会一直阻塞，直到内核把数据拷贝到用户空间。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6a9e704af49b4380bb686f0c96d33b81~tplv-k3u1fbpfcp-watermark.image\" alt=\"图源：《深入拆解Tomcat &amp; Jetty》\"></p>\n<p>在客户端连接数量不高的情况下，是没问题的。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。</p>\n<h3> NIO (Non-blocking/New I/O)</h3>\n<p>Java 中的 NIO 于 Java 1.4 中引入，对应 <code>java.nio</code> 包，提供了 <code>Channel</code> , <code>Selector</code>，<code>Buffer</code> 等抽象。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它是支持面向缓冲的，基于通道的 I/O 操作方法。 对于高负载、高并发的（网络）应用，应使用 NIO 。</p>\n<p>Java 中的 NIO 可以看作是 <strong>I/O 多路复用模型</strong>。也有很多人认为，Java 中的 NIO 属于同步非阻塞 IO 模型。</p>\n<p>跟着我的思路往下看看，相信你会得到答案！</p>\n<p>我们先来看看 <strong>同步非阻塞 IO 模型</strong>。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bb174e22dbe04bb79fe3fc126aed0c61~tplv-k3u1fbpfcp-watermark.image\" alt=\"图源：《深入拆解Tomcat &amp; Jetty》\"></p>\n<p>同步非阻塞 IO 模型中，应用程序会一直发起 read 调用，等待数据从内核空间拷贝到用户空间的这段时间里，线程依然是阻塞的，直到在内核把数据拷贝到用户空间。</p>\n<p>相比于同步阻塞 IO 模型，同步非阻塞 IO 模型确实有了很大改进。通过轮询操作，避免了一直阻塞。</p>\n<p>但是，这种 IO 模型同样存在问题：<strong>应用程序不断进行 I/O 系统调用轮询数据是否已经准备好的过程是十分消耗 CPU 资源的。</strong></p>\n<p>这个时候，<strong>I/O 多路复用模型</strong> 就上场了。</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88ff862764024c3b8567367df11df6ab~tplv-k3u1fbpfcp-watermark.image\" alt=\"\"></p>\n<p>IO 多路复用模型中，线程首先发起 select 调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起 read 调用。read 调用的过程（数据从内核空间 -&gt; 用户空间）还是阻塞的。</p>\n<blockquote>\n<p>目前支持 IO 多路复用的系统调用，有 select，epoll 等等。select 系统调用，目前几乎在所有的操作系统上都有支持。</p>\n<ul>\n<li><strong>select 调用</strong> ：内核提供的系统调用，它支持一次查询多个系统调用的可用状态。几乎所有的操作系统都支持。</li>\n<li><strong>epoll 调用</strong> ：linux 2.6 内核，属于 select 调用的增强版本，优化了 IO 的执行效率。</li>\n</ul>\n</blockquote>\n<p><strong>IO 多路复用模型，通过减少无效的系统调用，减少了对 CPU 资源的消耗。</strong></p>\n<p>Java 中的 NIO ，有一个非常重要的<strong>选择器 ( Selector )</strong> 的概念，也可以被称为 <strong>多路复用器</strong>。通过它，只需要一个线程便可以管理多个客户端连接。当客户端数据到了之后，才会为其服务。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f483f2437ce4ecdb180134270a00144~tplv-k3u1fbpfcp-watermark.image\" alt=\"\"></p>\n<h3> AIO (Asynchronous I/O)</h3>\n<p>AIO 也就是 NIO 2。Java 7 中引入了 NIO 的改进版 NIO 2,它是异步 IO 模型。</p>\n<p>异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3077e72a1af049559e81d18205b56fd7~tplv-k3u1fbpfcp-watermark.image\" alt=\"\"></p>\n<p>目前来说 AIO 的应用还不是很广泛。Netty 之前也尝试使用过 AIO，不过又放弃了。这是因为，Netty 使用了 AIO 之后，在 Linux 系统上的性能并没有多少提升。</p>\n<p>最后，来一张图，简单总结一下 Java 中的 BIO、NIO、AIO。</p>\n<p><img src=\"https://images.xiaozhuanlan.com/photo/2020/33b193457c928ae02217480f994814b6.png\" alt=\"\"></p>\n<h2> 参考</h2>\n<ul>\n<li>《深入拆解 Tomcat &amp; Jetty》</li>\n<li>如何完成一次 IO：https://llc687.top/126.html</li>\n<li>程序员应该这样理解 IO：<a href=\"https://www.jianshu.com/p/fa7bdc4f3de7\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.jianshu.com/p/fa7bdc4f3de7</a></li>\n<li>10 分钟看懂， Java NIO 底层原理：https://www.cnblogs.com/crazymakercircle/p/10225159.html</li>\n<li>IO 模型知多少 | 理论篇：https://www.cnblogs.com/sheng-jie/p/how-much-you-know-about-io-models.html</li>\n<li>《UNIX 网络编程 卷 1；套接字联网 API 》6.2 节 IO 模型</li>\n</ul>\n",
      "image": "https://img-blog.csdnimg.cn/20190624122126398.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9pcy1jbG91ZC5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70",
      "date_published": "2022-07-16T10:32:46.000Z",
      "date_modified": "2022-07-16T10:32:46.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "RPC 基础常见面试题总结",
      "url": "https://javaguide.cn/distributed-system/rpc/rpc-intro.html",
      "id": "https://javaguide.cn/distributed-system/rpc/rpc-intro.html",
      "summary": "简单介绍一下 RPC 相关的基础概念。 何为 RPC? RPC（Remote Procedure Call） 即远程过程调用，通过名字我们就能看出 RPC 关注的是远程调用而非本地调用。 为什么要 RPC ？ 因为，两个不同的服务器上的服务提供的方法不在一个内存空间，所以，需要通过网络编程才能传递方法调用所需要的参数。并且，方法调用的结果也需要通过网络编程来接收。但是，如果我们自己手动网络编程来实现这个调用过程的话工作量是非常大的，因为，我们需要考虑底层传输方式（TCP还是UDP）、序列化方式等等方面。",
      "content_html": "<p>简单介绍一下 RPC 相关的基础概念。</p>\n<h2> 何为 RPC?</h2>\n<p><strong>RPC（Remote Procedure Call）</strong> 即远程过程调用，通过名字我们就能看出 RPC 关注的是远程调用而非本地调用。</p>\n<p><strong>为什么要 RPC  ？</strong> 因为，两个不同的服务器上的服务提供的方法不在一个内存空间，所以，需要通过网络编程才能传递方法调用所需要的参数。并且，方法调用的结果也需要通过网络编程来接收。但是，如果我们自己手动网络编程来实现这个调用过程的话工作量是非常大的，因为，我们需要考虑底层传输方式（TCP还是UDP）、序列化方式等等方面。</p>\n<p><strong>RPC 能帮助我们做什么呢？</strong> 简单来说，通过 RPC 可以帮助我们调用远程计算机上某个服务的方法，这个过程就像调用本地方法一样简单。并且！我们不需要了解底层网络编程的具体细节。</p>\n<p>举个例子：两个不同的服务 A、B 部署在两台不同的机器上，服务 A 如果想要调用服务 B 中的某个方法的话就可以通过 RPC 来做。</p>\n<p>一言蔽之：<strong>RPC 的出现就是为了让你调用远程方法像调用本地方法一样简单。</strong></p>\n<h2> RPC 的原理是什么?</h2>\n<p>为了能够帮助小伙伴们理解 RPC 原理，我们可以将整个 RPC的 核心功能看作是下面👇 5 个部分实现的：</p>\n<ol>\n<li><strong>客户端（服务消费端）</strong> ：调用远程方法的一端。</li>\n<li><strong>客户端 Stub（桩）</strong> ： 这其实就是一代理类。代理类主要做的事情很简单，就是把你调用方法、类、方法参数等信息传递到服务端。</li>\n<li><strong>网络传输</strong> ： 网络传输就是你要把你调用的方法的信息比如说参数啊这些东西传输到服务端，然后服务端执行完之后再把返回结果通过网络传输给你传输回来。网络传输的实现方式有很多种比如最近基本的 Socket或者性能以及封装更加优秀的 Netty（推荐）。</li>\n<li><strong>服务端 Stub（桩）</strong> ：这个桩就不是代理类了。我觉得理解为桩实际不太好，大家注意一下就好。这里的服务端 Stub 实际指的就是接收到客户端执行方法的请求后，去执行对应的方法然后返回结果给客户端的类。</li>\n<li><strong>服务端（服务提供端）</strong> ：提供远程方法的一端。</li>\n</ol>\n<p>具体原理图如下，后面我会串起来将整个RPC的过程给大家说一下。</p>\n<p><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-6/37345851.jpg\" alt=\"RPC原理图\"></p>\n<ol>\n<li>服务消费端（client）以本地调用的方式调用远程服务；</li>\n<li>客户端 Stub（client stub） 接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体（序列化）：<code>RpcRequest</code>；</li>\n<li>客户端 Stub（client stub） 找到远程服务的地址，并将消息发送到服务提供端；</li>\n<li>服务端 Stub（桩）收到消息将消息反序列化为Java对象: <code>RpcRequest</code>；</li>\n<li>服务端 Stub（桩）根据<code>RpcRequest</code>中的类、方法、方法参数等信息调用本地的方法；</li>\n<li>服务端 Stub（桩）得到方法执行结果并将组装成能够进行网络传输的消息体：<code>RpcResponse</code>（序列化）发送至消费方；</li>\n<li>客户端 Stub（client stub）接收到消息并将消息反序列化为Java对象:<code>RpcResponse</code> ，这样也就得到了最终结果。over!</li>\n</ol>\n<p>相信小伙伴们看完上面的讲解之后，已经了解了 RPC 的原理。</p>\n<p>虽然篇幅不多，但是基本把 RPC 框架的核心原理讲清楚了！另外，对于上面的技术细节，我会在后面的章节介绍到。</p>\n<p><strong>最后，对于 RPC 的原理，希望小伙伴不单单要理解，还要能够自己画出来并且能够给别人讲出来。因为，在面试中这个问题在面试官问到 RPC 相关内容的时候基本都会碰到。</strong></p>\n<h2> 有哪些常见的 RPC 框架？</h2>\n<p>我们这里说的 RPC 框架指的是可以让客户端直接调用服务端方法，就像调用本地方法一样简单的框架，比如我下面介绍的 Dubbo、Motan、gRPC这些。  如果需要和 HTTP 协议打交道，解析和封装 HTTP 请求和响应。这类框架并不能算是“RPC 框架”，比如Feign。</p>\n<h3> Dubbo</h3>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/distributed-system/rpc/image-20220716111053081.png\" alt=\"\"></p>\n<p>Apache Dubbo 是一款微服务框架，为大规模微服务实践提供高性能 RPC 通信、流量治理、可观测性等解决方案，\n涵盖 Java、Golang 等多种语言 SDK 实现。</p>\n<p>Dubbo 提供了从服务定义、服务发现、服务通信到流量管控等几乎所有的服务治理能力，支持 Triple 协议（基于 HTTP/2 之上定义的下一代 RPC 通信协议）、应用级服务发现、Dubbo Mesh （Dubbo3 赋予了很多云原生友好的新特性）等特性。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/distributed-system/rpc/image-20220716111545343.png\" alt=\"\"></p>\n<p>Dubbo 是由阿里开源，后来加入了 Apache 。正是由于 Dubbo 的出现，才使得越来越多的公司开始使用以及接受分布式架构。</p>\n<p>Dubbo 算的是比较优秀的国产开源项目了，它的源码也是非常值得学习和阅读的！</p>\n<ul>\n<li>Github ：<a href=\"https://github.com/apache/incubator-dubbo\" title=\"https://github.com/apache/incubator-dubbo\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/apache/incubator-dubbo</a></li>\n<li>官网：https://dubbo.apache.org/zh/</li>\n</ul>\n<h3> Motan</h3>\n<p>Motan 是新浪微博开源的一款 RPC 框架，据说在新浪微博正支撑着千亿次调用。不过笔者倒是很少看到有公司使用，而且网上的资料也比较少。</p>\n<p>很多人喜欢拿 Motan 和 Dubbo 作比较，毕竟都是国内大公司开源的。笔者在查阅了很多资料，以及简单查看了其源码之后发现：<strong>Motan 更像是一个精简版的 Dubbo，可能是借鉴了 Dubbo 的思想，Motan 的设计更加精简，功能更加纯粹。</strong></p>\n<p>不过，我不推荐你在实际项目中使用 Motan。如果你要是公司实际使用的话，还是推荐 Dubbo ，其社区活跃度以及生态都要好很多。</p>\n<ul>\n<li>从 Motan 看 RPC 框架设计：<a href=\"http://kriszhang.com/motan-rpc-impl/\" title=\"http://kriszhang.com/motan-rpc-impl/\" target=\"_blank\" rel=\"noopener noreferrer\">http://kriszhang.com/motan-rpc-impl/</a></li>\n<li>Motan 中文文档：<a href=\"https://github.com/weibocom/motan/wiki/zh_overview\" title=\"https://github.com/weibocom/motan/wiki/zh_overview\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/weibocom/motan/wiki/zh_overview</a></li>\n</ul>\n<h3> gRPC</h3>\n<p><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2020-8/2843b10d-0c2f-4b7e-9c3e-ea4466792a8b.png\" alt=\"\"></p>\n<p>gRPC 是 Google 开源的一个高性能、通用的开源 RPC 框架。其由主要面向移动应用开发并基于 HTTP/2 协议标准而设计（支持双向流、消息头压缩等功能，更加节省带宽），基于 ProtoBuf 序列化协议开发，并且支持众多开发语言。</p>\n<p><strong>何谓 ProtoBuf？</strong> <a href=\"https://github.com/protocolbuffers/protobuf\" target=\"_blank\" rel=\"noopener noreferrer\">ProtoBuf（ Protocol Buffer）</a> 是一种更加灵活、高效的数据格式，可用于通讯协议、数据存储等领域，基本支持所有主流编程语言且与平台无关。不过，通过 ProtoBuf 定义接口和数据类型还挺繁琐的，这是一个小问题。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/distributed-system/rpc/image-20220716104304033.png\" alt=\"\"></p>\n<p>不得不说，gRPC 的通信层的设计还是非常优秀的，<a href=\"https://dubbogo.github.io/\" target=\"_blank\" rel=\"noopener noreferrer\">Dubbo-go 3.0</a>  的通信层改进主要借鉴了 gRPC。</p>\n<p>不过，gRPC 的设计导致其几乎没有服务治理能力。如果你想要解决这个问题的话，就需要依赖其他组件比如腾讯的 PolarisMesh（北极星）了。</p>\n<ul>\n<li>Github：<a href=\"https://github.com/grpc/grpc\" title=\"https://github.com/grpc/grpc\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/grpc/grpc</a></li>\n<li>官网：<a href=\"https://grpc.io/\" title=\"https://grpc.io/\" target=\"_blank\" rel=\"noopener noreferrer\">https://grpc.io/</a></li>\n</ul>\n<h3> Thrift</h3>\n<p>Apache Thrift 是 Facebook 开源的跨语言的 RPC 通信框架，目前已经捐献给 Apache 基金会管理，由于其跨语言特性和出色的性能，在很多互联网公司得到应用，有能力的公司甚至会基于 thrift 研发一套分布式服务框架，增加诸如服务注册、服务发现等功能。</p>\n<p><code>Thrift</code>支持多种不同的<strong>编程语言</strong>，包括<code>C++</code>、<code>Java</code>、<code>Python</code>、<code>PHP</code>、<code>Ruby</code>等（相比于 gRPC 支持的语言更多 ）。</p>\n<ul>\n<li>官网：<a href=\"https://thrift.apache.org/\" title=\"https://thrift.apache.org/\" target=\"_blank\" rel=\"noopener noreferrer\">https://thrift.apache.org/</a></li>\n<li>Thrift 简单介绍：<a href=\"https://www.jianshu.com/p/8f25d057a5a9\" title=\"https://www.jianshu.com/p/8f25d057a5a9\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.jianshu.com/p/8f25d057a5a9</a></li>\n</ul>\n<h3> 总结</h3>\n<p>gRPC 和 Thrift 虽然支持跨语言的 RPC 调用，但是它们只提供了最基本的 RPC 框架功能，缺乏一系列配套的服务化组件和服务治理功能的支撑。</p>\n<p>Dubbo 不论是从功能完善程度、生态系统还是社区活跃度来说都是最优秀的。而且，Dubbo在国内有很多成功的案例比如当当网、滴滴等等，是一款经得起生产考验的成熟稳定的 RPC 框架。最重要的是你还能找到非常多的 Dubbo 参考资料，学习成本相对也较低。</p>\n<p>下图展示了 Dubbo 的生态系统。</p>\n<p><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2020-8/eee98ff2-8e06-4628-a42b-d30ffcd2831e.png\" alt=\"\"></p>\n<p>Dubbo 也是 Spring Cloud Alibaba 里面的一个组件。</p>\n<p><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2020-8/0d195dae-72bc-4956-8451-3eaf6dd11cbd.png\" alt=\"\"></p>\n<p>但是，Dubbo 和 Motan 主要是给 Java 语言使用。虽然，Dubbo 和 Motan 目前也能兼容部分语言，但是不太推荐。如果需要跨多种语言调用的话，可以考虑使用 gRPC。</p>\n<p>综上，如果是 Java 后端技术栈，并且你在纠结选择哪一种 RPC 框架的话，我推荐你考虑一下 Dubbo。</p>\n<h2> 如何设计并实现一个 RPC 框架？</h2>\n<p><strong>《手写 RPC 框架》</strong> 是我的<a href=\"https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html\" target=\"_blank\" rel=\"noopener noreferrer\">知识星球</a>的一个内部小册，我写了 12 篇文章来讲解如何从零开始基于 Netty+Kyro+Zookeeper 实现一个简易的 RPC 框架。</p>\n<p>麻雀虽小五脏俱全，项目代码注释详细，结构清晰，并且集成了 Check Style 规范代码结构，非常适合阅读和学习。</p>\n<p><strong>内容概览</strong> ：</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/image-20220308100605485.png\" alt=\"\"></p>\n<h2> 既然有了 HTTP 协议，为什么还要有 RPC ？</h2>\n<p><a href=\"/distributed-system/rpc/http&amp;rpc.html\" target=\"blank\">HTTP 和 RPC 详细对比</a> 。</p>\n",
      "image": "https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-6/37345851.jpg",
      "date_published": "2022-07-16T03:43:09.000Z",
      "date_modified": "2023-03-03T12:41:00.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "分布式"
      ]
    },
    {
      "title": "我的个人校招经历和经验",
      "url": "https://javaguide.cn/high-quality-technical-articles/interview/my-personal-experience-in-2021.html",
      "id": "https://javaguide.cn/high-quality-technical-articles/interview/my-personal-experience-in-2021.html",
      "summary": "推荐语 ：这篇文章的作者校招最终去了飞书做开发。在这篇文章中，他分享了自己的校招经历以及个人经验。 原文地址 ： https://www.ihewro.com/archives/1217/ 基本情况 我是 C++主要是后台开发的方向。 2021 春招入职字节飞书客户端，入职字节之前拿到了百度 offer（音视频直播部分） 以及腾讯 PCG （微视、后台开发）的 HR 面试通过（还没有收到录用意向书）。",
      "content_html": "<blockquote>\n<p><strong>推荐语</strong> ：这篇文章的作者校招最终去了飞书做开发。在这篇文章中，他分享了自己的校招经历以及个人经验。</p>\n<br>\n<p><strong>原文地址</strong> ： https://www.ihewro.com/archives/1217/</p>\n</blockquote>\n<h2> 基本情况</h2>\n<p>我是 C++主要是后台开发的方向。</p>\n<p>2021 春招入职字节飞书客户端，入职字节之前拿到了百度 offer（音视频直播部分） 以及腾讯 PCG （微视、后台开发）的 HR 面试通过（还没有收到录用意向书）。</p>\n<h2> 不顺利的春招过程</h2>\n<h3> 春招实习对我来说不太顺利</h3>\n<p>实验室在 1 月份元旦的那天正式可以放假回家，但回家仍然继续“远程工作”，工作并没有减少，每天日复一日的测试，调试我们开发的“流媒体会议系统”。</p>\n<p>在 1 月的倒数第三天，我们开了“年终总结”线上会议。至此，作为研二基本上与实验室的工作开始告别。也正式开始了春招复习的阶段。</p>\n<p>2 月前已经间歇性的开始准备，无非就是在 LeetCode 上面刷刷题目，一天刷不了几道，后面甚至象征性的刷一下每日一题。对我的算法刷题帮助很少。</p>\n<p>2 月份开始，2 月初的时候，LeetCode 才刷了大概 40 多道题目，挤出了几周时间更新了 handsome 主题的 8.x 版本，这又是一个繁忙的几周。直到春节的当天正式发布，春节过后又开始陆陆续续用一些时间修复 bug，发布修复版本。2 月份这样悄悄溜走。</p>\n<h3> 找实习的过程</h3>\n<p><strong>2021-3 月初</strong></p>\n<p>3 月 初的时候，投了阿里提前批，没想到阿里 3 月 4 号提前批就结束了，那一天约的一面的电话面也被取消了。紧接了开学实验室开会同步进度的时候，发现大家都一面/二面/三面的进度，而我还没有投递的进度。</p>\n<p><strong>2021-3-8</strong></p>\n<p>投递了字节飞书</p>\n<p><strong>2021-4 月初</strong></p>\n<p>字节第一次一面，腾讯第一次一面</p>\n<p><strong>2021-4 中旬</strong></p>\n<p>美团一、二面，腾讯第二次一面和二面，百度三轮面试，通过了。</p>\n<p><strong>2021-4 底</strong></p>\n<p>腾讯第三次一面和字节第二次一面</p>\n<p><strong>2021-5 月初</strong></p>\n<p>腾讯第三次二面和字节第二次二面，后面这两个都通过了</p>\n<h4> 阿里</h4>\n<p>第一次投了钉钉，没想到因为行测做的不好，在简历筛选给拒绝了。</p>\n<p>第二次阿里妈妈的后端面试，一面电话面试，我感觉面的还可以，最后题目也做出来了。最后反问阶段问对我的面试有什么建议，面试官说投阿里最好还是 Java 的… 然后电话结束后就给我拒了…</p>\n<p>当时真的心态有点崩，问了这个晚上 7 点半的面试，一直看书晚上都没吃…</p>\n<p>所以春招和阿里就无缘了。</p>\n<h4> 美团</h4>\n<p>美团一面的面试官真的人很好。也很轻松，因为他们是 Java 岗位，也没问 c++知识，聊了一些基础知识，后面半个小时就是聊非技术问题，比如最喜欢网络上的某位程序员是谁，如何写出优雅的代码，推荐的技术类的书籍之类的。当时回答王垠是比较喜欢的程序员，面试官笑了说他也很喜欢。面试的氛围感觉很好。</p>\n<p>二面的时候全程就问简历上的一个项目，问了大概 90 分钟，感觉他从一开始就有点不太想要我的感觉，很大原因我觉的是我是 c++，转 Java 可能成本还是有一些的。最后问 HR 说结果待定，几天后通知被拒了。</p>\n<h4> 百度</h4>\n<p>百度一共三轮面试，在一个下午一起进行，真的很刺激。一面就是很基础的一些 c++问题，写了一个题目说一下思路没让运行（真的要运行还不一定能运行起来:)）</p>\n<p>二面也是基础，第一个题目合并两个有序数组，第二个题目写归并排序，写的结果不对，又给我换了一个题目，树的 BFS。二面面试官最后问我对今天面试觉得怎么样，我说虽然中间有一个道题目结果不对，但是思路是对的，可能某个小地方写的有问题，但总体的应该还是可以的。二面就给我通过了。</p>\n<p>三面问的技术问题比较少，30 多分钟，也没写题目，问了一些基本情况和基础知识。最后问部门做的什么内容。面试官说后面 hr 会联系我告诉我内容。</p>\n<h4> 字节飞书</h4>\n<p>第一次一面就凉了，原因应该是笔试题目结果不对…</p>\n<p>第二次一面在 4 月底了，很顺利。二面在五一劳动节后，面试官还让学姐告诉我让我多看看智能指针，面试的时候让我手写 shared_ptr，我之前看了一些实现，但是没有自己写过，导致代码考虑的不够完善，leader 就一直提醒我要怎么改怎么改。</p>\n<p>本来我以为凉了，在 5 月中旬的时候都准备去百度入职了，给我通知说过了，就这样决定去了字节。</p>\n<h4> 感悟</h4>\n<p>这么多次面试中，让我感悟最深的是面试中的考察题目真的很重要，因为我在基础知识上面也不突出，再加上如果算法题（一般 1 道或者 2 道）如果没做出来，基本就凉了。而面试之前的笔试考试反而没那么重要，也没那么难。基本 4 题写出来 1~2 道题目就有发起面试的机会了。难度也基本就是 LeetCode top 100 上面的那些算法。</p>\n<p>面试中做题，我很容易紧张，头脑就容易一片空白，稍不注意，写错个符号，或者链表赋值错了，很难看出来问题，导出最终结果不对。</p>\n<h2> 入职字节实习</h2>\n<p>入职字节之前我本来觉得这个岗位可能是我面试的最适合我的了，因为我主 c++，而且飞书用 c++应该挺深的。来之后就觉得我可能不太喜欢做客户端相关，感觉好复杂…也许服务端好一些，现在我仍然不能确定。</p>\n<p>字节的实习福利在这些公司中应该算是比较好的，小问题是工位比较窄，还是工作强度比其他的互联网公司大一些。字节食堂免费而且挺不错的。字节办公大厦很多，我所在的办公地点比较小。</p>\n<p>目前，需要放轻松，仓库代码慢慢看呗，mentor 也让我不急，准备有问题就多问问，不能憋着，浪费时间。拿到转正 offer 后，秋招还是想多试试外企或者国企。强度太大的工作目前很难适应。</p>\n<p>希望过段时间可以分享一下我的感受，以及能够更加适应目前的工作内容。</p>\n<h2> 求职经验分享</h2>\n<h3> 一些概念</h3>\n<h4> 日常实习与正式（暑期）实习有什么区别</h4>\n<ul>\n<li><strong>日常实习如果一个组比较缺人，就很可能一年四季都招实习生，就会有日常实习的机会</strong>，只要是在校学生都可以去面试。而正式实习开始时间有一个范围比较固定，比如每年的 3-6 月，也就是暑期实习。</li>\n<li>日常实习相对要好进一些，但是有的日常实习没有转正名额，这个要先确认一下。</li>\n<li><strong>字节的日常实习和正式实习在转正没什么区别，都是一起申请转正的。</strong></li>\n</ul>\n<h4> 正式实习拿到 offer 之后什么时候可以去实习</h4>\n<p>暑期实习拿到 offer 后就<strong>可以立即实习</strong>（一般需要走个流程 1 周左右的样子），<strong>也可以选择晚一点去实习</strong>，时间可以自己去把握，有的公司可以在系统上选择去实习的时间，有的是直接和 hr 沟通一下就可以。</p>\n<h4> 提前批和正式批的区别</h4>\n<p>以找实习为例：</p>\n<ul>\n<li>先提前批，再正式批，提前批一般是小组直接招人<strong>不进系统</strong>，<strong>没有笔试</strong>，<strong>流程相对走的快</strong>，一般一面过了，很快就是二面。</li>\n<li>正式批面试都会有面评，如果上一次失败的面试评价会影响下一次面试，所以还是谨慎一点好</li>\n</ul>\n<h4> 实习 offer 和正式 offer 区别</h4>\n<p>简单来说，实习 offer 只是给你一个实习的机会，如果在实习期间干的不错就可以转正，获得正式 offer。</p>\n<p>签署正式 offer 之后并不是意味着马上去上班，因为我们是校招生，拿到正式 offer 之后，可以继续实习（工资会是正式工资的百分比），也可以请假一段时间等真正毕业的时候再去正式工作。</p>\n<h3> 时间节点</h3>\n<blockquote>\n<p>尽早把简历弄出来，最好就是最近一段时间，因为大家对实验室项目现在还很熟悉，现在写起来不是很难，再过几个月写简历就比较痛苦了。</p>\n</blockquote>\n<p>以去年为例：</p>\n<ul>\n<li>2 月份中旬的时候阿里提前批开始（基本上只有阿里这个时候开了提前批），3 月 8 号阿里提前批结束。腾讯提前批是 3 月多开始的，4 月 15 号结束</li>\n<li>3-5 月拿到实习 offer，最好在 4 月份可以拿到比较想去的实习 offer。</li>\n<li>4-8 月份实习，7 月初秋招提前批，7 月底或者 8 月初就是秋招正式批，9 月底秋招就少了挺多，但是只是相对来说，还是有机会，</li>\n<li>10 月底秋招基本结束，后面还会有秋招补录</li>\n</ul>\n<hr>\n<ul>\n<li><strong>怎么找实习机会</strong>，个人觉得可以找认识的人内推比较好，内推好处除了可以帮看进度，一般可以直推到组，这样可以排除一些坑的组。提前知道这个组干嘛的。</li>\n<li><strong>实习挺重要，最好是实习的时候就找到一个想去的公司，秋招会轻松很多</strong>，因为实习转正基本没什么问题，其次实习转正的 offer 一般要比秋招的好（当然如果秋招表现好也是可以拿到很好的 offer）身边不少人正式 offer 都是实习转正的。</li>\n<li><strong>控制好实习的时间</strong>，因为边实习边准备秋招挺累的，一般实习的时候工作压力也挺大，没什么时间刷题。</li>\n</ul>\n<h3> 面试准备</h3>\n<h4> 项目经历</h4>\n<p>我觉得我们实验室项目是没问题的，重要是要讲好。</p>\n<ul>\n<li><strong>项目介绍</strong></li>\n</ul>\n<p>首先可能让你介绍一下这个项目是什么东西，以及<strong>为什么要去做这个项目</strong>。</p>\n<ul>\n<li><strong>项目的结果</strong></li>\n</ul>\n<p>然后可能会问这个项目的一些数据上最终结果，比如会议系统能够同时多少人使用，或者量化的体验，比如流畅度，或者是一些其他的一些优势。</p>\n<ul>\n<li><strong>项目中的困难</strong></li>\n</ul>\n<p>最后都会问过程中有没有遇到什么困难、挑战的，以及怎么解决的。这个过程中主要考察这个项目的技术点是什么。</p>\n<blockquote>\n<p>困难是指什么，个人觉得主要是花了好几天才解决的问题就是困难。</p>\n</blockquote>\n<p>举两个例子：</p>\n<p><strong>第一个例子是排查 bug 方面</strong>，比如有一个内存泄露的问题花了一周才排查出来，那就算一个困难，那么解决这个困难的过程就是<strong>如何去定位这个问题过程</strong>，比如我们先根据错误搜索相关资料，肯定没那么容易就直接找到原因，而是我们会在这些资料中找到一些<strong>关键词</strong>，比如一些工具，那么我们对这个工具的使用就是解决问题的一个过程。</p>\n<p><strong>第二个例子是需求方案的设计</strong>，比如某个需求完成，我们实现这个需求可能有多个可行的设计方案。解决这个困难的过程就是<strong>我们对最终选择这个方法的原因，以及其他的设计方案的优缺点的思考</strong>。</p>\n<p><a href=\"https://blog.csdn.net/u012423865/article/details/79452713\" target=\"_blank\" rel=\"noopener noreferrer\">面试中被问到：你在工作中碰到的最困难的问题是什么？<em>发现问题，解决问题.-CSDN 博客</em>面试中问到工作中遇到困难是怎么解决的</a></p>\n<p>有人说我解决方法就是通过百度搜索，但实际上细节也是先搜索某个错误或者问题，但是肯定不可能一下子就搜到了代码答案，而是找到一个答案中有某个关键词，接着我们继续找关键词获取其他的信息。</p>\n<h4> 笔试</h4>\n<p>找实习的笔试我觉得不会太难，一般如果是 4 道题目，做出来 1-2 道题目差不多就有面试的机会了。</p>\n<p>刷题老生常谈的问题，LeetCode Top100。一开始刷题很痛苦，等刷了 40 道题目的时候就有点感觉的，建议从链表、二叉树开始刷，数组类型题目有很多不能通用的技巧。</p>\n<ul>\n<li>::一定要用白版进行训练::，一定要用白板，不仅仅是为了面试记住 API，更重要的是用白板熟练后，写代码会更熟练而且思路更独立和没有依赖。</li>\n<li>算法题重中之重，终点不是困难题目，而是简单，中等，常见，高频的题目要熟能生巧，滚瓜烂熟。</li>\n<li>面试的笔试过程中，如果出现了问题，<strong>一定要第一时间申请使用本地 IDE 进行调试</strong>，否则可能很长时间找不到问题，浪费了机会。</li>\n</ul>\n<h4> 面试</h4>\n<p>面试一般 1 场 1 个小时候分为两个部分，前半部分会问一些基础知识或者项目经历，后半部分做题。</p>\n<p><strong>基础知识复习一开始没必要系统的去复习，首先是确保高频问题必会</strong>，比如计算机网络、操作系统那几个必问的问题，可以多看看面经就能找到常问题的问题，对于比较偏问题就算没答上来也不是决定性的影响。</p>\n<ul>\n<li><strong>多看面经!!!!!!</strong> 不要一直埋头自己学，要看别人问过了哪些常问的问题。</li>\n<li>对于实习工作，<strong>看的知识点常见的问题一定要全!!!!!</strong>，不是那么精问题不大，一定要全，一定要全！！！！</li>\n<li><strong>对于自己不会的，尽量多的说！！！！</strong> 实在不行，就往别的地方说！！！总之是引导面试官往自己会的地方上说。</li>\n<li>面试中的笔试和前面的笔试风格不同，面试笔试题目不太难，但是考察是冷静思考，代码优雅，没有 bug，先思考清楚！！！在写！！！</li>\n<li>在描述项目的难点的时候，不要去聊文档调研是难点，回答这部分问题更应该是技术上的难点，最后通过了什么技术解决了这个问题，这部分技术可以让面试官来更多提问以便知道自己的技术能力。</li>\n</ul>\n",
      "date_published": "2022-07-15T03:53:57.000Z",
      "date_modified": "2023-02-23T08:04:35.000Z",
      "authors": [
        {
          "name": "月色真美"
        }
      ],
      "tags": [
        "技术文章精选集"
      ]
    },
    {
      "title": "HTTP 常见状态码总结（应用层）",
      "url": "https://javaguide.cn/cs-basics/network/http-status-codes.html",
      "id": "https://javaguide.cn/cs-basics/network/http-status-codes.html",
      "summary": "HTTP 状态码用于描述 HTTP 请求的结果，比如2xx 就代表请求被成功处理。 1xx Informational（信息性状态码） 相比于其他类别状态码来说，1xx 你平时你大概率不会碰到，所以这里直接跳过。 2xx Success（成功状态码） 200 OK ：请求被成功处理。比如我们发送一个查询用户数据的HTTP 请求到服务端，服务端正确返回了用户数据。这个是我们平时最常见的一个 HTTP 状态码。 201 Created ：请求被成功处理并且在服务端创建了一个新的资源。比如我们通过 POST 请求创建一个新的用户。 202 Accepted ：服务端已经接收到了请求，但是还未处理。 204 No Content ： 服务端已经成功处理了请求，但是没有返回任何内容。",
      "content_html": "<p>HTTP 状态码用于描述 HTTP 请求的结果，比如2xx 就代表请求被成功处理。</p>\n<p><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/状态码.png\" alt=\"状态码\"></p>\n<h3> 1xx Informational（信息性状态码）</h3>\n<p>相比于其他类别状态码来说，1xx 你平时你大概率不会碰到，所以这里直接跳过。</p>\n<h3> 2xx Success（成功状态码）</h3>\n<ul>\n<li><strong>200 OK</strong> ：请求被成功处理。比如我们发送一个查询用户数据的HTTP 请求到服务端，服务端正确返回了用户数据。这个是我们平时最常见的一个 HTTP 状态码。</li>\n<li><strong>201 Created</strong> ：请求被成功处理并且在服务端创建了一个新的资源。比如我们通过 POST 请求创建一个新的用户。</li>\n<li><strong>202 Accepted</strong> ：服务端已经接收到了请求，但是还未处理。</li>\n<li><strong>204 No Content</strong> ： 服务端已经成功处理了请求，但是没有返回任何内容。</li>\n</ul>\n<p>这里格外提一下 204 状态码，平时学习/工作中见到的次数并不多。</p>\n<p><a href=\"https://tools.ietf.org/html/rfc2616#section-10.2.5\" target=\"_blank\" rel=\"noopener noreferrer\">HTTP RFC 2616对204状态码的描述</a>如下：</p>\n<blockquote>\n<p>The server has fulfilled the request but does not need to return an\nentity-body, and might want to return updated metainformation. The\nresponse MAY include new or updated metainformation in the form of\nentity-headers, which if present SHOULD be associated with the\nrequested variant.</p>\n<p>If the client is a user agent, it SHOULD NOT change its document view\nfrom that which caused the request to be sent. This response is\nprimarily intended to allow input for actions to take place without\ncausing a change to the user agent's active document view, although\nany new or updated metainformation SHOULD be applied to the document\ncurrently in the user agent's active view.</p>\n<p>The 204 response MUST NOT include a message-body, and thus is always\nterminated by the first empty line after the header fields.</p>\n</blockquote>\n<p>简单来说，204状态码描述的是我们向服务端发送 HTTP 请求之后，只关注处理结果是否成功的场景。也就是说我们需要的就是一个结果：true/false。</p>\n<p>举个例子：你要追一个女孩子，你问女孩子：“我能追你吗？”，女孩子回答：“好！”。我们把这个女孩子当做是服务端就很好理解 204 状态码了。</p>\n<h3> 3xx Redirection（重定向状态码）</h3>\n<ul>\n<li><strong>301 Moved Permanently</strong> ： 资源被永久重定向了。比如你的网站的网址更换了。</li>\n<li><strong>302 Found</strong> ：资源被临时重定向了。比如你的网站的某些资源被暂时转移到另外一个网址。</li>\n</ul>\n<h3> 4xx Client Error（客户端错误状态码）</h3>\n<ul>\n<li><strong>400 Bad Request</strong> ： 发送的HTTP请求存在问题。比如请求参数不合法、请求方法错误。</li>\n<li><strong>401 Unauthorized</strong> ： 未认证却请求需要认证之后才能访问的资源。</li>\n<li><strong>403 Forbidden</strong> ：直接拒绝HTTP请求，不处理。一般用来针对非法请求。</li>\n<li><strong>404 Not Found</strong> ： 你请求的资源未在服务端找到。比如你请求某个用户的信息，服务端并没有找到指定的用户。</li>\n<li><strong>409 Conflict</strong> ： 表示请求的资源与服务端当前的状态存在冲突，请求无法被处理。</li>\n</ul>\n<h3> 5xx Server Error（服务端错误状态码）</h3>\n<ul>\n<li><strong>500 Internal Server Error</strong> ： 服务端出问题了（通常是服务端出Bug了）。比如你服务端处理请求的时候突然抛出异常，但是异常并未在服务端被正确处理。</li>\n<li><strong>502 Bad Gateway</strong> ：我们的网关将请求转发到服务端，但是服务端返回的却是一个错误的响应。</li>\n</ul>\n<h3> 参考</h3>\n<ul>\n<li>https://www.restapitutorial.com/httpstatuscodes.html</li>\n<li>https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status</li>\n<li>https://en.wikipedia.org/wiki/List_of_HTTP_status_codes</li>\n<li>https://segmentfault.com/a/1190000018264501</li>\n</ul>\n",
      "image": "https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/%E7%8A%B6%E6%80%81%E7%A0%81.png",
      "date_published": "2022-07-08T00:49:36.000Z",
      "date_modified": "2022-09-08T03:09:04.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "计算机基础"
      ]
    },
    {
      "title": "华为 OD 275 天后，我进了腾讯！",
      "url": "https://javaguide.cn/high-quality-technical-articles/personal-experience/huawei-od-275-days.html",
      "id": "https://javaguide.cn/high-quality-technical-articles/personal-experience/huawei-od-275-days.html",
      "summary": "推荐语 ：一位朋友的华为 OD 工作经历以及腾讯面试经历分享，内容很不错。 原文地址 ：https://www.cnblogs.com/shoufeng/p/14322931.html 时间线 18 年 7 月，毕业于某不知名 985 计科专业； 毕业前，在某马的 JavaEE（后台开发）培训了 6 个月； 第一份工作（18-07 ~ 19-12）接触了大数据，感觉大数据更有前景； 19 年 12 月，入职中国平安产险（去到才发现是做后台开发 😢）； 20 年 3 月，从平安辞职，跳去华为 OD 做大数据基础平台； 2021 年 1 月，入职鹅厂",
      "content_html": "<blockquote>\n<p><strong>推荐语</strong> ：一位朋友的华为 OD 工作经历以及腾讯面试经历分享，内容很不错。</p>\n<br>\n<p><strong>原文地址</strong> ：https://www.cnblogs.com/shoufeng/p/14322931.html</p>\n</blockquote>\n<h2> 时间线</h2>\n<ul>\n<li>18 年 7 月，毕业于某不知名 985 计科专业；</li>\n<li>毕业前，在某马的 JavaEE（后台开发）培训了 6 个月；</li>\n<li>第一份工作（18-07 ~ 19-12）接触了大数据，感觉大数据更有前景；</li>\n<li>19 年 12 月，入职中国平安产险（去到才发现是做后台开发 😢）；</li>\n<li>20 年 3 月，从平安辞职，跳去华为 OD 做大数据基础平台；</li>\n<li>2021 年 1 月，入职鹅厂</li>\n</ul>\n<h2> 华为 OD 工作经历总结</h2>\n<h3> 为什么会去华为 OD</h3>\n<p>在平安产险（正式员工）只待了 3 个月，就跳去华为 OD，朋友们都是很不理解的 —— 好好的正编不做，去什么外包啊 😂</p>\n<p>但那个时候，我铁了心要去做大数据，不想和没完没了的 CRUD 打交道。刚好面试通过的岗位是华为 Cloud BU 的大数据部门，做的是国内政企中使用率绝对领先的大数据平台……\n平台和工作内容都不错，这么好的机会，说啥也要去啊 💪</p>\n<blockquote>\n<p>其实有想过在平安内部转岗到大数据的，但是不满足“入职一年以上”这个要求；\n「等待就是浪费生命」，在转正流程还没批下来的时候，赶紧溜了 😂</p>\n</blockquote>\n<h3> 华为 OD 的工作内容</h3>\n<p><strong>带着无限的期待，火急火燎地去华为报到了。</strong></p>\n<p>和招聘的 HR 说的一样，和华为自有员工一起办公，工作内容和他们完全一样：</p>\n<blockquote>\n<p>主管根据你的能力水平分配工作，逐渐增加难度，能者多劳；\n试用期 6 个月，有导师带你，一般都是高你 2 个 Level 的华为自有员工，基本都是部门大牛。</p>\n</blockquote>\n<p>所以，<strong>不存在外包做的都是基础的、流程性的、没有技术含量的工作</strong> —— 顾虑这个的完全不用担心，你只需要打听清楚要去的部门/小组具体做什么，能接受就再考虑其他的。</p>\n<p>感触很深的一点是：华为是有着近 20 万员工的巨头，内部有很多流程和制度。好处是：能接触到大公司的产品从开发、测试，到发布、运维等一系列的流程，比如提交代码的时候，会由经验资深、经过内部认证的大牛给你 Review，在拉会检视的时候，可以学习他们考虑问题的角度，还有对整个产品全局的把控。</p>\n<p>但同时，个人觉得这也有不好的地方：流程繁琐会导致工作效率变低，比如改动几行代码，就需要跑完整个 CI（有些耗时比较久），还要提供自验和 VT 的报告。</p>\n<h3> OD 与华为自有员工的对比</h3>\n<p>什么是 OD？Outstanding Dispatcher，人员派遣，官方强调说，OD 和常说的“外包”是不一样的。</p>\n<p>说说我了解的 OD：</p>\n<ul>\n<li>参考华为的薪酬框架，OD 人员的薪酬体系有一定的市场竞争力 —— 的确是这样，貌似会稍微倒挂同级别的自有员工；</li>\n<li>可以参与华为主力产品的研发 —— 是的，这也是和某软等“供应商”的兄弟们不一样的地方；</li>\n<li>外网权限也可以申请打开（对，就是梯子），部门内部的大多数文档都是可以看的；</li>\n<li>工号是单独的 300 号段，其他供应商员工的工号是 8 开头，或着 WX 开头；</li>\n<li>工卡带是红色的，和自有员工一样，但是工卡内容不同，OD 的明确标注：办公区通行证，并有德科公司的备注：</li>\n</ul>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/high-quality-technical-articles/personal-experience/1438655-20210124231550508-1315720640.jpg\" alt=\"\"></p>\n<p>还听到一些内部的说法：</p>\n<ul>\n<li>没股票，没 TUP，年终奖少，只有工资可能比我司高一点点而已；</li>\n<li>不能借针对 HW 的消费贷，也不能买公司提供的优惠保险…</li>\n</ul>\n<h3> 那，到底要不要去华为 OD？</h3>\n<p>我想，搜到我这篇文字的你，心里其实是有偏向的，只是缺最后一片雪花 ❄️，让自己下决心。</p>\n<p>作为过来人之一，我再提供一些参考吧 😃</p>\n<p>1）除了华为 OD，<strong>还有没有更好的选择？</strong> 综合考虑加班（996、有些是 9106 甚至更多）、薪资、工作内容，以及这份工作经历对你整个职业的加成等等因素；</p>\n<p>2）有看到一些内部的说法，比如：“奇怪 OD 这么棒，为啥大家不自愿转去 OD 啊？”；再比如：“OD 等同华为？这话都说的出口，既然都等同，为啥还要 OD？就是降成本嘛……”</p>\n<p>3）内心够强大吗？虽然没有人会说你是 OD，但总有一些事情会提醒你：<strong>你不是华为员工</strong>。比如：</p>\n<p>a) 内部发文啥的，还有心声平台的大部分内容，都是无权限看的：</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/high-quality-technical-articles/personal-experience/1438655-20210124225007848-1701355006.png\" alt=\"\"></p>\n<p>b) 你的考勤是在租赁人员管理系统里考核，绩效管理也是；</p>\n<p>c) 自有员工的工卡具有消费功能（包括刷夜宵），OD 的工卡不能消费，需要办个消费卡，而且夜宵只能通过手机软件领取（自有员工是用工卡领的）；</p>\n<p>d) 你的加班一定要提加班申请电子流换 Double 薪资，不然只能换调休，离职时没时间调休也换不来 Double —— 而华为员工即使自己主动离职，也是有 N+1，以及加班时间换成 Double 薪资的；</p>\n<h3> 网传的 OD 转华为正编，真的假的？</h3>\n<p>这个放到单独的一节，是因为它很重要，有很多纠结的同学在关注这个问题。</p>\n<p><strong>答案是：真的。</strong></p>\n<p>据各类非官方渠道（比如知乎上的一些分享），转华为自有是有条件的（https://www.zhihu.com/question/356592219/answer/1562692667）：</p>\n<p>1）入职时间：一年以上\n2）绩效要求：连续两次绩效 A\n3）认证要求：通过可信专业级认证\n4）其他条件：根据业务部门的人员需求及指标要求确定</p>\n<p>说说这些条件吧 😃</p>\n<p><strong>条件 2 连续两次绩效 A</strong></p>\n<p>上面链接里的说法：</p>\n<blockquote>\n<p>绩效 A 大约占整个部门的前 10%，连续两次 A 的意思就是一年里两次考评都排在部门前 10%，能做到这样的在华为属于火车头，这种难得的绩效会舍得分给一个租赁人员吗？</p>\n</blockquote>\n<p>OD 同学能拿到 A 吗？不知道，我入职晚，都没有经历一个完整的绩效考评。</p>\n<p>（20210605 更新下）一年多了，还留着的 OD 同学告知我：OD 是单独评绩效的，能拿到 A 的比例，大概是 1/5，对应的年终奖就是 4 个月；绩效是 B，年终奖就是 2 个月。</p>\n<p>在我看来，在试用期答辩时，能拿 A，接下来半年的绩效大概率也是拿 A 的。</p>\n<p>但总的来说，这种事既看实力，又看劳动态度（能不能拼命三郎疯狂加班），还要看运气（主管对你是不是认可）……</p>\n<p><strong>条件 3 通过可信专业级认证</strong></p>\n<p>可信专业级认证考试是啥？华为在推动技术人员的可信认证，算是一项安全合规的工作。\n专业级有哪些考试呢？共有四门：</p>\n<ul>\n<li>科目一：上级编程，对比力扣 2 道中等、1 道困难；</li>\n<li>科目二：编程知识与应用，考察基础的编程语言知识等；</li>\n<li>科目三：安全编程、质量、隐私，还有开发者测试等；</li>\n<li>科目四：重构知识，包括设计模式、代码重构等。</li>\n</ul>\n<p>上面这些，每一门单季度只能考一次（好像有些一年只能考 3 次），每个都要准备，少则 3 天，多则 1 星期，不准备，基本都过不了。\n我在 4 个月左右、还没转正的时候，就考过了专业级的科目二、三、四，只剩科目一大半年都没过（算法确实太菜了 😂\n但也有同事没准备，连着好几次都没通过。</p>\n<p><strong>条件 4 部门人员需求指标？</strong></p>\n<p>这个听起来都感觉很玄学。还是那句话，实力和运气到了，应该可以的！成功转正员工图镇楼：</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/high-quality-technical-articles/personal-experience/1438655-20210124231943817-1976130336.jpg\" alt=\"\"></p>\n<h3> 真的感谢 OD，也感谢华为</h3>\n<p>运气很好，在我换工作还不到 3 个月的时候，华为还收我。</p>\n<p>我遇到了很好的主管，起码在工作时间，感觉跟兄长一样指导、帮助我；</p>\n<p>分配给我的导师，是我工作以来认识到技术实力最厉害的人，定位问题思路清晰，编码实力强悍，全局思考问题、制定方案……</p>\n<p>小组、部门的同学都很 nice，9 个多月里，我基本每天都跟打了鸡血一样，现在想想，也不知道当时为什么会那么积极有干劲 😂</p>\n<p>从个人能力上来讲，我是进不去华为的（心里还是有点数的 😂）。正是有了 OD 这个渠道，才有机会切身感受华为的工作氛围，也学到了很多软技能：</p>\n<ul>\n<li>积极主动，勇于承担尝试，好工作要抢过来自己做；</li>\n<li>及时同步工作进展，包括已完成、待完成，存在的风险困难等内容，要让领导知道你的工作情况；</li>\n<li>勤于总结提炼输出，形成个人 DNA，利人利己；</li>\n<li>有不懂的可以随时找人问，脸皮要厚，虚心求教；</li>\n<li>不管多忙，所有的会议，不论大小，都要有会议纪要，邮件发给相关人……</li>\n</ul>\n<p>再次感谢，大家都加油，向很牛掰很牛掰前进 💪</p>\n<h2> 投简历，找面试官求虐</h2>\n<p>20年11月初的一天，在同事们讨论“某某被其他公司高薪挖去了，钱景无限”的消息。</p>\n<p>我忽然惊觉，自己来到华为半年多，除了熟悉内部的系统和流程，好像没有什么成长和进步？</p>\n<p>不禁反思：只有厉害的人才会被挖，现在这个状态的我，在市场上值几个钱？</p>\n<p>刚好想起了之前的一个同事在离职聚会上分享的经验：</p>\n<blockquote>\n<p>技术人不能闭门造车，要多交流，多看看外面的动态。</p>\n<p>如果感觉自己太安逸了，那就把简历挂出去，去了解其他公司用的是什么技术，他们更关注哪些痛点？面几次你就有方向了。</p>\n</blockquote>\n<p>这时候起了个念头：找面试官求虐，以此来鞭策自己，进而更好地制定学习方向。</p>\n<p>于是我重新下载了某聘软件，在首页推荐里投了几家公司。</p>\n<h2> 开始面试</h2>\n<p>11 月 10 号投的简历，当天就有 2 家预约了 11 号下午的线上面试，其中就有鹅厂 🐧</p>\n<p>好巧不巧，10 号晚上要双十一业务保障，一直到第二天凌晨 2 点半才下班。</p>\n<p>熬夜太伤身，还好能申请调休一天，也省去了找借口请假 🙊</p>\n<p>这段时间集中面了 3 家：</p>\n<blockquote>\n<p>第 1 个是广州的公司，11 号当晚就完成了 2 轮线上面试，开得有点低，就婉拒了；\n第 2 个就是本文的重点——鹅厂；\n第 3 个是做跨境电商的公司，一面就跪（恭喜它荣升为“在我有限的工作经历中，面试体验最差的 2 家公司之一”🙂️）</p>\n</blockquote>\n<h2> 鹅厂，去还是不去？</h2>\n<p>一直有一个大厂梦，奈何菜鸟一枚，之前试过好几次，都跪在技术面了。</p>\n<p>所以想了个曲线救国的方法：先在其他单位积累着，有机会了再争取大厂的机会 💪</p>\n<p>很幸运，也很猝不及防，这次竟然通过了鹅厂的所有面试。</p>\n<p>虽然已到年底，但是要是错过这么难得的机会，下次就不知道什么时候才能再通关了。</p>\n<p>所以，<strong>年后拿到年终再跳槽 vs 已到手的鹅厂 Offer，我选择了后者 😄</strong></p>\n<h2> 我的鹅厂面试</h2>\n<p>如本文标题所说，16 天通关五轮面试，第 17 天，我终于收到了期盼已久的鹅厂 Offer。</p>\n<p>做技术的同学，可能会对鹅厂的面试很好奇，他们都会问哪些问题呢？</p>\n<p>我应聘的是大数据开发（Java）岗位，接下来对我的面试做个梳理，也给想来鹅厂的同学们一个参考 😊</p>\n<blockquote>\n<p>几乎所有问题都能在网络上找到很详细的答案。\n篇幅有限，这里只写题目和一些引申的问题。</p>\n</blockquote>\n<h3> 技术一面</h3>\n<h4> Java 语言相关</h4>\n<p>1、对 Java 的类加载器有没有了解？如何自定义类加载器？</p>\n<blockquote>\n<p>引申：一个类能被加载多次吗？<code>java/javax</code> 包下的类会被加载多次吗？</p>\n</blockquote>\n<p>2、Java 中要怎么创建一个对象 🐘？</p>\n<p>3、对多线程有了解吗？在什么场景下需要使用多线程？</p>\n<blockquote>\n<p>引申：对 <strong>线程安全</strong> 的认识；对线程池的了解，以及各个线程池的适用场景。</p>\n</blockquote>\n<p>4、对垃圾回收的了解？</p>\n<p>5、对 JVM 分代的了解？</p>\n<p>6、NIO 的了解？用过 RandomAccessFile 吗？</p>\n<blockquote>\n<p>引申：对 <strong>同步、异步，阻塞、非阻塞</strong> 的理解？</p>\n<p>多路复用 IO 的优势？</p>\n</blockquote>\n<p>7、ArrayList 和 LinkedList 的区别？各自的适用场景？</p>\n<p>8、实现一个 Hash 集合，需要考虑哪些因素？</p>\n<blockquote>\n<p>引申：JDK 对 HashMap 的设计关键点，比如初识容量，扩所容，链表转红黑树，以及 JDK 7 和 JDK 8 的区别等等。</p>\n</blockquote>\n<h4> 通用学科相关</h4>\n<p>1、TCP 的三次握手；</p>\n<p>2、Linux 的常用命令，比如：</p>\n<blockquote>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div></blockquote>\n<h4> 项目框架相关</h4>\n<p>1、Kafka 和其他 MQ 的区别？它的吞吐量为什么高？</p>\n<blockquote>\n<p>消费者主动 pull 数据，目的是：控制消费节奏，还可以重复消费；</p>\n<p>吞吐量高：各 partition 顺序写 IO，批量刷新到磁盘（OS 的 pageCache 负责刷盘，Kafka 不用管），比随机 IO 快；读取数据基于 sendfile 的 Zero Copy；批量数据压缩……</p>\n</blockquote>\n<p>2、Hive 和 SparkSQL 的区别？</p>\n<p>3、Ranger 的权限模型、权限对象，鉴权过程，策略如何刷新……</p>\n<h4> 问题定位方法</h4>\n<p>1、ssh 连接失败，如何定位？</p>\n<blockquote>\n<p>是否能 ping 通（DNS 是否正确）、对端端口是否开了防火墙、对端服务是否正常……</p>\n</blockquote>\n<p>2、运行 Java 程序的服务器，CPU 使用率达到 100%，如何定位？</p>\n<blockquote>\n<p><code>ps aux | grep xxx</code> 或 <code>jps</code> 命令找到 Java 的进程号 <code>pid</code>，</p>\n<p>然后用 <code>top -Hp pid</code> 命令查看其阻塞的线程序号，<strong>将其转换为 16 进制</strong>；</p>\n<p>再通过 <code>jstack pid</code> 命令跟踪此 Java 进程的堆栈，搜索上述转换来的 16 进制线程号，即可找到对应的线程名及其堆栈信息……</p>\n</blockquote>\n<p>3、Java 程序发生了内存溢出，如何定位？</p>\n<blockquote>\n<p><code>jmap</code> 工具查看堆栈信息，看 Eden、Old 区的变化……</p>\n</blockquote>\n<h3> 技术二面</h3>\n<p>二面主要是过往项目相关的问题：</p>\n<p>1、Solr 和 Elasticsearch 的区别 / 优劣？</p>\n<p>2、对 Elasticsearch 的优化，它的索引过程，选主过程等问题……</p>\n<p>3、项目中遇到的难题，如何解决的？</p>\n<p>blabla 有少量的基础问题和一面有重复，还有几个和大数据相关的问题，记不太清了 😅</p>\n<h3> 技术三面</h3>\n<p>这一面是总监面，更多是个人关于职业发展的一些想法，以及在之前公司的成长和收获、对下一份工作的期望等问题。</p>\n<p>但也问了几个技术问题。印象比较深的是这个：</p>\n<blockquote>\n<p>1 个 1TB 的大文件，每行都只是 1 个数字，无重复，8GB 内存，要怎么对这个文件进行排序？</p>\n</blockquote>\n<p>首先想到的是 MapReduce 的思路，拆分小文件，分批排序，最后合并。</p>\n<p><strong>此时连环追问来了：</strong></p>\n<blockquote>\n<p>Q：如何尽可能多的利用内存呢？</p>\n<p>A：用位图法的思路，对数字按顺序映射。（对映射方法要有基本的了解）</p>\n<p>Q：如果在排好序之后，还需要快速查找呢？</p>\n<p>A：可以做索引，类似 Redis 的跳表，通过多级索引提高查找速度。</p>\n<p>Q：索引查找的还是文件。要如何才能更多地利用内存呢？</p>\n<p>A：那就要添加缓存了，把读取过的数字缓存到内存中。</p>\n<p>Q：缓存应该满足什么特点呢？</p>\n<p>A：应该使用 LRU 型的缓存。</p>\n</blockquote>\n<p>呼。。。总算是追问完了这道题 😂</p>\n<hr>\n<p>还有 GM 面和 HR 面，问题都和个人经历相关，这里就略去不表。</p>\n<h2> 文末的絮叨</h2>\n<p><strong>入职鹅厂已经1月有余。不同的岗位，不同的工作内容，也是不同的挑战。</strong></p>\n<p>感受比较深的是，作为程序员，还是要自我驱动，努力提升个人技术能力，横向纵向都要扩充，这样才能走得长远。</p>\n",
      "image": "https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/high-quality-technical-articles/personal-experience/1438655-20210124231550508-1315720640.jpg",
      "date_published": "2022-07-04T11:20:20.000Z",
      "date_modified": "2022-07-04T11:20:20.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "技术文章精选集"
      ]
    },
    {
      "title": "分布式必读经典书籍",
      "url": "https://javaguide.cn/books/distributed-system.html",
      "id": "https://javaguide.cn/books/distributed-system.html",
      "summary": "《深入理解分布式系统》 《深入理解分布式系统》 是今年 3 月份刚出的一本分布式中文原创书籍，主要讲的是分布式领域的基本概念、常见挑战以及共识算法。",
      "content_html": "<h2> 《深入理解分布式系统》</h2>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/books/deep-understanding-of-distributed-system.png\" alt=\"\"></p>\n<p><strong><a href=\"https://book.douban.com/subject/35794814/\" target=\"_blank\" rel=\"noopener noreferrer\">《深入理解分布式系统》</a></strong> 是今年 3 月份刚出的一本分布式中文原创书籍，主要讲的是分布式领域的基本概念、常见挑战以及共识算法。</p>\n<p>作者用了大量篇幅来介绍分布式领域中非常重要的共识算法，并且还会基于 Go 语言带着你从零实现了一个共识算法的鼻祖 Paxos 算法。</p>\n<p>实话说，我还没有开始看这本书。但是！这本书的作者的博客上的分布式相关的文章我几乎每一篇都认真看过。</p>\n<p>作者从 2019 年开始构思《深入理解分布式系统》，2020 年开始动笔，花了接近两年的时间才最终交稿。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/books/image-20220706121952258.png\" alt=\"\"></p>\n<p>作者专门写了一篇文章来介绍这本书的背后的故事，感兴趣的小伙伴可以自行查阅：https://zhuanlan.zhihu.com/p/487534882 。</p>\n<p>最后，放上这本书的代码仓库和勘误地址：https://github.com/tangwz/DistSysDeepDive 。</p>\n<h2> 《数据密集型应用系统设计》</h2>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/books/ddia.png\" alt=\"\"></p>\n<p>强推一波 <strong><a href=\"https://book.douban.com/subject/30329536/\" target=\"_blank\" rel=\"noopener noreferrer\">《Designing Data-Intensive Application》</a></strong> （DDIA，数据密集型应用系统设计），值得读很多遍！豆瓣有接近 90% 的人看了这本书之后给了五星好评。</p>\n<p>这本书主要讲了分布式数据库、数据分区、事务、分布式系统等内容。</p>\n<p>书中介绍的大部分概念你可能之前都听过，但是在看了书中的内容之后，你可能会豁然开朗：“哇塞！原来是这样的啊！这不是某技术的原理么？”。</p>\n<p>这本书我之前专门写过知乎回答介绍和推荐，没看过的朋友可以看看：<a href=\"https://www.zhihu.com/question/50408698/answer/2278198495\" target=\"_blank\" rel=\"noopener noreferrer\">有哪些你看了以后大呼过瘾的编程书？ </a> 。</p>\n<p>另外，如果你在阅读这本书的时候感觉难度比较大，很多地方读不懂的话，我这里推荐一下《深入理解分布式系统》作者写的<a href=\"https://ddia.qtmuniao.com\" target=\"_blank\" rel=\"noopener noreferrer\">《DDIA 逐章精读》小册</a>。</p>\n<h2> 《深入理解分布式事务》</h2>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/books/In-depth-understanding-of-distributed-transactions-xiaoyu.png\" alt=\"\"></p>\n<p><strong><a href=\"https://book.douban.com/subject/35626925/\" target=\"_blank\" rel=\"noopener noreferrer\">《深入理解分布式事务》</a></strong>  这本书是的其中一位作者是 Apache ShenYu（incubating）网关创始人、Hmily、RainCat、Myth等分布式事务框架的创始人。</p>\n<p>学习分布式事务的时候，可以参考一下这本书。虽有一些小错误以及逻辑不通顺的地方，但对于各种分布式事务解决方案的介绍，总体来说还是不错的。</p>\n<h2> 《从 Paxos 到 Zookeeper》</h2>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/books/image-20211216161350118.png\" alt=\"\"></p>\n<p><strong><a href=\"https://book.douban.com/subject/26292004/\" target=\"_blank\" rel=\"noopener noreferrer\">《从 Paxos 到 Zookeeper》</a></strong> 是一本带你入门分布式理论的好书。这本书主要介绍几种典型的分布式一致性协议，以及解决分布式一致性问题的思路，其中重点讲解了 Paxos 和 ZAB 协议。</p>\n<h2> 《微服务架构设计模式》</h2>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/books/microservices-patterns.png\" alt=\"\"></p>\n<p><strong><a href=\"https://book.douban.com/subject/33425123/\" target=\"_blank\" rel=\"noopener noreferrer\">《微服务架构设计模式》</a></strong> 的作者 Chris Richardson 被评为世界十大软件架构师之一、微服务架构先驱。这本书主要讲的是如何开发和部署生产级别的微服务架构应用，示例代码使用 Java 语言和 Spring 框架。</p>\n<h2> 《凤凰架构》</h2>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/books/f5bec14d3b404ac4b041d723153658b5.png\" alt=\"\"></p>\n<p><strong><a href=\"https://book.douban.com/subject/35492898/\" target=\"_blank\" rel=\"noopener noreferrer\">《凤凰架构》</a></strong> 这本书是周志明老师多年架构和研发经验的总结，内容非常干货，深度与广度并存，理论结合实践！</p>\n<p>正如书名的副标题“构建可靠的大型分布式系统”所说的那样，这本书的主要内容就是讲：“如何构建一套可靠的分布式大型软件系统” ，涵盖了下面这些方面的内容：</p>\n<ul>\n<li>软件架构从单体到微服务再到无服务的演进之路。</li>\n<li>架构师应该在架构设计时应该注意哪些问题，有哪些比较好的实践。</li>\n<li>分布式的基石比如常见的分布式共识算法 Paxos、Multi Paxos。</li>\n<li>不可变基础设施比如虚拟化容器、服务网格。</li>\n<li>向微服务迈进的避坑指南。</li>\n</ul>\n<p>这本书我推荐过很多次了。详见历史文章：</p>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247505254&amp;idx=1&amp;sn=04faf3093d6002354f06fffbfc2954e0&amp;chksm=cea19aadf9d613bbba7ed0e02ccc4a9ef3a30f4d83530e7ad319c2cc69cd1770e43d1d470046&amp;scene=178&amp;cur_album_id=1646812382221926401#rd\" target=\"_blank\" rel=\"noopener noreferrer\">周志明老师的又一神书！发现宝藏！</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/9nbzfZGAWM9_qIMp1r6uUQ\" target=\"_blank\" rel=\"noopener noreferrer\">Java 领域的又一神书！周志明老师 YYDS！</a></li>\n</ul>\n<h2> 《架构解密》</h2>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/books/jiagoujiemi.png\" alt=\"\"></p>\n<p><a href=\"https://book.douban.com/subject/35093373/\" target=\"_blank\" rel=\"noopener noreferrer\">《架构解密》</a>这本书和我渊源颇深，在大三的时候，我曾经在图书馆借阅过这本书的第一版，大概了花了不到一周就看完了。</p>\n<p>这本书的第二版在 2020 年就已经出来了，总共也才 15 个评价，算得上是一本非常小众的技术书籍了。</p>\n<p>书籍质量怎么说呢，各个知识点介绍的都比较泛，匆忙结束，一共 9 章，总共 331 页。如果你只是想初步了解一些分布式相关的概念的话，可以看看这本书，快速概览一波分布式相关的技术。</p>\n<h2> 其他</h2>\n<ul>\n<li><a href=\"https://book.douban.com/subject/21624776/\" target=\"_blank\" rel=\"noopener noreferrer\">《分布式系统 : 概念与设计》</a> ：偏教材类型，内容全而无趣，可作为参考书籍；</li>\n<li><a href=\"https://book.douban.com/subject/35689350/\" target=\"_blank\" rel=\"noopener noreferrer\">《分布式架构原理与实践》</a> ：2021 年出版的，没什么热度，我也还没看过。</li>\n</ul>\n",
      "image": "https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/books/deep-understanding-of-distributed-system.png",
      "date_published": "2022-07-02T07:06:16.000Z",
      "date_modified": "2022-11-15T12:25:47.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "计算机书籍"
      ]
    },
    {
      "title": "常见面试题自测(付费)",
      "url": "https://javaguide.cn/interview-preparation/self-test-of-common-interview-questions.html",
      "id": "https://javaguide.cn/interview-preparation/self-test-of-common-interview-questions.html",
      "summary": "面试之前，强烈建议大家多拿常见的面试题来进行自测，检查一下自己的掌握情况，这是一种非常实用的备战技术面试的小技巧。 在 《Java 面试指北》 的 「技术面试题自测篇」 ，我总结了 Java 面试中最重要的知识点的最常见的面试题并按照面试提问的方式展现出来。",
      "content_html": "<p>面试之前，强烈建议大家多拿常见的面试题来进行自测，检查一下自己的掌握情况，这是一种非常实用的备战技术面试的小技巧。</p>\n<p>在 <strong><a href=\"/zhuanlan/java-mian-shi-zhi-bei.html\" target=\"blank\">《Java 面试指北》</a></strong> 的 <strong>「技术面试题自测篇」</strong> ，我总结了 Java 面试中最重要的知识点的最常见的面试题并按照面试提问的方式展现出来。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220628102643202.png\" alt=\"\"></p>\n<p>每一道用于自测的面试题我都会给出重要程度，方便大家在时间比较紧张的时候根据自身情况来选择性自测。并且，我还会给出提示，方便你回忆起对应的知识点。</p>\n<p>在面试中如果你实在没有头绪的话，一个好的面试官也是会给你提示的。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220628102848236.png\" alt=\"\"></p>\n<p>欢迎准备 Java 面试以及学习 Java 的同学加入我的<a href=\"https://www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc\" target=\"_blank\" rel=\"noopener noreferrer\">知识星球</a>，干货非常多，学习氛围非常好！收费虽然是白菜价，但星球里的内容或许比你参加上万的培训班质量还要高。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220311203414600.png\" alt=\"\"></p>\n<p>下面是星球提供的部分服务（点击下方图片即可获取知识星球的详细介绍）：</p>\n<div align=\"center\">\n  <a href=\"https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html\">\n    <img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/xingqiufuwu.png\" style=\"margin: 0 auto; \">\n  </a>\n</div>\n<p>我有自己的原则，不割韭菜，用心做内容，真心希望帮助到你！</p>\n<p>如果你感兴趣的话，不妨花 3 分钟左右看看星球的详细介绍： <a href=\"https://www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc\" target=\"_blank\" rel=\"noopener noreferrer\">JavaGuide 知识星球详细介绍</a>（文末有优惠券）。</p>\n<div align=\"center\">\n  <a href=\"https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html\">\n    <img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/xingqiuyouhuijuanheyi.png\" style=\"margin: 0 auto; \">\n  </a>\n</div>\n",
      "image": "https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220628102643202.png",
      "date_published": "2022-06-28T04:05:29.000Z",
      "date_modified": "2022-08-25T03:25:52.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "知识星球"
      ]
    },
    {
      "title": "Java 16 新特性概览",
      "url": "https://javaguide.cn/java/new-features/java16.html",
      "id": "https://javaguide.cn/java/new-features/java16.html",
      "summary": "Java 16 在 2021 年 3 月 16 日正式发布，非长期支持（LTS）版本。 相关阅读：OpenJDK Java 16 文档 。 JEP 338:向量 API(第二次孵化) 向量（Vector） API 最初由 JEP 338 提出，并作为孵化 API集成到 Java 16 中。第二轮孵化由 JEP 414 提出并集成到 Java 17 中，第三轮孵化由 JEP 417 提出并集成到 Java 18 中，第四轮由 JEP 426 提出并集成到了 Java 19 中。",
      "content_html": "<p>Java 16 在 2021 年 3 月 16 日正式发布，非长期支持（LTS）版本。</p>\n<p>相关阅读：<a href=\"https://openjdk.java.net/projects/jdk/16/\" target=\"_blank\" rel=\"noopener noreferrer\">OpenJDK Java 16 文档</a> 。</p>\n<h2> JEP 338:向量 API(第二次孵化)</h2>\n<p>向量（Vector） API 最初由 <a href=\"https://openjdk.java.net/jeps/338\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 338</a> 提出，并作为<a href=\"http://openjdk.java.net/jeps/11\" target=\"_blank\" rel=\"noopener noreferrer\">孵化 API</a>集成到 Java 16 中。第二轮孵化由 <a href=\"https://openjdk.java.net/jeps/414\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 414</a> 提出并集成到 Java 17 中，第三轮孵化由 <a href=\"https://openjdk.java.net/jeps/417\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 417</a> 提出并集成到 Java 18 中，第四轮由 <a href=\"https://openjdk.java.net/jeps/426\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 426</a> 提出并集成到了 Java 19 中。</p>\n<p>该孵化器 API 提供了一个 API 的初始迭代以表达一些向量计算，这些计算在运行时可靠地编译为支持的 CPU 架构上的最佳向量硬件指令，从而获得优于同等标量计算的性能，充分利用单指令多数据（SIMD）技术（大多数现代 CPU 上都可以使用的一种指令）。尽管 HotSpot 支持自动向量化，但是可转换的标量操作集有限且易受代码更改的影响。该 API 将使开发人员能够轻松地用 Java 编写可移植的高性能向量算法。</p>\n<p>在 <a href=\"/java/new-features/java18.html\" target=\"blank\">Java 18 新特性概览</a> 中，我有详细介绍到向量 API，这里就不再做额外的介绍了。</p>\n<h2> JEP 347:启用 C++ 14 语言特性</h2>\n<p>Java 16 允许在 JDK 的 C++ 源代码中使用 C++14 语言特性，并提供在 HotSpot 代码中可以使用哪些特性的具体指导。</p>\n<p>在 Java 15 中，JDK 中 C++ 代码使用的语言特性仅限于 C++98/03 语言标准。它要求更新各种平台编译器的最低可接受版本。</p>\n<h2> JEP 376:ZGC 并发线程堆栈处理</h2>\n<p>Java16 将 ZGC 线程栈处理从安全点转移到一个并发阶段，甚至在大堆上也允许在毫秒内暂停 GC 安全点。消除 ZGC 垃圾收集器中最后一个延迟源可以极大地提高应用程序的性能和效率。</p>\n<h2> JEP 387:弹性元空间</h2>\n<p>自从引入了 Metaspace 以来，根据反馈，Metaspace 经常占用过多的堆外内存，从而导致内存浪费。弹性元空间这个特性可将未使用的 HotSpot 类元数据（即元空间，metaspace）内存更快速地返回到操作系统，从而减少元空间的占用空间。</p>\n<p>并且，这个提案还简化了元空间的代码以降低维护成本。</p>\n<h2> JEP 390:对基于值的类发出警告</h2>\n<blockquote>\n<p>以下介绍摘自：<a href=\"https://xie.infoq.cn/article/8304c894c4e38318d38ceb116\" target=\"_blank\" rel=\"noopener noreferrer\">实操 | 剖析 Java16 新语法特性</a>，原文写的很不错，推荐阅读。</p>\n</blockquote>\n<p>早在 Java9 版本时，Java 的设计者们就对 <code>@Deprecated</code> 注解进行了一次升级，增加了 <code>since</code> 和 <code>forRemoval</code> 等 2 个新元素。其中，since 元素用于指定标记了 <code>@Deprecated</code> 注解的 API 被弃用时的版本，而 <code>forRemoval</code> 则进一步明确了 API 标记 @Deprecated 注解时的语义，如果<code>forRemoval=true</code>时，则表示该 API 在未来版本中肯定会被删除，开发人员应该使用新的 API 进行替代，不再容易产生歧义（Java9 之前，标记 @Deprecated 注解的 API，语义上存在多种可能性，比如：存在使用风险、可能在未来存在兼容性错误、可能在未来版本中被删除，以及应该使用更好的替代方案等）。</p>\n<p>仔细观察原始类型的包装类（比如：<code>java.lang.Integer</code>、<code>java.lang.Double</code>），不难发现，其构造函数上都已经标记有<code>@Deprecated(since=\"9\", forRemoval = true)</code>注解，这就意味着其构造函数在将来会被删除，不应该在程序中继续使用诸如<code>new Integer();</code>这样的编码方式（建议使用<code>Integer a = 10;</code>或者<code>Integer.valueOf()</code>函数），如果继续使用，编译期将会产生'Integer(int)' is deprecated and marked for removal 告警。并且，值得注意的是，这些包装类型已经被指定为同 <code>java.util.Optional</code> 和 <code>java.time.LocalDateTime</code> 一样的值类型。</p>\n<p>其次，如果继续在 <code>synchronized</code> 同步块中使用值类型，将会在编译期和运行期产生警告，甚至是异常。在此大家需要注意，就算编译期和运行期没有产生警告和异常，也不建议在 <code>synchronized</code> 同步块中使用值类型，举个自增的例子。示例 1-5：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>当执行上述程序示例时，最终的输出结果一定会与你的期望产生差异，这是许多新人经常犯错的一个点，因为在并发环境下，<code>Integer</code> 对象根本无法通过 <code>synchronized</code> 来保证线程安全，这是因为每次的<code>count++</code>操作，所产生的 <code>hashcode</code> 均不同，简而言之，每次加锁都锁在了不同的对象上。因此，如果希望在实际的开发过程中保证其原子性，应该使用 <code>AtomicInteger</code>。</p>\n<h2> JEP 392:打包工具</h2>\n<p>在 Java 14 中，JEP 343 引入了打包工具，命令是 <code>jpackage</code>。在 Java 15 中，继续孵化，现在在 Java 16 中，终于成为了正式功能。</p>\n<p>这个打包工具允许打包自包含的 Java 应用程序。它支持原生打包格式，为最终用户提供自然的安装体验，这些格式包括 Windows 上的 msi 和 exe、macOS 上的 pkg 和 dmg，还有 Linux 上的 deb 和 rpm。它还允许在打包时指定启动时参数，并且可以从命令行直接调用，也可以通过 ToolProvider API 以编程方式调用。注意 jpackage 模块名称从 jdk.incubator.jpackage 更改为 jdk.jpackage。这将改善最终用户在安装应用程序时的体验，并简化了“应用商店”模型的部署。</p>\n<p>关于这个打包工具的实际使用，可以看这个视频 <a href=\"https://www.youtube.com/watch?v=KahYIVzRIkQ\" target=\"_blank\" rel=\"noopener noreferrer\">Playing with Java 16 jpackage</a>（需要梯子）。</p>\n<h2> JEP 393:外部内存访问 API(第三次孵化)</h2>\n<p>引入外部内存访问 API 以允许 Java 程序安全有效地访问 Java 堆之外的外部内存。</p>\n<p>Java 14(<a href=\"https://openjdk.org/jeps/370\" target=\"_blank\" rel=\"noopener noreferrer\"> JEP 370</a>) 的时候，第一次孵化外部内存访问 API，Java 15 中进行了第二次复活（<a href=\"https://openjdk.org/jeps/383\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 383</a>），在 Java 16 中进行了第三次孵化。</p>\n<p>引入外部内存访问 API 的目的如下：</p>\n<ul>\n<li>通用：单个 API 应该能够对各种外部内存（如本机内存、持久内存、堆内存等）进行操作。</li>\n<li>安全：无论操作何种内存，API 都不应该破坏 JVM 的安全性。</li>\n<li>控制：可以自由的选择如何释放内存（显式、隐式等）。</li>\n<li>可用：如果需要访问外部内存，API 应该是 <code>sun.misc.Unsafa</code>.</li>\n</ul>\n<h2> JEP 394:instanceof 模式匹配(转正)</h2>\n<table>\n<thead>\n<tr>\n<th>JDK 版本</th>\n<th>更新类型</th>\n<th>JEP</th>\n<th>更新内容</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Java SE 14</td>\n<td>preview</td>\n<td><a href=\"https://openjdk.org/jeps/305\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 305</a></td>\n<td>首次引入 instanceof 模式匹配。</td>\n</tr>\n<tr>\n<td>Java SE 15</td>\n<td>Second Preview</td>\n<td><a href=\"https://openjdk.org/jeps/375\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 375</a></td>\n<td>相比较上个版本无变化，继续收集更多反馈。</td>\n</tr>\n<tr>\n<td>Java SE 16</td>\n<td>Permanent Release</td>\n<td><a href=\"https://openjdk.org/jeps/394\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 394</a></td>\n<td>模式变量不在隐式为 final。</td>\n</tr>\n</tbody>\n</table>\n<p>从 Java 16 开始，你可以对 <code>instanceof</code> 中的变量值进行修改。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> JEP 395:记录类型(转正)</h2>\n<p>记录类型变更历史：</p>\n<table>\n<thead>\n<tr>\n<th>JDK 版本</th>\n<th>更新类型</th>\n<th>JEP</th>\n<th>更新内容</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Java SE 14</td>\n<td>Preview</td>\n<td><a href=\"https://openjdk.java.net/jeps/359\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 359</a></td>\n<td>引入 <code>record</code> 关键字，<code>record</code> 提供一种紧凑的语法来定义类中的不可变数据。</td>\n</tr>\n<tr>\n<td>Java SE 15</td>\n<td>Second Preview</td>\n<td><a href=\"https://openjdk.org/jeps/384\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 384</a></td>\n<td>支持在局部方法和接口中使用 <code>record</code>。</td>\n</tr>\n<tr>\n<td>Java SE 16</td>\n<td>Permanent Release</td>\n<td><a href=\"https://openjdk.org/jeps/395\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 395</a></td>\n<td>非静态内部类可以定义非常量的静态成员。</td>\n</tr>\n</tbody>\n</table>\n<p>从 Java SE 16 开始，非静态内部类可以定义非常量的静态成员。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><blockquote>\n<p>在 JDK 16 之前，如果写上面这种代码，IDE 会提示你静态字段 age 不能在非静态的内部类中定义，除非它用一个常量表达式初始化。（The field age cannot be declared static in a non-static inner type, unless initialized with a constant expression）</p>\n</blockquote>\n<h2> JEP 396:默认强封装 JDK 内部元素</h2>\n<p>此特性会默认强封装 JDK 的所有内部元素，但关键内部 API（例如 <code>sun.misc.Unsafe</code>）除外。默认情况下，使用早期版本成功编译的访问 JDK 内部 API 的代码可能不再起作用。鼓励开发人员从使用内部元素迁移到使用标准 API 的方法上，以便他们及其用户都可以无缝升级到将来的 Java 版本。强封装由 JDK 9 的启动器选项–illegal-access 控制，到 JDK 15 默认改为 warning，从 JDK 16 开始默认为 deny。（目前）仍然可以使用单个命令行选项放宽对所有软件包的封装，将来只有使用–add-opens 打开特定的软件包才行。</p>\n<h2> JEP 397:密封类(预览)</h2>\n<p>密封类由 <a href=\"https://openjdk.java.net/jeps/360\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 360</a> 提出预览，集成到了 Java 15 中。在 JDK 16 中， 密封类得到了改进（更加严格的引用检查和密封类的继承关系），由 <a href=\"https://openjdk.java.net/jeps/397\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 397</a> 提出了再次预览。</p>\n<p>在 <a href=\"/java/new-features/java15.html\" target=\"blank\">Java 15 新特性概览</a> 中，我有详细介绍到密封类，这里就不再做额外的介绍了。</p>\n<h2> 其他优化与改进</h2>\n<ul>\n<li><strong>JEP 380:Unix-Domain 套接字通道</strong> ：Unix-domain 套接字一直是大多数 Unix 平台的一个特性，现在在 Windows 10 和 Windows Server 2019 也提供了支持。此特性为 java.nio.channels 包的套接字通道和服务器套接字通道 API 添加了 Unix-domain（AF_UNIX）套接字支持。它扩展了继承的通道机制以支持 Unix-domain 套接字通道和服务器套接字通道。Unix-domain 套接字用于同一主机上的进程间通信（IPC）。它们在很大程度上类似于 TCP/IP，区别在于套接字是通过文件系统路径名而不是 Internet 协议（IP）地址和端口号寻址的。对于本地进程间通信，Unix-domain 套接字比 TCP/IP 环回连接更安全、更有效</li>\n<li>**JEP 389:外部链接器 API(孵化) ：**该孵化器 API 提供了静态类型、纯 Java 访问原生代码的特性，该 API 将大大简化绑定原生库的原本复杂且容易出错的过程。Java 1.1 就已通过 Java 原生接口（JNI）支持了原生方法调用，但并不好用。Java 开发人员应该能够为特定任务绑定特定的原生库。它还提供了外来函数支持，而无需任何中间的 JNI 粘合代码。</li>\n<li><strong>JEP 357:从 Mercurial 迁移到 Git</strong> ：在此之前，OpenJDK 源代码是使用版本管理工具 Mercurial 进行管理，现在迁移到了 Git。</li>\n<li><strong>JEP 369:迁移到 GitHub</strong>：和 JEP 357 从 Mercurial 迁移到 Git 的改变一致，在把版本管理迁移到 Git 之后，选择了在 GitHub 上托管 OpenJDK 社区的 Git 仓库。不过只对 JDK 11 以及更高版本 JDK 进行了迁移。</li>\n<li><strong>JEP 386:移植 Alpine Linux</strong> ：Apine Linux 是一个独立的、非商业的 Linux 发行版，它十分的小，一个容器需要不超过 8MB 的空间，最小安装到磁盘只需要大约 130MB 存储空间，并且十分的简单，同时兼顾了安全性。此提案将 JDK 移植到了 Apline Linux，由于 Apline Linux 是基于 musl lib 的轻量级 Linux 发行版，因此其他 x64 和 AArch64 架构上使用 musl lib 的 Linux 发行版也适用。</li>\n<li><strong>JEP 388:Windows/AArch64 移植</strong> ：这些 JEP 的重点不是移植工作本身，而是将它们集成到 JDK 主线存储库中；JEP 386 将 JDK 移植到 Alpine Linux 和其他使用 musl 作为 x64 上主要 C 库的发行版上。此外，JEP 388 将 JDK 移植到 Windows AArch64（ARM64）。</li>\n</ul>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://docs.oracle.com/en/java/javase/16/language/java-language-changes.html\" target=\"_blank\" rel=\"noopener noreferrer\">Java Language Changes</a></li>\n<li><a href=\"https://www.oracle.com/java/technologies/javase/16all-relnotes.html\" target=\"_blank\" rel=\"noopener noreferrer\">Consolidated JDK 16 Release Notes</a></li>\n<li><a href=\"https://www.infoq.cn/article/IAkwhx7i9V7G8zLVEd4L\" target=\"_blank\" rel=\"noopener noreferrer\">Java 16 正式发布，新特性一一解析</a></li>\n<li><a href=\"https://xie.infoq.cn/article/8304c894c4e38318d38ceb116\" target=\"_blank\" rel=\"noopener noreferrer\">实操 | 剖析 Java16 新语法特性</a>（写的很赞）</li>\n</ul>\n",
      "date_published": "2022-06-28T02:19:19.000Z",
      "date_modified": "2023-01-16T05:08:19.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "冗余设计详解",
      "url": "https://javaguide.cn/high-availability/redundancy.html",
      "id": "https://javaguide.cn/high-availability/redundancy.html",
      "summary": "冗余设计是保证系统和数据高可用的最常的手段。 对于服务来说，冗余的思想就是相同的服务部署多份，如果正在使用的服务突然挂掉的话，系统可以很快切换到备份服务上，大大减少系统的不可用时间，提高系统的可用性。 对于数据来说，冗余的思想就是相同的数据备份多份，这样就可以很简单地提高数据的安全性。 实际上，日常生活中就有非常多的冗余思想的应用。 拿我自己来说，我对于重要文件的保存方法就是冗余思想的应用。我日常所使用的重要文件都会同步一份在 Github 以及个人云盘上，这样就可以保证即使电脑硬盘损坏，我也可以通过 Github 或者个人云盘找回自己的重要文件。",
      "content_html": "<p>冗余设计是保证系统和数据高可用的最常的手段。</p>\n<p>对于服务来说，冗余的思想就是相同的服务部署多份，如果正在使用的服务突然挂掉的话，系统可以很快切换到备份服务上，大大减少系统的不可用时间，提高系统的可用性。</p>\n<p>对于数据来说，冗余的思想就是相同的数据备份多份，这样就可以很简单地提高数据的安全性。</p>\n<p>实际上，日常生活中就有非常多的冗余思想的应用。</p>\n<p>拿我自己来说，我对于重要文件的保存方法就是冗余思想的应用。我日常所使用的重要文件都会同步一份在 Github 以及个人云盘上，这样就可以保证即使电脑硬盘损坏，我也可以通过 Github 或者个人云盘找回自己的重要文件。</p>\n<p>高可用集群（High Availability Cluster，简称 HA Cluster）、同城灾备、异地灾备、同城多活和异地多活是冗余思想在高可用系统设计中最典型的应用。</p>\n<ul>\n<li><strong>高可用集群</strong> : 同一份服务部署两份或者多份，当正在使用的服务突然挂掉的话，可以切换到另外一台服务，从而保证服务的高可用。</li>\n<li><strong>同城灾备</strong> ：一整个集群可以部署在同一个机房，而同城灾备中相同服务部署在同一个城市的不同机房中。并且，备用服务不处理请求。这样可以避免机房出现意外情况比如停电、火灾。</li>\n<li><strong>异地灾备</strong> ：类似于同城灾备，不同的是，相同服务部署在异地（通常距离较远，甚至是在不同的城市或者国家）的不同机房中</li>\n<li><strong>同城多活</strong> ：类似于同城灾备，但备用服务可以处理请求，这样可以充分利用系统资源，提高系统的并发。</li>\n<li><strong>异地多活</strong> : 将服务部署在异地的不同机房中，并且，它们可以同时对外提供服务。</li>\n</ul>\n<p>高可用集群单纯是服务的冗余，并没有强调地域。同城灾备、异地灾备、同城多活和异地多活实现了地域上的冗余。</p>\n<p>同城和异地的主要区别在于机房之间的距离。异地通常距离较远，甚至是在不同的城市或者国家。</p>\n<p>和传统的灾备设计相比，同城多活和异地多活最明显的改变在于“多活”，即所有站点都是同时在对外提供服务的。异地多活是为了应对突发状况比如火灾、地震等自然或者人为灾害。</p>\n<p>光做好冗余还不够，必须要配合上 <strong>故障转移</strong> 才可以！ 所谓故障转移，简单来说就是实现不可用服务快速且自动地切换到可用服务，整个过程不需要人为干涉。</p>\n<p>举个例子：哨兵模式的 Redis 集群中，如果 Sentinel（哨兵） 检测到 master 节点出现故障的话， 它就会帮助我们实现故障转移，自动将某一台 slave 升级为 master，确保整个 Redis 系统的可用性。整个过程完全自动，不需要人工介入。我在<a href=\"https://www.yuque.com/docs/share/f37fc804-bfe6-4b0d-b373-9c462188fec7\" target=\"_blank\" rel=\"noopener noreferrer\">《Java 面试指北》</a>的「技术面试题篇」中的数据库部分详细介绍了 Redis 集群相关的知识点&amp;面试题，感兴趣的小伙伴可以看看。</p>\n<p>再举个例子：Nginx 可以结合 Keepalived 来实现高可用。如果 Nginx 主服务器宕机的话，Keepalived 可以自动进行故障转移，备用 Nginx 主服务器升级为主服务。并且，这个切换对外是透明的，因为使用的虚拟 IP，虚拟 IP 不会改变。我在<a href=\"https://www.yuque.com/docs/share/f37fc804-bfe6-4b0d-b373-9c462188fec7\" target=\"_blank\" rel=\"noopener noreferrer\">《Java 面试指北》</a>的「技术面试题篇」中的「服务器」部分详细介绍了 Nginx 相关的知识点&amp;面试题，感兴趣的小伙伴可以看看。</p>\n<p>异地多活架构实施起来非常难，需要考虑的因素非常多。本人不才，实际项目中并没有实践过异地多活架构，我对其了解还停留在书本知识。</p>\n<p>如果你想要深入学习异地多活相关的知识，我这里推荐几篇我觉得还不错的文章：</p>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/T6mMDdtTfBuIiEowCpqu6Q\" target=\"_blank\" rel=\"noopener noreferrer\">搞懂异地多活，看这篇就够了- 水滴与银弹 - 2021</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/hMD-IS__4JE5_nQhYPYSTg\" target=\"_blank\" rel=\"noopener noreferrer\">四步构建异地多活</a></li>\n<li><a href=\"http://gk.link/a/10pKZ\" target=\"_blank\" rel=\"noopener noreferrer\">《从零开始学架构》— 28 | 业务高可用的保障：异地多活架构</a></li>\n</ul>\n<p>不过，这些文章大多也都是在介绍概念知识。目前，网上还缺少真正介绍具体要如何去实践落地异地多活架构的资料。</p>\n",
      "date_published": "2022-06-22T07:27:43.000Z",
      "date_modified": "2022-11-03T15:33:32.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "高可用"
      ]
    },
    {
      "title": "《Java 必读源码系列》(付费)",
      "url": "https://javaguide.cn/zhuanlan/source-code-reading.html",
      "id": "https://javaguide.cn/zhuanlan/source-code-reading.html",
      "summary": "介绍 《Java 必读源码系列》 是我的知识星球的一个内部小册，目前已经整理了 Dubbo 2.6.x 、Netty 4.x、SpringBoot 2.1 等框架/中间件的源码。 结构清晰，内容详细，非常适合想要深入学习框架/中间件源码的同学阅读。 内容概览",
      "content_html": "<h2> 介绍</h2>\n<p><strong>《Java 必读源码系列》</strong> 是我的<a href=\"/about-the-author/zhishixingqiu-two-years.html\" target=\"blank\">知识星球</a>的一个内部小册，目前已经整理了 Dubbo 2.6.x 、Netty 4.x、SpringBoot 2.1 等框架/中间件的源码。</p>\n<p>结构清晰，内容详细，非常适合想要深入学习框架/中间件源码的同学阅读。</p>\n<h2> 内容概览</h2>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220621091832348.png\" alt=\"\"></p>\n<h2> 星球其他资源</h2>\n<p>除了 <strong>《Java 必读源码系列》</strong> 之外，星球还有 <strong>《从零开始写一个 RPC 框架》</strong> 、 <strong>《Java 面试指北》</strong>、 <strong>《Java 必读源码系列》</strong>（目前已经整理了 Dubbo 2.6.x 、Netty 4.x、SpringBoot2.1 的源码） 、<strong>《Kafka 常见面试题/知识点总结》</strong> 等多个专栏。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220211231206733.png\" alt=\"\"></p>\n<p>另外，星球还会有读书活动、学习打卡、简历修改、免费提问、海量 Java 优质面试资源以及各种不定时的福利。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220304124333119.png\" alt=\"\"></p>\n<h2> 星球其他资源</h2>\n<p>除了 <strong>《Java 必读源码系列》</strong> 之外，星球还有 <strong>《手写 RPC 框架》</strong>、 <strong>《Java 面试指北》</strong> 、<strong>《Kafka 常见面试题/知识点总结》</strong> 等多个专属小册。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220316200015412.png\" alt=\"\">\n另外，星球还会有读书活动、学习打卡、简历修改、免费提问、海量 Java 优质面试资源以及各种不定时的福利。\n<img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220304124333119.png\" alt=\"\"></p>\n<h2> 星球限时优惠</h2>\n<p>两年前，星球的定价是 <strong>50/年</strong> ，这是星球的最低定价，我还附送了 33 元优惠券。扣除了星球手续费，发了各种福利之后，几乎就是纯粹做公益。</p>\n<p>感兴趣的小伙伴可以看看我在 2020-01-03 发的头条：<a href=\"https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247486049&amp;idx=1&amp;sn=e0161b409e8f164251bdaa0c83a476bc&amp;chksm=cea245aaf9d5ccbcafdb95a546d959508814085620aabdbb4385c4b8cea6e50bf157c3697041&amp;token=1614894361&amp;lang=zh_CN#rd\" target=\"_blank\" rel=\"noopener noreferrer\">做了一个很久没敢做的事情</a>，去考古一下。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220311203414600.png\" alt=\"\"></p>\n<p>随着时间推移，星球积累的干货资源越来越多，我花在星球上的时间也越来越多。于是，我将星球的定价慢慢调整为了 <strong>159/年</strong>！后续会将星球的价格调整为 <strong>199/年</strong>，想要加入的小伙伴一定要尽早。</p>\n<p>这里再送一个 30 元的新人优惠券（续费半价）。</p>\n<div align=\"center\">\n  <a href=\"https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html\">\n    <img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/xingqiuyouhuijuanheyi.png\" style=\"margin: 0 auto; \">\n  </a>\n</div>\n<p>进入星球之后，记得添加微信，我会发你详细的星球使用指南。</p>\n<div align=\"center\">\n  <a href=\"https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html\">\n    <img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/IMG_3007.jpg\" style=\"margin: 0 auto; \">\n  </a>\n</div>\n<p><strong>真诚欢迎准备面试的小伙伴加入星球一起交流！真心希望能够帮助到更多小伙伴！</strong></p>\n",
      "image": "https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220621091832348.png",
      "date_published": "2022-06-21T01:57:56.000Z",
      "date_modified": "2023-01-29T03:31:13.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "知识星球"
      ]
    },
    {
      "title": "阿里技术面试的一些秘密",
      "url": "https://javaguide.cn/high-quality-technical-articles/interview/some-secrets-about-alibaba-interview.html",
      "id": "https://javaguide.cn/high-quality-technical-articles/interview/some-secrets-about-alibaba-interview.html",
      "summary": "推荐语 ： 详细介绍了求职者在面试中应该具备哪些能力才会有更大概率脱颖而出。 原文地址： https://mp.weixin.qq.com/s/M2M808PwQ2JcMqfLQfXQMw 最近我的工作稍微轻松些，就被安排去校招面试了 当时还是有些激动的，以前都是被面试的，现在我自己也成为一个面试别人的面试官 接下来就谈谈我的面试心得(谈谈阿里面试的秘籍) 我是怎么筛选简历的？",
      "content_html": "<blockquote>\n<p><strong>推荐语</strong> ： 详细介绍了求职者在面试中应该具备哪些能力才会有更大概率脱颖而出。</p>\n<br>\n<p><strong>原文地址：</strong> https://mp.weixin.qq.com/s/M2M808PwQ2JcMqfLQfXQMw</p>\n</blockquote>\n<p>最近我的工作稍微轻松些，就被安排去校招面试了</p>\n<p>当时还是有些<strong>激动</strong>的，以前都是被面试的，现在我自己也成为一个面试别人的面试官</p>\n<p>接下来就谈谈我的面试心得(谈谈阿里面试的秘籍)</p>\n<h2> 我是怎么筛选简历的？</h2>\n<p>面试之前都是要筛选简历，这个大家应该知道</p>\n<p>阿里对待招聘非常负责任，面试官必须对每位同学的简历进行查看和筛选，如果不合适还需要写清楚理由</p>\n<p>对于校招生来说，第一份工作非常重要，而且校招的面试机会也只有一次，一旦收到大家的简历意味着大家非常认可和喜爱阿里这家公司</p>\n<p>所以我们对每份简历都会认真看，大家可以非常放心，不会无缘无故挂掉大家的简历</p>\n<p>尽管我们报以非常负责任的态度，但有些同学们的简历实在是难以下看</p>\n<p>关于如何写简历，我之前写过类似的文章，这里就把之前的文章放这里让大家看看 <a href=\"https://mp.weixin.qq.com/s?__biz=MzI4MDYzNDc1Mg==&amp;mid=2247484010&amp;idx=1&amp;sn=afbe90c8446f5f21631cae750431d3ee&amp;scene=21#wechat_redirect\" target=\"_blank\" rel=\"noopener noreferrer\">一份好的简历应该有哪些内容</a></p>\n<p>在筛选简历的时候会有以下信息非常重要，大家一定要认真写</p>\n<ul>\n<li><strong>项目经历</strong>，具体写法可以看上面提到的文章</li>\n<li><strong>个人含金量比较高的奖项</strong>，比如 ACM 奖牌、计算机竞赛等</li>\n<li><strong>个人技能</strong> 这块会看，但是大多数简历写法都差不多，尽量写得<strong>言简意赅</strong></li>\n<li><strong>重要期刊论文发表、开源项目</strong> 加分项</li>\n</ul>\n<p>这些信息非常重要，我筛选简历的时候这些信息占整份简历的比重 4/5 左右</p>\n<h2> 面试的时候我会注重哪些方面？</h2>\n<h3> <strong>表达要清楚</strong></h3>\n<p>这点是硬伤，在面试的时候有些同学半天说不清楚自己做的项目，我都在替你着急</p>\n<p>描述项目有个简单的方法论，我自己总结的 大家看看适不适合自己</p>\n<ul>\n<li>最好言简意赅的描述一下你的项目背景，让面试官很快知道项目干了啥(让面试官很快对项目感兴趣)</li>\n<li>说下项目用了哪些技术，做技术的用了哪些技术得说清楚，面试官会对你的技术比较感兴趣</li>\n<li>解决了什么问题，做项目肯定是为了解决问题，总不能为了做项目而做项目吧(解决问题的能力非常重要)</li>\n<li>遇到哪些难题，如何突破这些难题，项目遇到困难问题很正常，突破困难才是一次好的成长</li>\n<li>项目还有哪些完善的地方，不可能设计出完美的执行方案，有待改进说明你对项目认识深刻，思考深入</li>\n</ul>\n<p>一场面试时间一般 60—80 分钟，好的表达有助于彼此之间了解更多的问题</p>\n<h3> <strong>基础知识要扎实</strong></h3>\n<p>校招非常注重基础知识，所以这块问的问题比较多，我一般会结合你项目去问，看看同学对技术是停留在用的阶段还是有自己的深入思考</p>\n<p>每个方向对基础知识要求不同，但有些基础知识是通用的</p>\n<p>比如<strong>数据结构与算法</strong>、<strong>操作系统</strong>、<strong>计算机网络</strong> 等</p>\n<p>这些基础技术知识一定要掌握扎实，技术岗位都会或多或少去问这些基础</p>\n<h3> <strong>动手能力很重要</strong></h3>\n<p>action，action，action ，重要的事情说三遍，做技术的不可能光靠一张嘴，能落地才是最重要的</p>\n<p>面试官除了问你基础知识和项目还会去考考你的动手能力，面试时间一般不会太长，根据岗位的不同一般会让同学们写一些算法题目</p>\n<p>阿里面试，不会给你出非常变态的算法题目</p>\n<p>主要还是考察大家的动手能力、思考问题的能力、数据结构的应用能力</p>\n<p>在写代码的过程中，我也总结了自己的方法论：</p>\n<ul>\n<li>上来不要先写，审题、问清楚题目意图，不要自以为是的去理解思路，工作中 沟通需求、明确需求、提出质疑和建议是非常好的习惯</li>\n<li>接下来说思路 思路错了写到一半再去改会非常浪费时间</li>\n<li>描述清楚之后，先写代码思路的步骤注释，一边写注释，脑子里迭代一遍自己的思路是否正确，是否是最优解</li>\n<li>最后，代码规范</li>\n</ul>\n<h2> 除了上面这些常规的方面</h2>\n<p>其实，现在面试已经非常<strong>卷</strong>了，上面说的这些很多都是 <strong>八股文</strong></p>\n<p>有些学生会拿到很多面试题目和答案，反复的去记忆，面试官问问题他就开始在脑子里面检索答案</p>\n<p>我一般问几个问题就知道该学生是不是在背八股文了。</p>\n<p>对于背八股文的同学，我真的非常难过。</p>\n<p>尽管你背的很好，但不能给你过啊，得对得起自己职责，得对公司负责啊！</p>\n<p>背的在好，不如理解一个知识点，理解一个知识点会有助于你去理解很多其他的知识点，很多知识点连起来就是一个知识体系。</p>\n<p>当面试官问你体系中的任何一个问题，都可以把这个体系讲给他听，不是<strong>背诵</strong> 。</p>\n<p>深入理解问题，我会比较关注。</p>\n<p>我在面试过程中，会通过一个问题去问一串问题，慢慢就把整体体系串起来。</p>\n<p>你的<strong>比赛</strong>和<strong>论文</strong>是你的亮点，这些东西是非常重要的加分项。</p>\n<p>我也会在面试中穿插一些<strong>开放性题目</strong>，都是思考题 考验一个同学思考问题的方式。</p>\n<h2> 最后</h2>\n<p>作为一个面试官，我很想对大家说，每个企业都非常渴望人才，都希望找到最适合企业发展的人</p>\n<p>面试的时候面试官会尽量去挖掘你的价值。</p>\n<p>但是，面试时间有限，同学们一定要在有限的时间里展现出自己的<strong>能力</strong>和<strong>无限的潜力</strong> 。</p>\n<p>最后，祝愿优秀的你能找到自己理想的工作！</p>\n",
      "date_published": "2022-06-20T11:13:41.000Z",
      "date_modified": "2022-06-20T11:13:41.000Z",
      "authors": [
        {
          "name": "龙叔"
        }
      ],
      "tags": [
        "技术文章精选集"
      ]
    },
    {
      "title": "斩获 20+ 大厂 offer 的面试经验分享",
      "url": "https://javaguide.cn/high-quality-technical-articles/interview/the-experience-of-get-offer-from-over-20-big-companies.html",
      "id": "https://javaguide.cn/high-quality-technical-articles/interview/the-experience-of-get-offer-from-over-20-big-companies.html",
      "summary": "推荐语 ：很实用的面试经验分享！ 原文地址 ： https://mp.weixin.qq.com/s/HXKg6-H0kGUU2OA1DS43Bw 突然回想起当年，我也在秋招时也斩获了 20+的互联网各大厂 offer。现在想起来也是有点唏嘘，毕竟拿得再多也只能选择一家。不过许多朋友想让我分享下互联网面试方法，今天就来给大家仔细讲讲打法！ 如今金九银十已经过去，满是硝烟的求职战场上也只留下一处处炮灰。在现在这段日子，又是重新锻炼，时刻准备着明年金三银四的时候。",
      "content_html": "<blockquote>\n<p><strong>推荐语</strong> ：很实用的面试经验分享！</p>\n<br>\n<p><strong>原文地址</strong> ： https://mp.weixin.qq.com/s/HXKg6-H0kGUU2OA1DS43Bw</p>\n</blockquote>\n<p>突然回想起当年，我也在秋招时也斩获了 20+的互联网各大厂 offer。现在想起来也是有点唏嘘，毕竟拿得再多也只能选择一家。不过许多朋友想让我分享下互联网面试方法，今天就来给大家仔细讲讲打法！</p>\n<p>如今金九银十已经过去，满是硝烟的求职战场上也只留下一处处炮灰。在现在这段日子，又是重新锻炼，时刻准备着明年金三银四的时候。</p>\n<p>对于还没毕业的学生来说，明年三四月是春招补招或者实习招聘的机会；对于职场老油条来说，明年三四月也是拿完年终奖准备提桶跑路的时候。</p>\n<p>所以这段日子，就需要好好准备积累面试方法以及面试经验，明年的冲锋陷阵打下基础。这篇文章将为大家讲讲，程序员应该如何准备好技术面试。</p>\n<p>一般而言，互联网公司技术岗的招聘都会根据需要设置为 3 ～ 4 轮面试，一些 HC 较少的岗位可能还会经历 5 ～ 8 轮面试不等。除此之外，视公司情况，面试之前还可能也会设定相应的笔试环节。</p>\n<p>多轮的面试中包括技术面和 HR 面。相对来说，在整体的招聘流程中，技术面的决定性比较重要，HR 面更多的是确认候选人的基本情况和职业素养。</p>\n<p>不过在某些大厂，HR 也具有一票否决权，所以每一轮面试都该好好准备和应对。技术面试一般可分为五个部分：</p>\n<ol>\n<li>双方自我介绍</li>\n<li>项目经历</li>\n<li>专业知识考查</li>\n<li>编码能力考察</li>\n<li>候选人 Q&amp;A</li>\n</ol>\n<h2> 双方自我介绍</h2>\n<p>面试往往是以自我介绍作为开场，很多时候一段条理清晰逻辑明确的开场会决定整场面试的氛围和节奏。</p>\n<p><strong>作为候选人，我们可以在自我介绍中适当的为本次面试提供指向性的信息，以辅助面试官去发掘自己身上的亮点和长处</strong>。</p>\n<p>其实自我介绍并不是简单的个人基本情况的条条过目，而是对自己简历的有效性概括。</p>\n<p>什么是有效性概括呢，就是意味着需要对简历中的信息进行核心关键词的提取整合。一段话下来，就能够让面试官对你整体的情况有了了解，从而能够引导面试官的联系提问。</p>\n<h2> 项目经历</h2>\n<p>项目经历是面试过程中非常重要的一环，特别是在社招的面试中。一般社招的职级越高，往往越看重项目经历。</p>\n<p>而对于一般的校招生而言，几份岗位度匹配度以及项目完整性高的项目经历可以成为面试的亮点，也是决定于拿<code>SP</code> or <code>SSP</code>的关键。</p>\n<p>但是准备好项目经历，并不是一件容易的事情。很多人并不清楚应该怎样去描述自己的项目，更不知道应该在经历中如何去体现自己的优势和亮点。</p>\n<p>这里针对项目经历给大家提几点建议：</p>\n<p><strong>1、高效有条理的描述</strong></p>\n<p>项目经历的一般是简历里篇幅最大的部分，所以在面试时这部分同样重要。在表述时，语言的逻辑和条理一定要清晰，以保证面试官能够在最快的时间抓到你的项目的整体思路。</p>\n<p>相信很多人都听说过写简历的各种原则，比如<code>STAR</code>、<code>SMART</code>等。但实际上这些原则都可以用来规范自己的表达逻辑。</p>\n<p><code>STAR</code>原则相对简单，用来在面试过程中规范自己的条理非常有效。所谓<code>STAR</code>，即<code>Situation</code>、<code>Target</code>、<code>Action</code>、<code>Result</code>。这跟写论文写文档的逻辑划分大体一致。</p>\n<ul>\n<li><code>Situation</code>: 即项目背景，需要将项目提出的原因、现状以及出发点表述清楚。简单来说，就是要将项目提出的来龙去脉描述清晰。比如某某平台建设的原因，是切入用户怎样的痛点之类的。</li>\n<li><code>Target</code>: 即项目目标，这点描述的是项目预期达到或完成的程度。**最好是有可量化的指标和预期结果。**比如性能优化的指标、架构优化所带来的业务收益等等。</li>\n<li><code>Action</code>: 即方法方案，意味着完成项目具体实施的行为。这点在技术面试中最为重要，也是表现候选人能力的基础。**项目的方法或方案可以从技术栈出发，根据采用的不同技术点来具体写明解决了哪些问题。**比如用了什么框架/技术实现了什么架构/优化/设计，解决了项目中什么样的问题。</li>\n<li><code>Result</code>: 即项目获得结果，这点可以在面试中讲讲自己经历过项目后的思考和反思。这样会让面试官感受到你的成长和沉淀，会比直接的结果并动人。</li>\n</ul>\n<p><strong>2、充分准备项目亮点</strong></p>\n<p>说实话，大部分人其实都没有十分亮眼的项目，但是并不意味着没有项目经历的亮点。特别是在面试中。</p>\n<p>在面试中，你可以通过充分的准备以及深入的思考来突出你的项目亮点。比如可以从以下几个方向入手：</p>\n<ul>\n<li>充分了解项目的业务逻辑和技术架构</li>\n<li>熟悉项目的整体架构和关键设计</li>\n<li>明确的知道业务架构或技术方案选型以及决策逻辑</li>\n<li>深入掌握项目中涉及的组件以及框架</li>\n<li>熟悉项目中的疑难杂症或长期遗留 bug 的解决方案</li>\n<li>......</li>\n</ul>\n<h2> 专业知识考查</h2>\n<p>有经验的面试官往往会在对项目经历刨根问底的同时，从中考察你的专业知识。</p>\n<p>所谓专业知识，对于程序员而言就是意向岗位的计算机知识图谱。对于校招生来说，大部分都是计算机基础；而对于社招而言，很大部分可能是对应岗位的技能树。</p>\n<p>计算机基础主要就是计算机网络、操作系统、编程语言之类的，也就是所谓的八股文。虽然这些东西在实际的工作中可能用处并不多，但是却是面试官评估候选人潜力的标准。</p>\n<p>而对应岗位的技能树就需要根据具体的岗位来划分，<strong>比如说客户端岗位可能会问移动操作系统理解、端性能优化、客户端架构以及跨端框架之类的。跟直播视频相关的岗位，还会问音视频处理、通信等相关的知识。</strong></p>\n<p>而后端岗位可能就更偏向于<strong>高可用架构、事务理论、分布式中间件以及一些服务化、异步、高可用可扩展的架构设计思想</strong>。</p>\n<p>总而言之，工作经验越丰富，岗位技术能的问题也就越深入。</p>\n<p>怎么在面试前去准备这些技术点，在这里我就不过多说了， 因为很多学习路线以及说的很清楚了。</p>\n<p>这里我就讲讲在应对面试的时候，该怎样去更好的表达描述清楚。</p>\n<p>这里针对专业知识考察给大家提几点建议：</p>\n<p><strong>1、提前建立一份技术知识图谱</strong></p>\n<p>在面试之前，可以先将自己比较熟悉的知识点做一个简单的归纳总结，根据不同方向和领域画个简单的草图。这是为了辅助自己在面试时能够进行合理的扩展和延伸。</p>\n<p>面试官一问一答形式的面试总是会给人不太好的面试体验，所以在回答技术要点的过程中，要善于利用自己已有的知识图谱来进行技术广度的扩展和技术深度的钻研。这样一来能够引导面试官往你擅长的方向去提问，二来能够尽可能多的展现自己的亮点。</p>\n<p><strong>2、结合具体经验来总结理解</strong></p>\n<p>技术点本身都是非常死板和冰冷的，但是如果能够将生硬的技术点与具体的案例结合起来描述，会让人眼前一亮。同时也能够表明自己是的的确确理解了该知识点。</p>\n<p>现在网上各种面试素材应有尽有，可能你背背题就能够应付面试官的提问。但是面试官也同样知道这点，所以他能够很清楚的判别出你是否在背题。</p>\n<p>因此，结合具体的经验来解释表达问题是能够防止被误认为背题的有效方法。可能有人会问了，那具体的经验哪里去找呢。</p>\n<p>这就得靠平时的积累了，平时需要多积累沉淀，多看大厂的各类技术输出。经验不一定是自己的，也可以是从别的地方总结而来的。</p>\n<p>此外，也可以结合自己在做项目的过程中的一些技术选型经验以及技术方案更新迭代的过程进行融会贯通，相互结合的来进行表述。</p>\n<h2> 编码能力考察</h2>\n<p>编码能力考察就是咱们俗称的手撕代码，也是许多同学最害怕的一关。很多人会觉得面试结果就是看手撕代码的表现，但其实并不一定。</p>\n<p>**首先得明确的一点是，编码能力不完全等于算法能力。**很多同学面试时候算法题明明写出来了，但是最终的面试评价却是编码能力一般。还有很多同学面试时算法题死活没通过，但是面试官却觉得他的编码能力还可以。</p>\n<p>所以一定要注意区分这点，编码能力不完全等于算法能力。从公司出发，如果纯粹为了出难度高的算法题来筛选候选人，是没有意义的。因为大家都知道，进了公司可能工作几年都写不了几个算法。</p>\n<p>要记住，做算法题只是一个用来验证编码能力和逻辑思维的手段和方式。</p>\n<p>当然说到底，在准备这一块的面试时，算法题肯定得刷，但是不该盲目追求难度，甚至是死记硬背。</p>\n<p>几点面试时的建议：</p>\n<p><strong>1、数据结构和算法思想是基础</strong></p>\n<p>算法本身实际上是逻辑思考的产物，所以掌握算法思想比会做某一道题要更有意义。数据结构是帮助实现算法的工具，这也很编程的基本能力。所以这二者的熟悉程度是手撕代码的基础。</p>\n<p><strong>2、不要忽视编码规范</strong></p>\n<p>这点就是提醒大家要记住，就算是一段很简单的算法题也能够从中看出你的编码能力。这往往就体现在一些基本的编码规范上。你说你编程经验有 3 年，但是发现连基本的函数封装类型保护都不会，让人怎么相信呢。</p>\n<p><strong>3、沟通很重要</strong></p>\n<p>手撕代码绝对不是一个闭卷考试的过程，而是一个相互沟通的过程。上面也说过，考察算法也是为了考察逻辑思维能力。所以让面试官知道你思考问题的思路以及逻辑比你直接写出答案更重要。</p>\n<p>不仅如此，提前沟通清楚思路，遇到题意不明确的地方及时询问，也是节省大家时间，给面试官留下好印象的机会。</p>\n<p>此外，自己写的代码一定要经得住推敲和质疑，自己能够讲的明白。这也是能够区分「背题」和「真正会做」的地方。</p>\n<p>最后，如果代码实在写不出来，但是也可以适当的表达自己的思路并与面试官交流探讨。毕竟面试也是一个学习的过程。</p>\n<h2> 候选人 Q&amp;A</h2>\n<p>一般正常的话，都会有候选人反问环节。倘若没有，可能是想让你回家等消息。</p>\n<p>反问环节其实也可以是面试中重要的环节，因为这个时候你能够从面试官口中获得关于公司关于岗位更具体真实的信息。</p>\n<p>这些信息可以帮助我们做出更全面更理性的决策，毕竟求职也是一个双向选择的过程。</p>\n<h2> 加分项</h2>\n<p>最后，给能够坚持看到最后的同学一个福利。我们来谈谈面试中的加分项。</p>\n<p>很多同学会觉得明明面试时候的问题都答上来了，但是最终却没有通过面试，或者面试评价并不高。这很有可能就是面试过程中缺少了亮点，可能你并不差，但是没有打动面试官的地方。</p>\n<p>一般面试官会从下面几个方面去考察候选人的亮点：</p>\n<p><strong>1、沟通</strong></p>\n<p>面试毕竟是问答与表达的艺术，所以你流利的表达，清晰有条理的思路自然能够增加面试官对你的高感度。同时如果还具有举一反三的思维，那也能够从侧面证明你的潜力。</p>\n<p><strong>2、匹配度</strong></p>\n<p>这一点毋庸置疑，但是却很容易被忽视。因为往往大家都会认为，匹配度不高的都在简历筛选阶段被刷掉了。但其实在面试过程中，面试官同样也会评估面试人与岗位的匹配度。</p>\n<p>这个匹配度与工作经历强相关，与之前做过的业务和技术联系很大。特别是某些垂直领域的技术岗位，比如财经、资金、音视频等。</p>\n<p>所以在面试中，如若有跟目标岗位匹配度很高的经历和项目，可以着重详细介绍。</p>\n<p><strong>3、高业绩，有超出岗位的思考</strong></p>\n<p>这点就是可遇不可及，毕竟不是所有人都能够拿着好业绩然后跳槽。但是上一份工作所带来的好业绩，以及在重要项目中的骨干身份会为自己的经历加分。</p>\n<p>同时，如果能在面试中表现出超出岗位本身的能力，更能引起面试官注意。比如具备一定的技术视野，具备良好的规划能力，或者对业务方向有比较深入的见解。这些都能够成为亮点。</p>\n<p><strong>4、技术深度或广度</strong></p>\n<p>相信很多人都听过，职场中最受欢迎的是<code>T</code>型人才。也就是在拥有一定技术广度的基础上，在自己擅长的领域十分拔尖。这样的人才的确很难得，既要求能够胜任自己的在职工作，又能够不设边界的学习和输出其它领域的知识。</p>\n<p>除此之外，<strong>比 T 型人才更为难得是所谓 π 型人才，相比于 T 型人才，有了不止一项拔尖的领域。这类人才更是公司会抢占的资源。</strong></p>\n<h2> 总结</h2>\n<p>面试虽说是考察和筛选优秀人才的过程，但说到底还是人与人沟通并展现自我的方式。所以掌握有效面试的技巧也是帮助自己收获更多的工具。</p>\n<p>这篇文章其实算讲的是方法论，很多我们一看就明白的「道理」实施起来可能会很难。可能会遇到一个不按常理出牌的面试官，也可能也会遇到一个沟通困难的面试官，当然也可能会撞上一个不怎么匹配的岗位。</p>\n<p>总而言之，为了自己想要争取的东西，做好足够的准备总是没有坏处的。祝愿大家能成为<code>π</code>型人才，获得想要的<code>offer</code>！</p>\n",
      "date_published": "2022-06-20T11:13:41.000Z",
      "date_modified": "2022-06-20T11:13:41.000Z",
      "authors": [
        {
          "name": "业余码农"
        }
      ],
      "tags": [
        "技术文章精选集"
      ]
    },
    {
      "title": "糟糕程序员的 20 个坏习惯",
      "url": "https://javaguide.cn/high-quality-technical-articles/advanced-programmer/20-bad-habits-of-bad-programmers.html",
      "id": "https://javaguide.cn/high-quality-technical-articles/advanced-programmer/20-bad-habits-of-bad-programmers.html",
      "summary": "推荐语 ： Kaito 大佬的一篇文章，很实用的建议！ 原文地址： https://mp.weixin.qq.com/s/6hUU6SZsxGPWAIIByq93Rw 我想你肯定遇到过这样一类程序员：他们无论是写代码，还是写文档，又或是和别****人沟通，都显得特别专业。每次遇到这类人，我都在想，他们到底是怎么做到的？ 随着工作时间的增长，渐渐地我也总结出一些经验，他们身上都保持着一些看似很微小的优秀习惯，但正是因为这些习惯，体现出了一个优秀程序员的基本素养。",
      "content_html": "<blockquote>\n<p><strong>推荐语</strong> ： Kaito 大佬的一篇文章，很实用的建议！</p>\n<br>\n<p><strong>原文地址：</strong> https://mp.weixin.qq.com/s/6hUU6SZsxGPWAIIByq93Rw</p>\n</blockquote>\n<p>我想你肯定遇到过这样一类程序员：<strong>他们无论是写代码，还是写文档，又或是和别****人沟通，都显得特别专业</strong>。每次遇到这类人，我都在想，他们到底是怎么做到的？</p>\n<p>随着工作时间的增长，渐渐地我也总结出一些经验，他们身上都保持着一些看似很微小的优秀习惯，但正是因为这些习惯，体现出了一个优秀程序员的基本素养。</p>\n<p>但今天我们来换个角度，来看看一个糟糕程序员有哪些坏习惯？只要我们都能避开这些问题，就可以逐渐向一个优秀程序员靠近。</p>\n<h2> 1、技术名词拼写不规范</h2>\n<p>无论是个人简历，还是技术文档，我经常看到拼写不规范的技术名词，例如 JAVA、javascript、python、MySql、Hbase、restful。</p>\n<p>正确的拼写应该是 Java、JavaScript、Python、MySQL、HBase、RESTful，不要小看这个问题，很多面试官很有可能因为这一点刷掉你的简历。</p>\n<h2> 2、写文档，中英文混排不规范</h2>\n<p>中文描述使用英文标点符号，英文和数字使用了全角字符，中文与英文、数字之间没有空格等等。</p>\n<p>其中很多人会忽视中文和英文、数字之间加一个「空格」，这样排版阅读起来会更舒服。之前我的文章排版，都是遵循了这些细节。</p>\n<h2> 3、重要逻辑不写注释，或写得很拖沓</h2>\n<p>复杂且重要的逻辑代码，很多程序员不写注释，除了自己能看懂代码逻辑，其他人根本看不懂。或者是注释虽然写了，但写得很拖沓，没有逻辑可言。</p>\n<p>重要的逻辑不止要写注释，还要写得简洁、清晰。如果是一眼就能读懂的简单代码，可以不加注释。</p>\n<h2> 4、写复杂冗长的函数</h2>\n<p>一个函数几百行，一个文件上千行代码，复杂函数不做拆分，导致代码变得越来越难维护，最后谁也不敢动。</p>\n<p>基本的设计模式还是要遵守的，例如单一职责，一个函数只做一件事，开闭原则，对扩展开放，对修改关闭。</p>\n<p>如果函数逻辑确实复杂，也至少要保证主干逻辑足够清晰。</p>\n<h2> 5、不看官方文档，只看垃圾博客</h2>\n<p>很多人遇到问题不先去看官方文档，而是热衷于去看垃圾博客，这些博客的内容都是互相抄袭，错误百出。</p>\n<p>其实很多软件官方文档写得已经非常好了，常见问题都能找到答案，认真读一读官方文档，比看垃圾博客强一百倍，要养成看官方文档的好习惯。</p>\n<h2> 6、宣扬内功无用论</h2>\n<p>有些人天天追求日新月异的开源项目和框架，却不肯花时间去啃一啃底层原理，常见问题虽然可以解决，但遇到稍微深一点的问题就束手无策。</p>\n<p>很多高大上的架构设计，思路其实都源于底层。想一想，像计算机体系结构、操作系统、网络协议这些东西，经过多少年演进才变为现在的样子，演进过程中遇到的复杂问题比比皆是，理解了解决这些问题的思路，再看上层技术会变得很简单。</p>\n<h2> 7、乐于炫技</h2>\n<p>有些人天天把「高大上」的技术名词挂在嘴边，生怕别人不知道自己学了什么高深技术，嘴上乐于炫技，但别人一问他细节就会哑口无言。</p>\n<h2> 8、不接受质疑</h2>\n<p>自己设计的方案，别人提出疑问时只会回怼，而不是理性分析利弊，抱着学习的心态交流。</p>\n<p>这些人学了点东西就觉得自己很有本事，殊不知只是自己见识太少。</p>\n<h2> 9、接口协议不规范</h2>\n<p>和别人定 API 协议全靠口头沟通，不给规范的文档说明，甚至到了测试联调时会发现，竟然和协商的还不一样，或者改协议了却不通知对接方，合作体验极差。</p>\n<h2> 10、遇到问题自己死磕</h2>\n<p>很初级程序员容易犯的问题，遇到问题只会自己死磕，拖到 deadline 也没有产出，领导来问才知道有问题解决不了。</p>\n<p>有问题及时反馈才是对自己负责，对团队负责。</p>\n<h2> 11、一说就会，一写就废</h2>\n<p>平时技术方案吹得天花乱坠，一让他写代码就废，典型的眼高手低选手。</p>\n<h2> 12、表达没有逻辑，不站在对方角度看问题</h2>\n<p>讨论问题不交代背景，上来就说自己的方案，别人听得云里雾里，让你从头描述你又讲不明白。</p>\n<p>学会沟通和表达，是合作的基础。</p>\n<h2> 13、不主动思考，伸手党</h2>\n<p>遇到问题不去 google，不做思考就向别人提问，喜欢做伸手党。</p>\n<p>每个人的时间都很宝贵，大家都更喜欢你带着自己的思考来提问，一来可以规避很多低级问题，二来可以提高交流质量。</p>\n<h2> 14、经常犯重复的错误</h2>\n<p>出问题后说下次会注意，但下次问题依旧，对自己不负责任，说到底是态度问题。</p>\n<h2> 15、加功能不考虑扩展性</h2>\n<p>加新功能只关注某一小块业务，不考虑系统整体的扩展性，堆代码行为严重。</p>\n<p>要学会分析需求和未来可能发生的变化，设计更通用的解决方案，降低后期开发成本。</p>\n<h2> 16、接口不自测，出问题不打日志</h2>\n<p>自己开发的接口不自测就和别人联调，出了问题又说没打日志，协作效率极低。</p>\n<h2> 17、提交代码不规范</h2>\n<p>很多人提交代码不写描述，或者写的是无意义的描述，尤其是修改很少代码时，这种情况会导致回溯问题成本变高。</p>\n<p>制定代码提交规范，能让你在每一次提交代码时，不会做太随意的代码修改。</p>\n<h2> 18、手动修改生产环境数据库</h2>\n<p>直连生产环境数据库修改数据，更有 UPDATE / DELETE SQL 忘写 WEHRE 条件的情况，产生数据事故。</p>\n<p>修改生产环境数据库一定要谨慎再谨慎，建议操作前先找同事 review 代码再操作。</p>\n<h2> 19、没理清需求就直接写代码</h2>\n<p>很多程序员接到需求后，不怎么思考就开始写代码，需求和自己理解的有偏差，造成无意义返工。</p>\n<p>多花些时间梳理需求，能规避很多不合理的问题。</p>\n<h2> 20、重要设计不写文档</h2>\n<p>重要的设计没有文档输出，和别人交接系统时只做口头描述，丢失关键信息。</p>\n<p>有时候理解一个设计方案，一个好的文档要比看几百行代码更高效。</p>\n<h2> 总结</h2>\n<p>以上这些不良习惯，你命中几个呢？或者你身边有没有碰到这样的人？</p>\n<p>我认为提早规避这些问题，是成为一个优秀程序员必须要做的。这些习惯总结起来大致分为这 4 个方面：</p>\n<ul>\n<li>良好的编程修养</li>\n<li>谦虚的学习心态</li>\n<li>良好的沟通和表达</li>\n<li>注重团队协作</li>\n</ul>\n<p>优秀程序员的专业技能，我们可能很难在短时间内学会，但这些基本的职业素养，是可以在短期内做到的。</p>\n<p>希望你我可以有则改之，无则加勉。</p>\n",
      "date_published": "2022-06-20T02:18:14.000Z",
      "date_modified": "2022-06-20T02:18:14.000Z",
      "authors": [
        {
          "name": "Kaito"
        }
      ],
      "tags": [
        "技术文章精选集"
      ]
    },
    {
      "title": "如何在技术初试中考察程序员的技术能力",
      "url": "https://javaguide.cn/high-quality-technical-articles/interview/how-to-examine-the-technical-ability-of-programmers-in-the-first-test-of-technology.html",
      "id": "https://javaguide.cn/high-quality-technical-articles/interview/how-to-examine-the-technical-ability-of-programmers-in-the-first-test-of-technology.html",
      "summary": "推荐语 ：从面试官和面试者两个角度探讨了技术面试！非常不错！ 内容概览： 实战与理论结合。比如，候选人叙述 JVM 内存模型布局之后，可以接着问：有哪些原因可能会导致 OOM , 有哪些预防措施? 你是否遇到过内存泄露的问题? 如何排查和解决这类问题? 项目经历考察不宜超过两个。因为要深入考察一个项目的详情，所占用的时间还是比较大的。一般来说，会让候选人挑选一个他或她觉得最有收获的/最有挑战的/印象最深刻的/自己觉得特有意思的项目。然后围绕这个项目进行发问。通常是从项目背景出发，考察项目的技术栈、项目模块及交互的整体理解、项目中遇到的有挑战性的技术问题及解决方案、排查和解决问题、代码可维护性问题、工程质量保障等。 多问少说，让候选者多表现。根据候选者的回答适当地引导或递进或横向移动。 原文地址 ：https://www.cnblogs.com/lovesqcc/p/15169365.html",
      "content_html": "<blockquote>\n<p><strong>推荐语</strong> ：从面试官和面试者两个角度探讨了技术面试！非常不错！</p>\n<br>\n<p><strong>内容概览：</strong></p>\n<ul>\n<li>实战与理论结合。比如，候选人叙述 JVM 内存模型布局之后，可以接着问：有哪些原因可能会导致 OOM , 有哪些预防措施? 你是否遇到过内存泄露的问题? 如何排查和解决这类问题?</li>\n<li>项目经历考察不宜超过两个。因为要深入考察一个项目的详情，所占用的时间还是比较大的。一般来说，会让候选人挑选一个他或她觉得最有收获的/最有挑战的/印象最深刻的/自己觉得特有意思的项目。然后围绕这个项目进行发问。通常是从项目背景出发，考察项目的技术栈、项目模块及交互的整体理解、项目中遇到的有挑战性的技术问题及解决方案、排查和解决问题、代码可维护性问题、工程质量保障等。</li>\n<li>多问少说，让候选者多表现。根据候选者的回答适当地引导或递进或横向移动。</li>\n</ul>\n<br>\n<p><strong>原文地址</strong> ：https://www.cnblogs.com/lovesqcc/p/15169365.html</p>\n</blockquote>\n<h2> 灵魂三连问</h2>\n<ol>\n<li>你觉得人怎么样？ 【表达能力、沟通能力、学习能力、总结能力、自省改进能力、抗压能力、情绪管理能力、影响力、团队管理能力】</li>\n<li>如果让他独立完成项目的设计和实现，你觉得他能胜任吗？ 【系统设计能力、项目管理能力】</li>\n<li>他的分析和解决问题的能力，你的评价是啥？【原理理解能力、实战应用能力】</li>\n</ol>\n<h2> 考察目标和思路</h2>\n<p>首先明确，技术初试的考察目标：</p>\n<ul>\n<li>候选人的技术基础；</li>\n<li>候选人解决问题的思路和能力。</li>\n</ul>\n<p>技术基础是基石（冰山之下的东西），占七分， 解决问题的思路和能力是落地（冰山之上露出的部分），占三分。 业务和技术基础考察，三七开。</p>\n<p>核心考察目标： 分析和解决问题的能力。</p>\n<p>技术层面：深度 + 应用能力 + 广度。 对于校招或社招 P6 级别以下，要多注重 深度 + 应用能力，广度是加分项； 在 P6 之上，可增加 广度。</p>\n<ul>\n<li>校招： 基础扎实，思维敏捷。 主要考察内容：基础数据结构与算法、进程与并发、内存管理、系统调用与 IO 机制、网络协议、数据库范式与设计、设计模式、设计原则、编程习惯；</li>\n<li>社招： 经验丰富，里外兼修。 主要考察内容：有一定深度的基础技术机制，比如 Java 内存模型及内存泄露、 JVM 机制、类加载机制、数据库索引及查询优化、缓存、消息中间件、项目、架构设计、工程规范等。</li>\n</ul>\n<h3> 技术基础是什么?</h3>\n<p>作为技术初试官，怎么去考察技术基础？究竟什么是技术基础？是知道什么，还是知道如何思考？知识作为现有的成熟原理体系，构成了基础的重要组成部分，而知道如何思考亦尤为重要。俗话说，知其然而知其所以然。知其然，是指熟悉现有知识体系，知其所以然，则是自底向上推导，真正理解知识的来龙去脉，理解为何是这样而不是那样。毕竟，对于本质是逻辑的程序世界而言，并无定法。知道如何思考，并能缜密地设计和开发，深入到细节，这就是技术基础吧。</p>\n<h3> 为什么要考察技术基础?</h3>\n<p>程序员最重要的两种技术思维能力，是逻辑思维能力和抽象设计能力。逻辑思维能力是基础，抽象设计能力是高阶。 考察技术基础，正好可以同时考察这两种思维能力。能不能理解基础技术概念及关联，是考察逻辑思维能力；能不能把业务问题抽象成技术问题并合理的组织映射，是考察抽象设计能力。</p>\n<p>绝大部分业务问题，都可以抽象成技术问题。在某种意义上，业务问题只是技术问题的领域化表述。</p>\n<p>因此，通过技术基础考察候选者，才能考察到候选者的真实技术实力：技术深度和广度。</p>\n<h3> 为什么不能单考察业务维度？</h3>\n<p>因为业务方面通常比较熟悉，可能就直接按照现有方案说出来了，很难考察到候选人的深入理解、横向拓展和归纳总结能力。</p>\n<p>这一点，建议有针对性地考察下候选人的归纳总结能力：比如， 微服务搭建或开发或维护/保证系统稳定性或性能方面的过程中，你收获了哪些可以分享的经验？</p>\n<h3> 为什么要考察业务维度？</h3>\n<p>技术基础考察，容易错过的地方是，候选人的非技术能力特质，比如沟通组织能力、带项目能力、抗压能力、解决实际问题的能力、团队影响力、其它性格特质等。</p>\n<h2> 考察方法</h2>\n<h3> 技术基础考察</h3>\n<p>技术基础怎么考察？通过有效的多角度的发问模式来考察。</p>\n<p><strong>是什么-为什么</strong></p>\n<p>是什么考察对概念的基本理解，为什么考察对概念的实现原理。</p>\n<p>比如索引是什么？ 索引是如何实现的？</p>\n<p><strong>引导-横向发问-深入发问</strong></p>\n<p>引导性，比如 “你对 java 同步工具熟悉吗？” 作个试探，得到肯定答复后，可以进一步问： “你熟悉哪些同步工具类？” 了解候选者的广度；</p>\n<p>获取候选者的回答后，可以进一步问：“ 谈谈 ConcurrentHashMap 或 AQS 的实现原理？”</p>\n<p>一个人在多大程度上把技术原理能讲得清晰，包括思路和细节，说明他对技术的掌握能力有多强。</p>\n<p><strong>深度有梯度和层次的发问</strong></p>\n<p>设置三个深度层次的发问。每个深度层次可以对应到某个技术深度。</p>\n<ul>\n<li>第一个发问是基本概念层次，考察候选人对概念的理解能力和深度；</li>\n<li>第二个发问是原理机制层次，考察候选人对概念的内涵和外延的理解深度；</li>\n<li>第三个发问是应用层次，考察候选人的应用能力和思维敏捷程度。</li>\n</ul>\n<p><strong>跳跃式/交叉式发问</strong></p>\n<p>比如，讲到哈希高效查找，可以谈谈哈希一致性算法 。 两者既有关联又有很多不同点。也是一种技术广度的考察方法。</p>\n<p><strong>总结性发问</strong></p>\n<p>比如，你在做 XXX 中，获得了哪些可以分享的经验？ 考察候选人的归纳总结能力。</p>\n<p><strong>实战与理论结合</strong></p>\n<ul>\n<li>比如，候选人叙述 JVM 内存模型布局之后，可以接着问：有哪些原因可能会导致 OOM , 有哪些预防措施? 你是否遇到过内存泄露的问题? 如何排查和解决这类问题?</li>\n<li>比如，候选人有谈到 SQL 优化和索引优化，那就正好谈谈索引的实现原理，如何建立最佳索引？</li>\n<li>比如，候选人有谈到事务，那就正好谈谈事务实现原理，隔离级别，快照实现等；</li>\n</ul>\n<p><strong>熟悉与不熟悉结合</strong></p>\n<p>针对候选人简历上写的熟悉的部分，和没有写出的都问下。比如候选人简历上写着：熟悉 JVM 内存模型， 那我就考察下内存管理相关（熟悉部分），再考察下 Java 并发工具类（不确定是否熟悉部分）。</p>\n<p><strong>死知识与活知识结合</strong></p>\n<p>比如，查找算法有哪些？顺序查找、二分查找、哈希查找。这些大家通常能说出来，也是“死知识”。</p>\n<p>这些查找算法各适用于什么场景？在你工作中，有哪些场景用到了哪些查找算法？为什么？ 这些是“活知识”。</p>\n<p><strong>学习或工作中遇到的</strong></p>\n<p>有时，在学习和工作中遇到的问题，也可以作为面试题。</p>\n<p>比如，最近在学习《操作系统导论》并发部分，有一章节是如何使数据结构成为线程安全的。这里就有一些可以提问的地方：如何实现一个锁？如何实现一个线程安全的计数器？如何实现一个线程安全的链表？如何实现一个线程安全的 Map ？如何提升并发的性能？</p>\n<p>工作中遇到的问题，也可以抽象提炼出来，作为技术基础面试题。</p>\n<p><strong>技术栈适配度发问</strong></p>\n<p>如果候选人（简历上所写的）使用的某些技术与本公司的技术栈比较契合，则可以针对这些技术点进行深入提问，考察候选人在这些技术点的掌握程度。如果掌握程度比较好，则技术适配度相对更高一些。</p>\n<p>当然，这一点并不能作为筛掉那些没有使用该技术栈的候选人的依据。比如本公司使用 MongoDB 和 MySQL， 而一个候选人没有用过 Mongodb， 但使用过 MySQL, Redis, ES, HBase 等多种存储系统，那么适配度并不比仅使用过 MySQL 和 Mongodb 的候选人逊色，因为他所涉及的技术广度更大，可以推断出他有足够能力掌握 Mongodb。</p>\n<p><strong>应对背题式面试</strong></p>\n<p>首先，背题式面试，说明候选人至少是有做准备的。当然，对于招聘的一方来说，更希望找到有能力而不是仅记忆了知识的候选人。</p>\n<p>应对背题式面试，可以通过 “引导-横向发问-深入发问” 的方式，先对候选人关于某个知识点的深度和广度做一个了解，然后出一道实际应用题来考察他是否能灵活使用知识。</p>\n<p>比如 Java 线程同步机制，可以出一道题：线程 A 执行了一段代码，然后创建了一个异步任务在线程 B 中执行，线程 A 需要等待线程 B 执行完成后才能继续执行，请问怎么实现？</p>\n<p>”理论 + 应用题“的模式。敌知我之变，而不知我变之形。变之形，不计其数。</p>\n<p><strong>实用不生僻</strong></p>\n<p>考察工作中频繁用到的知识、技能和能力，不考察冷僻的知识。</p>\n<p>比如我偏向考察数据结构与算法、并发、设计 这三类。因为这三类非常基础非常核心。</p>\n<p><strong>综合串联式发问</strong></p>\n<p>知识之间总是相互联系着的，不要单独考察一个知识点。</p>\n<p>设计一个初始问题，比如说查找算法，然后从这个初始问题出发，串联起各个知识点。比如：</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/open-source-project/502996-20220211115505399-72788909.png\" alt=\"\"></p>\n<p>在每一个技术点上，都可以应用以上发问技巧，导向不同的问题分支。同时考察面试者的深度、广度和应用能力。</p>\n<p><strong>创造有个性的面试题库</strong></p>\n<p>每个技术面试官都会有一个面试题库。持续积累面试题库，日常中突然想到的问题，就随手记录下来。</p>\n<h3> 解决问题能力考察</h3>\n<p>仅仅只是技术基础还不够，通常最好结合实际业务，针对他项目里的业务，抽象出技术问题进行考察。</p>\n<p>解决思路重在层层递进。这一点对于面试官的要求也比较高，兼具良好的倾听能力、技术深度和业务经验。首先要仔细倾听候选人的阐述，找到适当的技术切入点，然后进行发问。如果进不去，那就容易考察失败。\n常见问题：</p>\n<ul>\n<li>性能方面，qps, tps 多少？采用了什么优化措施，达成了什么效果？</li>\n<li>如果有大数据量，如何处理？如何保证稳定性？</li>\n<li>你觉得这个功能/模块/系统的关键点在哪里？有什么解决方案？</li>\n<li>为什么使用 XXX 而不是 YYY ？</li>\n<li>长字段如何做索引？</li>\n<li>还有哪些方案或思路？各自的利弊？</li>\n<li>第三方对接，如何应对外部接口的不稳定性？</li>\n<li>第三方对接，对接大量外部系统，代码可维护性？</li>\n<li>资损场景？严重故障场景？</li>\n<li>线上出现了 CPU 飙高，如何处理？ OOM 如何处理？ IO 读写尖刺，如何排查？</li>\n<li>线上运行过程中，出现过哪些问题？如何解决的？</li>\n<li>多个子系统之间的数据一致性问题？</li>\n<li>如果需要新增一个 XXX 需求，如何扩展？</li>\n<li>重来一遍，你觉得可以在哪些方面改进？</li>\n</ul>\n<p>系统可问的关联问题：</p>\n<ul>\n<li>绝大多数系统都有性能相关问题。如果没有性能问题，则说明是小系统，小系统就不值得考察了；</li>\n<li>中大型系统通常有技术选型问题；</li>\n<li>绝大多数系统都有改进空间；</li>\n<li>大多数业务系统都涉及可扩展性问题和可维护性问题；</li>\n<li>大多数重要业务系统都经历过比较惨重的线上教训；</li>\n<li>大数据量系统必定有稳定性问题；</li>\n<li>消费系统必定有时延和堆积问题；</li>\n<li>第三方系统对接必定涉及可靠性问题；</li>\n<li>分布式系统必定涉及可用性问题；</li>\n<li>多个子系统协同必定涉及数据一致性问题；</li>\n<li>交易系统有资损和故障场景；</li>\n</ul>\n<p><strong>设计问题</strong></p>\n<ul>\n<li>比如多个机器间共享大量业务对象，这些业务对象之间有些联合字段是重复的，如何去重？ 如果字段比较长，怎么处理？</li>\n<li>如果瞬时有大量请求涌入，如何保证服务器的稳定性？</li>\n<li>组件级别：设计一个本地缓存？ 设计一个分布式缓存？</li>\n<li>模块级别：设计一个任务调度模块？需要考虑什么因素？</li>\n<li>系统级别：设计一个内部系统，从各个部门获取销售数据然后统计出报表。复杂性体现在哪里？关键质量属性是哪些？模块划分，模块之间的关联关系？技术选型？</li>\n</ul>\n<p><strong>项目经历</strong></p>\n<p>项目经历考察不宜超过两个。因为要深入考察一个项目的详情，所占用的时间还是比较大的。</p>\n<p>一般来说，会让候选人挑选一个他或她觉得最有收获的/最有挑战的/印象最深刻的/自己觉得特有意思/感受到挫折的项目。然后围绕这个项目进行发问。通常是从项目背景出发，考察项目的技术栈、项目模块及交互的整体理解、项目中遇到的有挑战性的技术问题及解决方案、排查和解决问题、代码可维护性问题、工程质量保障、重来一遍可以改进哪些等。</p>\n<h2> 面试过程</h2>\n<h3> 预先准备</h3>\n<p>面试官也需要做一些准备。比如熟悉候选者的技能优势、工作经历等，做一个面试设计。</p>\n<p>在面试将要开始时，做好面试准备。此外，面试官也需要对公司的一些基本情况有所了解，尤其是公司所使用技术栈、业务全景及方向、工作内容、晋升制度等，这一点技术型候选人问得比较多。</p>\n<h3> 面试启动</h3>\n<p>一般以候选人自我介绍启动，不过候选人往往会谈得比较散，因此，我会直接提问：谈谈你有哪些优势以及自己觉得可以改进的地方？</p>\n<p>然后以一个相对简单的基础题作为技术提问的开始：你熟悉哪些查找算法？大多数人是能答上顺序查找、二分查找、哈希查找的。</p>\n<h3> 问题设计</h3>\n<p>提前阅读候选人简历，从简历中筛选出关键词，根据这些关键词进行有针对性地问题设计。</p>\n<p>比如候选人简历里提到 MVVM ，可以问 MVVM 与 MVC 的区别； 提到了观察者模式，可以谈谈观察者模式，顺便问问他还熟悉哪些设计模式。</p>\n<p>可遵循“优势-标准-随机”原则：</p>\n<ul>\n<li>首先，问他对哪方面技术感兴趣、投入较多（优势部分），根据其优势部分，阐述原理及实战应用；</li>\n<li>其次，问若干标准化的问题，看看他的原理理解、实战应用如何；</li>\n<li>最后，随机选一个问题，看看他的原理理解、实战应用如何；</li>\n</ul>\n<p>对于项目同样可以如此：</p>\n<ul>\n<li>首先，问他最有成就感的项目，技术栈、模块及关联、技术选型、设计关键问题、解决方案、实现细节、改进空间；</li>\n<li>其次，问他有挫折感的项目，问题在哪里、做过什么努力、如何改进；</li>\n</ul>\n<h3> 宽松氛围</h3>\n<p>即使问的问题比较多比较难，也要注意保持宽松氛围。</p>\n<p>在面试前，根据候选人基本信息适当调侃一下，比如一位候选人叫汪奎，那我就说：之前我们团队有位叫袁奎，我们都喊他奎爷。</p>\n<p>在面试过程中，适当提示，或者给出少量自己的看法，也能缓解候选人的紧张情绪。</p>\n<h3> 学会倾听</h3>\n<p>多问少说，让候选者多表现。根据候选者的回答适当地引导或递进或横向移动。</p>\n<p>引导候选人表现他最优势的一面，让他或她感觉好一些：毕竟一场面试双方都付出了时间和精力，不应该是面试官 Diss 候选人的场合，而应该让彼此有更好的交流。很大可能，你也能从候选人那里学到不少东西。</p>\n<p>面试这件事，只不过双方的角色和立场有所不同，但并不代表面试官的水平就一定高于候选人。</p>\n<h3> 记录重点</h3>\n<p>认真客观地记录候选人的回答，尽可能避免任何主观评价，亦不作任何加工（比如自己给总结一下，总结能力也是候选人的一个特质）。</p>\n<h3> 多练习</h3>\n<p>模拟面试。</p>\n<h3> 作出判断</h3>\n<p>面试过程是一种铺垫，关键的是作出判断。</p>\n<p>作出判断最容易陷入误区的是：贪深求全。总希望候选人技术又深入又全面。实际上，这是一种奢望。如果候选人的技术能力又深入又全面，很可能也会面临两种情况：1. 候选人有更好的选择； 2. 候选人在其它方面可能存在不足，比如团队协作方面。</p>\n<p>一个比较合适的尺度是：1. 他或她的技术水平能否胜任当前工作； 2. 他或她的技术水平与同组团队成员水平如何； 3. 他或她的技术水平是否与年限相对匹配，是否有潜力胜任更复杂的任务。</p>\n<h3> 不同年龄看重的东西不一样</h3>\n<p>对于三年以下的工程师，应当更看重其技术基础，因为这代表着他的未来潜能；同时也考察下他在实际开发中的体现，比如团队协作、业务经验、抗压能力、主动学习的热情和能力等。</p>\n<p>对于三年以上的工程师，应当更看重其业务经验、解决问题能力，看看他或她是如何分析具体问题，在业务范畴内考察其技术基础的深度和广度。</p>\n<p>如何判断一个候选人的真实技术水平及是否适合所需，这方面，我也在学习中。</p>\n<h2> 面试初上路</h2>\n<ul>\n<li>提前准备好摄像头和音频，可以用耳机测试下。</li>\n<li>提前阅读候选人简历，从中筛选关键字，准备几个基本问题。</li>\n<li>多问技术基础题，培养下面试感觉。</li>\n<li>适当深入问下原理和实现。</li>\n<li>如果候选人简历有突出的地方，就先问那个部分；如果没有，就让候选人介绍项目背景，根据项目背景及经验来提问。</li>\n<li>小量练习“连问”技巧，直到能够熟悉使用。</li>\n<li>着重考察分析和解决问题的能力，必要的话，可以出个编程题。</li>\n<li>留出时间给对方问：你有什么想问的？并告知对方三个工作日内回复面试结果。</li>\n</ul>\n<h2> 高效考察</h2>\n<p>当作为技术面试官有一定熟悉度时，就需要提升面试效率。即：在更少的时间内有效考察候选人的技术深度和技术广度。可以准备一些常见的问题，作为标准化测试。</p>\n<p>比如我喜欢考察内存管理及算法、数据库索引、缓存、并发、系统设计、问题分析和思考能力等子主题。</p>\n<ul>\n<li>熟悉哪些用于查找的数据结构和算法？ 请任选一种阐述其思想以及你认为有意思的地方。</li>\n<li>如果运行到一个 Java 方法，里面创建了一个对象列表，内存是如何分配的？什么时候可能导致栈溢出？什么时候可能导致 OOM ？ 导致 OOM 的原因有哪些？如何避免？ 线上是否有遇到过 OOM ，怎么解决的？</li>\n<li>Java 分代垃圾回收算法是怎样的？ 项目里选用的垃圾回收器是怎样的？为什么选择这个回收器而不是那个？</li>\n<li>Java 并发工具有哪些？不同工具适合于什么场景？</li>\n<li><code>Atomic</code> 原子类的实现原理 ？ <code>ConcurrentHashMap</code> 的实现原理？</li>\n<li>如何实现一个可重入锁？</li>\n<li>举个项目中的例子，哪些字段使用了索引？为什么是这些字段？你觉得还有什么优化空间？如何建一个好的索引？</li>\n<li>缓存的可设置的参数有哪些？分别的影响是什么？</li>\n<li>Redis 过期策略有哪些？ 如何选择 redis 过期策略？</li>\n<li>如何实现病毒文件检测任务去重？</li>\n<li>熟悉哪些设计模式和设计原则？</li>\n<li>从 0 到 1 搭建一个模块/完整系统？你如何着手？</li>\n</ul>\n<p>如果候选人答不上，可以问：如果你来设计这样一个 XXX， 你会怎么做？</p>\n<p>时间占比大概为 ： 技术基础（25-30 分钟） + 项目（20-25 分钟） + 候选人提问（5-10 分钟）</p>\n<h2> 给候选人的话</h2>\n<p><strong>为什么候选人需要关注技术基础</strong></p>\n<p>一个常见的疑惑是：开发业务系统的大多数时候，基本不涉及数据结构与算法的设计与实现，为什么要考察 <code>HashMap</code> 的实现原理？为什么要学好数据结构与算法、操作系统、网络通信这些基础课程？</p>\n<p>现在我可以给出一个答案了：</p>\n<ul>\n<li>正如上面所述，绝大多数的业务问题，实际上最终都会映射到基础技术问题上：数据结构与算法的实现、内存管理、并发控制、网络通信等；这些是理解现代互联网大规模程序以及解决程序疑难问题的基石，—— 除非能祝福自己永远都不会遇到疑难问题，永远都只满足于编写 CRUD；</li>\n<li>这些技术基础正是程序世界里最有趣最激动人心的地方。如果对这些不感兴趣，就很难在这个领域里深入进去，不如及早转行从事其它职业，非技术的世界一直都很精彩广阔（有时我也想多出去走走，不想局限于技术世界）；</li>\n<li>技术基础是程序员的内功，而具体技术则是招式。徒有招式而内功不深，遇到高手（优秀同行从业者的竞争及疑难杂症）容易不堪一击；</li>\n<li>具备扎实的专业技术基础，能达到的上限更高，未来更有可能胜任复杂的技术问题求解，或者在同样的问题上能够做到更好的方案；</li>\n<li>人们喜欢跟与自己相似的人合作，牛人倾向于与牛人合作能得到更好的效果；如果一个团队大部分人技术基础比较好，那么进来一个技术基础比较薄弱的人，协作成本会变高；如果你想和牛人一起合作拿到更好的结果，那就要让自己至少在技术基础上能够与牛人搭配的上；</li>\n<li>在 CRUD 的基础上拓展其它才能也不失为一种好的选择，但这不会是一个真正的程序员的姿态，顶多是有技术基础的产品经理、项目经理、HR、运营、客满等其它岗位人才。这是职业选择的问题，已经超出了考察程序员的范畴。</li>\n</ul>\n<p><strong>不要在意某个问题回答不上来</strong></p>\n<p>如果面试官问你很多问题，而有些没有回答上来，不要在意。面试官很可能只是在测试你的技术深度和广度，然后判断你是否达到某个水位线。</p>\n<p>重点是：有些问题你答得很有深度，也体现了你的深度思考能力。</p>\n<p>这一点是我当了技术面试官才领会到的。当然，并不是每位技术面试官都是这么想的，但我觉得这应该是个更合适的方式。</p>\n<h2> 参考资料</h2>\n<ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/51404304\" target=\"_blank\" rel=\"noopener noreferrer\">技术面试官的 9 大误区</a></li>\n<li><a href=\"https://www.zhihu.com/question/26240321\" target=\"_blank\" rel=\"noopener noreferrer\">如何当一个好的面试官？</a></li>\n</ul>\n",
      "image": "https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/open-source-project/502996-20220211115505399-72788909.png",
      "date_published": "2022-06-20T02:18:14.000Z",
      "date_modified": "2022-06-20T02:18:14.000Z",
      "authors": [
        {
          "name": "琴水玉"
        }
      ],
      "tags": [
        "技术文章精选集"
      ]
    },
    {
      "title": "普通人的春招总结（阿里、腾讯offer）",
      "url": "https://javaguide.cn/high-quality-technical-articles/interview/summary-of-spring-recruitment.html",
      "id": "https://javaguide.cn/high-quality-technical-articles/interview/summary-of-spring-recruitment.html",
      "summary": "推荐语 ： 牛客网热帖，写的很全面！暑期实习，投了阿里、腾讯、字节，拿到了阿里和腾讯的 offer。 原文地址： https://www.nowcoder.com/discuss/640519 下篇 ：十年饮冰，难凉热血——秋招总结",
      "content_html": "<blockquote>\n<p><strong>推荐语</strong> ： 牛客网热帖，写的很全面！暑期实习，投了阿里、腾讯、字节，拿到了阿里和腾讯的 offer。</p>\n<br>\n<p><strong>原文地址：</strong> https://www.nowcoder.com/discuss/640519</p>\n<br>\n<p><strong>下篇</strong> ：<a href=\"https://www.nowcoder.com/discuss/804679\" target=\"_blank\" rel=\"noopener noreferrer\">十年饮冰，难凉热血——秋招总结</a></p>\n</blockquote>\n<h2> 背景</h2>\n<p>写这篇文章的时候，腾讯 offer 已经下来了，春招也算结束了，这次找暑期实习没有像去年找日常实习一样海投，只投了 BAT 三家，阿里和腾讯收获了 offer，字节没有给面试机会，可能是笔试太拉垮了。</p>\n<p>楼主大三，双非本科，我的春招的起始时间应该是 2 月 20 日到 3 月 23 日收到阿里意向书为止，但是从 3 月 7 日蚂蚁技术终面面完之后就没有面过技术面了，只面过两个 HR 面，剩下的时间都在等 offer。最开始是找朋友内推了字节财经的日常实习，但是到现在还在简历评估，后面又投了财经的暑期实习，笔试之后就一直卡在流程里了。腾讯是一开始被天美捞了，一面挂了之后被 PCG 捞了，最后走完了流程。阿里提前批投了好多部门，蚂蚁最先走完了终面，就录入了系统，最后拿了 offer。这一路走过来真的是酸甜苦辣都经历过，因为学历自卑过，以至于想去考研。总而言之，一定要找一个搭档和你一起复习，比如说 @你怕是个憨批哦，这是我实验室的同学，也是我们实验室的队长，这个人是真的强，阿里核心部门都拿遍了，他在我复习的过程中给了我很多帮助。</p>\n<h2> 写这个帖子的目的</h2>\n<ol>\n<li>写给自己：总结反思一下大学前三年以及找工作的一些经历与感悟。</li>\n<li>写给还在找实习的朋友：希望自己的经历以及面经]能给你们一些启发和帮助。</li>\n<li>写给和我一样有着大厂梦的学弟学妹们：你们还有很长的准备时间，无论你之前在干什么，没有目标也好，碌碌无为也好，没找对方向也好，只要从现在开始，找对学习的方向，并且坚持不懈的学上一年两年，一定可以实现你的梦想的。</li>\n</ol>\n<h2> 我的大学经历</h2>\n<p>先简单聊聊一下自己大学的经历。</p>\n<p>本人无论文、无比赛、无 ACM，要啥奖没啥奖，绩点还行，不是很拉垮，也不亮眼。保研肯定保不了，考研估计也考不上。</p>\n<p>大一时候加入了工作室，上学期自学了 C 语言和数据结构，从寒假开始学 Java，当时还不知道 Java 那么卷，我得到的消息是 Java 好找工作，这里就不由得感叹信息差的重要性了，我当时只知道前端、后端和安卓开发，而我确实对后端开发感兴趣，但是因为信息差，我只知道 Java 可以做后端开发，并不知道后端开发其实是一个很局限的概念，后面才慢慢了解到后台开发、服务端开发这些名词，也不知道 C++、Golang 等语言也可以做后台开发，所以就学了 Java。但其实 Java 更适合做业务，C++ 更适合做底层开发、服务端开发，我虽然对业务不反感，但是对 OS、Network 这些更感兴趣一些，当然这些会作为我的一些兴趣，业余时间会自己去研究下。</p>\n<h3> 学习路线</h3>\n<p>大概学习的路线就是：Java SE 基础 -&gt; MySQL -&gt; Java Web（主要包括 JDBC、Servlet、JSP 等）-&gt; SSM（其实当时 Spring Boot 已经兴起，但是我觉得没有 SSM 基础很难学会 Spring Boot，就先学了 SSM）-&gt; Spring Boot -&gt; Spring Cloud（当时虽然学了 Spring Cloud，但是缺少项目的锤炼，完全不会用，只是了解了分布式的一些概念）-&gt; Redis -&gt; Nginx -&gt; 计算机网络（本来是计算机专业的必修课，可是我们专业要到大三下才学，所以就提前自学了）-&gt; Dubbo -&gt; Zookeeper -&gt; JVM -&gt; JUC -&gt; Netty -&gt; Rabbit MQ -&gt; 操作系统（同计算机网络）-&gt; 计算机组成原理（直接不开这门课）。</p>\n<p>这就是我的一个具体的学习路线，大概是在大二的下学期学完的这些东西，都是通过看视频学的，只会用，并不了解底层原理，达不到面试八股文的水准，把这些东西学完之后，搭建起了知识体系，就开始准备面试了，大概的开始时间是去年的六月份，开始在牛客网上看一些面经，然后会自己总结。准备面试的阶段我觉得最重要的是啃书 + 刷题，八股文只是辅助，我们只是自嘲说面试就背背八股文，但其实像阿里这样的公司，背八股文是完全不能蒙混过关的，除非你有非常亮眼的项目或者实习经历。</p>\n<h3> 书籍推荐</h3>\n<ul>\n<li>《Thinking in Java》：不多说了，好书，但太厚了，买了没看。</li>\n<li>《深入理解 Java 虚拟机》：JVM 的圣经，看了两遍，每一遍都有不同的收获。</li>\n<li>《Java 并发编程的艺术》：阿里人写的，基本涵盖了面试会问的并发编程的问题。</li>\n<li>《MySQL 技术内幕》：写的很深入，但是对初学者可能不太友好，第一感觉写的比较深而杂，后面单独去看每一章节，觉得收获很大。</li>\n<li>《Redis 设计与实现》：书如其名，结合源码深入讲解了 Redis 的实现原理，必看。</li>\n<li>《深入理解计算机系统》：大名鼎鼎的 CSAPP，对你面 Java 可能帮助不是很大，但是不得不说这是一本经典，涵盖了计算机系统、体系结构、组成原理、操作系统等知识，我蚂蚁二面的时候就被问了遇到的最大的困难，我就和面试官交流了读这本书中遇到的一些问题，淘系二面的时候也和面试官交流了这本书，我们都觉得这本书还需要二刷。</li>\n<li>《TCP/IP 详解卷 1》：我只看了 TCP 相关的章节，但是是有必要通读一遍的，面天美时候和面试官交流了这本书。</li>\n<li>《操作系统导论》：颇具盛名的 OSTEP，南大操作系统的课本，看的时候可以结合在 B 站蒋炎岩老师的视频，我会在下面放链接。</li>\n</ul>\n<p>这几本书理解透彻了，我相信面试的时候可以面试官面试官聊的很深入了，面试官也会对你印象非常好。但是对于普通人来说，看一遍是肯定记不住的，遗忘是非常正常的现象，我很多也只看了一遍，很多细节也记不清了，最近准备二刷。</p>\n<p>更多书籍推荐建议大家看 <a href=\"https://javaguide.cn/books/\" target=\"_blank\" rel=\"noopener noreferrer\">JavaGuide</a> 这个网站上的书籍推荐，比较全面。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/62099c9b2fd24d3cb6511e49756f486b~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"\"></p>\n<h3> 教程推荐</h3>\n<p>我上面谈到的学习路线，我建议是跟着视频学，尚硅谷和黑马的教程都可以，一定要手敲一遍。</p>\n<ul>\n<li><a href=\"https://www.bilibili.com/video/BV1HN41197Ko\" target=\"_blank\" rel=\"noopener noreferrer\">2021 南京大学 “操作系统：设计与实现” (蒋炎岩)</a>： 我不多说了，看评论就知道了。</li>\n<li><a href=\"https://www.bilibili.com/video/BV16J41127jq\" target=\"_blank\" rel=\"noopener noreferrer\">SpringSecurity-Social-OAuth2 社交登录接口授权鉴权系列课程</a> ：字母哥讲的 Spring Security 也很好，Spring Security 或者 Shiro 是做项目必备的，会一个就好，根据实际场景以及个人喜好（笑）来选型。</li>\n<li><a href=\"https://www.bilibili.com/video/BV1jt4y117KR\" target=\"_blank\" rel=\"noopener noreferrer\">清华大学邓俊辉数据结构与算法</a> ：清华不解释了。</li>\n<li><a href=\"https://time.geekbang.org/column/intro/100020801\" target=\"_blank\" rel=\"noopener noreferrer\">MySQL 实战 45 讲</a>：前 27 讲多看几遍基本可以秒杀面试中遇到的 MySQL 问题了。</li>\n<li><a href=\"https://time.geekbang.org/column/intro/100056701\" target=\"_blank\" rel=\"noopener noreferrer\">Redis 核心技术与实战</a>：讲解了大量的 Redis 在生产上的使用场景，和《Redis 设计与实现》配合着看，也可以秒杀面试中遇到的 Redis 问题了。</li>\n<li><a href=\"https://javaguide.cn/books/\" target=\"_blank\" rel=\"noopener noreferrer\">JavaGuide</a> ：「Java 学习+面试指南」一份涵盖大部分 Java 程序员所需要掌握的核心知识。</li>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247519384&amp;idx=1&amp;sn=bc7e71af75350b755f04ca4178395b1a&amp;chksm=cea1c353f9d64a458f797696d4144b4d6e58639371a4612b8e4d106d83a66d2289e7b2cd7431&amp;token=660789642&amp;lang=zh_CN&amp;scene=21#wechat_redirect\" target=\"_blank\" rel=\"noopener noreferrer\">《Java 面试指北》</a>：这是一份教你如何更高效地准备面试的小册，涵盖常见八股文（系统设计、常见框架、分布式、高并发 ......）、优质面经等内容。</li>\n</ul>\n<h2> 找工作</h2>\n<p>大概是去年 11 月的时候，牛客上日常实习的面经开始多了起来，我也有了找实习的意识，然后就开始一边复习一边海投，投了很多公司，给面试机会的就那几家，腾讯二面挂了两次，当时心态完全崩了，甚至有了看空春招的想法。很幸运最后收获了一个实习机会，在实习的时候，除了完成日常的工作以外，其余时间也没有松懈，晚上下班后、周末的时间都用来复习，心里也暗暗下定决心，春招一定要卷土重来！</p>\n<p>从二月下旬开始海投阿里提前批，基本都有了面试，开系统那天收到了 16 封内推邮件，具体的面经可以看我以前发的文章。</p>\n<p>从 3.1 到 3.7 那一个周平均每天三场面试，真的非常崩溃，一度想考研，也焦虑过、哭过、笑过，还好结果是好的，最后也去了一直想去的支付宝。</p>\n<p>我主要是想通过自己对面试过程的总结给大家提一些建议，大佬不喜勿喷。</p>\n<h3> 面试准备</h3>\n<p>要去面试首先要准备一份简历，我个人认为一份好的简历应该有一下三个部分：</p>\n<ol>\n<li>完整的个人信息，这个不多说了吧，个人信息不完整面试官或 HR 都联系不上你，就算学校不好也要写上去，因为听说有些公司没有学校无法进行简历评估，非科班或者说学校不太出名可以将教育信息写在最下面。</li>\n<li>项目/实习经历，项目真的很重要，面试大部分时间会围绕着项目来，你项目准备好了可以把控面试的节奏，引导面试官问你擅长的方向，我就是在这方面吃了亏。如果没有项目怎么办，可以去 GitHub 上找一些开源的项目，自己跟着做一遍，加入一些自己的思考和理解。还有做项目不能简单实现功能，还要考虑性能和优化，面试官并不关注你这个功能是怎么实现的，他想知道的是你是如何一步步思考的，一开始的方案是什么，后面选了什么方案，对性能有哪些提升，还能再改进吗？</li>\n<li>具备的专业技能，这个可以简单的写一下你学过的专业知识，这样可以让面试官有针对的问一些基础知识，切忌长篇罗列，最擅长的一定要写在上面，依次往下。</li>\n</ol>\n<p>简历写好了之后就进入了投递环节，最好找一个靠谱的内推人，因为内推人可以帮你跟进面试的进度，必要时候和 HR 沟通，哪怕挂了也可以告诉你原因，哪些方面表现的不好。现在内推已经不再是门槛，而是最低的入场券，没有认识的人内推也可以在牛客上找一些师兄内推，他们往往也很热情。</p>\n<p>在面试过程中一定不要紧张，因为一面面试官可能比我们大不了几岁，也工作没几年，所以 duck 不必紧张的不会说话，不会就说不会，然后笑一下，会就流利的表达出来，面试并不是一问一答，面试是沟通，是交流，你可以大胆的说出自己的思考，表达沟通能力也是面试的一个衡量指标。</p>\n<p>我个人认为面试和追妹子是差不多的，都是尽快的让对方了解自己，发现你身上的闪光点，只不过面试是让面试官了解你在技术上的造诣。所以，自我介绍环节就变得非常重要，你可以简单介绍完自己的个人信息之后，介绍一下你做过的项目，自我介绍最好长一些，因为在面试前，面试官可能没看过你的简历（逃），你最好留给面试官充足的时间去看你的简历。自我介绍包括项目的介绍可以写成一遍文档，多读几遍，在面试的时候能够背下来，实在不行也可以照着读。</p>\n<h3> 项目</h3>\n<p>我还是要重点讲一下项目，我以前认为项目是一个不确定性非常大的地方，后来经过面试才知道项目是最容易带面试官节奏的地方。问项目的意义是通过项目来问基础知识，所以就要求你对自己的项目非常熟悉，考虑各种极端情况以及优化方案，熟悉用到的中间件原理，以及这些中间件是如何处理这些情况的，比如说，MQ 的宕机恢复，Redis 集群、哨兵，缓存雪崩、缓存击穿、缓存穿透等。</p>\n<p>优化主要可以从缓存、MQ 解耦、加索引、多线程、异步任务、用 ElasticSearch 做检索等方面考虑，我认为项目优化主要的着手点就是减少数据库的访问量，减少同步调用的次数，比如说加缓存、用 ElasticSearch 做检索就是通过减少数据库的访问来实现的优化，MQ 解耦、异步任务等就是通过减少同步调用的次数来实现的优化。</p>\n<p>项目中还可以学到很多东西，比如下面的这些就是通过项目来学习的：</p>\n<ol>\n<li>权限控制（ABAC、RBAC）</li>\n<li>JWT</li>\n<li>单点登录</li>\n<li>分库分表</li>\n<li>分片上传/导出</li>\n<li>分布式锁</li>\n<li>负载均衡</li>\n</ol>\n<p>当然还有很多东西，每个人的项目不一样，能学到的东西也天差地别，但是你要相信的是，你接触到的东西，面试官应该是都会的，所以一定要好好准备，不然容易被怼。</p>\n<p>本质上来讲，项目也可以拆解成八股文，可以用准备基础知识的方式来准备项目。</p>\n<h3> 算法</h3>\n<p>项目的八股文化，会进一步导致无法准确的甄选候选人，所以就到了面试的第三个衡量标准，那就是算法，我曾经在反问阶段问过面试官刷算法对哪些方面有帮助，面试官直截了当的对我说，刷题对你以后找工作有帮助。我的观点是算法其实也是可以通过记忆来提高的，LeetCode 前 200 道题能刷上 3 遍，我不信面试时候还能手撕不了，所以在复习的过程中一定要保持算法的训练。</p>\n<h3> 面试建议</h3>\n<ol>\n<li>自我介绍尽量丰富一下，项目提前准备好如何介绍。</li>\n<li>在面试的时候，遇到不会的问题最好不要直接说不会，然后愣着，等面试官问下一个问题，你可以说自己对这方面不太了解，但是对 XX 有一些了解，然后讲一下，如果面试官感兴趣，你就可以继续说，不感兴趣他就会问下一个问题，面试官一般是不会打断的，这也是让面试官快速了解你的一个小技巧。</li>\n<li>尽量向面试官展示你的技术热情，比如说你可以和面试官聊 Java 每个版本的新特性，最近技术圈的一些新闻等等，因为就我所知，技术热情也是阿里面试考察的一方面。</li>\n<li>面试是一个双向选择的过程，不要表现的太过去谄媚。</li>\n<li>好好把握好反问阶段，问一些有价值的内容，比如说新人培养机制、转正机制等。</li>\n</ol>\n<h2> 经验</h2>\n<ol>\n<li>如果你现在大一，OK，我希望你能多了解一下互联网就业的方向，看看自己的兴趣在哪，先把基础打好，比如说数据结构、操作性、计算机网络、计算机组成原理，因为这四门课既是大部分学校考研的专业课，也是面试中常常会被问到的问题。</li>\n<li>如果已经大二了，那就要明确自己的方向，要有自驱力，知道你学习的这个方向都要学哪些知识，学到什么程度能够就业，合理安排好时间，知道自己在什么阶段要达到什么样的水准。</li>\n<li>如果你学历比较吃亏，亦或是非科班出身，那么我建议你一定要付出超过常人的努力，因为在我混迹牛客这么多年，我看到的面经一般是学校好一些的问的简单一些，相对差一些的问的难一些，其实也可以理解，毕竟普遍上来说名校出身的综合实力要强一些。</li>\n<li>尽量早点实习，如果你现在大二，已经有了能够实习的水平，我建议你早点投简历，尽量找暑期实习，你相信我，如果你这个暑假去实习了，明年一定是乱杀。</li>\n<li>接上条，如果找不到实习，尽量要做几个有挑战的项目，并且找到这个项目的抓手。</li>\n<li>多刷刷牛客，我在牛客上就认识了很多志同道合的人，他们在我找工作过程中给了我很多帮助。</li>\n</ol>\n<h2> 建议</h2>\n<ol>\n<li>一定要抱团取暖，一起找工作的同学可以拉一个群，无论是自己学校的还是网上认识的，平常多交流复习心得，n 个 1 相加的和一定是大于 n 的。</li>\n<li>知识的深度和广度都很重要，平常一定要多了解新技术，而且每学一门技术一定要争取了解它的原理，不然你学的不算是计算机，而是英语系，工作职位也不是研发工程师，而是 API 调用工程师。</li>\n<li>运营好自己的 CSDN、掘金等博客平台，我有个学弟大二是 CSDN 博客专家，已经有猎头联系他了，平常写的代码尽量都提交到 GitHub 上，无论是项目也好，实验也好，如果有能力的话最好能录制一些视频发到哔哩哔哩上，因为这是面试官在面试你之前了解你表达能力的一个重要途径。</li>\n<li>心态一定要好，面试不顺利，不一定是你的能力问题，也可能是因为他们招人很少，或者说某一些客观条件与他们不匹配，一定要多尝试不同的选择。</li>\n<li>多和人沟通交流，不要自己埋头苦干，因为你以后进公司里也需要和别人合作，所以表达和沟通能力是一项基本的技能，要提前培养。</li>\n</ol>\n<h2> 闲聊</h2>\n<h3> 谈谈信息差</h3>\n<p>我觉得学校的差距并不只是体现在教学水平上，诚然名校的老师讲课水平、实验水平都是高于弱校的，但是信息差才是主要的差距。在 985 学校里面读书，不仅能接触到更多优质企业的校招宣讲、讲座，还能接触到更好的就业氛围，因为名校里面去大厂、去外企的人、甚至出国的人更多，学长学姐的内推只是一方面，另一方面是你可以从他们身上学到技术以外的东西，而双非学校去大厂的人少，他们能影响的只是很少一部分人，这就是信息差。信息差的劣势主要体现在哪些方面呢？比如人家大二已经开始找日常实习了，而你认为找工作是大四的事情，人家大三已经找到暑期实习了，你暑假还需要去参加学校组织的培训，一步步的就这样拉下了。</p>\n<p>好在，互联网的出现让信息更加透明，你可以在网上检索各种各样你想要的信息，比如我就在牛客]上认识了一些志同道合的朋友，他们在找工作的过程中给了我很多帮助。平常可以多刷刷牛客，能够有效的减小信息差。</p>\n<h3> 谈谈 Java 的内卷</h3>\n<p>Java 卷吗？毫无疑问，很卷，我个人认为开发属于没有什么门槛的工作，本科生来干正合适，但是因为算法岗更是神仙打架，导致很多的研究生也转了开发，而且基本都转了 Java 开发。Java 的内卷只是这个原因造成的吗？当然不是，我认为还有一个原因就是培训机构的兴起，让这个行业的门槛进一步降低，你要学什么东西，怎么学，都有人给你安排好了，这是造成内卷的第二个原因。第三个原因就是非科班转码，其它行业的凋落和互联网行业的繁荣形成了鲜明对比，导致很多其它专业的人也自学计算机，找互联网的工作，导致这个行业的人越来越多，蛋糕就那么大，分蛋糕的人却越来越多。</p>\n<p>其实内卷也不一定是个坏现象，这说明阶级上升的通道还没有完全关闭，还是有不少人愿意通过努力来改变现状，这也一定程度上会加快行业的发展，社会的发展。选择权在你自己手上，你可以选择回老家躺平或者进互联网公司内卷，如果选择后者的话，我的建议还是尽早占下坑位，因为唯一不变的是变化，你永远不知道三年后是什么样子。</p>\n<h2> 祝福</h2>\n<p>惟愿诸君，前程似锦！</p>\n",
      "image": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/62099c9b2fd24d3cb6511e49756f486b~tplv-k3u1fbpfcp-zoom-1.image",
      "date_published": "2022-06-19T15:10:45.000Z",
      "date_modified": "2022-06-20T02:38:55.000Z",
      "authors": [
        {
          "name": "钟期既遇"
        }
      ],
      "tags": [
        "技术文章精选集"
      ]
    },
    {
      "title": "网站历史",
      "url": "https://javaguide.cn/javaguide/history.html",
      "id": "https://javaguide.cn/javaguide/history.html",
      "summary": "由于项目内容一直持续在更新迭代，所以，这里就不记录项目内容的具体更新情况了。 你可以通过 RSS 订阅获取网站的最新更新，你还可以通过 https://javaguide.cn/article/获取到网站最新更新的文章。",
      "content_html": "<p>由于项目内容一直持续在更新迭代，所以，这里就不记录项目内容的具体更新情况了。</p>\n<p>你可以通过 <a href=\"https://javaguide.cn/feed.json\" target=\"_blank\" rel=\"noopener noreferrer\">RSS 订阅</a>获取网站的最新更新，你还可以通过 <a href=\"https://javaguide.cn/article/\" target=\"_blank\" rel=\"noopener noreferrer\">https://javaguide.cn/article/</a>获取到网站最新更新的文章。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguideimage-20220614172338606.png\" alt=\"\"></p>\n<p>这里只记录一些比较重要的一些节点：</p>\n<ul>\n<li><a href=\"https://github.com/Snailclimb/JavaGuide/commit/83efb36fb56d197f2c4b471084b884c6a4f23e37\" target=\"_blank\" rel=\"noopener noreferrer\">2022-06-13</a>：完善网站排版以及样式。</li>\n<li><a href=\"https://github.com/Snailclimb/JavaGuide/commit/618477f96c4a976cfe5a3bba2f646c0d20e3137e\" target=\"_blank\" rel=\"noopener noreferrer\">2022-04-09</a>：添加<a href=\"https://javaguide.cn/books/\" target=\"_blank\" rel=\"noopener noreferrer\">技术书籍精选</a>。</li>\n<li><a href=\"https://github.com/Snailclimb/JavaGuide/commit/5c45af9c7a7cff0d3bc905b09b3bc42f2ee8a88a\" target=\"_blank\" rel=\"noopener noreferrer\">2021-03-13</a> ：添加<a href=\"https://javaguide.cn/open-source-project/\" target=\"_blank\" rel=\"noopener noreferrer\">开源项目精选</a>。</li>\n<li><a href=\"https://github.com/Snailclimb/JavaGuide/commit/827996e7722fd51718863d4bee156a8c6c759ff5\" target=\"_blank\" rel=\"noopener noreferrer\">2021-03-03</a> : 移除了开发工具的部分内容。</li>\n<li><a href=\"https://github.com/Snailclimb/JavaGuide/commit/5a5f8ccb3bfb8d6ba8ac41295f1a1e4555395260\" target=\"_blank\" rel=\"noopener noreferrer\">2021-03-03</a> ： vuepress-theme-hope 主题更新升级（比较重要的一次主题更新，从 1.x 版本升级到 2.x 版本，网站性能提升）。</li>\n<li><a href=\"https://github.com/Snailclimb/JavaGuide/commit/dc45389934b7763f4f9789168f71c72ef303d3c4\" target=\"_blank\" rel=\"noopener noreferrer\">2021-11-09</a> : 基于 vuepress 重构整个项目，提升阅读体验。</li>\n</ul>\n",
      "image": "https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguideimage-20220614172338606.png",
      "date_published": "2022-06-14T09:40:32.000Z",
      "date_modified": "2022-06-14T09:40:32.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "走近项目"
      ]
    },
    {
      "title": "程序员高效出书避坑和实践指南",
      "url": "https://javaguide.cn/high-quality-technical-articles/programmer/efficient-book-publishing-and-practice-guide.html",
      "id": "https://javaguide.cn/high-quality-technical-articles/programmer/efficient-book-publishing-and-practice-guide.html",
      "summary": "推荐语 ：详细介绍了程序员出书的一些常见问题，强烈建议有出书想法的朋友看看这篇文章。 原文地址 ：https://www.cnblogs.com/JavaArchitect/p/14128202.html 古有三不朽， 所谓立德、立功、立言。程序员出一本属于自己的书，如果说是立言，可能过于高大上，但终究也算一件雅事。 出书其实不挣钱，而且从写作到最终拿钱的周期也不短。但程序员如果有一本属于自己的技术书，那至少在面试中能很好地证明自己，也能渐渐地在业内积累自己的名气，面试和做其它事情时也能有不少底气。在本文里，本人就将结合自己的经验和自己踩过的坑，和大家聊聊程序员出书的那些事。",
      "content_html": "<blockquote>\n<p><strong>推荐语</strong> ：详细介绍了程序员出书的一些常见问题，强烈建议有出书想法的朋友看看这篇文章。</p>\n<br>\n<p><strong>原文地址</strong> ：https://www.cnblogs.com/JavaArchitect/p/14128202.html</p>\n</blockquote>\n<p>古有三不朽， 所谓立德、立功、立言。程序员出一本属于自己的书，如果说是立言，可能过于高大上，但终究也算一件雅事。</p>\n<p>出书其实不挣钱，而且从写作到最终拿钱的周期也不短。但程序员如果有一本属于自己的技术书，那至少在面试中能很好地证明自己，也能渐渐地在业内积累自己的名气，面试和做其它事情时也能有不少底气。在本文里，本人就将结合自己的经验和自己踩过的坑，和大家聊聊程序员出书的那些事。</p>\n<h2> 1.出书的稿酬收益和所需要的时间</h2>\n<p>先说下出书的收益和需要付出的代价，这里姑且先不谈“出书带来的无形资产”，先谈下真金白银的稿酬。</p>\n<p>如果直接和出版社联系，一般稿酬是版税，是书价格的 8%乘以印刷数（或者实际销售数），如果你是大牛的话，还可以往上加，不过一般版税估计也就 10%到 12%。请注意这里的价格是书的全价，不是打折后的价格。</p>\n<p>比如一本书全价是 70 块，在京东等地打 7 折销售，那么版税是 70 块的 8%，也就是说卖出一本作者能有 5.6 的收益，当然真实拿到手以后还再要扣税。</p>\n<p>同时也请注意合同的约定是支付稿酬的方式是印刷数还是实际销售数，我和出版社谈的，一般是印刷数量，这有什么差别呢？现在计算机类的图书一般是首印 2500 册，那么实际拿到手的钱数是 70*8%*2500，当然还要扣税。但如果是按实际销售数量算的话，如果首印才销了 1800 本的话，那么就得按这个数量算钱了。</p>\n<p>现在一本 300 页的书，定价一般在 70 左右，按版税 8%和 2500 册算的话，税前收益是 14000，税后估计是 12000 左右，对新手作者的话，300 的书至少要写 8 个月，由此大家可以算下平均每个月的收益，算下来其实每月也就 1500 的收益，真不多。</p>\n<p>别人的情况我不敢说，但我出书以后，除了稿酬，还有哪些其它的收益呢？</p>\n<ul>\n<li>在当下和之前的公司面试时，告诉面试官我在相关方面出过书以后，面试官就直接会认为我很资深，帮我省了不少事情。</li>\n<li>我还在做线下的培训，我就直接拿我最近出的 Python 书做教材了，省得我再备课了。</li>\n<li>和别人谈项目，能用我的书证明自己的技术实力，如果是第一次和别人打交道，那么这种证明能立杆见效。</li>\n</ul>\n<p>尤其是第一点，其实对一些小公司或者是一些外派开发岗而言，如果候选人在这个方面出过书，甚至都有可能免面试直接录取，本人之前面试过一个大公司的外派岗，就得到过这种待遇。</p>\n<h2> 2.支付稿酬的时间点和加印后的收益</h2>\n<p>我是和出版社直接联系出书，支付稿酬的时间点一般是在首印后的 3 个月内拿到首印部分稿酬的一部分（具体是 50%到 90%），然后在图书出版后的一年后再拿到其它部分的稿酬。当下有不少书，能销掉首印的册数就不错了，不过也有不少书能加印，甚至出第二和第三版，一般加印册数的版税会在加印后的半年到一年内结清。</p>\n<p>从支付稿酬的时间点上来，对作者确实会有延迟，外加上稿酬也不算高，相对于作者的辛勤劳动，所以出书真不是挣钱的事，而且拿钱的周期还长。如果个别图书公司工作人员一方面在出书阶段对作者没什么帮助， 另一方面还要在中间再挣个差价，那么真有些作践作者的辛勤劳动了。</p>\n<h2> 3.同图书公司打交道的所见所闻</h2>\n<p>在和出版社编辑沟通前，我也和图书公司的工作人员交流过，不少工作人员对我也是比较尊重，交流虽然不算深入，但也算客气。不过最终对比出版社给出的稿酬等条件，我还是没有通过图书公司出书，这也是比较可惜的事情。下面我给出些具体的经历。</p>\n<ul>\n<li>我经常在博客园等地收到一些图书公司工作人员的留言，问要不要出书，一般我不问，他们不会说自己是出版社编辑还是图书公司的工作人员。有个别图书公司的工作人员，会向作者，尤其是新手作者，说些“出版社编辑一般不会直接和作者联系”，以及“出书一般是通过图书公司”等的话。其实这些话不能算错，比如你不联系出版社编辑，那么对方自然不会直接联系你，但相反如果作者直接和出版社编辑联系，第一没难度，第二可能更直接。</li>\n<li>我和出版社编辑交流大纲时，即使大纲有不足，他们也能直接给出具体的修改意见，比如某个章节该写什么，某个小节的大纲该怎么写。而我和个别图书公司的工作人员交流过大纲时，得到的反馈大多是“要重写”，怎么个重写法？这些工作人员可能只能给出抽象的意见，什么都要我自己琢磨。在我之前的博文<a href=\"./how-do-programmers-publish-a-technical-book\">程序员怎样出版一本技术书</a>里，我就给出过具体的经历。</li>\n<li>由于交流不深，所以我没有和图书公司签订过出书协议，但我知道，只有出版社能出书。由于没有经历过，所以我也不知道图书公司在合同里是否有避规风险等条款，但我见过一位图书公司人员人员给出的一些退稿案例，并隐约流露出对作者的责备之意。细思感觉不妥，对接的工作人员第一不能在出问题的第一时间及时发现并向作者反馈，第二在出问题之后不能对应协调最终导致退稿，第三在退稿之后，作者在付出劳动的情况下图书公司不仅不用承担任何风险，并还能指摘作者。对此，退稿固然有作者的因素，但同是作者的我未免有兔死狐悲之谈。而我在出版社出书时，编辑有时候甚至会主动关心，主动给素材，哪怕有问题也会第一时间修改，所以甚至大范围修改稿件的情况都基本没有出现。</li>\n<li>再说下图书公司给作者的稿酬。我见过按页给钱，比如一页 30 到 50 块，并卖断版权，即书重印后作者也无法再得到稿酬，如果是按版税给钱，我也见过给 6%，至于图书公司能否给到 8 个点甚至更高，我没见到过，所以不知道，也不敢擅拟。</li>\n</ul>\n<p>我交流过的图书公司工作人员不多，交流也不深，因为我现在主要是和出版社的编辑交流。所以以上只是我对个别图书公司编辑的感受，我无意以偏概全，而和我交流的一些图书公司工作人员至少态度上对我很尊重。所以大家也可以对比尝试下和图书公司以及出版社合作的不同方式。不管怎样，你在写书甚至在签出书协议前，你需要问清楚如下的事项，并且对方有义务让你了解如下的事实。</p>\n<ul>\n<li>你得问清楚，对方的身份是出版社编辑还是图书公司工作人员，这其实应当是对方主动告之。</li>\n<li>你的书在哪个出版社出版？这点需要在出书协议里明确给出，不能是先完稿再定出版社。而且，最终能出版书的，一定是出版社，而不是图书公司。</li>\n<li>稿酬的支付方式，哪怕图书公司中间可能挣差价，但至少你得了解出版社能给到的稿酬。如果你是通过图书公司出的书，不管图书公司怎么和你谈的，但出版社给图书公司的钱一分不会少，中间部分应该就是图书公司的盈利。</li>\n<li>最终和你签订出书合同的，是图书公司还是出版社，这一定得在你签字前搞明白，哪怕你最终是和图书公司签协议，但至少得知道你还能直接和出版社签协议。</li>\n<li>你不能存有“在图书公司出书要求低”的想法，更不应该存有“我能力一般，所以只能在图书公司出书”的想法。图书公司自己是没有资格出书的，所以他们也是会把稿件交给出版社，所以该有的要求一点也不会低。你的大纲在出版社编辑那边通不过，那么在图书公司的工作人员那边同样通不过，哪怕你索要的稿酬少，图书公司方面对应的要求一定也不会降低。</li>\n</ul>\n<p>如果你明知“图书公司和出版社的差别”，并还是和图书公司合作，这个是两厢情愿的事情。但如果对方“不主动告知”，而你在不了解两者差异的基础上同图书公司合作，那么对方也无可指摘。不过兼听则明，大家如果要出书，不妨和出版社和图书公司都去打打交道对比下。</p>\n<h2> 4.如何直接同国内计算机图书的知名出版社编辑联系</h2>\n<p>我在清华大学出版社、机械工业出版社、北京大学出版社和电子工业出版社出过书，出书流程也比较顺畅，和编辑打交道也比较愉快。我个人无意把国内出版社划分成三六九等，但计算机行业，比较知名的出版社有清华、机工、电子工业和人邮这四家，当然其它出版社在计算机方面也出版过精品书。</p>\n<p>如何同这些知名出版社的编辑直接打交道？</p>\n<ul>\n<li>直接到官网，一般官网上都直接有联系方式。</li>\n<li>你在博客园等地发表文章，会有人找你出书，其中除了图书公司的工作人员外，也有出版社编辑，一般出版社的编辑会直接说明身份，比如我是 xx 出版社的编辑 xx。</li>\n<li>本人也和些出版社的编辑联系过，大家如果要，我可以给。</li>\n</ul>\n<p>那怎么去找图书公司的工作人员？一般不用主动找，你发表若干博文后，他们会主动找你。如果你细问，“您是出版社编辑还是图书公司的编辑”，他们会表明身份，如果你再细问，那么他们可能会站在图书公司的立场上解释出版社和图书公司的差异。</p>\n<p>从中大家可以看到，不管你最终是否写成书，但去找知名出版社的编辑，并不难。并且，你找到后，他们还会进一步和你交流选题。</p>\n<h2> 5.定选题和出书的流程</h2>\n<p>这里给出我和出版社编辑交流合作，最终出书的流程。</p>\n<p>第一，联系上出版社编辑后，先讨论选题，你可以选择一个你比较熟悉的方向，或者你愿意专攻的方向，这个方向可以是 java 分布式组件，Spring cloud 全家桶，微服务，或者是 Python 数据分析，机器学习或深度学习等。这方面你如果有扎实的项目经验那最好，如果你当下虽然不熟悉，但你有毅力经过短时间的系统学习确保你写的内容能成系统或者能帮到别人，那么你也可以在这方面出书。</p>\n<p>第二，定好选题方向后，你可以先列出大纲，比如以 Python 数据分析为例，你可以定 12 个章节，第一章讲语法，第二章讲 numpy 类等等，以此类推，你定大纲的时候，可以参考别人书的目录，从而制定你的写作内容。定好大纲以后，你可以和编辑交流，当编辑也认可这个大纲以后，就可以定出版协议。</p>\n<p>对一般作者而言，出版协议其实差不多，稿酬一般是 8 个点，写作周期是和出版社协商，支付周期可能也大同小异，然后出版社会买断这本书的电子以及各种文字的版权。但如果作者是大牛，那么这些细节都可以和出版社协商。</p>\n<p>然后是写书，这是很枯燥的，尤其是写最后几章的时候。我一般是工作日每天用半小时，两天周末周末用 4,5 个小时写，这样一般半年能写完一本 300 页的书，关于高效写书的技巧，后文会详细提及。</p>\n<p>在写书时，一般建议每写好一个章节就交给编辑审阅，这样就不会导致太大问题的出现，而且如果是新手作者，刚开始的措辞和写作技巧都需要积累，这样出版社的编辑在开始阶段也能及时帮到作者。</p>\n<p>当你写完把稿件交到编辑以后，可能会有三校三审的事情，在其中同我合作的编辑会帮助我修改语法和错别字等问题，然后会形成一个修改意见让我确认和修改。我了解下来，如果在图书公司出书，退稿的风险一般就发生在这个阶段，因为图书公司可能是会一次性地把稿件提交给出版社。但由于我会把每个章节都直接提交给出版社编辑审阅，所以即使有大问题，那么在写开始几个章节时都已经暴露并修改，所以最后的修改意见一般不会太长。也就是说，如果是直接和出版社沟通，在三校三审阶段，工作量可能未必大，我一般是在提交一本书以后，由编辑做这个事情，然后我就继续策划并开始写后一本书。</p>\n<p>最后就是拿稿酬，之前已经说了，作者其实不应该对稿酬有太大的期望，也就是聊胜于无。但如果一不小心写了本销量在 5000 乃至 10000 本左右的畅销书，那么可能在一年内也能有 5 万左右的额外收益，并能在业内积累些名气。</p>\n<h2> 6.出案例书比出经验书要快</h2>\n<p>对一些作者而言，尤其是新手作者，出书不容易，往往是开始几个章节干劲十足，后面发现问题越积越多，外加工作一忙，就不了了之了，或者用 1 年以上的时间才能完成一本书。对此，我的感受是，一本 300 到 400 书的写作周期最长是 8 个月。为了能在这个时间段里完成一本书，我对应给出的建议是，新手作者可以写案例书，别先写介绍经验类的书。</p>\n<p>什么叫案例书？比如一本书里用一个大案例贯穿，系统介绍一个知识点，比如小程序开发，或者全栈开发等。或者一本书一个章节放一个案例，在一本书里给出 10 个左右 Python 深度学习方面的案例。什么叫经验类书呢？比如介绍面试经验的书就属于这这种，或者一些技术大牛写的介绍分布式高并发开发经验的书也算经验类书。</p>\n<p>请注意这里并没有区分两类书的差异，只是对新手作者而言，案例书好写。因为在其中，更多的是看图说话，先给出案例（比如 Python 深度学习里的图像识别案例），然后通过案例介绍 API 的用法（比如 Python 对应库的用法），以及技术的综合要点（比如如何用 Python 库综合实现图像识别功能）。并且案例书里需要作者主观发挥的点比较少，作者无需用自己的话整理相关的经验。对新手作者而言，在组织文字介绍经验时，可能会有自己明白但说不上来的感觉，这样一方面就无法达到预期的效果，另一方面还有可能因为无法有效表述而导致进度的延迟。</p>\n<p>但相反对于案例书，第一案例一般可以借鉴别人的，第二介绍现存的技术总比介绍自己的经验要容易，第三一般还有同类的书可以供作者参考，所以作者不大需要斟酌措辞，新手作者用半年到八个月的时间也有可能写完一本。当作者通过写几本书积累一定经验后，再去挑战经验类书，在这种情况下，写出来的经验类书就有可能畅销了。</p>\n<p>那么具体而言，怎么高效出一本案例书呢？</p>\n<ul>\n<li>对整本书而言，先用少量章节介绍搭建环境和通用基本语法的内容。</li>\n<li>在写每个章节案例时，用到总分总的结构，先总体介绍下你这个案例的需求功能，以及要用的技术点，再分开介绍每个功能点的代码实现，最后再总结下这些功能点的使用要点。</li>\n<li>在介绍案例中具体代码时，也可以用到总分总的结构，即先总体介绍下这段代码的结构，再分别给出关键代码的说明，最后再给出运行效果并综述其中技术的实现要点。</li>\n</ul>\n<p>这样的话，刚开始可以是 1 个月一个章节，写到后面熟练以后估计一个月能写两个章节，这样 8 个月完成一本书，也就不是不可能了。</p>\n<h2> 7.如何在参考现有内容的基础上避免版权问题</h2>\n<p>写书时，一般多少都需要参考现有的代码和现有的书，但这绝不是重复劳动。比如某位作者整合了不同网站上多个案例，然后系统地讲述了 Python 数据分析，这样虽然现成资料都有，但对读者来说，就能一站式学习。同样地，比如在 Python 神经网络方面，现有 2,3 本书分别给出了若干人脸识别等若干案例，但如果你有效整合到一起，并加他人的基础上加上你的功能，那对读者来说也是有价值的。</p>\n<p>这里就涉及到版权问题，先要说明，作者不能抱有任何幻想，如果出了版权问题，书没出版还好，如果已经出版了，作者不仅要赔钱，而且在业内就会有不好的名声，可谓身败名裂。但其实要避免版权问题一点也不难。</p>\n<ul>\n<li>不能抄袭网上现有的内容，哪怕一句也不行。对此，作者可以在理解人家语句含义的基础上改写。不能抄袭人家书上现有的目录，更不能抄袭人家书上的话，同样一句也不行，对应的解决方法同样是在理解的基础上改写。</li>\n<li>不能抄袭 Github 上或者任何地方别人的代码，哪怕这个代码是开源的。对此，你可以在理解对方代码的基础上，先运行通，然后一定得自己新建一个项目，在你的项目里参考别人的代码实现你的功能，在这个过程中不能有大段的复制粘贴操作。也就是说，你的代码和别人的代码，在注释，变量命名，类名和方法名上不能有雷同的地方，当然你还可以额外加上你自己的功能。</li>\n<li>至于在写技术和案例介绍时，你就可以用你自己的话来说，这样也不会出现版权问题。</li>\n</ul>\n<p>用了上述办法以后，作者就可以在参考现有资料的基础上，充分加上属于你的功能，写上你独到的理解，从而高效地出版属于你自己的书。</p>\n<h2> 8.新手作者需要着着重避免的问题</h2>\n<p>在上文里详细给出了出书的流程，并通过案例书，给出了具体的习作方法，这里就特别针对新手作者，给出些需要注意的实践要点。</p>\n<ul>\n<li>技术书不同于文艺书，在其中首先要确保把技能知识点讲清楚，然后再此基础上可以适当加上些风趣生动的措辞。所以对新手作者而言，甚至可以直接用朴素的文字介绍案例技术，而无需过多考虑文字上的生动性。</li>\n<li>内容需要针对初学者，在介绍技术时，从最基本的零基础讲起，别讲太深的。这里以 Python 机器学习为例，可以从什么是机器学习以及 Python 如何实现机器学习讲起，但如果首先就讲机器学习里的实践经验，就未必能确保初学者能学会。</li>\n<li>新手作者恨不得把自己知道的都写出来。这种态度非常好，但需要考虑读者的客观接受水平所以需要在写书前设置个预期效果，比如零基础的 Python 开发人员读了我的书以后至少能干活。这个预期效果别不可行，比如不能是“零基础的 Python 开发人员读了我书以后能达到 3 年开发的水准”。这样就可以根据预先制定的效果，制定写作内容，从在你的书就能更着重讲基础知识，这样读者就能有真正有收获。</li>\n</ul>\n<p>不过话说回来，如果新手作者直接和出版社编辑联系，找个热门点的方向，并根据案例仔细讲解技术，甚至都有可能写出销量过万的畅销书。</p>\n<h2> 9.总结：在国内知名出版社出书，其实是个体力活</h2>\n<p>可能当下，写公众号和录视频等的方式，挣钱收益要高于出书，不过话可以这样说，经营公众号和录制视频也是个长期的事情，在短时间里可能未必有收益，如果不是系统地发表内容的话，可能甚至不会有收益。所以出书可能是个非常好的前期准备工作，你靠出书系统积累了素材，靠出书整合了你的知识体系，那么在此基础上，靠公众号或者录视频挣钱可能就会事半功倍。</p>\n<p>从上文里大家可以看到，在出书前期，联系出版社编辑和定选题并不难，如果要写案例书，那么在参考别人内容的基础上，要写完一般书可能也不是高不可攀的事情。甚至可以这样说，出书是个体力活，只要坚持，要出本书并不难，只是你愿不愿意坚持下去的问题。但一旦你有了属于自己的技术书，那么在找工作时，你就能自信地和面试官说你是这方面的专家，在你的视频、公众号和文字里，你也能正大光明地说，你是计算机图书的作者。更为重要的是，和名校、大厂经历一样，属于你的技术书同样是证明程序员能力的重要证据，当你通过出书有效整合了相关方面的知识体系后，那么在这方面，不管是找工作，或者是干私活，或者是接项目做，你都能理直气壮地和别人说：我能行！</p>\n",
      "date_published": "2022-06-13T08:45:44.000Z",
      "date_modified": "2022-06-20T02:18:14.000Z",
      "authors": [
        {
          "name": "hsm_computer"
        }
      ],
      "tags": [
        "技术文章精选集"
      ]
    },
    {
      "title": "程序员怎样出版一本技术书",
      "url": "https://javaguide.cn/high-quality-technical-articles/programmer/how-do-programmers-publish-a-technical-book.html",
      "id": "https://javaguide.cn/high-quality-technical-articles/programmer/how-do-programmers-publish-a-technical-book.html",
      "summary": "推荐语 ：详细介绍了程序员应该如何从头开始出一本自己的书籍。 原文地址 ：https://www.cnblogs.com/JavaArchitect/p/12195219.html 在面试或联系副业的时候，如果能令人信服地证明自己的实力，那么很有可能事半功倍。如何证明自己的实力？最有信服力的是大公司职位背景背书，没有之一，比如在 BAT 担任资深架构，那么其它话甚至都不用讲了。 不过，不是每个人入职后马上就是大公司架构师，在上进的路上，还可以通过公众号，专栏博文，Github 代码量和出书出视频等方式来证明自己。和其它方式相比，属于自己的技术图书由于经过了国家级出版社的加持，相对更能让别人认可自己的实力，而对于一些小公司而言，一本属于自己的书甚至可以说是免面试的通行证。所以在本文里，就将和广大程序员朋友聊聊出版技术书的那些事。",
      "content_html": "<blockquote>\n<p><strong>推荐语</strong> ：详细介绍了程序员应该如何从头开始出一本自己的书籍。</p>\n<br>\n<p><strong>原文地址</strong> ：https://www.cnblogs.com/JavaArchitect/p/12195219.html</p>\n</blockquote>\n<p>在面试或联系副业的时候，如果能令人信服地证明自己的实力，那么很有可能事半功倍。如何证明自己的实力？最有信服力的是大公司职位背景背书，没有之一，比如在 BAT 担任资深架构，那么其它话甚至都不用讲了。</p>\n<p>不过，不是每个人入职后马上就是大公司架构师，在上进的路上，还可以通过公众号，专栏博文，Github 代码量和出书出视频等方式来证明自己。和其它方式相比，属于自己的技术图书由于经过了国家级出版社的加持，相对更能让别人认可自己的实力，而对于一些小公司而言，一本属于自己的书甚至可以说是免面试的通行证。所以在本文里，就将和广大程序员朋友聊聊出版技术书的那些事。</p>\n<h2> 1.不是有能力了再出书，而是在出书过程中升能力</h2>\n<p>我知道的不少朋友，是在工作 3 年内出了第一本书，有些优秀的，甚至在校阶段就出书了。</p>\n<p>与之相比还有另外一种态度，不少同学可能想，要等到技术积累到一定程度再写。其实这或许就不怎么积极了，边写书，边升技术，而且写出的书对人还有帮助，这绝对可以做到的。</p>\n<p>比如有同学向深入了解最近比较热门的 Python 数据分析和机器学习，那么就可以在系统性的学习之后，整理之前学习到的爬虫，数据分析和机器学习的案例，根据自己的理解，用适合于初学者的方式整理一下，然后就能出书了。这种书，对资深的人帮助未必大，但由于包含案例，对入门级的读者绝对有帮助，因为这属于现身说法。而且话说回来，如果没有出书这个动力，或者学习过程也就是浅尝辄止，或者未必能全身心地投入，有了出书这个目标，更能保证学习的效果。</p>\n<h2> 2.适合初级开发，高级开发和架构师写的书</h2>\n<p>之前也提到了，初级开发适合写案例书，就拿 Python 爬虫数据分析机器学习题材为例，可以先找几本这方面现成的书，这些书里，或者章节内容不同，但一起集成看的话，应该可以包含这方面的内容。然后就参考别人书的思路，比如一章写爬虫，一章写 pandas，一章写 matplotlib 等等，整合起来，就可以用 若干个章节构成一本书了。总之，别人书里包含什么内容，你别照抄，但可以参考别人写哪些技术点。</p>\n<p>定好章节后，再定下每个章节的小节，比如第三章讲爬虫案例，那么可以定 3.1 讲爬虫概念，3.2 讲如何搭建 Scrapy 库，3.3 讲如何开发 Scrapy 爬虫案例，通过先章再节的次序，就可以定好一本书的框架。由于是案例书，所以是先给运行通的代码，再用这些代码案例教别人入门，所以案例未必很深，但需要让初学者看了就能懂，而且按照你给出的知识体系逐步学习之后，能理解这个主题的内容。并且，能在看完你这本书以后，能通过调通你给出的爬虫，机器学习等的案例，掌握这一领域的知识，并能从事这方面的基本开发。这个目标，对初级开发而言，稍微用点心，费点时间，应该不难达到。</p>\n<p>而对于高级开发和架构师而言，除了写存粹案例书以外，还可以在书里给出你在大公司里总结出来的开发经验，也就是所谓踩过的坑，比如 Python 在用 matplotlib 会图例时，在设置坐标轴方面有哪些技巧，设置时会遇到哪些常见问题，如果在书里大量包含这种经验，你的书含金量更高。</p>\n<p>此外，高级开发和架构师还可以写一些技术含量更高的书，比如就讲高并发场景下的实践经验，或者 k8s+docker 应对高并发的经验，这种书里，可以给出代码，更可以给出实施方案和架构实施技巧，比如就讲高并发场景里，缓存该如何选型，如何避免击穿，雪崩等场景，如何排查线上 redis 问题，如何设计故障应对预案。除了这条路之外，还可以深入细节，比如通过讲 dubbo 底层代码，告诉大家如何高效配置 dubbo，出了问题该如何排查。如果架构师或高级开发有这类书作为背书，外带大厂工作经验，那么就更可以打出自己的知名度。</p>\n<h2> 3.可以直接找出版社，也可以找出版公司</h2>\n<p>在我的这篇博文里，<a href=\"https://www.cnblogs.com/JavaArchitect/p/11616906.html\" target=\"_blank\" rel=\"noopener noreferrer\">程序员副业那些事：聊聊出书和录视频</a>，给出了通过出版社出书和图书公司出书的差别，供大家参考，大家看了以后可以自行决定出书方式。</p>\n<p>不过不管怎么选，在出书前你得搞明白一些事，或许个别图书出版公司的工作人员不会主动说，这需要你自己问清楚。</p>\n<ul>\n<li>你的合作方是谁？图书出版公司还是出版社？</li>\n<li>你的书将在哪个出版社出版？国内比较有名的是清华，人邮，电子和机械，同时其它出版社不能说不好，但业内比较认这四个。</li>\n<li>和你沟通的人，是最终有决定权的图书编辑吗？还是图书公司里的工作人员？再啰嗦下，最后能决定书能否出版，以及确定修改意见的，是出版社的编辑。</li>\n</ul>\n<p>通过对比出版社和图书出版公司，在搞清楚诸多细节后，大家可以自己斟酌考虑合作的方式。而且，出版社和图书公司的联系方式，在官网上都有，大家可以自行通过邮件等方式联系。</p>\n<h2> 4.如果别人拿你做试错对象，或有不尊重，赶紧止损</h2>\n<p>我之前看到有图书出版公司招募面向 Java 初学者图书的作者，并且也主动联系过相关人员，得到的反馈大多是：“要重写”。</p>\n<p>比如我列了大纲发过去，反馈是“要重写”，原因是对方没学过 Java，但作为零基础的人看了我的大纲，发现学不会。至于要重写成什么样子 ，对方也说不上来，总之让我再给个大纲，再给一版后，同样没过，这次好些，给了我几本其它类似书的大纲，让我自行看别人有什么好的点。总之不提（或者说提不出）具体的改进点，要我自行尝试各种改进点，试到对方感觉可以为止。</p>\n<p>相比我和几位出版社专业的编辑沟通时，哪怕大纲或稿件有问题，对方会指明到点，并给出具体的修改意见。我不知道图书出版公司里的组织结构，但出版社里，计算机图书有专门的部门，专门的编辑，对方提出的意见都是比较专业，且修改起来很有操作性。</p>\n<p>另外，我在各种渠道，时不时看到有图书出版公司的人员，晒出别人交付的稿件，在众目睽睽之下，说其中有什么问题，意思让大家引以为戒。姑且不论这样做的动机，并且这位工作人员也涂掉了能表面作者身份的信息。但作者出于信任把稿件交到你手上，在不征得作者同意就公开稿件，说“不把作者当回事”，这并不为过。不然，完全可以用私信的方式和作者交流，而不是把作者无心之过公示于众。</p>\n<p>我在和出版社合作时，这类事绝没发生过，而且我认识的出版社编辑，都对各位作者保持着足够的尊重。而且我和我的朋友和多位图书出版公司的朋友交流时，也能得到尊重和礼遇。所以，如果大家在写书时，尤其在写第一本书时，如果遇到被试错，或者从言辞等方面感觉对方不把你当会事，那么可以当即止损。其实也没有什么“损失”，你把当前的大纲和稿件再和出版社编辑交流时，或许你的收益还能提升。</p>\n<h2> 5.如何写好 30 页篇幅的章节？</h2>\n<p>在和出版社定好写作合同后，就可以创作了。书是由章节构成，这里讲下如何构思并创作一个章节。</p>\n<p>比如写爬虫章节，大概 30 页，先定节和目，比如 3.1 搭建爬虫环境是小节，3.1.1 下载 Python Scrapy 包，则是目。先定要写的内容，具体到爬虫小节，可以写 3.1 搭建环境，3.2 Scrapy 的重要模块，3.3 如何开发 Scrapy 爬虫，3.4 开发好以后如何运行，3.5 如何把爬到的信息放入数据库，这些都是小节。</p>\n<p>再具体到目，比如 3.5 里，3.5.1 里写如何搭建数据库环境 3.5.2 里写如何在 Scrapy 里连接数据库 3.5.3 里给出实际案例 3.5.4 里给出运行步骤和示例效果。</p>\n<p>这样可以搭建好一个章的框架，在每个小节里，先给出可以运行通的，而且能说明问题的代码，再给出对代码的说明，再写下代码如何配置，开发时该注意哪些问题，必要时用表格和图来说明，用这样的条理，最多 3 个星期可以完成一个章节，快的话一周半就一个章节。</p>\n<p>以此类推，一本书大概有 12 个章节，第一章可以讲如何安装环境，以及基础语法，后面就可以由浅入深，一个章节一个主题，比如讲 Python 爬虫，第二章可以是讲基础语法，第三章讲 http 协议以及爬虫知识点，以此深入，讲全爬虫，数据分析，数据展示和机器学习等技能。</p>\n<p>按这样算，如果出第一本书，平均下来一个月 2 个章节，大概半年到八个月可以完成一本书，思路就是先搭建书的知识体系，写每个章节时再搭建某个知识点的框架，在小节和目里，用代码结合说明的方式，这样从简到难，大家就可以完成第一本属于自己的书了。</p>\n<h2> 6.如何写出一本销量过 5 千的书</h2>\n<p>目前纸质书一般一次印刷在 2500 册，大多数书一般就一次印刷，买完为止。如果能销调 5000 本，就属于受欢迎了，如果销量过万，就可以说是大神级书的。这里先不论大神级书，就说下如何写一本过 5000 的畅销书。</p>\n<p>1 最好贴近热点，比如当前热点是全栈开发和机器学习等，如何找热点，就到京东等处去看热销书的关键字。具体操作起来，多和出版社编辑沟通，或许作者更多是从技术角度分析，但出版社的编辑是从市场角度来考虑问题。</p>\n<p>2 如果你的书能被培训机构用作教材，那想不热都不行。培训机构一般用哪些教材呢？第一面向初学者，第二代码全面，第三在这个领域里涵盖知识点全。如果要达成这点，大家可以和出版社的编辑直接沟通，问下相关细节。</p>\n<p>3 可以文字生动，但不能用过于花哨的文字来掩盖书的内涵不足，也就是说畅销书一定要有干货，能解决初学者实际问题，比如 Python 机器学习方向，就写一本用案例涵盖目前常用的机器学习算法，一个章节一种算法，并且案例中有可视化，数据分析，爬虫等要素，可视化的效果如果再吸引人，这本书畅销的可能性也很大。</p>\n<p>4 一定不能心存敷衍，代码调通不算，更力求简洁，说明文字多面向读者，内容上，确保读者一看就会，而且看了有收获，或许这点说起来很抽象，但我写了几本书以后切身体会，要做到这很难，同时做到了，书哪怕不畅想，但至少不误人子弟。</p>\n<h2> 7.总结，出书仅是一个里程碑，程序员在上进路上应永不停息</h2>\n<p>出书不简单，因为不是每个人都愿意在半年到八个月里，每个晚上每个周末都费时费力写书。但出书也不难，毕竟时间用上去了，出书也只是调试代码加写文字的活，最多再外加些和人沟通的成本。</p>\n<p>其实出书收益并不高，算下来月入大概能在 3k 左右，如果是和图书出版公司合作，估计更少，但这好歹能证明自己的实力。不过在出书后不能止步于此，因为在大厂里有太多的牛人，甚至不用靠出书来证明自己的实力。</p>\n<p>那么如何让出书带来的利益最大化呢？第一可以靠这进大厂，面试时有自己的书绝对是加分项。第二可以用这个去各大网站开专栏，录视频，或者开公众号，毕竟有出版社的背书，能更让别人信服你的能力。第三更得用写书时积累的学习方法和上进的态势继续专研更高深技术，技术有了，不仅能到大厂挣更多的钱，还能通过企业培训等方式更高效地挣钱。</p>\n",
      "date_published": "2022-06-13T08:45:44.000Z",
      "date_modified": "2022-06-20T02:18:14.000Z",
      "authors": [
        {
          "name": "hsm_computer"
        }
      ],
      "tags": [
        "技术文章精选集"
      ]
    },
    {
      "title": "聊聊大厂的绩效考核",
      "url": "https://javaguide.cn/high-quality-technical-articles/work/employee-performance.html",
      "id": "https://javaguide.cn/high-quality-technical-articles/work/employee-performance.html",
      "summary": "内容概览 ： 在大部分公司，绩效跟你的年终奖、职级晋升、薪水涨幅等等福利是直接相关的。 你的上级、上上级对你的绩效拥有绝对的话语权，这是潜规则，放到任何公司都是。成年人的世界，没有绝对的公平，绩效考核尤为明显。 提升绩效的打法： 短期打法：找出 1-2 件事，体现出你的独特价值（抓关键事件）。 长期打法：通过一步步信任的建立，成为团队的核心人员或者是老板的心腹，具备不可替代性。 原文地址 ：https://mp.weixin.qq.com/s/D1s8p7z8Sp60c-ndGyh2yQ",
      "content_html": "<blockquote>\n<p><strong>内容概览</strong> ：</p>\n<ul>\n<li>在大部分公司，绩效跟你的年终奖、职级晋升、薪水涨幅等等福利是直接相关的。</li>\n<li>你的上级、上上级对你的绩效拥有绝对的话语权，这是潜规则，放到任何公司都是。成年人的世界，没有绝对的公平，绩效考核尤为明显。</li>\n<li>提升绩效的打法：\n<ul>\n<li>短期打法：找出 1-2 件事，体现出你的独特价值（抓关键事件）。</li>\n<li>长期打法：通过一步步信任的建立，成为团队的核心人员或者是老板的心腹，具备不可替代性。</li>\n</ul>\n</li>\n</ul>\n<br>\n<p><strong>原文地址</strong> ：https://mp.weixin.qq.com/s/D1s8p7z8Sp60c-ndGyh2yQ</p>\n</blockquote>\n<p>在新公司度过了一个完整的 Q3 季度，被打了绩效，也给下属打了绩效，感慨颇深。</p>\n<p>今天就好好聊聊<strong>大厂打工人最最关心的「绩效考核」</strong>，谈谈它背后的逻辑以及潜规则，摸清楚了它，你在大厂这片丛林里才能更好的生存下去。</p>\n<h2> 大厂的绩效到底有多重要？</h2>\n<p>先从公司角度，谈谈为什么需要绩效考核？</p>\n<p>有一个著名的管理者言论，即：企业战略的上三路和下三路。</p>\n<blockquote>\n<p>上三路是使命、愿景、价值观，下三路是组织、人才、KPI。下三路需要确保上三路能执行下去，否则便是空谈。那怎么才能达成呢？</p>\n</blockquote>\n<p>马老板在湖畔大学的课堂上，对底下众多 CEO 学员说，“只能靠 KPI。没有 KPI，一切都是空话，组织和公司是不会进步的”。</p>\n<p>所以，KPI 一般是用来承接企业战略的。身处大厂的打工者们，也能深深感受到：每个季度的 KPI 是如何从大 Boss、到 Boss、再到基层，一层层拆解下来的，最终让所有人朝着一个方向行动，这便是 KPI 对于公司的意义。</p>\n<p>然鹅，并非每个员工都会站在 CEO 的高度去理解 KPI 的价值，大家更关注的是 KPI 对于我个人来说到底有什么意义？</p>\n<p>在互联网大厂，每家公司都会设定一套绩效考核体系，字节用的是 OKR，阿里用的是 KPI，通常都是「271」 制度，即 ：</p>\n<blockquote>\n<p>20% 的比例是 A+ 和 A，对应明星员工。</p>\n<p>70% 的比例是 B，对应普通员工。</p>\n<p>10% 的比例是 C 和 C-，对应需要绩效改进或者淘汰的员工。</p>\n</blockquote>\n<p>有了三六九等，然后才有了利益分配。</p>\n<p><strong>在大厂，绩效结果跟奖金、晋升、薪水涨幅、股票授予是直接相关的。在内卷的今天，甚至可以直接划上等号。</strong></p>\n<p>绩效好的员工，奖金必然多，一年可能调薪两次，晋升答辩时能 PK 掉绩效一般的人，职级低的人甚至可以晋升免试。</p>\n<p>而绩效差的人，有可能一年白干，甚至走人（大厂的末尾淘汰是不成文的规定）。</p>\n<p>总之，你能想到的直接利益都和「绩效」息息相关。所以，在大厂这片高手众多的丛林里，多琢磨下绩效背后的逻辑，既是生存之道，更是一技之长。</p>\n<h2> 你是怎么看待绩效的？</h2>\n<p>凡是用来考核人的规则，大部分人在潜意识里都想去突破它，而不是被束缚。</p>\n<p>至少在我刚工作的前几年，看着身边有些同事因为背个 C 黯然离开的时候，觉得绩效考核就是一个冷血的管理工具。</p>\n<p>尤其遇到自己看不上的领导时，对于他给我打的绩效，其实也是很不屑的。</p>\n<p>到今天，实在见过太多的反面案例了，自己也踩过一些坑，逐渐认识到：当初的想法除了让自己心里爽一点，好像起不到任何作用，甚至会让我的工作方式变形。</p>\n<p>当思维方式变了，也就改变了我对绩效的态度，至少有两点我认为是打工人需要看清的。</p>\n<p><strong>第一，你的上级、上上级对你的绩效拥有绝对的话语权，这是潜规则，放到任何公司都是。</strong></p>\n<p>大家可以去看看身边发展特别好的人，除了有很强的个人能力以外，几乎都是善于利用规则，而不是去挑战规则的人。</p>\n<p>当然，我并不是说你要一味地去跪舔你的领导，而是表达：工作中不要站在领导的对立面去做对抗，如果领导做法很过分，要么直接沟通去影响他，要么选择离开。</p>\n<p><strong>第二，成年人的世界，没有绝对的公平，绩效考核尤为明显。</strong></p>\n<p>我所待过的团队，绩效考核还是相对公平的，虽然也存在受照顾的情况，但都是个例。</p>\n<p>另外就是，技术岗的绩效考核不同于销售或者运营岗，很容易指标化。</p>\n<p>需求吞吐量、BUG数、线上事故... 的确有一大堆研发效能指标，但这些指标在绩效考核时是否会被参考？具体又该如何分配比重？本身就是一个扯不清楚的难题。</p>\n<p>最终决定你绩效结果的还是你领导的主观判断。你所见到的 360 环评，以及弄一些指标排序，这些都只是将绩效结果合理化的一种方式，并非关键所在。</p>\n<p>因此，多琢磨如何去影响你的领导？站在他的视角去审视他在绩效考核时到底关注哪些核心点？这才是至关重要的。</p>\n<p>上面讲了一堆潜规则，是不是意味着绩效考核是可以投机取巧，完全不看工作业绩呢，当然不是。</p>\n<p>“你的努力不一定会被看见” 、“你的努力应该有的放矢”，大家先记住这两条。</p>\n<p>下面我再展开聊聊，大家最最关心的 A 和 C，它们背后的逻辑。</p>\n<h2> 绩效被打A和C的逻辑是什么？</h2>\n<p>“铆足了劲拿不到 A，一不留神居然拿了个 C”，这是绝大多数打工人最真实的职场现状。</p>\n<p>A 和 C 属于绩效的两个极端，背后的逻辑类似，反着理解即可，下面我详细分析下 C。</p>\n<p>先从我身边人的情况说起，我所看到的案例绝大多数都属于：绩效被打了 C，完全没有任何预感，主管跟他沟通结果时，还是一脸懵逼，“为什么会给我打 C？一定是黑我呀！”。</p>\n<p>前阵子听公司一位大佬分享，用他的话说，这种人就是没有「角色认知」，他不知道他所处的角色和职级该做好哪些事？做成什么样才算「做好了」？被打 C 后自然觉得是在背锅。</p>\n<p>所以，务必确保你对于当前角色是认知到位的，这样才称得上进入了「工作状态」，否则你的一次松懈，一段不太好的表现，很可能导致 C 落在你的头上，岗位越高，摔得越重。</p>\n<p>有了角色认知，再说下对绩效的认知。</p>\n<p>第一，团队很优秀，是不是不用背 C？不是！大厂的 C 都是强制分配的，再优秀的团队也会有 C。所以团队越厉害，竞争越惨烈。</p>\n<p>第二，完成了 KPI，没有工作失误，是不是就万事大吉，不用背 C？不是，绩效是相对的，你必须清楚你在团队所处的位置，你在老板眼中的排序，慢慢练出这种嗅觉。</p>\n<p>懂了上面这些道理，很自然就能知道打 C 的逻辑，C 会集中在两类人上：</p>\n<blockquote>\n<p>1、工作表现称不上角色要求的人。</p>\n<p>2、在老板眼里排序靠后，就算离开，对团队影响也很小的人。</p>\n</blockquote>\n<p>要规避 C，有两种打法。</p>\n<p>第 1 种是短期打法：抓关键事件，能不能找出 1-2 件事，体现出你的独特价值（比如本身影响力很大的项目，或者是领导最重视的事），相当于让你的排序有了最基本的保障。</p>\n<p>这种打法，你不能等到评价时再去改变，一定是在前期就抓住机会，承担起最有挑战的任务，然后全力以赴，做好了拿 A，不弄砸也不至于背 C，就怕静水潜流，躺平了去工作。</p>\n<p>第 2 种是长期打法：通过一步步信任的建立，成为团队的核心人员或者是老板的心腹，具备不可替代性。</p>\n<p>上面两种打法都是大的思路，还有很多锦上添花的技巧，比如：加强主动汇报（抹平领导的信息差）、让关键干系人给你点赞（能影响到你领导做出绩效决策的人）。</p>\n<h2> 写在最后</h2>\n<p>有人的地方就有江湖，有江湖就一定有规则，大厂平面看似平静，其实在绩效考核、晋升等利益点面前，都是一场厮杀。</p>\n<p>当大家攻山头的能力都很强时，**到底做成什么样才算做好了？**当你弄清楚了这个玄机，职场也就看透了。</p>\n<p>如果这篇文章让你有一点启发，来个点赞和在看呀！我是武哥，我们下期见！</p>\n",
      "date_published": "2022-06-13T08:45:44.000Z",
      "date_modified": "2022-06-13T08:45:44.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "技术文章精选集"
      ]
    },
    {
      "title": "缓存基础常见面试题总结(付费)",
      "url": "https://javaguide.cn/database/redis/cache-basics.html",
      "id": "https://javaguide.cn/database/redis/cache-basics.html",
      "summary": "缓存基础",
      "content_html": "<p><strong>缓存基础</strong></p>\n",
      "date_published": "2022-06-13T05:14:26.000Z",
      "date_modified": "2023-03-07T15:14:52.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "数据库"
      ]
    },
    {
      "title": "Redis 集群详解(付费)",
      "url": "https://javaguide.cn/database/redis/redis-cluster.html",
      "id": "https://javaguide.cn/database/redis/redis-cluster.html",
      "summary": "Redis 集群 相关的面试题为我的知识星球（点击链接即可查看详细介绍以及加入方法）专属内容，已经整理到了《Java 面试指北》中。",
      "content_html": "<p><strong>Redis 集群</strong> 相关的面试题为我的<a href=\"https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html\" target=\"_blank\" rel=\"noopener noreferrer\">知识星球</a>（点击链接即可查看详细介绍以及加入方法）专属内容，已经整理到了<a href=\"https://javaguide.cn/zhuanlan/java-mian-shi-zhi-bei.html\" target=\"_blank\" rel=\"noopener noreferrer\">《Java 面试指北》</a>中。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/redis-cluster-javamianshizhibei.png\" alt=\"\"></p>\n<p><a href=\"https://javaguide.cn/zhuanlan/java-mian-shi-zhi-bei.html\" target=\"_blank\" rel=\"noopener noreferrer\">《Java 面试指北》</a>（点击链接即可查看详细介绍）的部分内容展示如下，你可以将其看作是 <a href=\"https://javaguide.cn\" target=\"_blank\" rel=\"noopener noreferrer\">JavaGuide</a> 的补充完善，两者可以配合使用。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220304102536445.png\" alt=\"\"></p>\n<p>最近几年，市面上有越来越多的“技术大佬”开始办培训班/训练营，动辄成千上万的学费，却并没有什么干货，单纯的就是割韭菜。</p>\n<p>为了帮助更多同学准备 Java 面试以及学习 Java ，我创建了一个纯粹的知识星球。虽然收费只有培训班/训练营的百分之一，但是知识星球里的内容质量更高，提供的服务也更全面。</p>\n<p>欢迎准备 Java 面试以及学习 Java 的同学加入我的<a href=\"https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html\" target=\"_blank\" rel=\"noopener noreferrer\">知识星球</a>，干货非常多，学习氛围也很不错！收费虽然是白菜价，但星球里的内容或许比你参加上万的培训班质量还要高。</p>\n<div align=\"center\">\n  <a href=\"https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html\">\n    <img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220311203414600.png\" style=\"margin: 0 auto; \">\n  </a>\n</div>\n<p>下面是星球提供的部分服务（点击下方图片即可获取知识星球的详细介绍）：</p>\n<div align=\"center\">\n  <a href=\"https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html\">\n    <img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/xingqiufuwu.png\" style=\"margin: 0 auto; \">\n  </a>\n</div>\n<p><strong>我有自己的原则，不割韭菜，用心做内容，真心希望帮助到你！</strong></p>\n<p>如果你感兴趣的话，不妨花 3 分钟左右看看星球的详细介绍： <a href=\"https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html\" target=\"_blank\" rel=\"noopener noreferrer\">JavaGuide 知识星球详细介绍</a>。</p>\n<p>这里再送一个 30 元的新人优惠券（续费半价）。</p>\n<div align=\"center\">\n  <a href=\"https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html\">\n    <img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/xingqiuyouhuijuanheyi.png\" style=\"margin: 0 auto; \">\n  </a>\n</div>\n<p>进入星球之后，记得添加微信，我会发你详细的星球使用指南。</p>\n<div align=\"center\">\n  <a href=\"https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html\">\n    <img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/IMG_3007.jpg\" style=\"margin: 0 auto; \">\n  </a>\n</div>",
      "image": "https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/redis-cluster-javamianshizhibei.png",
      "date_published": "2022-06-13T05:14:26.000Z",
      "date_modified": "2023-01-29T03:31:13.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "数据库"
      ]
    },
    {
      "title": "泛型&通配符详解",
      "url": "https://javaguide.cn/java/basis/generics-and-wildcards.html",
      "id": "https://javaguide.cn/java/basis/generics-and-wildcards.html",
      "summary": "泛型&amp;通配符 相关的面试题为我的知识星球（点击链接即可查看详细介绍以及加入方法）专属内容，已经整理到了《Java 面试指北》（点击链接即可查看详细介绍以及获取方法）中。",
      "content_html": "<p><strong>泛型&amp;通配符</strong> 相关的面试题为我的<a href=\"https://www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc\" target=\"_blank\" rel=\"noopener noreferrer\">知识星球</a>（点击链接即可查看详细介绍以及加入方法）专属内容，已经整理到了<a href=\"https://www.yuque.com/docs/share/f37fc804-bfe6-4b0d-b373-9c462188fec7\" target=\"_blank\" rel=\"noopener noreferrer\">《Java 面试指北》</a>（点击链接即可查看详细介绍以及获取方法）中。</p>\n<p><a href=\"https://www.yuque.com/docs/share/f37fc804-bfe6-4b0d-b373-9c462188fec7\" target=\"_blank\" rel=\"noopener noreferrer\">《Java 面试指北》</a> 的部分内容展示如下，你可以将其看作是 <a href=\"https://javaguide.cn/#/\" target=\"_blank\" rel=\"noopener noreferrer\">JavaGuide</a> 的补充完善，两者可以配合使用。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220304102536445.png\" alt=\"\"></p>\n<p><a href=\"https://www.yuque.com/docs/share/f37fc804-bfe6-4b0d-b373-9c462188fec7\" target=\"_blank\" rel=\"noopener noreferrer\">《Java 面试指北》</a>只是星球内部众多资料中的一个，星球还有很多其他优质资料比如<a href=\"https://javaguide.cn/zhuanlan/\" target=\"_blank\" rel=\"noopener noreferrer\">专属专栏</a>、Java 编程视频、PDF 资料。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220211231206733.png\" alt=\"\"></p>\n<p>最近几年，市面上有越来越多的“技术大佬”开始办培训班/训练营，动辄成千上万的学费，却并没有什么干货，单纯的就是割韭菜。</p>\n<p>为了帮助更多同学准备 Java 面试以及学习 Java ，我创建了一个纯粹的<a href=\"https://www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc\" target=\"_blank\" rel=\"noopener noreferrer\">知识星球</a>。虽然收费只有培训班/训练营的百分之一，但是<a href=\"https://www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc\" target=\"_blank\" rel=\"noopener noreferrer\">知识星球</a>里的内容质量更高，提供的服务也更全面。</p>\n<p>欢迎准备 Java 面试以及学习 Java 的同学加入我的<a href=\"https://www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc\" target=\"_blank\" rel=\"noopener noreferrer\">知识星球</a>，干货非常多，学习氛围非常好！收费虽然是白菜价，但星球里的内容或许比你参加上万的培训班质量还要高。</p>\n<p>下面是星球提供的部分服务（点击下方图片即可获取知识星球的详细介绍）：</p>\n<div align=\"center\">\n  <a href=\"https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html\">\n    <img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/xingqiufuwu.png\" style=\"margin: 0 auto; \">\n  </a>\n</div>\n<p>我有自己的原则，不割韭菜，用心做内容，真心希望帮助到你！</p>\n<p>如果你感兴趣的话，不妨花 3 分钟左右看看星球的详细介绍： <a href=\"https://www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc\" target=\"_blank\" rel=\"noopener noreferrer\">JavaGuide 知识星球详细介绍</a>（文末有优惠券）。</p>\n<div align=\"center\">\n  <a href=\"https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html\">\n    <img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/xingqiuyouhuijuanheyi.png\" style=\"margin: 0 auto; \">\n  </a>\n</div>",
      "image": "https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220304102536445.png",
      "date_published": "2022-06-13T05:14:26.000Z",
      "date_modified": "2022-08-25T03:25:52.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "SpringBoot常见面试题总结(付费)",
      "url": "https://javaguide.cn/system-design/framework/spring/springboot-knowledge-and-questions-summary.html",
      "id": "https://javaguide.cn/system-design/framework/spring/springboot-knowledge-and-questions-summary.html",
      "summary": "Spring Boot 相关的面试题为我的知识星球（点击链接即可查看详细介绍以及加入方法）专属内容，已经整理到了《Java 面试指北》中。",
      "content_html": "<p><strong>Spring Boot</strong> 相关的面试题为我的<a href=\"https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html\" target=\"_blank\" rel=\"noopener noreferrer\">知识星球</a>（点击链接即可查看详细介绍以及加入方法）专属内容，已经整理到了<a href=\"https://javaguide.cn/zhuanlan/java-mian-shi-zhi-bei.html\" target=\"_blank\" rel=\"noopener noreferrer\">《Java 面试指北》</a>中。</p>\n<p><a href=\"https://javaguide.cn/zhuanlan/java-mian-shi-zhi-bei.html\" target=\"_blank\" rel=\"noopener noreferrer\">《Java 面试指北》</a>（点击链接即可查看详细介绍）的部分内容展示如下，你可以将其看作是 <a href=\"https://javaguide.cn\" target=\"_blank\" rel=\"noopener noreferrer\">JavaGuide</a> 的补充完善，两者可以配合使用。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220304102536445.png\" alt=\"\"></p>\n<p>最近几年，市面上有越来越多的“技术大佬”开始办培训班/训练营，动辄成千上万的学费，却并没有什么干货，单纯的就是割韭菜。</p>\n<p>为了帮助更多同学准备 Java 面试以及学习 Java ，我创建了一个纯粹的知识星球。虽然收费只有培训班/训练营的百分之一，但是知识星球里的内容质量更高，提供的服务也更全面。</p>\n<p>欢迎准备 Java 面试以及学习 Java 的同学加入我的<a href=\"https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html\" target=\"_blank\" rel=\"noopener noreferrer\">知识星球</a>，干货非常多，学习氛围也很不错！收费虽然是白菜价，但星球里的内容或许比你参加上万的培训班质量还要高。</p>\n<div align=\"center\">\n  <a href=\"https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html\">\n    <img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220311203414600.png\" style=\"margin: 0 auto; \">\n  </a>\n</div>\n<p>下面是星球提供的部分服务（点击下方图片即可获取知识星球的详细介绍）：</p>\n<div align=\"center\">\n  <a href=\"https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html\">\n    <img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/xingqiufuwu.png\" style=\"margin: 0 auto; \">\n  </a>\n</div>\n<p><strong>我有自己的原则，不割韭菜，用心做内容，真心希望帮助到你！</strong></p>\n<p>如果你感兴趣的话，不妨花 3 分钟左右看看星球的详细介绍： <a href=\"https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html\" target=\"_blank\" rel=\"noopener noreferrer\">JavaGuide 知识星球详细介绍</a>。</p>\n<p>这里再送一个 30 元的新人优惠券（续费半价）。</p>\n<div align=\"center\">\n  <a href=\"https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html\">\n    <img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/xingqiuyouhuijuanheyi.png\" style=\"margin: 0 auto; \">\n  </a>\n</div>\n<p>进入星球之后，记得添加微信，我会发你详细的星球使用指南。</p>\n<div align=\"center\">\n  <a href=\"https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html\">\n    <img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/IMG_3007.jpg\" style=\"margin: 0 auto; \">\n  </a>\n</div>\n",
      "image": "https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220304102536445.png",
      "date_published": "2022-06-13T05:14:26.000Z",
      "date_modified": "2023-01-29T03:31:13.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "框架"
      ]
    },
    {
      "title": "害，毕业三年了！",
      "url": "https://javaguide.cn/about-the-author/my-college-life.html",
      "id": "https://javaguide.cn/about-the-author/my-college-life.html",
      "summary": "关于初高中的生活，可以看 2020年我写的我曾经也是网瘾少年这篇文章。 2019 年 6 月份毕业，距今已经过去了 3 年。趁着高考以及应届生毕业之际，简单聊聊自己的大学生活。 下面是正文。 我本科毕业于荆州校区的长江大学，一所不起眼的双非一本。",
      "content_html": "<blockquote>\n<p>关于初高中的生活，可以看 2020年我写的<a href=\"https://javaguide.cn/about-the-author/internet-addiction-teenager.html\" target=\"_blank\" rel=\"noopener noreferrer\">我曾经也是网瘾少年</a>这篇文章。</p>\n</blockquote>\n<p>2019 年 6 月份毕业，距今已经过去了 3 年。趁着高考以及应届生毕业之际，简单聊聊自己的大学生活。</p>\n<p>下面是正文。</p>\n<p>我本科毕业于荆州校区的长江大学，一所不起眼的双非一本。</p>\n<p>在这里度过的四年大学生活还是过的挺开心的，直到现在，我依然非常怀念！</p>\n<p>在学校的这几年的生活，总体来说，还算是比较丰富多彩的。我会偶尔通宵敲代码，也会偶尔半夜发疯跑出去和同学一起走走古城墙、去网吧锤一夜的 LOL。</p>\n<p>写下这篇杂文，记录自己逝去的大学生活！希望未来继续砥砺前行，不忘初心！</p>\n<h2> 大一</h2>\n<p>大一那会，我没有把精力放在学习编程上，大部分时间都在参加课外活动。</p>\n<p>或许是因为来到了一座新鲜的城市，对周围的一切都充满了兴趣。又或许是因为当时的我还比较懵懂，也没有任何学习方向。</p>\n<p>这一年，我和班里的一群新同学去逛了荆州的很多地方比如荆州博物馆、长江大桥、张居正故居、关帝庙。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/about-the-author/college-life/41239dd7d18642f7af201292ead94f1a~tplv-k3u1fbpfcp-zoom-1.image.png\" alt=\"大一的一次班级出行\"></p>\n<p>即使如此，我当时还是对未来充满了希望，憧憬着工作之后的生活。</p>\n<p>我还记得当时我们 6 个室友那会一起聊天的时候，其他 5 个室友都觉得说未来找工作能找一个 6k 的就很不错了。我当时就说：“怎么得至少也要 8k 吧！”。他们无言，觉得我的想法太天真。</p>\n<p>其实，我当时内心想的是至少是月薪 1w 起步，只是不太好意思直接说出来。</p>\n<p>我不爱出风头，性格有点内向。刚上大学那会，内心还是有一点不自信，干什么事情都畏畏缩缩，还是迫切希望改变自己的！</p>\n<p>于是，凭借着一腔热血，我尝试了很多我之前从未尝试过的事情：<strong>露营</strong>、<strong>户外烧烤</strong>、<strong>公交车演讲</strong>、<strong>环跑古城墙</strong>、<strong>徒步旅行</strong>、<strong>异地求生</strong>、<strong>圣诞节卖苹果</strong> 、<strong>元旦晚会演出</strong>...。</p>\n<p>下面这些都是我和社团的小伙伴利用课外时间自己做的，在圣诞节那周基本都卖完了。我记得，为了能够多卖一些，我们还挨个去每一个寝室推销了一遍。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/about-the-author/college-life/7cf1a2da505249a58e1f29834dbac435~tplv-k3u1fbpfcp-zoom-1.image.png\" alt=\"\"></p>\n<p>我还参加了大一元旦晚会，不过，那次演出我还是没放开，说实话，感觉没有表现出应该有的那味。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/about-the-author/college-life/850cae1f8c644c5d920140f66ae9303d~tplv-k3u1fbpfcp-zoom-1.image.png\" alt=\"\"></p>\n<p>经过这次演出之后，我发现我是真的没有表演的天赋，很僵硬。并且，这种僵硬呆板是自己付出努力之后也没办法改变的。</p>\n<p>下图是某一次社团聚餐，我喝的有点小醉之后，被朋友拍下的。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/about-the-author/college-life/82a503e365354bd1bf190540fbf1039a~tplv-k3u1fbpfcp-zoom-1.image.png\" alt=\"\"></p>\n<p>那时候，还经常和和社团的几位小伙伴一起去夜走荆州古城墙。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/about-the-author/college-life/007a83e6d26c43b9aa6e0b0266c3314b~tplv-k3u1fbpfcp-zoom-1.image.png\" alt=\"某一次要去夜走古城墙的路上我拍的\"></p>\n<p>不知道社团的大家现在过得怎么样呢？</p>\n<p>虽然这些经历对于我未来的工作和发展其实没有任何帮助，但却让我的大学生活更加完整，经历了更多有趣的事情，有了更多可以回忆的经历。</p>\n<p>我的室友们都窝在寝室玩游戏、玩手机的时候，我很庆幸自己做了这些事情。</p>\n<p>个人感觉，大一的时候参加一些不错的社团活动，认识一些志同道合的朋友还是很不错的！</p>\n<p><strong>参加课外活动之余，CS 专业的小伙伴，尽量早一点养成一个好的编程习惯，学好一门编程语言，然后平时没事就刷刷算法题。</strong></p>\n<h3> 办补习班</h3>\n<p>大一暑假的时候，我作为负责人，在孝感的小乡镇上办过 5 个补习班（本来是 7 个，后来砍掉了 2 个） 。</p>\n<p>从租房子、租借桌椅再到招生基本都是从零开始做的。</p>\n<p>每个周末我都会从荆州坐车跑到孝感，在各个县城之间来回跑。绝大部分时候，只有我一个人，偶尔也会有几个社团的小伙伴陪我一起。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/about-the-author/college-life/6ee6358c236144d8a8a205cc6bc99b9b~tplv-k3u1fbpfcp-zoom-1.image.png\" alt=\"\"></p>\n<p>记忆犹新，那一年孝感也是闹洪水，还挺严重的。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/image-20210820201908759.png\" alt=\"\"></p>\n<p>有一次我差点回不去学校参加期末考试。虽然没有备考，但是也没有挂过任何一门课，甚至很多科目考的还不错。不过，这还是对我绩点产生了比较大的影响，导致我后面没有机会拿到奖学金。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/about-the-author/college-life/3c5fe7af43ba4e348244df1692500fce~tplv-k3u1fbpfcp-zoom-1.image.png\" alt=\"\"></p>\n<p>这次比较赶时间，所以就坐的是火车回学校。在火车上竟然还和别人撞箱子了！</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/about-the-author/college-life/570f5791aeb54fa1a76892b69e46fec2~tplv-k3u1fbpfcp-zoom-1.image.png\" alt=\"\"></p>\n<p>当时去小乡镇上的时候，自己最差的时候住过 15 元的旅馆。真的是 15 元，你没看错。就那种老旧民房的小破屋，没有独卫，床上用品也很不卫生，还不能洗澡。</p>\n<p>下面这个还是我住过最豪华的一个，因为当时坐客车去了孝感之后，突然下大雨，我就在车站附近找了一个相对便宜点的。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/about-the-author/college-life/687c3ede3f094c65a72d812ca0f06bb4~tplv-k3u1fbpfcp-zoom-1.image.png\" alt=\"\"></p>\n<p>为了以更低的价钱租到房子，我经常和房东砍价砍的面红耳赤。</p>\n<p>说句心里话，这些都是我不太愿意去做的事情，我本身属于比较爱面子而且不那么自信的人。</p>\n<p>当时，我需要在各个乡镇来回跑，每天就直接顶着太阳晒 。每次吃饭都特别香，随便炒个蔬菜都能吃几碗米饭。</p>\n<p>我本身是比较挑食的，这次经历让我真正体会到人饿了之后吃嘛嘛香!</p>\n<p>我一个人给 6 个老师加上 10 来个学生和房东们一家做了一个多月的饭，我的厨艺也因此得到了很大的锻炼。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/about-the-author/college-life/2e3b6101abcd46a8a213c08782aeac33~tplv-k3u1fbpfcp-zoom-1.image.png\" alt=\"\"></p>\n<p>这些学生有小学的，也有初中的，都比较听话。有很多还是留守儿童，爸爸妈妈在外打工，跟着爷爷奶奶一起生活。</p>\n<p>加上我的话，我们一共有 4 位老师，我主要讲的是初中和高中的物理课。</p>\n<p>学生们都挺听话，没有出现和我们几个老师闹过矛盾。只有两个调皮的小学生被我训斥之后，怀恨在心，写下了一些让我忍俊不禁的话！哈哈哈哈！太可爱了！</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/about-the-author/college-life/3680cead2c0f4165bb4865f038326b61~tplv-k3u1fbpfcp-zoom-1.image.png\" alt=\"\"></p>\n<p>离开之前的前一天的晚上，我和老师们商量请一些近点的同学们来吃饭。我们一大早就出去买菜了，下图是做成后的成品。虽然是比较简单的一顿饭，但我们吃的特别香。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/about-the-author/college-life/f36bfd719b9b4463b2f1d3edc51faa97~tplv-k3u1fbpfcp-zoom-1.image.png\" alt=\"补习班的最后一顿晚餐\"></p>\n<p>那天晚上还有几个家长专门跑过来看我做饭，家长们说他们的孩子非常喜欢我做的饭，哈哈哈！我表面淡然说自己做的不好，实则内心暗暗自喜，就很“闷骚”的一个人，哈哈哈！</p>\n<p>不知道这些学生们，现在怎么样呢？怀念啊！</p>\n<p>培训班结束，我回家之后，我爸妈都以为我是逃荒回来的。</p>\n<h3> 自己赚钱去孤儿院</h3>\n<p>大一尾声的时候，还做了一件非常有意义的事情。我和我的朋友们去了一次孤儿院（荆州私立孤儿教养院）。这个孤儿院曾经还被多家电视台报道过，目前也被百度百科收录。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/about-the-author/college-life/db8f5c276f4d4a7c9d7bd1e6100de301~tplv-k3u1fbpfcp-zoom-1.image.png\" alt=\"\"></p>\n<p>孤儿院的孩子们，大多是一些无父无母或者本身有一些疾病被父母遗弃的孩子。</p>\n<p>去之前，我们买了很多小孩子的玩具、文具、零食这些东西。这些钱的来源也比较有意义，都是我和社团的一些小伙伴自己去外面兼职赚的一些钱。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/about-the-author/college-life/cf43853c49bd489a9fc0ee437a2af432~tplv-k3u1fbpfcp-zoom-1.image.png\" alt=\"离开之前和创建孤儿院的老爷爷的一张合照\"></p>\n<p>勿以善小而不为！引用《爱的风险》这首歌的一句歌词：“只要人人都献出一点爱，世界将变成美好的人间” 。</p>\n<p>我想看看这个孤儿院的现状，于是在网上有搜了一下，看到了去年 1 月份荆州新闻网的一份报道。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/about-the-author/college-life/0ac27206389c498882dd7f6f440c6abb~tplv-k3u1fbpfcp-zoom-1.image.png\" alt=\"\"></p>\n<p>孤儿教养院创办 33 年来，累计收养孤儿 85 人，其中有 5 人参军入伍报效祖国，20 人上大学，有的早已参加工作并成家立业。</p>\n<p>叔叔也慢慢老了，白发越来越多。有点心酸，想哭，希望有机会再回去看看您！一定会的！</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/about-the-author/college-life/ea803a99c08149f892ca29e784653503~tplv-k3u1fbpfcp-zoom-1.image.png\" alt=\"\"></p>\n<h3> 徒步旅行</h3>\n<p>大一那会还有一件让我印象非常深刻的事情——徒步旅行。</p>\n<p>我和一群社团的小伙伴，徒步走了接近 45 公里。我们从学校的西校区，徒步走到了枝江那边的一个沙滩。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/about-the-author/college-life/94ca5b6c5ea84dfb9e12b7a718587ea3~tplv-k3u1fbpfcp-zoom-1.image.png\" alt=\"\"></p>\n<p>是真的全程步行，这还是我第一次走这么远。</p>\n<p>走到目的地的时候，我的双腿已经不听使唤，脚底被磨了很多水泡。</p>\n<p>我们在沙滩上露营，烧烤，唱歌跳舞，一直到第二天早上才踏上回学校的路程。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/about-the-author/college-life/8120d45d30254c908f9db20b3c00f514~tplv-k3u1fbpfcp-zoom-1.image.png\" alt=\"\"></p>\n<h2> 大二</h2>\n<p>到了大二，我开始把自己的重点转移到编程知识的学习上。</p>\n<p>不过，我遇到一个让我比较纠结的问题：社团里玩的最好的几个朋友为了能让社团能继续延续下去，希望我和他们一起来继续带这个团队。</p>\n<p>但是，我当时已经规划好了自己大二要做的事情，真的想把精力都放在编程学习上，想要好好沉淀一下自己的技术。</p>\n<p>迫于无奈，我最终还是妥协，选择了和朋友一起带社团。毕竟，遇到几个真心的朋友属实不易！</p>\n<h3> 带社团</h3>\n<p>带社团确实需要花费很多业余时间，除了每周要从东校区打车到西校区带着他们跑步之外，我们还需要经常带着他们组织一些活动。</p>\n<p>比如我们一起去了长江边上烧烤露营。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/about-the-author/college-life/8a6945ccc087017c1f96ee93f3af8178-20220608154206500.png\" alt=\"\"></p>\n<p>再比如我们一起去环跑了古城墙。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/about-the-author/college-life/2cfba22049e8b99e11955bcb7662d790.png\" alt=\"\"></p>\n<p>大学那会，我还是非常热爱运动的！</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/about-the-author/college-life/2dd503a60f814a7a953816bc3b5194cd~tplv-k3u1fbpfcp-zoom-1.image.png\" alt=\"\"></p>\n<p>大二那会，我就已经环跑了 3 次古城墙。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/about-the-author/college-life/949543b550e847d5a7314b7e1842489b~tplv-k3u1fbpfcp-zoom-1.image.png\" alt=\"\"></p>\n<h3> 加入长大在线</h3>\n<p>在大二的时候，我还加入了学校党委宣传部下的组织——长大在线。这是一个比较偏技术性质的组织，主要负责帮学校做做网站、APP 啥的。</p>\n<p>在百度上，还能搜索到长大在线的词条。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/about-the-author/college-life/34ecf650120a4289a68b7549eb7d00cc~tplv-k3u1fbpfcp-zoom-1.image.png\" alt=\"\"></p>\n<p>莫名其妙还被发了一个记者证，哈哈哈！</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/about-the-author/college-life/image-20220606121111042.png\" alt=\"\"></p>\n<p>我选的是安卓组，然后我就开始了学习安卓开发的旅程。</p>\n<p>刚加入这个组织的时候，我连 HTML、CSS、JS、Java、Linux 这些名词都不知道啥意思。</p>\n<p>再到后面，我留下来当了副站长，继续为组织服务了大半年多。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/about-the-author/college-life/image-20220608121413761.png\" alt=\"\"></p>\n<h3> 第一次参加比赛</h3>\n<p>那会也比较喜欢去参加一些学校的比赛，也获得过一些不错的名次，让我印象最深的是一次 PPT 大赛，这也是我第一次参加学校的比赛。</p>\n<p>参加比赛之前，自己也是一个 PPT 小白，苦心学了一周多之后，我的一个作品竟然顺利获得了第一名。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/about-the-author/college-life/image-20220608121446529.png\" alt=\"\"></p>\n<p>也正是因为这次比赛，我免费拥有了自己的第一个机械键盘，这个键盘陪我度过了后面的大学生活。</p>\n<h3> 确定技术方向</h3>\n<p>在大二上学期末，我最终确定了自己以后要走的技术方向是走 Java 后端。于是，我就开始制定学习计划，开始了自己的 Java 后端领域的打怪升级之路。</p>\n<p>每次忙到很晚，一个人走在校园的时候还是很爽的！非常喜欢这种安静的感觉。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/about-the-author/college-life/336fd489ce314d259d6090194f237e1b~tplv-k3u1fbpfcp-zoom-1.image.png\" alt=\"\"></p>\n<p>当时身体素质真好，熬夜之后第二天照常起来上课学习。现在熬个夜，后面两天直接就废了！</p>\n<p>到了大三，我基本把 Java 后端领域一些必备的技术都给过了一遍，还用自己学的东西做了两个实战项目。</p>\n<p>由于缺少正确的人指导，我当时学的时候也走了很多弯路，浪费了不少时间（我很羡慕大家能有我，就很厚脸皮！）。</p>\n<p>那个时候还贼自恋，没事就喜欢自拍一张。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/about-the-author/college-life/image-20210820202341008.png\" alt=\"\"></p>\n<p>国庆节的时候也不回家，继续在学校刷 Java 视频和书籍。</p>\n<p>我记得那次国庆节的时候效率还是非常高的，学习起来也特别有动力。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/about-the-author/college-life/WX20210820-203458.png\" alt=\"\"></p>\n<h2> 大三</h2>\n<p>整个大三，我依然没有周末，基本没有什么娱乐时间。绝大部分时间都是一个人在寝室默默学习，平时偶尔也会去图书馆和办公室。</p>\n<p>虽然室友经常会玩游戏和看剧什么的，但是我对我并没有什么影响。一个人戴上耳机之后，世界仿佛都是自己的。</p>\n<p>和很多大佬可能不太一样，比起图书馆和办公室，我在寝室的学习效率更高一些。</p>\n<h3> JavaGuide 诞生</h3>\n<p>我的开源项目 JavaGuide 和公众号都是这一年启动的。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/about-the-author/college-life/the-birth-of-javaguide.jpeg\" alt=\"\"></p>\n<p>目前的话，JavaGuide 也已经 100k star ，我的公众号也已经有 15w+ 的关注。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/about-the-author/college-life/image-20210820211926742.png\" alt=\"\"></p>\n<h3> 接私活赚钱</h3>\n<p>一些机遇也让我这一年也接了一些私活赚钱。为了能够顺利交付，偶尔也会熬夜。当时的心态是即使熬夜也还是很开心、充实。每次想到自己通过技术赚到了钱，就会非常有动力。</p>\n<p>我也曾写过文章分享过接私活的经历：<a href=\"https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247499539&amp;idx=1&amp;sn=ff153f9bd98bb3109b1f14e58ed9a785&amp;chksm=cea1b0d8f9d639cee4744f845042df6b1fc319f4383b87eba76a944c2648c81a51c28d25e3b6&amp;token=2114015135&amp;lang=zh_CN#rd\" target=\"_blank\" rel=\"noopener noreferrer\">唠唠嗑！大学那会接私活赚了 3w+</a> 。</p>\n<p>不过，我接的几个私活也是比较杂的，并不太适合作为简历上的项目经历。</p>\n<p>于是，为了能让简历上的项目经历看着更好看一些，我自己也找了两个项目做。一个是我跟着视频一起做的，是一个商城类型的项目。另外一个是自己根据自己的想法做的，是一个视频网站类型的项目。</p>\n<p>商城类型的项目大概的架构图如下（没有找到当时自己画的原图）：</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/about-the-author/college-life/206fab84bf5b4c048f8a88bc68c942f6~tplv-k3u1fbpfcp-zoom-1.image.png\" alt=\"\"></p>\n<p>那会商城项目貌似也已经烂大街了，用的人比较多。为了让自己的商城项目更有竞争力，对照着视频教程做完之后，我加入了很多自己的元素比如更换消息队列 ActiveMQ 为 Kafka、增加二级缓存。</p>\n<p>在暑假的时候，还和同学老师一起做了一个员工绩效管理的企业真实项目。这个项目和我刚进公司做的项目，非常非常相似，不过公司做得可能更高级点 ，代码质量也要更高一些。实在是太巧了！</p>\n<p>我记得当时自己独立做项目的时候，遇到了很多问题。<strong>就很多时候，你看书很容易就明白的东西，等到你实践的时候，总是会遇到一些小问题。我一般都是通过 Google 搜索解决的，用好搜索引擎真的能解决自己 99% 的问题。</strong></p>\n<h3> 参加软件设计大赛</h3>\n<p>大三这一年也有遗憾吧！我和几位志同道合的朋友一起参加过一个软件设计大赛，我们花了接近两个月做的系统顺利进入了复赛。</p>\n<p>不过，我后面因为自己个人觉得再花时间做这个系统学不到什么东西还浪费时间就直接退出了。然后，整个团队就散了。</p>\n<p>其实，先来回头看也是可以学到东西的，自己当时的心态有点飘了吧，心态有一些好高骛远。</p>\n<p>现在想来，还是挺对不起那些一起奋斗到深夜的小伙伴。</p>\n<p>人生就是这样，一生很长，任何时候你回头看过去的自己，肯定都会有让自己后悔的事情。</p>\n<h3> 放弃读研</h3>\n<p>当时，我也有纠结过是否读研，毕竟学校确实一般，读个研确实能够镀点金，提升一下学历。</p>\n<p>不过，我最终还是放弃了读研。当时比较自信，心里就觉得自己不需要读研也能够找到好工作。</p>\n<h3> 实习</h3>\n<p>大三还找了一家离学校不远的公司实习，一位老学长创办的。不过，说实话哈，总体实习体验很差，没有学到什么东西不说，还耽误了自己很多已经计划好的事情。</p>\n<p>我记得当时这个公司很多项目还是在用 JSP，用的技术很老。如果是老项目还好，我看几个月前启动的项目也还是用的 JSP，就很离谱。。。</p>\n<p>当时真的很难受，而且一来就想着让你上手干活，活还贼多，干不完还想让你免费加班。。。</p>\n<p>当时也没办法，因为荆州实在是找不到其他公司可以让你实习，你又没办法跑到其他城市去实习。这也是放弃选择一二线城市的学校带来的问题吧！</p>\n<h2> 大四</h2>\n<h3> 开始找工作</h3>\n<p>找实习找工作时候，才知道大学所在的城市的重要性。</p>\n<p>由于，我的学校在荆州，而且本身学校就很一般，因此，基本没有什么比较好的企业来招人。</p>\n<p>当时，唯一一个还算可以的就是苏宁，不过，我遇到的那个苏宁的 HR 还挺恶心的，第一轮面试的时候就开始压薪资了，问我能不能加班。然后，我也就对苏宁没有了想法。</p>\n<p>秋招我犯了一个比较严重的问题，那就是投递简历开始的太晚。我是把学校的项目差不多做完之后，才开始在网上投递简历。这个时候，暑假差不多已经结束了，秋招基本已经尾声了。</p>\n<p>可能也和学校环境有一些关系，当时，身边的同学没有参加秋招的。大三暑假的时候，都跑去搞学院组织的实习。我是留在学校做项目，没有去参加那次实习。</p>\n<p>我觉得学校还是非常有必要提醒学生们把握住秋招这次不错的机会的！</p>\n<p>在网上投递了一些简历之后，很多笔试我觉得做的还可以的都没有回应。</p>\n<p>我有点慌了！于是，我就从荆州来到武汉，想在武大华科这些不错的学校参加一些宣讲会。</p>\n<p>到了武汉之后，我花了一天时间找了一个蛋壳公寓住下。第二天，我就跑去武汉理工大学参加宣讲会。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/about-the-author/college-life/image-20210820204919942.png\" alt=\"\"></p>\n<p>当天，我就面试了自己求职过程中的第一家公司—<strong>玄武科技</strong>。</p>\n<p>就是这样一家中小型的公司，当时来求职面试的很多都是武大华科的学生。不过，他们之中一定有很多人和我一样，就是单纯来刷一波经验，找找信心。</p>\n<p>整个过程也就持续了 3 天左右，我就顺利的拿下了玄武科技的 offer。不过，最终没有签约。</p>\n<h3> 拿到 Offer</h3>\n<p>来武汉之前，我实际上已经在网上投递了 <strong>ThoughtWorks</strong>，并且，作业也已经通过了。</p>\n<p>当时，我对 ThoughtWorks 是最有好感的，内心的想法就是：“拿下了 ThoughtWorks，就不再面试其他公司了”。</p>\n<p>奈何 ThoughtWorks 的进度太慢，担心之余，才来武汉面试其他公司留个保底。</p>\n<p>不过，我最终如愿以偿获得了 ThoughtWorks 的 offer。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/about-the-author/college-life/9ad97dcc5038499b96239dd826c471b7~tplv-k3u1fbpfcp-zoom-1.image.png\" alt=\"\"></p>\n<p>面试 ThoughtWorks 的过程就不多说了，我在<a href=\"https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247484842&amp;idx=1&amp;sn=4489dfab0ef2479122b71407855afc71&amp;chksm=cea24a61f9d5c3774a8ed67c5fcc3234cb0741fbe831152986e5d1c8fb4f36a003f4fb2f247e&amp;scene=178&amp;cur_album_id=1323354342556057602#rd\" target=\"_blank\" rel=\"noopener noreferrer\">《结束了我短暂的秋招，说点自己的感受》</a>这篇文章中有提到。</p>\n<h2> 几点建议</h2>\n<p>说几点自己的建议，虽然我不优秀，但毕竟你可以更优秀：</p>\n<ol>\n<li>确定好自己的方向，搞清你是要考研还是要找工作。如果你要考研的话，好好上每一门可能是考研的科目，平时有时间也要敲代码，最好也能做一个项目，对你复试还有能力提升都有帮助。找工作的话，尽早确定好自己的方向，心里有一个规划，搞清自己的优势和劣势。</li>\n<li>尽可能早一点以求职为导向来学习，这样更有针对性，并且可以大概率减己处在迷茫的时间，很大程度上还可以让自己少走很多弯路。</li>\n<li>自学很重要，养成自学的习惯，学会学习。</li>\n<li>不要觉得逃课就是坏学生。我大学逃了很多课，逃课的大部分时间都是在学自己觉得更重要的东西，逃的大部分也是不那么重要并且不会影响我毕业的课。</li>\n<li>大学恋爱还是相对来说很纯粹的，遇到合适的可以尝试去了解一下， 别人不喜欢你的话不要死缠烂打，这种东西强求不来。你不得不承认，你了解一个人欲望还是始于他的长相而并不是有趣的灵魂。</li>\n<li>管理自己的身材，没事去跑跑步，别当油腻男。</li>\n<li>别太看重绩点。我觉得绩点对于找工作还有考研实际的作用都可以忽略不计，不过不挂科还是比较重要的。但是，绩点确实在奖学金评选和保研名额选取上占有最大的分量。</li>\n<li>别太功利性。做事情以及学习知识都不要奢求它能立马带给你什么，坚持和功利往往是成反比的。</li>\n<li>......</li>\n</ol>\n<h2> 后记</h2>\n<p>我们在找工作的过程中难免会遇到卡学历的情况，特别是我们这种学校本身就比较一般的。我觉得这真的不可厚非，没有什么不公平，要怪就只能怪自己没有考上好的学校。</p>\n<p><strong>考虑到招聘成本和时间，公司一定更愿意在学校本身比较好的人中选拔人才。</strong></p>\n<p>我也曾抱怨过自己为什么不在 211 或者 985 的学校。但，其实静下心来想一想，本来考不上 211 或者 985 就是自己的问题，而且在我们计算机这个领域，学历本身就相对于其他专业稍微要更加公平一点。</p>\n<p>我身边专科、三本毕业就进大厂的人也比比皆是。我这句话真不是鸡汤，为了鼓励一些学校出身不太好的朋友。</p>\n<p><strong>多行动，少抱怨。</strong></p>\n",
      "image": "https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/about-the-author/college-life/41239dd7d18642f7af201292ead94f1a~tplv-k3u1fbpfcp-zoom-1.image.png",
      "date_published": "2022-06-08T08:17:13.000Z",
      "date_modified": "2022-06-14T09:40:32.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "走近作者"
      ]
    },
    {
      "title": "JWT 基础概念详解",
      "url": "https://javaguide.cn/system-design/security/jwt-intro.html",
      "id": "https://javaguide.cn/system-design/security/jwt-intro.html",
      "summary": "什么是 JWT? JWT （JSON Web Token） 是目前最流行的跨域认证解决方案，是一种基于 Token 的认证授权机制。 从 JWT 的全称可以看出，JWT 本身也是 Token，一种规范化之后的 JSON 结构的 Token。 JWT 自身包含了身份验证所需要的所有信息，因此，我们的服务器不需要存储 Session 信息。这显然增加了系统的可用性和伸缩性，大大减轻了服务端的压力。 可以看出，JWT 更符合设计 RESTful API 时的「Stateless（无状态）」原则 。 并且， 使用 JWT 认证可以有效避免 CSRF 攻击，因为 JWT 一般是存在在 localStorage 中，使用 JWT 进行身份验证的过程中是不会涉及到 Cookie 的。",
      "content_html": "<h2> 什么是 JWT?</h2>\n<p>JWT （JSON Web Token） 是目前最流行的跨域认证解决方案，是一种基于 Token 的认证授权机制。 从 JWT 的全称可以看出，JWT 本身也是 Token，一种规范化之后的 JSON 结构的 Token。</p>\n<p>JWT 自身包含了身份验证所需要的所有信息，因此，我们的服务器不需要存储 Session 信息。这显然增加了系统的可用性和伸缩性，大大减轻了服务端的压力。</p>\n<p>可以看出，<strong>JWT 更符合设计 RESTful API 时的「Stateless（无状态）」原则</strong> 。</p>\n<p>并且， 使用 JWT 认证可以有效避免 CSRF 攻击，因为 JWT 一般是存在在 localStorage 中，使用 JWT 进行身份验证的过程中是不会涉及到 Cookie 的。</p>\n<p>我在 <a href=\"/system-design/security/advantages&amp;disadvantages-of-jwt.html\" target=\"blank\">JWT 优缺点分析</a>这篇文章中有详细介绍到使用 JWT 做身份认证的优势和劣势。</p>\n<p>下面是 <a href=\"https://tools.ietf.org/html/rfc7519\" target=\"_blank\" rel=\"noopener noreferrer\">RFC 7519</a> 对 JWT 做的较为正式的定义。</p>\n<blockquote>\n<p>JSON Web Token (JWT) is a compact, URL-safe means of representing claims to be transferred between two parties. The claims in a JWT are encoded as a JSON object that is used as the payload of a JSON Web Signature (JWS) structure or as the plaintext of a JSON Web Encryption (JWE) structure, enabling the claims to be digitally signed or integrity protected with a Message Authentication Code (MAC) and/or encrypted. ——<a href=\"https://tools.ietf.org/html/rfc7519\" target=\"_blank\" rel=\"noopener noreferrer\">JSON Web Token (JWT)</a></p>\n</blockquote>\n<h2> JWT 由哪些部分组成？</h2>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/system-design/jwt/jwt-composition.png\" alt=\"此图片来源于：https://supertokens.com/blog/oauth-vs-jwt\"></p>\n<p>JWT 本质上就是一组字串，通过（<code>.</code>）切分成三个为 Base64 编码的部分：</p>\n<ul>\n<li><strong>Header</strong> : 描述 JWT 的元数据，定义了生成签名的算法以及 <code>Token</code> 的类型。</li>\n<li><strong>Payload</strong> : 用来存放实际需要传递的数据</li>\n<li><strong>Signature（签名）</strong> ：服务器通过 Payload、Header 和一个密钥(Secret)使用 Header 里面指定的签名算法（默认是 HMAC SHA256）生成。</li>\n</ul>\n<p>JWT 通常是这样的：<code>xxxxx.yyyyy.zzzzz</code>。</p>\n<p>示例：</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>你可以在 <a href=\"https://jwt.io/\" target=\"_blank\" rel=\"noopener noreferrer\">jwt.io</a> 这个网站上对其 JWT 进行解码，解码之后得到的就是 Header、Payload、Signature 这三部分。</p>\n<p>Header 和 Payload 都是 JSON 格式的数据，Signature 由 Payload、Header 和 Secret(密钥)通过特定的计算公式和加密算法得到。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/system-design/jwt/jwt.io.png\" alt=\"\"></p>\n<h3> Header</h3>\n<p>Header 通常由两部分组成：</p>\n<ul>\n<li><code>typ</code>（Type）：令牌类型，也就是 JWT。</li>\n<li><code>alg</code>（Algorithm） ：签名算法，比如 HS256。</li>\n</ul>\n<p>示例：</p>\n<div class=\"language-json line-numbers-mode\" data-ext=\"json\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>JSON 形式的 Header 被转换成 Base64 编码，成为 JWT 的第一部分。</p>\n<h3> Payload</h3>\n<p>Payload 也是 JSON 格式数据，其中包含了 Claims(声明，包含 JWT 的相关信息)。</p>\n<p>Claims 分为三种类型：</p>\n<ul>\n<li><strong>Registered Claims（注册声明）</strong> ：预定义的一些声明，建议使用，但不是强制性的。</li>\n<li><strong>Public Claims（公有声明）</strong> ：JWT 签发方可以自定义的声明，但是为了避免冲突，应该在 <a href=\"https://www.iana.org/assignments/jwt/jwt.xhtml\" target=\"_blank\" rel=\"noopener noreferrer\">IANA JSON Web Token Registry</a> 中定义它们。</li>\n<li><strong>Private Claims（私有声明）</strong> ：JWT 签发方因为项目需要而自定义的声明，更符合实际项目场景使用。</li>\n</ul>\n<p>下面是一些常见的注册声明：</p>\n<ul>\n<li><code>iss</code>（issuer）：JWT 签发方。</li>\n<li><code>iat</code>（issued at time）：JWT 签发时间。</li>\n<li><code>sub</code>（subject）：JWT 主题。</li>\n<li><code>aud</code>（audience）：JWT 接收方。</li>\n<li><code>exp</code>（expiration time）：JWT 的过期时间。</li>\n<li><code>nbf</code>（not before time）：JWT 生效时间，早于该定义的时间的 JWT 不能被接受处理。</li>\n<li><code>jti</code>（JWT ID）：JWT 唯一标识。</li>\n</ul>\n<p>示例：</p>\n<div class=\"language-json line-numbers-mode\" data-ext=\"json\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>Payload 部分默认是不加密的，<strong>一定不要将隐私信息存放在 Payload 当中！！！</strong></p>\n<p>JSON 形式的 Payload 被转换成 Base64 编码，成为 JWT 的第二部分。</p>\n<h3> Signature</h3>\n<p>Signature 部分是对前两部分的签名，作用是防止 JWT（主要是 payload） 被篡改。</p>\n<p>这个签名的生成需要用到：</p>\n<ul>\n<li>Header + Payload。</li>\n<li>存放在服务端的密钥(一定不要泄露出去)。</li>\n<li>签名算法。</li>\n</ul>\n<p>签名的计算公式如下：</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用\"点\"（<code>.</code>）分隔，这个字符串就是 JWT 。</p>\n<h2> 如何基于 JWT 进行身份验证？</h2>\n<p>在基于 JWT 进行身份验证的的应用程序中，服务器通过 Payload、Header 和 Secret(密钥)创建 JWT 并将 JWT 发送给客户端。客户端接收到 JWT 之后，会将其保存在 Cookie 或者 localStorage 里面，以后客户端发出的所有请求都会携带这个令牌。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/system-design/jwt/jwt-authentication process.png\" alt=\" JWT 身份验证示意图\"></p>\n<p>简化后的步骤如下：</p>\n<ol>\n<li>用户向服务器发送用户名、密码以及验证码用于登陆系统。</li>\n<li>如果用户用户名、密码以及验证码校验正确的话，服务端会返回已经签名的 Token，也就是 JWT。</li>\n<li>用户以后每次向后端发请求都在 Header 中带上这个 JWT 。</li>\n<li>服务端检查 JWT 并从中获取用户相关信息。</li>\n</ol>\n<p>两点建议：</p>\n<ol>\n<li>建议将 JWT 存放在 localStorage 中，放在 Cookie 中会有 CSRF 风险。</li>\n<li>请求服务端并携带 JWT 的常见做法是将其放在 HTTP Header 的 <code>Authorization</code> 字段中（<code>Authorization: Bearer Token</code>）。</li>\n</ol>\n<p><strong><a href=\"https://github.com/Snailclimb/spring-security-jwt-guide\" target=\"_blank\" rel=\"noopener noreferrer\">spring-security-jwt-guide</a></strong> 就是一个基于 JWT 来做身份认证的简单案例，感兴趣的可以看看。</p>\n<h2> 如何防止 JWT 被篡改？</h2>\n<p>有了签名之后，即使 JWT 被泄露或者截获，黑客也没办法同时篡改 Signature 、Header 、Payload。</p>\n<p>这是为什么呢？因为服务端拿到 JWT 之后，会解析出其中包含的 Header、Payload 以及 Signature 。服务端会根据 Header、Payload、密钥再次生成一个 Signature。拿新生成的 Signature 和 JWT 中的 Signature 作对比，如果一样就说明 Header 和 Payload 没有被修改。</p>\n<p>不过，如果服务端的秘钥也被泄露的话，黑客就可以同时篡改 Signature 、Header 、Payload 了。黑客直接修改了 Header 和 Payload 之后，再重新生成一个 Signature 就可以了。</p>\n<p><strong>密钥一定保管好，一定不要泄露出去。JWT 安全的核心在于签名，签名安全的核心在密钥。</strong></p>\n<h2> 如何加强 JWT 的安全性？</h2>\n<ol>\n<li>使用安全系数高的加密算法。</li>\n<li>使用成熟的开源库，没必要造轮子。</li>\n<li>JWT 存放在 localStorage 中而不是 Cookie 中，避免 CSRF 风险。</li>\n<li>一定不要将隐私信息存放在 Payload 当中。</li>\n<li>密钥一定保管好，一定不要泄露出去。JWT 安全的核心在于签名，签名安全的核心在密钥。</li>\n<li>Payload 要加入 <code>exp</code> （JWT 的过期时间），永久有效的 JWT 不合理。并且，JWT 的过期时间不易过长。</li>\n<li>......</li>\n</ol>\n",
      "image": "https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/system-design/jwt/jwt-composition.png",
      "date_published": "2022-05-29T06:45:53.000Z",
      "date_modified": "2022-11-13T16:21:16.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "系统设计"
      ]
    },
    {
      "title": "十大经典排序算法总结",
      "url": "https://javaguide.cn/cs-basics/algorithms/10-classical-sorting-algorithms.html",
      "id": "https://javaguide.cn/cs-basics/algorithms/10-classical-sorting-algorithms.html",
      "summary": "本文转自：http://www.guoyaohua.com/sorting.html，JavaGuide 对其做了补充完善。 引言 所谓排序，就是使一串记录，按照其中的某个或某些关键字的大小，递增或递减的排列起来的操作。排序算法，就是如何使得记录按照要求排列的方法。排序算法在很多领域得到相当地重视，尤其是在大量数据的处理方面。一个优秀的算法可以节省大量的资源。在各个领域中考虑到数据的各种限制和规范，要得到一个符合实际的优秀算法，得经过大量的推理和分析。 两年前，我曾在博客园发布过一篇《十大经典排序算法最强总结（含 JAVA 代码实现）》博文，简要介绍了比较经典的十大排序算法，不过在之前的博文中，仅给出了 Java 版本的代码实现，并且有一些细节上的错误。所以，今天重新写一篇文章，深入了解下十大经典排序算法的原理及实现。",
      "content_html": "<blockquote>\n<p>本文转自：http://www.guoyaohua.com/sorting.html，JavaGuide 对其做了补充完善。</p>\n</blockquote>\n<h2> 引言</h2>\n<p>所谓排序，就是使一串记录，按照其中的某个或某些关键字的大小，递增或递减的排列起来的操作。排序算法，就是如何使得记录按照要求排列的方法。排序算法在很多领域得到相当地重视，尤其是在大量数据的处理方面。一个优秀的算法可以节省大量的资源。在各个领域中考虑到数据的各种限制和规范，要得到一个符合实际的优秀算法，得经过大量的推理和分析。</p>\n<p>两年前，我曾在<a href=\"https://www.cnblogs.com/guoyaohua/\" target=\"_blank\" rel=\"noopener noreferrer\">博客园</a>发布过一篇<a href=\"https://www.cnblogs.com/guoyaohua/p/8600214.html\" target=\"_blank\" rel=\"noopener noreferrer\">《十大经典排序算法最强总结（含 JAVA 代码实现）》</a>博文，简要介绍了比较经典的十大排序算法，不过在之前的博文中，仅给出了 Java 版本的代码实现，并且有一些细节上的错误。所以，今天重新写一篇文章，深入了解下十大经典排序算法的原理及实现。</p>\n<h2> 简介</h2>\n<p>排序算法可以分为：</p>\n<ul>\n<li><strong>内部排序</strong> ：数据记录在内存中进行排序。</li>\n<li><strong><a href=\"https://zh.wikipedia.org/wiki/%E5%A4%96%E6%8E%92%E5%BA%8F\" target=\"_blank\" rel=\"noopener noreferrer\">外部排序</a></strong> ：因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。</li>\n</ul>\n<p>常见的内部排序算法有：<strong>插入排序</strong>、<strong>希尔排序</strong>、<strong>选择排序</strong>、<strong>冒泡排序</strong>、<strong>归并排序</strong>、<strong>快速排序</strong>、<strong>堆排序</strong>、<strong>基数排序</strong>等，本文只讲解内部排序算法。用一张图概括：</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/sorting-algorithms/sort1.png\" alt=\"十大排序算法\"></p>\n<p><strong>图片名词解释：</strong></p>\n<ul>\n<li><strong>n</strong>：数据规模</li>\n<li><strong>k</strong>：“桶” 的个数</li>\n<li><strong>In-place</strong>：占用常数内存，不占用额外内存</li>\n<li><strong>Out-place</strong>：占用额外内存</li>\n</ul>\n<h3> 术语说明</h3>\n<ul>\n<li><strong>稳定</strong>：如果 A 原本在 B 前面，而 A=B，排序之后 A 仍然在 B 的前面。</li>\n<li><strong>不稳定</strong>：如果 A 原本在 B 的前面，而 A=B，排序之后 A 可能会出现在 B 的后面。</li>\n<li><strong>内排序</strong>：所有排序操作都在内存中完成。</li>\n<li><strong>外排序</strong>：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行。</li>\n<li><strong>时间复杂度</strong>： 定性描述一个算法执行所耗费的时间。</li>\n<li><strong>空间复杂度</strong>：定性描述一个算法执行所需内存的大小。</li>\n</ul>\n<h3> 算法分类</h3>\n<p>十种常见排序算法可以分类两大类别：<strong>比较类排序</strong>和<strong>非比较类排序</strong>。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/sorting-algorithms/sort2.png\" alt=\"排序算法分类\"></p>\n<p>常见的<strong>快速排序</strong>、<strong>归并排序</strong>、<strong>堆排序</strong>以及<strong>冒泡排序</strong>等都属于<strong>比较类排序算法</strong>。比较类排序是通过比较来决定元素间的相对次序，由于其时间复杂度不能突破 <code>O(nlogn)</code>，因此也称为非线性时间比较类排序。在冒泡排序之类的排序中，问题规模为 <code>n</code>，又因为需要比较 <code>n</code> 次，所以平均时间复杂度为 <code>O(n²)</code>。在<strong>归并排序</strong>、<strong>快速排序</strong>之类的排序中，问题规模通过<strong>分治法</strong>消减为 <code>logn</code> 次，所以时间复杂度平均 <code>O(nlogn)</code>。</p>\n<p>比较类排序的优势是，适用于各种规模的数据，也不在乎数据的分布，都能进行排序。可以说，比较排序适用于一切需要排序的情况。</p>\n<p>而<strong>计数排序</strong>、<strong>基数排序</strong>、<strong>桶排序</strong>则属于<strong>非比较类排序算法</strong>。非比较排序不通过比较来决定元素间的相对次序，而是通过确定每个元素之前，应该有多少个元素来排序。由于它可以突破基于比较排序的时间下界，以线性时间运行，因此称为线性时间非比较类排序。 非比较排序只要确定每个元素之前的已有的元素个数即可，所有一次遍历即可解决。算法时间复杂度 <code>O(n)</code>。</p>\n<p>非比较排序时间复杂度底，但由于非比较排序需要占用空间来确定唯一位置。所以对数据规模和数据分布有一定的要求。</p>\n<h2> 冒泡排序 (Bubble Sort)</h2>\n<p>冒泡排序是一种简单的排序算法。它重复地遍历要排序的序列，依次比较两个元素，如果它们的顺序错误就把它们交换过来。遍历序列的工作是重复地进行直到没有再需要交换为止，此时说明该序列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢 “浮” 到数列的顶端。</p>\n<h3> 算法步骤</h3>\n<ol>\n<li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li>\n<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li>\n<li>针对所有的元素重复以上的步骤，除了最后一个；</li>\n<li>重复步骤 1~3，直到排序完成。</li>\n</ol>\n<h3> 图解算法</h3>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/sorting-algorithms/bubble_sort.gif\" alt=\"冒泡排序\"></p>\n<h3> 代码实现</h3>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>此处对代码做了一个小优化，加入了 <code>is_sorted</code> Flag，目的是将算法的最佳时间复杂度优化为 <code>O(n)</code>，即当原输入序列就是排序好的情况下，该算法的时间复杂度就是 <code>O(n)</code>。</strong></p>\n<h3> 算法分析</h3>\n<ul>\n<li><strong>稳定性</strong>：稳定</li>\n<li><strong>时间复杂度</strong> ：最佳：O(n) ，最差：O(n2)， 平均：O(n2)</li>\n<li><strong>空间复杂度</strong> ：O(1)</li>\n<li><strong>排序方式</strong> ：In-place</li>\n</ul>\n<h2> 选择排序 (Selection Sort)</h2>\n<p>选择排序是一种简单直观的排序算法，无论什么数据进去都是 <code>O(n²)</code> 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>\n<h3> 算法步骤</h3>\n<ol>\n<li>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</li>\n<li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li>\n<li>重复第 2 步，直到所有元素均排序完毕。</li>\n</ol>\n<h3> 图解算法</h3>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/sorting-algorithms/selection_sort.gif\" alt=\"Selection Sort\"></p>\n<h3> 代码实现</h3>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 算法分析</h3>\n<ul>\n<li><strong>稳定性</strong>：不稳定</li>\n<li><strong>时间复杂度</strong> ：最佳：O(n2) ，最差：O(n2)， 平均：O(n2)</li>\n<li><strong>空间复杂度</strong> ：O(1)</li>\n<li><strong>排序方式</strong> ：In-place</li>\n</ul>\n<h2> 插入排序 (Insertion Sort)</h2>\n<p>插入排序是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用 in-place 排序（即只需用到 <code>O(1)</code> 的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p>\n<p>插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>\n<p>插入排序和冒泡排序一样，也有一种优化算法，叫做拆半插入。</p>\n<h3> 算法步骤</h3>\n<ol>\n<li>从第一个元素开始，该元素可以认为已经被排序；</li>\n<li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li>\n<li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li>\n<li>重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置；</li>\n<li>将新元素插入到该位置后；</li>\n<li>重复步骤 2~5。</li>\n</ol>\n<h3> 图解算法</h3>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/sorting-algorithms/insertion_sort.gif\" alt=\"insertion_sort\"></p>\n<h3> 代码实现</h3>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 算法分析</h3>\n<ul>\n<li><strong>稳定性</strong>：稳定</li>\n<li><strong>时间复杂度</strong> ：最佳：O(n) ，最差：O(n2)， 平均：O(n2)</li>\n<li><strong>空间复杂度</strong> ：O(1)</li>\n<li><strong>排序方式</strong> ：In-place</li>\n</ul>\n<h2> 希尔排序 (Shell Sort)</h2>\n<p>希尔排序是希尔 (Donald Shell) 于 1959 年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为递减增量排序算法，同时该算法是冲破 <code>O(n²)</code> 的第一批算法之一。</p>\n<p>希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录 “基本有序” 时，再对全体记录进行依次直接插入排序。</p>\n<h3> 算法步骤</h3>\n<p>我们来看下希尔排序的基本步骤，在此我们选择增量 <code>gap=length/2</code>，缩小增量继续以 <code>gap = gap/2</code> 的方式，这种增量选择我们可以用一个序列来表示，<code>{n/2, (n/2)/2, ..., 1}</code>，称为<strong>增量序列</strong>。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处我们做示例使用希尔增量。</p>\n<p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p>\n<ul>\n<li>选择一个增量序列 <code>{t1, t2, …, tk}</code>，其中 <code>(ti&gt;tj, i&lt;j, tk=1)</code>；</li>\n<li>按增量序列个数 k，对序列进行 k 趟排序；</li>\n<li>每趟排序，根据对应的增量 <code>t</code>，将待排序列分割成若干长度为 <code>m</code> 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li>\n</ul>\n<h3> 图解算法</h3>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/sorting-algorithms/shell_sort.png\" alt=\"shell_sort\"></p>\n<h3> 代码实现</h3>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 算法分析</h3>\n<ul>\n<li><strong>稳定性</strong>：稳定</li>\n<li><strong>时间复杂度</strong> ：最佳：O(nlogn)， 最差：O(n2) 平均：O(nlogn)</li>\n<li><strong>空间复杂度</strong> ：<code>O(1)</code></li>\n</ul>\n<h2> 归并排序 (Merge Sort)</h2>\n<p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法 (Divide and Conquer) 的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为 2 - 路归并。</p>\n<p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 <code>O(nlogn)</code> 的时间复杂度。代价是需要额外的内存空间。</p>\n<h3> 算法步骤</h3>\n<p>归并排序算法是一个递归过程，边界条件为当输入序列仅有一个元素时，直接返回，具体过程如下：</p>\n<ol>\n<li>如果输入内只有一个元素，则直接返回，否则将长度为 <code>n</code> 的输入序列分成两个长度为 <code>n/2</code> 的子序列；</li>\n<li>分别对这两个子序列进行归并排序，使子序列变为有序状态；</li>\n<li>设定两个指针，分别指向两个已经排序子序列的起始位置；</li>\n<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间（用于存放排序结果），并移动指针到下一位置；</li>\n<li>重复步骤 3 ~4 直到某一指针达到序列尾；</li>\n<li>将另一序列剩下的所有元素直接复制到合并序列尾。</li>\n</ol>\n<h3> 图解算法</h3>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/sorting-algorithms/merge_sort.gif\" alt=\"MergeSort\"></p>\n<h3> 代码实现</h3>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 算法分析</h3>\n<ul>\n<li><strong>稳定性</strong>：稳定</li>\n<li><strong>时间复杂度</strong> ：最佳：O(nlogn)， 最差：O(nlogn)， 平均：O(nlogn)</li>\n<li><strong>空间复杂度</strong> ：O(n)</li>\n</ul>\n<h2> 快速排序 (Quick Sort)</h2>\n<p>快速排序用到了分治思想，同样的还有归并排序。乍看起来快速排序和归并排序非常相似，都是将问题变小，先排序子串，最后合并。不同的是快速排序在划分子问题的时候经过多一步处理，将划分的两组数据划分为一大一小，这样在最后合并的时候就不必像归并排序那样再进行比较。但也正因为如此，划分的不定性使得快速排序的时间复杂度并不稳定。</p>\n<p>快速排序的基本思想：通过一趟排序将待排序列分隔成独立的两部分，其中一部分记录的元素均比另一部分的元素小，则可分别对这两部分子序列继续进行排序，以达到整个序列有序。</p>\n<h3> 算法步骤</h3>\n<p>快速排序使用<a href=\"https://zh.wikipedia.org/wiki/%E5%88%86%E6%B2%BB%E6%B3%95\" target=\"_blank\" rel=\"noopener noreferrer\">分治法</a>（Divide and conquer）策略来把一个序列分为较小和较大的 2 个子序列，然后递回地排序两个子序列。具体算法描述如下：</p>\n<ol>\n<li>从序列中<strong>随机</strong>挑出一个元素，做为 “基准”(<code>pivot</code>)；</li>\n<li>重新排列序列，将所有比基准值小的元素摆放在基准前面，所有比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个操作结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li>\n<li>递归地把小于基准值元素的子序列和大于基准值元素的子序列进行快速排序。</li>\n</ol>\n<h3> 图解算法</h3>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/sorting-algorithms/random_quick_sort.gif\" alt=\"RandomQuickSort\"></p>\n<h3> 代码实现</h3>\n<blockquote>\n<p>来源：<a href=\"https://segmentfault.com/a/1190000040022056\" target=\"_blank\" rel=\"noopener noreferrer\">使用 Java 实现快速排序（详解）</a></p>\n</blockquote>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 算法分析</h3>\n<ul>\n<li><strong>稳定性</strong> ：不稳定</li>\n<li><strong>时间复杂度</strong> ：最佳：O(nlogn)， 最差：O(nlogn)，平均：O(nlogn)</li>\n<li><strong>空间复杂度</strong> ：O(nlogn)</li>\n</ul>\n<h2> 堆排序 (Heap Sort)</h2>\n<p>堆排序是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足<strong>堆的性质</strong>：即<strong>子结点的值总是小于（或者大于）它的父节点</strong>。</p>\n<h3> 算法步骤</h3>\n<ol>\n<li>将初始待排序列 <code>(R1, R2, ……, Rn)</code> 构建成大顶堆，此堆为初始的无序区；</li>\n<li>将堆顶元素 <code>R[1]</code> 与最后一个元素 <code>R[n]</code> 交换，此时得到新的无序区 <code>(R1, R2, ……, Rn-1)</code> 和新的有序区 (Rn), 且满足 <code>R[1, 2, ……, n-1]&lt;=R[n]</code>；</li>\n<li>由于交换后新的堆顶 <code>R[1]</code> 可能违反堆的性质，因此需要对当前无序区 <code>(R1, R2, ……, Rn-1)</code> 调整为新堆，然后再次将 R [1] 与无序区最后一个元素交换，得到新的无序区 <code>(R1, R2, ……, Rn-2)</code> 和新的有序区 <code>(Rn-1, Rn)</code>。不断重复此过程直到有序区的元素个数为 <code>n-1</code>，则整个排序过程完成。</li>\n</ol>\n<h3> 图解算法</h3>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/sorting-algorithms/heap_sort.gif\" alt=\"HeapSort\"></p>\n<h3> 代码实现</h3>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 算法分析</h3>\n<ul>\n<li><strong>稳定性</strong> ：不稳定</li>\n<li><strong>时间复杂度</strong> ：最佳：O(nlogn)， 最差：O(nlogn)， 平均：O(nlogn)</li>\n<li><strong>空间复杂度</strong> ：O(1)</li>\n</ul>\n<h2> 计数排序 (Counting Sort)</h2>\n<p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，<strong>计数排序要求输入的数据必须是有确定范围的整数</strong>。</p>\n<p>计数排序 (Counting sort) 是一种稳定的排序算法。计数排序使用一个额外的数组 <code>C</code>，其中第 <code>i</code> 个元素是待排序数组 <code>A</code> 中值等于 <code>i</code> 的元素的个数。然后根据数组 <code>C</code> 来将 <code>A</code> 中的元素排到正确的位置。<strong>它只能对整数进行排序</strong>。</p>\n<h3> 算法步骤</h3>\n<ol>\n<li>找出数组中的最大值 <code>max</code>、最小值 <code>min</code>；</li>\n<li>创建一个新数组 <code>C</code>，其长度是 <code>max-min+1</code>，其元素默认值都为 0；</li>\n<li>遍历原数组 <code>A</code> 中的元素 <code>A[i]</code>，以 <code>A[i]-min</code> 作为 <code>C</code> 数组的索引，以 <code>A[i]</code> 的值在 <code>A</code> 中元素出现次数作为 <code>C[A[i]-min]</code> 的值；</li>\n<li>对 <code>C</code> 数组变形，<strong>新元素的值是该元素与前一个元素值的和</strong>，即当 <code>i&gt;1</code> 时 <code>C[i] = C[i] + C[i-1]</code>；</li>\n<li>创建结果数组 <code>R</code>，长度和原始数组一样。</li>\n<li><strong>从后向前</strong>遍历原始数组 <code>A</code> 中的元素 <code>A[i]</code>，使用 <code>A[i]</code> 减去最小值 <code>min</code> 作为索引，在计数数组 <code>C</code> 中找到对应的值 <code>C[A[i]-min]</code>，<code>C[A[i]-min]-1</code> 就是 <code>A[i]</code> 在结果数组 <code>R</code> 中的位置，做完上述这些操作，将 <code>count[A[i]-min]</code> 减小 1。</li>\n</ol>\n<h3> 图解算法</h3>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/sorting-algorithms/counting_sort.gif\" alt=\"CountingSort\"></p>\n<h3> 代码实现</h3>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 算法分析</h2>\n<p>当输入的元素是 <code>n</code> 个 <code>0</code> 到 <code>k</code> 之间的整数时，它的运行时间是 <code>O(n+k)</code>。计数排序不是比较排序，排序的速度快于任何比较排序算法。由于用来计数的数组 <code>C</code> 的长度取决于待排序数组中数据的范围（等于待排序数组的<strong>最大值与最小值的差加上 1</strong>），这使得计数排序对于数据范围很大的数组，需要大量额外内存空间。</p>\n<ul>\n<li><strong>稳定性</strong> ：稳定</li>\n<li><strong>时间复杂度</strong> ：最佳：<code>O(n+k)</code> 最差：<code>O(n+k)</code> 平均：<code>O(n+k)</code></li>\n<li><strong>空间复杂度</strong> ：<code>O(k)</code></li>\n</ul>\n<h2> 桶排序 (Bucket Sort)</h2>\n<p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点：</p>\n<ol>\n<li>在额外空间充足的情况下，尽量增大桶的数量</li>\n<li>使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中</li>\n</ol>\n<p>桶排序的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行。</p>\n<h3> 算法步骤</h3>\n<ol>\n<li>设置一个 BucketSize，作为每个桶所能放置多少个不同数值；</li>\n<li>遍历输入数据，并且把数据依次映射到对应的桶里去；</li>\n<li>对每个非空的桶进行排序，可以使用其它排序方法，也可以递归使用桶排序；</li>\n<li>从非空桶里把排好序的数据拼接起来。</li>\n</ol>\n<h3> 图解算法</h3>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/sorting-algorithms/bucket_sort.gif\" alt=\"BucketSort\"></p>\n<h3> 代码实现</h3>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 算法分析</h3>\n<ul>\n<li><strong>稳定性</strong> ：稳定</li>\n<li><strong>时间复杂度</strong> ：最佳：<code>O(n+k)</code> 最差：<code>O(n²)</code> 平均：<code>O(n+k)</code></li>\n<li><strong>空间复杂度</strong> ：<code>O(k)</code></li>\n</ul>\n<h2> 基数排序 (Radix Sort)</h2>\n<p>基数排序也是非比较的排序算法，对元素中的每一位数字进行排序，从最低位开始排序，复杂度为 <code>O(n×k)</code>，<code>n</code> 为数组长度，<code>k</code> 为数组中元素的最大的位数；</p>\n<p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。</p>\n<h3> 算法步骤</h3>\n<ol>\n<li>取得数组中的最大数，并取得位数，即为迭代次数 <code>N</code>（例如：数组中最大数值为 1000，则 <code>N=4</code>）；</li>\n<li><code>A</code> 为原始数组，从最低位开始取每个位组成 <code>radix</code> 数组；</li>\n<li>对 <code>radix</code> 进行计数排序（利用计数排序适用于小范围数的特点）；</li>\n<li>将 <code>radix</code> 依次赋值给原数组；</li>\n<li>重复 2~4 步骤 <code>N</code> 次</li>\n</ol>\n<h3> 图解算法</h3>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/sorting-algorithms/radix_sort.gif\" alt=\"RadixSort\"></p>\n<h3> 代码实现</h3>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 算法分析</h3>\n<ul>\n<li><strong>稳定性</strong> ：稳定</li>\n<li><strong>时间复杂度</strong> ：最佳：<code>O(n×k)</code> 最差：<code>O(n×k)</code> 平均：<code>O(n×k)</code></li>\n<li><strong>空间复杂度</strong> ：<code>O(n+k)</code></li>\n</ul>\n<p><strong>基数排序 vs 计数排序 vs 桶排序</strong></p>\n<p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p>\n<ul>\n<li>基数排序：根据键值的每位数字来分配桶</li>\n<li>计数排序：每个桶只存储单一键值</li>\n<li>桶排序：每个桶存储一定范围的数值</li>\n</ul>\n<h2> 参考文章</h2>\n<ul>\n<li>https://www.cnblogs.com/guoyaohua/p/8600214.html</li>\n<li>https://en.wikipedia.org/wiki/Sorting_algorithm</li>\n<li>https://sort.hust.cc/</li>\n</ul>\n",
      "image": "https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/sorting-algorithms/sort1.png",
      "date_published": "2022-05-27T03:08:59.000Z",
      "date_modified": "2022-09-22T07:40:30.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "计算机基础"
      ]
    },
    {
      "title": "搜索引擎必读经典书籍",
      "url": "https://javaguide.cn/books/search-engine.html",
      "id": "https://javaguide.cn/books/search-engine.html",
      "summary": "Lucene Elasticsearch 在 Apache Lucene 的基础上开发而成，学习 ES 之前，建议简单了解一下 Lucene 的相关概念。 《Lucene实战》 是国内为数不多的中文版本讲 Lucene 的书籍，适合用来学习和了解 Lucene 相关的概念和常见操作。",
      "content_html": "<h2> Lucene</h2>\n<p>Elasticsearch 在 Apache Lucene 的基础上开发而成，学习 ES 之前，建议简单了解一下 Lucene 的相关概念。</p>\n<p><strong><a href=\"https://book.douban.com/subject/6440615/\" target=\"_blank\" rel=\"noopener noreferrer\">《Lucene实战》</a></strong> 是国内为数不多的中文版本讲 Lucene 的书籍，适合用来学习和了解 Lucene 相关的概念和常见操作。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/books/vAJkdYEyol4e6Nr.png\" alt=\"《Lucene实战》-实战\"></p>\n<h2> Elasticsearch</h2>\n<p>极客时间的<a href=\"http://gk.link/a/10bcT\" title=\"《Elasticsearch 核心技术与实战》\" target=\"_blank\" rel=\"noopener noreferrer\">《Elasticsearch 核心技术与实战》</a>这门课程基于 Elasticsearch 7.1 版本讲解，还算比较新。并且，作者是 eBay 资深技术专家，有 20 年的行业经验，课程质量有保障！</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20210420231125225.png\" alt=\"《Elasticsearch 核心技术与实战》-极客时间\"></p>\n<p>如果你想看书的话，可以考虑一下 <strong><a href=\"https://book.douban.com/subject/30380439/\" target=\"_blank\" rel=\"noopener noreferrer\">《Elasticsearch 实战》</a></strong> 这本书。不过，需要说明的是，这本书中的 Elasticsearch 版本比较老，你可以将其作为一个参考书籍来看，有一些原理性的东西可以在上面找找答案。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20210420231700232.png\" alt=\"《Elasticsearch 实战》-豆瓣\"></p>\n<p>如果你想进一步深入研究 Elasticsearch 原理的话，可以看看张超老师的 <strong><a href=\"https://book.douban.com/subject/30386800/\" target=\"_blank\" rel=\"noopener noreferrer\">《Elasticsearch 源码解析与优化实战》</a></strong> 这本书。这是市面上唯一一本写 Elasticsearch 源码的书。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20210420231952270.png\" alt=\"《Elasticsearch 源码解析与优化实战》-豆瓣\"></p>\n",
      "image": "https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/books/vAJkdYEyol4e6Nr.png",
      "date_published": "2022-04-24T04:03:47.000Z",
      "date_modified": "2022-07-15T03:53:57.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "计算机书籍"
      ]
    },
    {
      "title": "计算机基础必读经典书籍",
      "url": "https://javaguide.cn/books/cs-basics.html",
      "id": "https://javaguide.cn/books/cs-basics.html",
      "summary": "考虑到很多同学比较喜欢看视频，因此，这部分内容我不光会推荐书籍，还会顺便推荐一些我觉得不错的视频教程和各大高校的 Project。 操作系统 为什么要学习操作系统？ 从对个人能力方面提升来说，操作系统中的很多思想、很多经典的算法，你都可以在我们日常开发使用的各种工具或者框架中找到它们的影子。比如说我们开发的系统使用的缓存（比如 Redis）和操作系统的高速缓存就很像。CPU 中的高速缓存有很多种，不过大部分都是为了解决 CPU 处理速度和内存处理速度不对等的问题。我们还可以把内存可以看作外存的高速缓存，程序运行的时候我们把外存的数据复制到内存，由于内存的处理速度远远高于外存，这样提高了处理速度。同样地，我们使用的 Redis 缓存就是为了解决程序处理速度和访问常规关系型数据库速度不对等的问题。高速缓存一般会按照局部性原理（2-8 原则）根据相应的淘汰算法保证缓存中的数据是经常会被访问的。我们平常使用的 Redis 缓存很多时候也会按照 2-8 原则去做，很多淘汰算法都和操作系统中的类似。既说了 2-8 原则，那就不得不提命中率了，这是所有缓存概念都通用的。简单来说也就是你要访问的数据有多少能直接在缓存中直接找到。命中率高的话，一般表明你的缓存设计比较合理，系统处理速度也相对较快。",
      "content_html": "<p>考虑到很多同学比较喜欢看视频，因此，这部分内容我不光会推荐书籍，还会顺便推荐一些我觉得不错的视频教程和各大高校的 Project。</p>\n<h2> 操作系统</h2>\n<p><strong>为什么要学习操作系统？</strong></p>\n<p><strong>从对个人能力方面提升来说</strong>，操作系统中的很多思想、很多经典的算法，你都可以在我们日常开发使用的各种工具或者框架中找到它们的影子。比如说我们开发的系统使用的缓存（比如 Redis）和操作系统的高速缓存就很像。CPU 中的高速缓存有很多种，不过大部分都是为了解决 CPU 处理速度和内存处理速度不对等的问题。我们还可以把内存可以看作外存的高速缓存，程序运行的时候我们把外存的数据复制到内存，由于内存的处理速度远远高于外存，这样提高了处理速度。同样地，我们使用的 Redis 缓存就是为了解决程序处理速度和访问常规关系型数据库速度不对等的问题。高速缓存一般会按照局部性原理（2-8 原则）根据相应的淘汰算法保证缓存中的数据是经常会被访问的。我们平常使用的 Redis 缓存很多时候也会按照 2-8 原则去做，很多淘汰算法都和操作系统中的类似。既说了 2-8 原则，那就不得不提命中率了，这是所有缓存概念都通用的。简单来说也就是你要访问的数据有多少能直接在缓存中直接找到。命中率高的话，一般表明你的缓存设计比较合理，系统处理速度也相对较快。</p>\n<p><strong>从面试角度来说</strong>，尤其是校招，对于操作系统方面知识的考察是非常非常多的。</p>\n<p><strong>简单来说，学习操作系统能够提高自己思考的深度以及对技术的理解力，并且，操作系统方面的知识也是面试必备。</strong></p>\n<p>如果你要系统地学习操作系统的话，最硬核最权威的书籍是 <strong><a href=\"https://book.douban.com/subject/33463930/\" target=\"_blank\" rel=\"noopener noreferrer\">《操作系统导论》</a></strong> 。你可以再配套一个 <strong><a href=\"https://book.douban.com/subject/1230413/\" target=\"_blank\" rel=\"noopener noreferrer\">《深入理解计算机系统》</a></strong> 加深你对计算机系统本质的认识，美滋滋！</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/booksimage-20201012191645919.png\" alt=\"\"></p>\n<p>另外，去年新出的一本国产的操作系统书籍也很不错：<strong><a href=\"https://book.douban.com/subject/35208251/\" target=\"_blank\" rel=\"noopener noreferrer\">《现代操作系统：原理与实现》</a></strong> （夏老师和陈老师团队的力作，值得推荐）。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20210406132050845.png\" alt=\"\"></p>\n<p>如果你比较喜欢动手，对于理论知识比较抵触的话，我推荐你看看 <strong><a href=\"https://book.douban.com/subject/11530329/\" target=\"_blank\" rel=\"noopener noreferrer\">《30 天自制操作系统》</a></strong> ，这本书会手把手教你编写一个操作系统。</p>\n<p>纸上学来终觉浅 绝知此事要躬行！强烈推荐 CS 专业的小伙伴一定要多多实践！！！</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/booksimage-20220409123802972.png\" alt=\"\"></p>\n<p>其他相关书籍推荐：</p>\n<ul>\n<li><strong><a href=\"https://book.douban.com/subject/1422377/\" target=\"_blank\" rel=\"noopener noreferrer\">《自己动手写操作系统》</a></strong> ： 不光会带着你详细分析操作系统原理的基础，还会用丰富的实例代码，一步一步地指导你用 C 语言和汇编语言编写出一个具备操作系统基本功能的操作系统框架。</li>\n<li><strong><a href=\"https://book.douban.com/subject/3852290/\" target=\"_blank\" rel=\"noopener noreferrer\">《现代操作系统》</a></strong> ： 内容很不错，不过，翻译的一般。如果你是精读本书的话，建议把课后习题都做了。</li>\n<li><strong><a href=\"https://book.douban.com/subject/26745156/\" target=\"_blank\" rel=\"noopener noreferrer\">《操作系统真象还原》</a></strong> ： 这本书的作者毕业于北京大学，前百度运维高级工程师。因为在大学期间曾重修操作系统这一科，后对操作系统进行深入研究，著下此书。</li>\n<li><strong><a href=\"https://book.douban.com/subject/25743846/\" target=\"_blank\" rel=\"noopener noreferrer\">《深度探索 Linux 操作系统》</a></strong> ：跟着这本书的内容走，可以让你对如何制作一套完善的 GNU/Linux 系统有了清晰的认识。</li>\n<li><strong><a href=\"https://book.douban.com/subject/2044818/\" target=\"_blank\" rel=\"noopener noreferrer\">《操作系统设计与实现》</a></strong> ：操作系统的权威教学教材。</li>\n<li><strong><a href=\"https://book.douban.com/subject/3735649/\" target=\"_blank\" rel=\"noopener noreferrer\">《Orange'S:一个操作系统的实现》</a></strong> ： 从只有二十行的引导扇区代码出发，一步一步地向读者呈现一个操作系统框架的完成过程。配合《操作系统设计与实现》一起食用更佳！</li>\n</ul>\n<p>如果你比较喜欢看视频的话，推荐哈工大李治军老师主讲的慕课 <a href=\"https://www.icourse163.org/course/HIT-1002531008\" target=\"_blank\" rel=\"noopener noreferrer\">《操作系统》</a>，内容质量吊打一众国家精品课程。</p>\n<p>课程的大纲如下：</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/books/image-20220414144527747.png\" alt=\"课程大纲\"></p>\n<p>主要讲了一个基本操作系统中的六个基本模块： CPU 管理、内存管理、外设管理、磁盘管理与文件系统、用户接口和启动模块 。</p>\n<p>课程难度还是比较大的，尤其是课后的 lab。如果大家想要真正搞懂操作系统底层原理的话，对应的 lab 能做尽量做一下。正如李治军老师说的那样：“纸上得来终觉浅，绝知此事要躬行”。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/books/image-20220414145210679.png\" alt=\"\"></p>\n<p>如果你能独立完成几个 lab 的话，我相信你对操作系统的理解绝对要上升几个台阶。当然了，如果你仅仅是为了突击面试的话，那就不需要做 lab 了。</p>\n<p>说点心里话，我本人非常喜欢李治军老师讲的课，我觉得他是国内不可多得的好老师。他知道我们国内的教程和国外的差距在哪里，也知道国内的学生和国外学生的差距在哪里，他自己在努力着通过自己的方式来缩小这个差距。真心感谢，期待李治军老师的下一个课程。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/books/image-20220414145249714.png\" alt=\"\"></p>\n<p>还有下面这个国外的课程 <a href=\"https://www.bilibili.com/video/av31289365?from=search&amp;seid=16298868573410423104\" target=\"_blank\" rel=\"noopener noreferrer\">《深入理解计算机系统 》</a> 也很不错。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/booksimage-20201204140653318.png\" alt=\"\"></p>\n<h2> 计算机网络</h2>\n<p>计算机网络是一门系统性比较强的计算机专业课，各大名校的计算机网络课程打磨的应该都比较成熟。</p>\n<p>要想学好计算机网络，首先要了解的就是 OSI 七层模型或 TCP/IP 五层模型，即应用层（应用层、表示层、会话层）、传输层、网络层、数据链路层、物理层。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/booksosi七层模型2.png\" alt=\"osi七层模型\"></p>\n<p>关于这门课，首先强烈推荐参考书是<strong>机械工业出版社的《计算机网络——自顶向下方法》</strong>。该书目录清晰，按照 TCP/IP 五层模型逐层讲解，对每层涉及的技术都展开了详细讨论，基本上高校里开设的课程的教学大纲就是这本书的目录了。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/booksimage-20220409123250570.png\" alt=\"\"></p>\n<p>如果你觉得上面这本书看着比较枯燥的话，我强烈推荐+安利你看看下面这两本非常有趣的网络相关的书籍：</p>\n<ul>\n<li><a href=\"https://book.douban.com/subject/25863515/\" title=\"《图解 HTTP》\" target=\"_blank\" rel=\"noopener noreferrer\">《图解 HTTP》</a> ： 讲漫画一样的讲 HTTP，很有意思，不会觉得枯燥，大概也涵盖也 HTTP 常见的知识点。因为篇幅问题，内容可能不太全面。不过，如果不是专门做网络方向研究的小伙伴想研究 HTTP 相关知识的话，读这本书的话应该来说就差不多了。</li>\n<li><a href=\"https://book.douban.com/subject/26941639/\" title=\"《网络是怎样连接的》\" target=\"_blank\" rel=\"noopener noreferrer\">《网络是怎样连接的》</a> ：从在浏览器中输入网址开始，一路追踪了到显示出网页内容为止的整个过程，以图配文，讲解了网络的全貌，并重点介绍了实际的网络设备和软件是如何工作的。</li>\n</ul>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/booksimage-20201011215144139.png\" alt=\"\"></p>\n<p>除了理论知识之外，学习计算机网络非常重要的一点就是：“<strong>动手实践</strong>”。这点和我们编程差不多。</p>\n<p>Github 上就有一些名校的计算机网络试验/Project：</p>\n<ul>\n<li><a href=\"https://github.com/rccoder/HIT-Computer-Network\" target=\"_blank\" rel=\"noopener noreferrer\">哈工大计算机网络实验</a></li>\n<li><a href=\"https://github.com/moranzcw/Computer-Networking-A-Top-Down-Approach-NOTES\" target=\"_blank\" rel=\"noopener noreferrer\">《计算机网络－自顶向下方法(原书第 6 版)》编程作业，Wireshark 实验文档的翻译和解答。</a></li>\n<li><a href=\"https://github.com/KevinWang15/network-pj-chatroom\" target=\"_blank\" rel=\"noopener noreferrer\">计算机网络的期末 Project，用 Python 编写的聊天室</a></li>\n<li><a href=\"https://computer-networks.github.io/sp19/lectures.html\" target=\"_blank\" rel=\"noopener noreferrer\">CMU 的计算机网络课程</a></li>\n</ul>\n<p>我知道，还有很多小伙伴可能比较喜欢边看视频边学习。所以，我这里再推荐几个顶好的计算机网络视频讲解。</p>\n<p><strong>1、<a href=\"http://www.icourse163.org/course/HIT-154005\" target=\"_blank\" rel=\"noopener noreferrer\">哈工大的计算机网络课程</a></strong> ：国家精品课程，截止目前已经开了 10 次课了。大家对这门课的评价都非常高！所以，非常推荐大家看一下！</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/booksimage-20201218141241911.png\" alt=\"\"></p>\n<p><strong>2、<a href=\"https://www.bilibili.com/video/BV19E411D78Q?from=search&amp;seid=17198507506906312317\" target=\"_blank\" rel=\"noopener noreferrer\">王道考研的计算机网络</a></strong> ：非常适合 CS 专业考研的小朋友！这个视频目前在哔哩哔哩上已经有 1.6w+的点赞。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/booksimage-20201218141652837.png\" alt=\"\"></p>\n<h2> 算法</h2>\n<p>先来看三本入门书籍。 这三本入门书籍中的任何一本拿来作为入门学习都非常好。</p>\n<ol>\n<li><a href=\"https://book.douban.com/subject/30357170/\" target=\"_blank\" rel=\"noopener noreferrer\">《我的第一本算法书》</a></li>\n<li><a href=\"https://book.douban.com/subject/26979890/\" target=\"_blank\" rel=\"noopener noreferrer\">《算法图解》</a></li>\n<li><a href=\"https://book.douban.com/subject/25894685/\" target=\"_blank\" rel=\"noopener noreferrer\">《啊哈!算法》</a></li>\n</ol>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/java-guide-blog/image-20210327104418851.png\" alt=\"\"></p>\n<p>我个人比较倾向于 <strong><a href=\"https://book.douban.com/subject/30357170/\" target=\"_blank\" rel=\"noopener noreferrer\">《我的第一本算法书》</a></strong> 这本书籍，虽然它相比于其他两本书集它的豆瓣评分略低一点。我觉得它的配图以及讲解是这三本书中最优秀，唯一比较明显的问题就是没有代码示例。但是，我觉得这不影响它是一本好的算法书籍。因为本身下面这三本入门书籍的目的就不是通过代码来让你的算法有多厉害，只是作为一本很好的入门书籍让你进入算法学习的大门。</p>\n<p>再推荐几本比较经典的算法书籍。</p>\n<p><strong><a href=\"https://book.douban.com/subject/19952400/\" target=\"_blank\" rel=\"noopener noreferrer\">《算法》</a></strong></p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/booksimage-20220409123422140.png\" alt=\"\"></p>\n<p>这本书内容非常清晰易懂，适合数据结构和算法小白阅读。书中把一些常用的数据结构和算法都介绍到了！</p>\n<p>我在大二的时候被我们的一个老师强烈安利过！自己也在当时购买了一本放在宿舍，到离开大学的时候自己大概看了一半多一点。因为内容实在太多了！另外，这本书还提供了详细的 Java 代码，非常适合学习 Java 的朋友来看，可以说是 Java 程序员的必备书籍之一了。</p>\n<blockquote>\n<p><strong>下面这些书籍都是经典中的经典，但是阅读起来难度也比较大，不做太多阐述，神书就完事了！</strong></p>\n<p><strong>如果你仅仅是准备算法面试的话，不建议你阅读下面这些书籍。</strong></p>\n</blockquote>\n<p><strong><a href=\"https://book.douban.com/subject/3227098/\" target=\"_blank\" rel=\"noopener noreferrer\">《编程珠玑》</a></strong></p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/booksimage-20220409145334093.png\" alt=\"\"></p>\n<p>经典名著，ACM 冠军、亚军这种算法巨佬都强烈推荐的一本书籍。这本书的作者也非常厉害，Java 之父 James Gosling 就是他的学生。</p>\n<p>很多人都说这本书不是教你具体的算法，而是教你一种编程的思考方式。这种思考方式不仅仅在编程领域适用，在其他同样适用。</p>\n<p><strong><a href=\"https://book.douban.com/subject/4048566/\" target=\"_blank\" rel=\"noopener noreferrer\">《算法设计手册》</a></strong></p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/booksimage-20220409145411049.png\" alt=\"\"></p>\n<p>这是一本被 Github 上的爆火的计算机自学项目 <a href=\"https://link.zhihu.com/?target=https%3A//teachyourselfcs.com/\" target=\"_blank\" rel=\"noopener noreferrer\">Teach Yourself Computer Science</a> 强烈推荐的一本算法书籍。</p>\n<p>类似的神书还有 <a href=\"https://book.douban.com/subject/20432061/\" target=\"_blank\" rel=\"noopener noreferrer\">《算法导论》</a>、<a href=\"https://book.douban.com/subject/1130500/\" target=\"_blank\" rel=\"noopener noreferrer\">《计算机程序设计艺术（第 1 卷）》</a> 。</p>\n<p><strong>如果说你要准备面试的话，下面这几本书籍或许对你有帮助！</strong></p>\n<p><strong><a href=\"https://book.douban.com/subject/6966465/\" target=\"_blank\" rel=\"noopener noreferrer\">《剑指 Offer》</a></strong></p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/booksimage-20220409145506482.png\" alt=\"\"></p>\n<p>这本面试宝典上面涵盖了很多经典的算法面试题，如果你要准备大厂面试的话一定不要错过这本书。</p>\n<p>《剑指 Offer》 对应的算法编程题部分的开源项目解析：<a href=\"https://link.zhihu.com/?target=https%3A//github.com/gatieme/CodingInterviews\" target=\"_blank\" rel=\"noopener noreferrer\">CodingInterviews</a> 。</p>\n<p><strong><a href=\"https://book.douban.com/subject/30422021/\" target=\"_blank\" rel=\"noopener noreferrer\">《程序员代码面试指南（第 2 版）》</a></strong></p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/booksimage-20220409145622758.png\" alt=\"\"></p>\n<p>《程序员代码面试指南（第 2 版）》里的大部分题目相比于《剑指 offer》 来说要难很多，题目涵盖面相比于《剑指 offer》也更加全面。全书一共有将近 300 道真实出现过的经典代码面试题。</p>\n<p>视频的话，推荐北京大学的国家精品课程—<strong><a href=\"https://www.icourse163.org/course/PKU-1001894005\" target=\"_blank\" rel=\"noopener noreferrer\">程序设计与算法（二）算法基础</a></strong>，讲的非常好！</p>\n<p><img src=\"https://img-blog.csdnimg.cn/22ce4a17dc0c40f6a3e0d58002261b7a.png\" alt=\"\"></p>\n<p>这个课程把七种基本的通用算法（枚举、二分、递归、分治、动态规划、搜索、贪心）都介绍到了。各种复杂算法问题的解决，都可能用到这些基本的思想。并且，这个课程的一部分的例题和 ACM 国际大学生程序设计竞赛中的中等题相当，如果你能够解决这些问题，那你的算法能力将超过绝大部分的高校计算机专业本科毕业生。</p>\n<h2> 数据结构</h2>\n<p>其实，上面提到的很多算法类书籍（比如 <strong>《算法》</strong> 和 <strong>《算法导论》</strong>）都详细地介绍了常用的数据结构。</p>\n<p>我这里再另外补充基本和数据结构相关的书籍。</p>\n<p><strong><a href=\"https://book.douban.com/subject/6424904/\" target=\"_blank\" rel=\"noopener noreferrer\">《大话数据结构》</a></strong></p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/booksimage-20220409145803440.png\" alt=\"\"></p>\n<p>入门类型的书籍，读起来比较浅显易懂，适合没有数据结构基础或者说数据结构没学好的小伙伴用来入门数据结构。</p>\n<p><strong><a href=\"https://book.douban.com/subject/3351237/\" target=\"_blank\" rel=\"noopener noreferrer\">《数据结构与算法分析：Java 语言描述》</a></strong></p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/booksimage-20220409145823973.png\" alt=\"\"></p>\n<p>质量很高，介绍了常用的数据结构和算法。</p>\n<p>类似的还有 <strong><a href=\"https://book.douban.com/subject/1139426/\" target=\"_blank\" rel=\"noopener noreferrer\">《数据结构与算法分析 ：C 语言描述》</a></strong> 、<strong><a href=\"https://book.douban.com/subject/1971825/\" target=\"_blank\" rel=\"noopener noreferrer\">《数据结构与算法分析：C++ 描述》</a></strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/d9c450ccc5224a5fba77f4fa937f7b9c.png\" alt=\"\"></p>\n<p>视频的话推荐你看浙江大学的国家精品课程—<strong><a href=\"https://www.icourse163.org/course/ZJU-93001#/info\" target=\"_blank\" rel=\"noopener noreferrer\">《数据结构》</a></strong> 。</p>\n<p>姥姥的数据结构讲的非常棒！不过，还是有一些难度的，尤其是课后练习题。</p>\n<h2> 计算机专业基础课</h2>\n<p>数学和英语属于通用课，一般在大一和大二两学年就可以全部修完，大二大三逐渐接触专业课。通用课作为许多高中生升入大学的第一门课，算是高中阶段到本科阶段的一个过渡，从职业生涯重要性上来说，远不及专业课重要，但是在本科阶段的学习生活规划中，有着非常重要的地位。由于通用课的课程多，学分重，占据了本科阶段绩点的主要部分，影响到学生在前两年的专业排名，也影响到大三结束时的推免资格分配，也就是保研。而从升学角度来看，对于攻读研究生和博士生的小伙伴来说，数学和英语这两大基础课，还是十分有用的。</p>\n<h3> 数学</h3>\n<h4> 微积分（高等数学）</h4>\n<p>微积分，即传说中的高数，成为了无数新大一心中的痛。但好在，大学的课程考核没那么严格，期末想要拿高分，也不至于像高中那样刷题刷的那么狠。微积分对于计算机专业学生的重要性，主要体现在计算机图形学中的函数变换，机器学习中的梯度算法，信号处理等领域。</p>\n<p>微积分的知识体系包括微分和积分两部分，一般会先学微分，再学积分，也有的学校把高数分为两个学期。微分就是高中的导数的升级版，对于大一萌新来说还算比较友好。积分恰好是微分的逆运算，思想上对大一萌新来说比较新，一时半会可能接受不了。不过这门课所有的高校都有开设，而且大部分的名校都有配套的网课，教材也都打磨的非常出色，结合网课和教材的“啃书”学习模式，这门课一定不会落下。</p>\n<p>书籍的话，推荐《普林斯顿微积分读本》。这本书详细讲解了微积分基础、极限、连续、微分、导数的应用、积分、无穷级数、泰勒级数与幂级数等内容。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/booksimage-20220409155056751.png\" alt=\"\"></p>\n<h4> 线性代数（高等代数）</h4>\n<p>线性代数的思维模式就更加复杂了一些，它定义了一个全新的数学世界，所有的符号、定理都是全新的，唯一能尝试的去理解的方式，大概就是用几何的方式去理解线性代数了。由于线性代数和几何学有着密不可分的关系，比如空间变换的理论支撑就是线性代数，因此，网上有着各种“可视化学习线性代数”的学习资源，帮助理解线性代数的意义，有助于公式的记忆。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/booksimage-20220409153940473.png\" alt=\"\"></p>\n<p>书籍的话，推荐中科大李尚志老师的 <strong><a href=\"https://book.douban.com/subject/26390093/\" target=\"_blank\" rel=\"noopener noreferrer\">《线性代数学习指导》</a></strong> 。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/booksimage-20220409155325251.png\" alt=\"\"></p>\n<h4> 概率论与数理统计</h4>\n<p>对于计算机专业的小伙伴来说，这门课可能是概率论更有用一点，而非数理统计。可能某些学校只开设概率论课程，也可能数理统计也教，但仅仅是皮毛。概率论的学习路线和微积分相似，就是一个个公式辅以实例，不像线性代数那么抽象，比较贴近生活。在现在的就业形势下，概率论与数理统计专业的学生，应该是数学专业最好就业的了，他们通常到岗位上会做一些数据分析的工作，因此，<strong>这门课程确实是数据分析的重要前置课程，概率论在机器学习中的重要性也就不言而喻了。</strong></p>\n<p>书籍的话，推荐 <strong><a href=\"https://book.douban.com/subject/34897672/\" target=\"_blank\" rel=\"noopener noreferrer\">《概率论与数理统计教程》</a></strong> 。这本书共八章，前四章为概率论部分，主要叙述各种概率分布及其性质，后四章为数理统计部分，主要叙述各种参数估计与假设检验。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/booksimage-20220409155738505.png\" alt=\"\"></p>\n<h4> 离散数学（集合论、图论、近世代数等）</h4>\n<p>离散数学是计算机专业的专属数学，但实际上对于本科毕业找工作的小伙伴来说，离散数学还并没有发挥它的巨大作用。离散数学的作用主要在在图研究等领域，理论性极强，需要读研深造的小伙伴尽可能地扎实掌握。</p>\n<h3> 英语</h3>\n<p>英语算是大学里面比较灵活的一项技能了，有的人会说，“英语学的越好，对个人发展越有利”，此话说的没错，但是对于一些有着明确发展目标的小伙伴，可能英语技能并不在他们的技能清单内。接下来的这些话只针对计算机专业的小伙伴们哦。</p>\n<p>英语课在大学本科一般只有前两年开设，小伙伴们可以记住，<strong>想用英语课来提升自己的英语水平的，可以打消这个念头了。</strong> 英语水平的提高全靠自己平时的积累和练习，以及有针对性的刷题。</p>\n<p><strong>英语的大学四六级一定要过。</strong> 这是必备技能，绝大部分就业岗位都要看四六级水平的，最起码要通过的。四级比高中英语稍微难一些，一般的小伙伴可能会卡在六级上，六级需要针对性的训练一下，因为大学期间能接触英语的实在太少了，每学期一门英语课是不足以保持自己的英语水平的。对于一些来自于偏远地区，高中英语基础薄弱的，考四六级会更加吃力。建议考前集中训练一下历年真题，辅以背一下高频词汇，四六级通过只需要 425 分，这个分数线还是比较容易达到的。稍微好一点的小伙伴可能冲一下 500 分，要是能考到 600 分的话，那是非常不错的水平了，算是简历上比较有亮点的一项。</p>\n<p>英语的雅思托福考试只限于想要出国的小伙伴，以及应聘岗位对英语能力有特殊要求的。雅思托福考试裸考不容易通过，花钱去比较靠谱的校外补课班应该是一个比较好的选择。</p>\n<p>对于计算机专业的小伙伴来说，英语能力还是比较重要的，虽然应聘的时候不会因为没有雅思托福成绩卡人，但是你起码要能够：</p>\n<ul>\n<li><strong>熟练使用英文界面的软件、系统等</strong></li>\n<li><strong>对于外网的一些博客、bug 解决方案等，阅读无压力</strong></li>\n<li><strong>熟练阅读英文文献</strong></li>\n<li><strong>具备一定的英文论文的撰写能力</strong></li>\n</ul>\n<p>毕竟计算机语言就是字符语言，听说读写中最起码要满足<strong>读写</strong>这两项不过分吧。</p>\n<h3> 编译原理</h3>\n<p>编译原理相比于前面介绍的专业课，地位显得不那么重要了。编译原理的重要性主要体现在：</p>\n<ul>\n<li>底层语言、引擎或高级语言的开发，如 MySQL，Java 等</li>\n<li>操作系统或嵌入式系统的开发</li>\n<li>词法、语法、语义的思想，以及自动机思想</li>\n</ul>\n<p><strong>编译原理的重要前置课程就是形式语言与自动机，自动机的思想在词法分析当中有着重要应用，学习了这门课后，应该就会发现许多场景下，自动机算法的妙用了。</strong></p>\n<p>总的来说，这门课对于各位程序员的职业发展来说，相对不那么重要，但是从难度上来说，学习这门课可以对编程思想有一个较好的巩固。学习资源的话，除了课堂上的幻灯片课件以外，还可以把 《编译原理》 这本书作为参考书，用以辅助自己学不懂的地方（大家口中的龙书，想要啃下来还是有一定难度的）。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20210406152148373.png\" alt=\"\"></p>\n<p>其他书籍推荐:</p>\n<ul>\n<li><strong><a href=\"https://book.douban.com/subject/30191414/\" target=\"_blank\" rel=\"noopener noreferrer\">《现代编译原理》</a></strong> ：编译原理的入门书。</li>\n<li><strong><a href=\"https://book.douban.com/subject/20436488/\" target=\"_blank\" rel=\"noopener noreferrer\">《编译器设计》</a></strong> ： 覆盖了编译器从前端到后端的全部主题。</li>\n</ul>\n<p>我上面推荐的书籍的难度还是比较高的，真心很难坚持看完。这里强烈推荐<a href=\"https://www.icourse163.org/course/HIT-1002123007\" target=\"_blank\" rel=\"noopener noreferrer\">哈工大的编译原理视频课程</a>，真心不错，还是国家精品课程，关键还是又漂亮有温柔的美女老师讲的！</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20210406152847824.png\" alt=\"\"></p>\n",
      "image": "https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/booksimage-20201012191645919.png",
      "date_published": "2022-04-09T08:19:10.000Z",
      "date_modified": "2023-03-06T14:05:42.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "计算机书籍"
      ]
    },
    {
      "title": "数据库必读经典书籍",
      "url": "https://javaguide.cn/books/database.html",
      "id": "https://javaguide.cn/books/database.html",
      "summary": "数据库基础 数据库基础这块，如果你觉得书籍比较枯燥，自己坚持不下来的话，我推荐你可以先看看一些不错的视频，北京师范大学的《数据库系统原理》、哈尔滨工业大学的《数据库系统（下）：管理与技术》就很不错。",
      "content_html": "<h2> 数据库基础</h2>\n<p>数据库基础这块，如果你觉得书籍比较枯燥，自己坚持不下来的话，我推荐你可以先看看一些不错的视频，北京师范大学的<a href=\"https://www.icourse163.org/course/BNU-1002842007\" target=\"_blank\" rel=\"noopener noreferrer\">《数据库系统原理》</a>、哈尔滨工业大学的<a href=\"https://www.icourse163.org/course/HIT-1001578001\" target=\"_blank\" rel=\"noopener noreferrer\">《数据库系统（下）：管理与技术》</a>就很不错。</p>\n<p><a href=\"https://www.icourse163.org/course/BNU-1002842007\" target=\"_blank\" rel=\"noopener noreferrer\">《数据库系统原理》</a>这个课程的老师讲的非常详细，而且每一小节的作业设计的也与所讲知识很贴合，后面还有很多配套实验。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20210406154403673.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0MzM3Mjcy,size_16,color_FFFFFF,t_70\" alt=\"\"></p>\n<p>如果你比较喜欢动手，对于理论知识比较抵触的话，推荐你看看<a href=\"https://cstack.github.io/db_tutorial/\" target=\"_blank\" rel=\"noopener noreferrer\">《如何开发一个简单的数据库》</a> ，这个 project 会手把手教你编写一个简单的数据库。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20210406154601698.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0MzM3Mjcy,size_16,color_FFFFFF,t_70\" alt=\"\"></p>\n<p>Github上也已经有大佬用 Java 实现过一个简易的数据库，介绍的挺详细的，感兴趣的朋友可以去看看。地址：<a href=\"https://github.com/alchemystar/Freedom\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/alchemystar/Freedom</a> 。</p>\n<p>除了这个用 Java 写的之外，<strong><a href=\"https://github.com/cstack/db_tutorial\" target=\"_blank\" rel=\"noopener noreferrer\">db_tutorial</a></strong> 这个项目是国外的一个大佬用 C 语言写的，朋友们也可以去瞅瞅。</p>\n<p><strong>只要利用好搜索引擎，你可以找到各种语言实现的数据库玩具。</strong></p>\n<p><img src=\"https://oscimg.oschina.net/oscnet/up-d32d853f847633ac7ed0efdecf56be1f1d2.png\" alt=\"\"></p>\n<p><strong>纸上学来终觉浅 绝知此事要躬行！强烈推荐 CS 专业的小伙伴一定要多多实践！！！</strong></p>\n<h3> 《数据库系统概念》</h3>\n<p><a href=\"https://book.douban.com/subject/10548379/\" target=\"_blank\" rel=\"noopener noreferrer\">《数据库系统概念》</a>这本书涵盖了数据库系统的全套概念，知识体系清晰，是学习数据库系统非常经典的教材！不是参考书！</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/booksimage-20220409150441742.png\" alt=\"\"></p>\n<h3> 《数据库系统实现》</h3>\n<p>如果你也想要研究 MySQL 底层原理的话，我推荐你可以先阅读一下<a href=\"https://book.douban.com/subject/4838430/\" target=\"_blank\" rel=\"noopener noreferrer\">《数据库系统实现》</a>。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/books/database-system-implementation.png\" alt=\"\"></p>\n<p>不管是 MySQL 还是Oracle ，它们总体的架子是差不多的，不同的是其内部的实现比如数据库索引的数据结构、存储引擎的实现方式等等。</p>\n<p>这本书有些地方还是翻译的比较蹩脚，有能力看英文版的还是建议上手英文版。</p>\n<p>《数据库系统实现》 这本书是斯坦福的教材，另外还有一本<a href=\"https://book.douban.com/subject/3923575/\" target=\"_blank\" rel=\"noopener noreferrer\">《数据库系统基础教程》</a>是前置课程，可以带你入门数据库。</p>\n<h2> MySQL</h2>\n<p>我们网站或者 APP 的数据都是需要使用数据库来存储数据的。</p>\n<p>一般企业项目开发中，使用 MySQL 比较多。如果你要学习 MySQL 的话，可以看下面这 3 本书籍：</p>\n<ul>\n<li><strong><a href=\"https://book.douban.com/subject/3354490/\" target=\"_blank\" rel=\"noopener noreferrer\">《MySQL 必知必会》</a></strong> ：非常薄！非常适合 MySQL 新手阅读，很棒的入门教材。</li>\n<li><strong><a href=\"https://book.douban.com/subject/23008813/\" target=\"_blank\" rel=\"noopener noreferrer\">《高性能 MySQL》</a></strong> ： MySQL 领域的经典之作！学习 MySQL 必看！属于进阶内容，主要教你如何更好地使用 MySQL 。既有有理论，又有实践！如果你没时间都看一遍的话，我建议第 5 章（创建高性能的索引） 、第 6 章（查询性能优化） 你一定要认真看一下。</li>\n<li><strong><a href=\"https://book.douban.com/subject/24708143/\" target=\"_blank\" rel=\"noopener noreferrer\">《MySQL 技术内幕》</a></strong> ：你想深入了解 MySQL 存储引擎的话，看这本书准没错！</li>\n</ul>\n<p><img src=\"https://oscimg.oschina.net/oscnet/up-3d31e762933f9e50cc7170b2ebd8433917b.png\" alt=\"\"></p>\n<p>视频的话，你可以看看动力节点的 <a href=\"https://www.bilibili.com/video/BV1fx411X7BD\" target=\"_blank\" rel=\"noopener noreferrer\">《MySQL 数据库教程视频》</a>。这个视频基本上把 MySQL 的相关一些入门知识给介绍完了。</p>\n<p>另外，强推一波 <strong><a href=\"https://book.douban.com/subject/35231266/\" target=\"_blank\" rel=\"noopener noreferrer\">《MySQL 是怎样运行的》</a></strong> 这本书，内容很适合拿来准备面试。讲的很细节，但又不枯燥，内容非常良心！</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20210703120643370.png\" alt=\"\"></p>\n<h2> PostgreSQL</h2>\n<p>和 MySQL 一样，PostgreSQL 也是开源免费且功能强大的关系型数据库。PostgreSQL 的 Slogan 是“<strong>世界上最先进的开源关系型数据库</strong>” 。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/books/image-20220702144954370.png\" alt=\"\"></p>\n<p>最近几年，由于 PostgreSQL 的各种新特性过于优秀，使用 PostgreSQL 代替 MySQL 的项目越来越多了。</p>\n<p>如果你还在纠结是否尝试一下 PostgreSQL 的话，建议你看看这个知乎话题：<a href=\"https://www.zhihu.com/question/20010554\" target=\"_blank\" rel=\"noopener noreferrer\">PostgreSQL 与 MySQL 相比，优势何在？ - 知乎</a> 。</p>\n<h3> 《PostgreSQL 指南：内幕探索》</h3>\n<p><a href=\"https://book.douban.com/subject/33477094/\" target=\"_blank\" rel=\"noopener noreferrer\">《PostgreSQL 指南：内幕探索》</a>这本书主要介绍了 PostgreSQL 内部的工作原理，包括数据库对象的逻辑组织与物理实现，进程与内存的架构。</p>\n<p>刚工作那会需要用到 PostgreSQL ，看了大概 1/3 的内容，感觉还不错。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/books/PostgreSQL-Guide.png\" alt=\"\"></p>\n<h3> 《PostgreSQL 技术内幕：查询优化深度探索》</h3>\n<p><a href=\"https://book.douban.com/subject/30256561/\" target=\"_blank\" rel=\"noopener noreferrer\">《PostgreSQL 技术内幕：查询优化深度探索》</a>这本书主要讲了 PostgreSQL 在查询优化上的一些技术实现细节，可以让你对 PostgreSQL 的查询优化器有深层次的了解。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/books/PostgreSQL-TechnologyInsider.png\" alt=\"\"></p>\n<h2> Redis</h2>\n<p><strong>Redis 就是一个使用 C 语言开发的数据库</strong>，不过与传统数据库不同的是 <strong>Redis 的数据是存在内存中的</strong> ，也就是它是内存数据库，所以读写速度非常快，因此 Redis 被广泛应用于缓存方向。</p>\n<p>如果你要学习 Redis 的话，强烈推荐 <strong><a href=\"https://book.douban.com/subject/25900156/\" target=\"_blank\" rel=\"noopener noreferrer\">《Redis 设计与实现》</a></strong> 和 <strong><a href=\"https://book.douban.com/subject/26612779/\" target=\"_blank\" rel=\"noopener noreferrer\">《Redis 实战》</a></strong> 这两本书。</p>\n<p>另外，<strong><a href=\"https://book.douban.com/subject/26971561/\" target=\"_blank\" rel=\"noopener noreferrer\">《Redis 开发与运维》</a></strong> 这本书也非常不错，既有基础介绍，又有一线开发运维经验分享。</p>\n<p><img src=\"https://oscimg.oschina.net/oscnet/up-9f20f5e860d143181bd27343abfef3af2ce.png\" alt=\"\"></p>\n",
      "image": "https://img-blog.csdnimg.cn/20210406154403673.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0MzM3Mjcy,size_16,color_FFFFFF,t_70",
      "date_published": "2022-04-09T08:19:10.000Z",
      "date_modified": "2023-03-06T14:05:42.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "计算机书籍"
      ]
    },
    {
      "title": "技术书籍精选",
      "url": "https://javaguide.cn/books/",
      "id": "https://javaguide.cn/books/",
      "summary": "这是一则或许对你有用的小广告 👉 欢迎准备 Java 面试以及学习 Java 的同学加入我的知识星球，干货很多！收费虽然是白菜价，但星球里的内容或许比你参加上万的培训班质量还要高。 👉 《Java 面试指北》持续更新完善中！这是一份教你如何更高效地准备面试的小册，涵盖常见八股文（系统设计、常见框架、分布式、高并发 ......）、优质面经等内容。",
      "content_html": "<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">这是一则或许对你有用的小广告</p>\n<p>👉 欢迎准备 Java 面试以及学习 Java 的同学加入我的<a href=\"/about-the-author/zhishixingqiu-two-years.html\" target=\"blank\">知识星球</a>，干货很多！收费虽然是白菜价，但星球里的内容或许比你参加上万的培训班质量还要高。</p>\n<p>👉 <a href=\"/zhuanlan/java-mian-shi-zhi-bei.html\" target=\"blank\">《Java 面试指北》</a>持续更新完善中！这是一份教你如何更高效地准备面试的小册，涵盖常见八股文（系统设计、常见框架、分布式、高并发 ......）、优质面经等内容。</p>\n</div>\n<p>精选优质计算机书籍。</p>\n<p>开源的目的是为了大家能一起完善，如果你觉得内容有任何需要完善/补充的地方，欢迎大家在项目 <a href=\"https://github.com/CodingDocs/awesome-cs/issues\" target=\"_blank\" rel=\"noopener noreferrer\">issues 区</a> 推荐自己认可的技术书籍，让我们共同维护一个优质的技术书籍精选集！</p>\n<ul>\n<li>Github 地址：<a href=\"https://github.com/CodingDocs/awesome-cs\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/CodingDocs/awesome-cs</a></li>\n<li>Gitee 地址：<a href=\"https://gitee.com/SnailClimb/awesome-cs\" target=\"_blank\" rel=\"noopener noreferrer\">https://gitee.com/SnailClimb/awesome-cs</a></li>\n</ul>\n<p>如果内容对你有帮助的话，欢迎给本项目点个 Star。我会用我的业余时间持续完善这份书单，感谢！</p>\n<p>本项目推荐的大部分书籍的 PDF 版本我已经整理到了云盘里，你可以在公众号“<strong>Github掘金计划</strong>” 后台回复“<strong>书籍</strong>”获取到。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/booksimage-20220409153638398.png\" alt=\"\"></p>\n",
      "image": "https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/booksimage-20220409153638398.png",
      "date_published": "2022-04-09T08:19:10.000Z",
      "date_modified": "2022-11-13T08:46:36.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "计算机书籍"
      ]
    },
    {
      "title": "软件质量必读经典书籍",
      "url": "https://javaguide.cn/books/software-quality.html",
      "id": "https://javaguide.cn/books/software-quality.html",
      "summary": "下面推荐都是我看过并且我觉得值得推荐的书籍。 不过，这些书籍都比较偏理论，只能帮助你建立一个写优秀代码的意识标准。 如果你想要编写更高质量的代码、更高质量的软件，还是应该多去看优秀的源码，多去学习优秀的代码实践。 代码整洁之道 《重构》",
      "content_html": "<p>下面推荐都是我看过并且我觉得值得推荐的书籍。</p>\n<p>不过，这些书籍都比较偏理论，只能帮助你建立一个写优秀代码的意识标准。 如果你想要编写更高质量的代码、更高质量的软件，还是应该多去看优秀的源码，多去学习优秀的代码实践。</p>\n<h2> 代码整洁之道</h2>\n<p><strong><a href=\"https://book.douban.com/subject/30468597/\" target=\"_blank\" rel=\"noopener noreferrer\">《重构》</a></strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/20210328174841577.png\" alt=\"\"></p>\n<p>必看书籍！无需多言。编程书籍领域的瑰宝。</p>\n<p>世界顶级、国宝级别的 Martin Fowler 的书籍，可以说是软件开发领域最经典的几本书之一。目前已经出了第二版。</p>\n<p>这是一本值得你看很多遍的书籍。</p>\n<p><strong><a href=\"https://book.douban.com/subject/4199741/\" target=\"_blank\" rel=\"noopener noreferrer\">《Clean Code》</a></strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/20210328174824891.png\" alt=\"\"></p>\n<p>《Clean Code》是 Bob 大叔的一本经典著作，强烈建议小伙伴们一定要看看。</p>\n<p>Bob 大叔将自己对整洁代码的理解浓缩在了这本书中，真可谓是对后生的一大馈赠。</p>\n<p><strong><a href=\"https://book.douban.com/subject/30412517/\" target=\"_blank\" rel=\"noopener noreferrer\">《Effective Java 》</a></strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/82d510c951384383b325080428af6c0a.png\" alt=\"\"></p>\n<p>《Effective Java 》这本书是 Java 领域国宝级别的书，非常经典。Java 程序员必看！</p>\n<p>这本书主要介绍了在 Java 编程中很多极具实用价值的经验规则，这些经验规则涵盖了大多数开发人员每天所面临的问题的解决方案。这篇文章能够非常实际地帮助你写出更加清晰、健壮和高效的代码。本书中的每条规则都以简短、独立的小文章形式出现，并通过例子代码加以进一步说明。</p>\n<p><strong><a href=\"https://book.douban.com/subject/1477390/\" target=\"_blank\" rel=\"noopener noreferrer\">《代码大全》</a></strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/20210314173253221.png\" alt=\"\"></p>\n<p>其实，《代码大全（第 2 版）》这本书我本身是不太想推荐给大家了。但是，看在它的豆瓣评分这么高的份上，还是拿出来说说吧！</p>\n<p>这也是一本非常经典的书籍，第二版对第一版进行了重写。</p>\n<p>我简单地浏览过全书的内容，感觉内容总体比较虚，对于大部分程序员的作用其实不大。如果你想要切实地提高自己的代码质量，《Clean Code》和 《编写可读代码的艺术》我觉得都要比《代码大全》这本书更好。</p>\n<p>不过，最重要的还是要多看优秀的源码，多学习优秀的代码实践。</p>\n<p><strong><a href=\"https://book.douban.com/subject/10797189/\" target=\"_blank\" rel=\"noopener noreferrer\">《编写可读代码的艺术》</a></strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/20210314175536443.png\" alt=\"\"></p>\n<p>《编写可读代码的艺术》这本书要表达的意思和《Clean Code》很像，你看它俩的目录就可以看出来了。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20210314174853141.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0MzM3Mjcy,size_16,color_FFFFFF,t_70\" alt=\"\"></p>\n<p>在我看来，如果你看过 《Clean Code》 的话，就不需要再看这本书了。当然，如果你有时间和精力，也可以快速过一遍。</p>\n<p>另外，我这里还要推荐一个叫做 <strong><a href=\"https://github.com/biezhi/write-readable-code\" target=\"_blank\" rel=\"noopener noreferrer\">write-readable-code</a></strong> 的仓库。这个仓库的作者免费分享了一系列基于《编写可读代码的艺术》这本书的视频。这一系列视频会基于 Java 语言来教你如何优化咱们的代码。</p>\n<p>在实践中学习的效果肯定会更好！推荐小伙伴们都抓紧学起来啊！</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20210314180405396.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0MzM3Mjcy,size_16,color_FFFFFF,t_70\" alt=\"\"></p>\n<h2> 程序员职业素养</h2>\n<p><strong><a href=\"https://book.douban.com/subject/26919457/\" target=\"_blank\" rel=\"noopener noreferrer\">《The Clean Coder》</a></strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/20210314191210273.png\" alt=\"\"></p>\n<p>《 The Clean Coder》是 Bob 大叔的又一经典著作。</p>\n<p>《Clean Code》和《 The Clean Coder》这两本书在国内都翻译为 《代码整洁之道》，我觉得这个翻译还是不够优雅的。</p>\n<p>另外，两者的内容差异也很大。《Clean Code》这本书从代码层面来讲解如何提高自己的代码质量。而《The Clean Coder》这本书则是从如何成为一名更优秀的开发者的角度来写的，比如这书会教你如何在自己的领域更专业、如何说不、如何做时间管理、如何处理压力等等。</p>\n<h2> 架构整洁之道</h2>\n<p><strong><a href=\"https://book.douban.com/subject/30333919/\" target=\"_blank\" rel=\"noopener noreferrer\">《架构整洁之道》</a></strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/2021031412342771.png\" alt=\"\"></p>\n<p>你没看错，《架构整洁之道》这本书又是 Bob 大叔的经典之作。</p>\n<p>这本书我强烈安利！认真读完之后，我保证你对编程本质、编程语言的本质、软件设计、架构设计可以有进一步的认识。</p>\n<p>国内的很多书籍和专栏都借鉴了《架构整洁之道》 这本书。毫不夸张地说，《架构整洁之道》就是架构领域最经典的书籍之一。</p>\n<p>正如作者说的那样：</p>\n<blockquote>\n<p>如果深入研究计算机编程的本质，我们就会发现这 50 年来，计算机编程基本没有什么大的变化。编程语言稍微进步了一点，工具的质量大大提升了，但是计算机程序的基本构造没有什么变化。</p>\n<p>虽然我们有了新的编程语言、新的编程框架、新的编程范式，但是软件架构的规则仍然和 1946 年阿兰·图灵写下第一行机器代码的时候一样。</p>\n<p>这本书就是为了把这些永恒不变的软件架构规则展现出来。</p>\n</blockquote>\n<h2> 项目管理</h2>\n<p><strong><a href=\"https://book.douban.com/subject/1102259/\" target=\"_blank\" rel=\"noopener noreferrer\">《人月神话》</a></strong></p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2021/03/8ece325c-4491-4ffd-9d3d-77e95159ec40.png\" alt=\"\"></p>\n<p>这本书主要描述了软件开发的基本定律：<strong>一个需要 10 天才能干完的活，不可能让 10 个人在 1 天干完！</strong></p>\n<p>看书名的第一眼，感觉不像是技术类的书籍。但是，就是这样一个看似和编程不沾边的书名，却成了编程领域长久相传的经典。</p>\n<p><strong>这本书对于现代软件尤其是复杂软件的开发的规范化有深刻的意义。</strong></p>\n<p><strong><a href=\"https://book.douban.com/subject/5344973/\" target=\"_blank\" rel=\"noopener noreferrer\">《领域驱动设计:软件核心复杂性应对之道》</a></strong></p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2021/03/7e80418d-20b1-4066-b9af-cfe434b1bf1a.png\" alt=\"\"></p>\n<p>这本领域驱动设计方面的经典之作一直被各种推荐，但是我还来及读。</p>\n<h2> 其他</h2>\n<ul>\n<li><a href=\"https://book.douban.com/subject/24536403/\" target=\"_blank\" rel=\"noopener noreferrer\">《代码的未来》</a> ：这本书的作者是 Ruby 之父松本行弘，算是一本年代比较久远的书籍（13 年出版），不过，还是非常值得一读。这本书的内容主要介绍是编程/编程语言的本质。我个人还是比较喜欢松本行弘的文字风格，并且，你看他的文章也确实能够有所收获。</li>\n<li><a href=\"https://book.douban.com/subject/1488876/\" target=\"_blank\" rel=\"noopener noreferrer\">《深入浅出设计模式》</a> ： 比较有趣的风格，适合设计模式入门。</li>\n<li><a href=\"https://book.douban.com/subject/30443578/\" target=\"_blank\" rel=\"noopener noreferrer\">《软件架构设计:大型网站技术架构与业务架构融合之道》</a> ： 内容非常全面。适合面试前突击一些比较重要的理论知识，也适合拿来扩充/完善自己的技术广度。</li>\n<li><a href=\"https://book.douban.com/subject/33425123/\" target=\"_blank\" rel=\"noopener noreferrer\">《微服务架构设计模式》</a> ：这本书是世界十大软件架构师之一、微服务架构先驱 Chris Richardson 亲笔撰写，豆瓣评分 9.6。示例代码使用 Java 语言和 Spring 框架。帮助你设计、实现、测试和部署基于微服务的应用程序。</li>\n</ul>\n<p>最后再推荐两个相关的文档：</p>\n<ul>\n<li><strong>阿里巴巴 Java 开发手册</strong> ：https://github.com/alibaba/p3c</li>\n<li><strong>Google Java 编程风格指南：</strong> http://www.hawstein.com/posts/google-java-style.html</li>\n</ul>\n",
      "image": "https://img-blog.csdnimg.cn/20210328174841577.png",
      "date_published": "2022-04-09T08:19:10.000Z",
      "date_modified": "2022-12-18T05:47:15.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "计算机书籍"
      ]
    },
    {
      "title": "MySQL隐式转换造成索引失效",
      "url": "https://javaguide.cn/database/mysql/index-invalidation-caused-by-implicit-conversion.html",
      "id": "https://javaguide.cn/database/mysql/index-invalidation-caused-by-implicit-conversion.html",
      "summary": "本次测试使用的 MySQL 版本是 5.7.26，随着 MySQL 版本的更新某些特性可能会发生改变，本文不代表所述观点和结论于 MySQL 所有版本均准确无误，版本差异请自行甄别。 原文：https://www.guitu18.com/post/2019/11/24/61.html 前言 数据库优化是一个任重而道远的任务，想要做优化必须深入理解数据库的各种特性。在开发过程中我们经常会遇到一些原因很简单但造成的后果却很严重的疑难杂症，这类问题往往还不容易定位，排查费时费力最后发现是一个很小的疏忽造成的，又或者是因为不了解某个技术特性产生的。",
      "content_html": "<blockquote>\n<p>本次测试使用的 MySQL 版本是 <code>5.7.26</code>，随着 MySQL 版本的更新某些特性可能会发生改变，本文不代表所述观点和结论于 MySQL 所有版本均准确无误，版本差异请自行甄别。</p>\n<p>原文：https://www.guitu18.com/post/2019/11/24/61.html</p>\n</blockquote>\n<h2> 前言</h2>\n<p>数据库优化是一个任重而道远的任务，想要做优化必须深入理解数据库的各种特性。在开发过程中我们经常会遇到一些原因很简单但造成的后果却很严重的疑难杂症，这类问题往往还不容易定位，排查费时费力最后发现是一个很小的疏忽造成的，又或者是因为不了解某个技术特性产生的。</p>\n<p>于数据库层面，最常见的恐怕就是索引失效了，且一开始因为数据量小还不易被发现。但随着业务的拓展数据量的提升，性能问题慢慢的就体现出来了，处理不及时还很容易造成雪球效应，最终导致数据库卡死甚至瘫痪。造成索引失效的原因可能有很多种，相关技术博客已经有太多了，今天我要记录的是<strong>隐式转换造成的索引失效</strong>。</p>\n<h2> 数据准备</h2>\n<p>首先使用存储过程生成 1000 万条测试数据，\n测试表一共建立了 7 个字段（包括主键），<code>num1</code>和<code>num2</code>保存的是和<code>ID</code>一样的顺序数字，其中<code>num2</code>是字符串类型。\n<code>type1</code>和<code>type2</code>保存的都是主键对 5 的取模，目的是模拟实际应用中常用类似 type 类型的数据，但是<code>type2</code>是没有建立索引的。\n<code>str1</code>和<code>str2</code>都是保存了一个 20 位长度的随机字符串，<code>str1</code>不能为<code>NULL</code>，<code>str2</code>允许为<code>NULL</code>，相应的生成测试数据的时候我也会在<code>str2</code>字段生产少量<code>NULL</code>值（每 100 条数据产生一个<code>NULL</code>值）。</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>数据量比较大，还涉及使用<code>MD5</code>生成随机字符串，所以速度有点慢，稍安勿躁，耐心等待即可。</p>\n<p>1000 万条数据，我用了 33 分钟才跑完（实际时间跟你电脑硬件配置有关）。这里贴几条生成的数据，大致长这样。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/mysqlindex-invalidation-caused-by-implicit-conversion-01.png\" alt=\"\"></p>\n<h2> SQL 测试</h2>\n<p>先来看这组 SQL，一共四条，我们的测试数据表<code>num1</code>是<code>int</code>类型，<code>num2</code>是<code>varchar</code>类型，但是存储的数据都是跟主键<code>id</code>一样的顺序数字，两个字段都建立有索引。</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这四条 SQL 都是有针对性写的，12 查询的字段是 int 类型，34 查询的字段是<code>varchar</code>类型。12 或 34 查询的字段虽然都相同，但是一个条件是数字，一个条件是用引号引起来的字符串。这样做有什么区别呢？先不看下边的测试结果你能猜出这四条 SQL 的效率顺序吗？</p>\n<p>经测试这四条 SQL 最后的执行结果却相差很大，其中 124 三条 SQL 基本都是瞬间出结果，大概在 0.001~0.005 秒，在千万级的数据量下这样的结果可以判定这三条 SQL 性能基本没差别了。但是第三条 SQL，多次测试耗时基本在 4.5~4.8 秒之间。</p>\n<p>为什么 34 两条 SQL 效率相差那么大，但是同样做对比的 12 两条 SQL 却没什么差别呢？查看一下执行计划，下边分别 1234 条 SQL 的执行计划数据：</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/mysqlindex-invalidation-caused-by-implicit-conversion-02.png\" alt=\"\"></p>\n<p>可以看到，124 三条 SQL 都能使用到索引，连接类型都为<code>ref</code>，扫描行数都为 1，所以效率非常高。再看看第三条 SQL，没有用上索引，所以为全表扫描，<code>rows</code>直接到达 1000 万了，所以性能差别才那么大。</p>\n<p>仔细观察你会发现，34 两条 SQL 查询的字段<code>num2</code>是<code>varchar</code>类型的，查询条件等号右边加引号的第 4 条 SQL 是用到索引的，那么是查询的数据类型和字段数据类型不一致造成的吗？如果是这样那 12 两条 SQL 查询的字段<code>num1</code>是<code>int</code>类型，但是第 2 条 SQL 查询条件右边加了引号为什么还能用上索引呢。</p>\n<p>查阅 MySQL 相关文档发现是隐式转换造成的，看一下官方的描述：</p>\n<blockquote>\n<p>官方文档： <a href=\"https://dev.mysql.com/doc/refman/5.7/en/type-conversion.html?spm=5176.100239.blogcont47339.5.1FTben\" target=\"_blank\" rel=\"noopener noreferrer\">12.2 Type Conversion in Expression Evaluation</a></p>\n<p>当操作符与不同类型的操作数一起使用时，会发生类型转换以使操作数兼容。某些转换是隐式发生的。例如，MySQL 会根据需要自动将字符串转换为数字，反之亦然。以下规则描述了比较操作的转换方式：</p>\n<ol>\n<li>两个参数至少有一个是<code>NULL</code>时，比较的结果也是<code>NULL</code>，特殊的情况是使用<code>&lt;=&gt;</code>对两个<code>NULL</code>做比较时会返回<code>1</code>，这两种情况都不需要做类型转换</li>\n<li>两个参数都是字符串，会按照字符串来比较，不做类型转换</li>\n<li>两个参数都是整数，按照整数来比较，不做类型转换</li>\n<li>十六进制的值和非数字做比较时，会被当做二进制串</li>\n<li>有一个参数是<code>TIMESTAMP</code>或<code>DATETIME</code>，并且另外一个参数是常量，常量会被转换为<code>timestamp</code></li>\n<li>有一个参数是<code>decimal</code>类型，如果另外一个参数是<code>decimal</code>或者整数，会将整数转换为<code>decimal</code>后进行比较，如果另外一个参数是浮点数，则会把<code>decimal</code>转换为浮点数进行比较</li>\n<li><strong>所有其他情况下，两个参数都会被转换为浮点数再进行比较</strong></li>\n</ol>\n</blockquote>\n<p>根据官方文档的描述，我们的第 23 两条 SQL 都发生了隐式转换，第 2 条 SQL 的查询条件<code>num1 = '10000'</code>，左边是<code>int</code>类型右边是字符串，第 3 条 SQL 相反，那么根据官方转换规则第 7 条，左右两边都会转换为浮点数再进行比较。</p>\n<p>先看第 2 条 SQL：<code>SELECT * FROM</code>test1<code>WHERE num1 = '10000';</code> <strong>左边为 int 类型</strong><code>10000</code>，转换为浮点数还是<code>10000</code>，右边字符串类型<code>'10000'</code>，转换为浮点数也是<code>10000</code>。两边的转换结果都是唯一确定的，所以不影响使用索引。</p>\n<p>第 3 条 SQL：<code>SELECT * FROM</code>test1<code>WHERE num2 = 10000;</code> <strong>左边是字符串类型</strong><code>'10000'</code>，转浮点数为 10000 是唯一的，右边<code>int</code>类型<code>10000</code>转换结果也是唯一的。但是，因为左边是检索条件，<code>'10000'</code>转到<code>10000</code>虽然是唯一，但是其他字符串也可以转换为<code>10000</code>，比如<code>'10000a'</code>，<code>'010000'</code>，<code>'10000'</code>等等都能转为浮点数<code>10000</code>，这样的情况下，是不能用到索引的。</p>\n<p>关于这个<strong>隐式转换</strong>我们可以通过查询测试验证一下，先插入几条数据，其中<code>num2='10000a'</code>、<code>'010000'</code>和<code>'10000'</code>：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>然后使用第三条 SQL 语句<code>SELECT * FROM</code>test1<code>WHERE num2 = 10000;</code>进行查询：</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/mysqlindex-invalidation-caused-by-implicit-conversion-03.png\" alt=\"\"></p>\n<p>从结果可以看到，后面插入的三条数据也都匹配上了。那么这个字符串隐式转换的规则是什么呢？为什么<code>num2='10000a'</code>、<code>'010000'</code>和<code>'10000'</code>这三种情形都能匹配上呢？查阅相关资料发现规则如下：</p>\n<ol>\n<li><strong>不以数字开头</strong>的字符串都将转换为<code>0</code>。如<code>'abc'</code>、<code>'a123bc'</code>、<code>'abc123'</code>都会转化为<code>0</code>；</li>\n<li><strong>以数字开头的</strong>字符串转换时会进行截取，从第一个字符截取到第一个非数字内容为止。比如<code>'123abc'</code>会转换为<code>123</code>，<code>'012abc'</code>会转换为<code>012</code>也就是<code>12</code>，<code>'5.3a66b78c'</code>会转换为<code>5.3</code>，其他同理。</li>\n</ol>\n<p>现对以上规则做如下测试验证：</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/mysqlindex-invalidation-caused-by-implicit-conversion-04.png\" alt=\"\"></p>\n<p>如此也就印证了之前的查询结果了。</p>\n<p>再次写一条 SQL 查询 str1 字段：<code>SELECT * FROM</code>test1<code>WHERE str1 = 1234;</code></p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/mysqlindex-invalidation-caused-by-implicit-conversion-05.png\" alt=\"\"></p>\n<h2> 分析和总结</h2>\n<p>通过上面的测试我们发现 MySQL 使用操作符的一些特性：</p>\n<ol>\n<li>当操作符<strong>左右两边的数据类型不一致</strong>时，会发生<strong>隐式转换</strong>。</li>\n<li>当 where 查询操作符<strong>左边为数值类型</strong>时发生了隐式转换，那么对效率影响不大，但还是不推荐这么做。</li>\n<li>当 where 查询操作符<strong>左边为字符类型</strong>时发生了隐式转换，那么会导致索引失效，造成全表扫描效率极低。</li>\n<li>字符串转换为数值类型时，非数字开头的字符串会转化为<code>0</code>，以数字开头的字符串会截取从第一个字符到第一个非数字内容为止的值为转化结果。</li>\n</ol>\n<p>所以，我们在写 SQL 时一定要养成良好的习惯，查询的字段是什么类型，等号右边的条件就写成对应的类型。特别当查询的字段是字符串时，等号右边的条件一定要用引号引起来标明这是一个字符串，否则会造成索引失效触发全表扫描。</p>\n",
      "image": "https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/mysqlindex-invalidation-caused-by-implicit-conversion-01.png",
      "date_published": "2022-04-06T01:52:22.000Z",
      "date_modified": "2023-01-14T10:33:11.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "数据库"
      ]
    },
    {
      "title": "Java 序列化详解",
      "url": "https://javaguide.cn/java/basis/serialization.html",
      "id": "https://javaguide.cn/java/basis/serialization.html",
      "summary": "什么是序列化和反序列化? 如果我们需要持久化 Java 对象比如将 Java 对象保存在文件中，或者在网络传输 Java 对象，这些场景都需要用到序列化。 简单来说： 序列化： 将数据结构或对象转换成二进制字节流的过程 反序列化：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程 对于 Java 这种面向对象编程语言来说，我们序列化的都是对象（Object）也就是实例化后的类(Class)，但是在 C++这种半面向对象的语言中，struct(结构体)定义的是数据结构类型，而 class 对应的是对象类型。",
      "content_html": "<h2> 什么是序列化和反序列化?</h2>\n<p>如果我们需要持久化 Java 对象比如将 Java 对象保存在文件中，或者在网络传输 Java 对象，这些场景都需要用到序列化。</p>\n<p>简单来说：</p>\n<ul>\n<li><strong>序列化</strong>： 将数据结构或对象转换成二进制字节流的过程</li>\n<li><strong>反序列化</strong>：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程</li>\n</ul>\n<p>对于 Java 这种面向对象编程语言来说，我们序列化的都是对象（Object）也就是实例化后的类(Class)，但是在 C++这种半面向对象的语言中，struct(结构体)定义的是数据结构类型，而 class 对应的是对象类型。</p>\n<p>下面是序列化和反序列化常见应用场景：</p>\n<ul>\n<li>对象在进行网络传输（比如远程方法调用 RPC 的时候）之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化；</li>\n<li>将对象存储到文件之前需要进行序列化，将对象从文件中读取出来需要进行反序列化；</li>\n<li>将对象存储到数据库（如 Redis）之前需要用到序列化，将对象从缓存数据库中读取出来需要反序列化；</li>\n<li>将对象存储到内存之前需要进行序列化，从内存中读取出来之后需要进行反序列化。</li>\n</ul>\n<p>维基百科是如是介绍序列化的：</p>\n<blockquote>\n<p><strong>序列化</strong>（serialization）在计算机科学的数据处理中，是指将数据结构或对象状态转换成可取用格式（例如存成文件，存于缓冲，或经由网络中发送），以留待后续在相同或另一台计算机环境中，能恢复原先状态的过程。依照序列化格式重新获取字节的结果时，可以利用它来产生与原始对象相同语义的副本。对于许多对象，像是使用大量引用的复杂对象，这种序列化重建的过程并不容易。面向对象中的对象序列化，并不概括之前原始对象所关系的函数。这种过程也称为对象编组（marshalling）。从一系列字节提取数据结构的反向操作，是反序列化（也称为解编组、deserialization、unmarshalling）。</p>\n</blockquote>\n<p>综上：<strong>序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中。</strong></p>\n<p><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2020-8/a478c74d-2c48-40ae-9374-87aacf05188c.png\" alt=\"\"></p>\n<p style=\"text-align:right;font-size:13px;color:gray\">https://www.corejavaguru.com/java/serialization/interview-questions-1</p>\n<p><strong>序列化协议对应于 TCP/IP 4 层模型的哪一层？</strong></p>\n<p>我们知道网络通信的双方必须要采用和遵守相同的协议。TCP/IP 四层模型是下面这样的，序列化协议属于哪一层呢？</p>\n<ol>\n<li>应用层</li>\n<li>传输层</li>\n<li>网络层</li>\n<li>网络接口层</li>\n</ol>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/network/tcp-ip-4-model.png\" alt=\"TCP/IP 四层模型\"></p>\n<p>如上图所示，OSI 七层协议模型中，表示层做的事情主要就是对应用层的用户数据进行处理转换为二进制流。反过来的话，就是将二进制流转换成应用层的用户数据。这不就对应的是序列化和反序列化么？</p>\n<p>因为，OSI 七层协议模型中的应用层、表示层和会话层对应的都是 TCP/IP 四层模型中的应用层，所以序列化协议属于 TCP/IP 协议应用层的一部分。</p>\n<h2> 常见序列化协议有哪些？</h2>\n<p>JDK 自带的序列化方式一般不会用 ，因为序列化效率低并且存在安全问题。比较常用的序列化协议有 Hessian、Kryo、Protobuf、ProtoStuff，这些都是基于二进制的序列化协议。</p>\n<p>像 JSON 和 XML 这种属于文本类序列化方式。虽然可读性比较好，但是性能较差，一般不会选择。</p>\n<h3> JDK 自带的序列化方式</h3>\n<p>JDK 自带的序列化，只需实现 <code>java.io.Serializable</code>接口即可。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>serialVersionUID 有什么作用？</strong></p>\n<p>序列化号 <code>serialVersionUID</code> 属于版本控制的作用。反序列化时，会检查 <code>serialVersionUID</code> 是否和当前类的 <code>serialVersionUID</code> 一致。如果 <code>serialVersionUID</code> 不一致则会抛出 <code>InvalidClassException</code> 异常。强烈推荐每个序列化类都手动指定其 <code>serialVersionUID</code>，如果不手动指定，那么编译器会动态生成默认的 <code>serialVersionUID</code>。</p>\n<p><strong>serialVersionUID 不是被 static 变量修饰了吗？为什么还会被“序列化”？</strong></p>\n<p><code>static</code> 修饰的变量是静态变量，位于方法区，本身是不会被序列化的。 <code>static</code> 变量是属于类的而不是对象。你反序列之后，<code>static</code> 变量的值就像是默认赋予给了对象一样，看着就像是 <code>static</code> 变量被序列化，实际只是假象罢了。</p>\n<p><strong>如果有些字段不想进行序列化怎么办？</strong></p>\n<p>对于不想进行序列化的变量，可以使用 <code>transient</code> 关键字修饰。</p>\n<p><code>transient</code> 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 <code>transient</code> 修饰的变量值不会被持久化和恢复。</p>\n<p>关于 <code>transient</code> 还有几点注意：</p>\n<ul>\n<li><code>transient</code> 只能修饰变量，不能修饰类和方法。</li>\n<li><code>transient</code> 修饰的变量，在反序列化后变量值将会被置成类型的默认值。例如，如果是修饰 <code>int</code> 类型，那么反序列后结果就是 <code>0</code>。</li>\n<li><code>static</code> 变量因为不属于任何对象(Object)，所以无论有没有 <code>transient</code> 关键字修饰，均不会被序列化。</li>\n</ul>\n<p><strong>为什么不推荐使用 JDK 自带的序列化？</strong></p>\n<p>我们很少或者说几乎不会直接使用 JDK 自带的序列化方式，主要原因有下面这些原因：</p>\n<ul>\n<li><strong>不支持跨语言调用</strong> : 如果调用的是其他语言开发的服务的时候就不支持了。</li>\n<li><strong>性能差</strong> ：相比于其他序列化框架性能更低，主要原因是序列化之后的字节数组体积较大，导致传输成本加大。</li>\n<li><strong>存在安全问题</strong> ：序列化和反序列化本身并不存在问题。但当输入的反序列化的数据可被用户控制，那么攻击者即可通过构造恶意输入，让反序列化产生非预期的对象，在此过程中执行构造的任意代码。相关阅读：<a href=\"https://cryin.github.io/blog/secure-development-java-deserialization-vulnerability/\" target=\"_blank\" rel=\"noopener noreferrer\">应用安全:JAVA反序列化漏洞之殇 - Cryin</a> 、<a href=\"https://www.zhihu.com/question/37562657/answer/1916596031\" target=\"_blank\" rel=\"noopener noreferrer\">Java反序列化安全漏洞怎么回事? - Monica</a>。</li>\n</ul>\n<h3> Kryo</h3>\n<p>Kryo 是一个高性能的序列化/反序列化工具，由于其变长存储特性并使用了字节码生成机制，拥有较高的运行速度和较小的字节码体积。</p>\n<p>另外，Kryo 已经是一种非常成熟的序列化实现了，已经在 Twitter、Groupon、Yahoo 以及多个著名开源项目（如 Hive、Storm）中广泛的使用。</p>\n<p><a href=\"https://github.com/Snailclimb/guide-rpc-framework\" target=\"_blank\" rel=\"noopener noreferrer\">guide-rpc-framework</a> 就是使用的 kryo 进行序列化，序列化和反序列化相关的代码如下：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>Github 地址：<a href=\"https://github.com/EsotericSoftware/kryo\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/EsotericSoftware/kryo</a> 。</p>\n<h3> Protobuf</h3>\n<p>Protobuf 出自于 Google，性能还比较优秀，也支持多种语言，同时还是跨平台的。就是在使用中过于繁琐，因为你需要自己定义 IDL 文件和生成对应的序列化代码。这样虽然不灵活，但是，另一方面导致 protobuf 没有序列化漏洞的风险。</p>\n<blockquote>\n<p>Protobuf 包含序列化格式的定义、各种语言的库以及一个 IDL 编译器。正常情况下你需要定义 proto 文件，然后使用 IDL 编译器编译成你需要的语言</p>\n</blockquote>\n<p>一个简单的 proto 文件如下：</p>\n<div class=\"language-protobuf line-numbers-mode\" data-ext=\"protobuf\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>Github 地址：<a href=\"https://github.com/protocolbuffers/protobuf\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/protocolbuffers/protobuf</a>。</p>\n<h3> ProtoStuff</h3>\n<p>由于 Protobuf 的易用性，它的哥哥 Protostuff 诞生了。</p>\n<p>protostuff 基于 Google protobuf，但是提供了更多的功能和更简易的用法。虽然更加易用，但是不代表 ProtoStuff 性能更差。</p>\n<p>Github 地址：<a href=\"https://github.com/protostuff/protostuff\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/protostuff/protostuff</a>。</p>\n<h3> Hessian</h3>\n<p>Hessian 是一个轻量级的，自定义描述的二进制 RPC 协议。Hessian 是一个比较老的序列化实现了，并且同样也是跨语言的。</p>\n<p><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2020-8/8613ec4c-bde5-47bf-897e-99e0f90b9fa3.png\" alt=\"\"></p>\n<p>Dubbo2.x 默认启用的序列化方式是 Hessian2 ,但是，Dubbo 对 Hessian2 进行了修改，不过大体结构还是差不多。</p>\n<h3> 总结</h3>\n<p>Kryo 是专门针对 Java 语言序列化方式并且性能非常好，如果你的应用是专门针对 Java 语言的话可以考虑使用，并且 Dubbo 官网的一篇文章中提到说推荐使用 Kryo 作为生产环境的序列化方式。(文章地址：<a href=\"https://dubbo.apache.org/zh/docs/v2.7/user/references/protocol/rest/\" target=\"_blank\" rel=\"noopener noreferrer\">https://dubbo.apache.org/zh/docs/v2.7/user/references/protocol/rest/</a>)</p>\n<p><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2020-8/569e541a-22b2-4846-aa07-0ad479f07440.png\" alt=\"\"></p>\n<p>像 Protobuf、 ProtoStuff、hessian 这类都是跨语言的序列化方式，如果有跨语言需求的话可以考虑使用。</p>\n<p>除了我上面介绍到的序列化方式的话，还有像 Thrift，Avro 这些。</p>\n",
      "image": "https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2020-8/a478c74d-2c48-40ae-9374-87aacf05188c.png",
      "date_published": "2022-04-04T01:08:31.000Z",
      "date_modified": "2022-11-08T02:21:36.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "",
      "url": "https://javaguide.cn/distributed-system/theorem_algorithm_protocol/gossip.html",
      "id": "https://javaguide.cn/distributed-system/theorem_algorithm_protocol/gossip.html",
      "summary": "背景 在分布式系统中，不同的节点进行数据/信息共享是一个基本的需求。 一种比较简单粗暴的方法就是 集中式发散消息，简单来说就是一个主节点同时共享最新信息给其他所有节点，比较适合中心化系统。这种方法的缺陷也很明显，节点多的时候不光同步消息的效率低，还太依赖与中心节点，存在单点风险问题。 于是，分散式发散消息 的 Gossip 协议 就诞生了。 Gossip 协议介绍 Gossip 直译过来就是闲话、流言蜚语的意思。流言蜚语有什么特点呢？容易被传播且传播速度还快，你传我我传他，然后大家都知道了。",
      "content_html": "<h2> 背景</h2>\n<p>在分布式系统中，不同的节点进行数据/信息共享是一个基本的需求。</p>\n<p>一种比较简单粗暴的方法就是 <strong>集中式发散消息</strong>，简单来说就是一个主节点同时共享最新信息给其他所有节点，比较适合中心化系统。这种方法的缺陷也很明显，节点多的时候不光同步消息的效率低，还太依赖与中心节点，存在单点风险问题。</p>\n<p>于是，<strong>分散式发散消息</strong> 的 <strong>Gossip 协议</strong> 就诞生了。</p>\n<h2> Gossip 协议介绍</h2>\n<p>Gossip 直译过来就是闲话、流言蜚语的意思。流言蜚语有什么特点呢？容易被传播且传播速度还快，你传我我传他，然后大家都知道了。</p>\n<p></p>\n<p>Gossip 协议也叫 Epidemic 协议（流行病协议）或者 Epidemic propagation 算法（疫情传播算法），别名很多。不过，这些名字的特点都具有 <strong>随机传播特性</strong> （联想一下病毒传播、癌细胞扩散等生活中常见的情景），这也正是 Gossip 协议最主要的特点。</p>\n<p>Gossip 协议最早是在 ACM 上的一篇 1987 年发表的论文 <a href=\"https://dl.acm.org/doi/10.1145/41840.41841\" target=\"_blank\" rel=\"noopener noreferrer\">《Epidemic Algorithms for Replicated Database Maintenance》</a>中被提出的。根据论文标题，我们大概就能知道 Gossip 协议当时提出的主要应用是在分布式数据库系统中各个副本节点同步数据。</p>\n<p>正如 Gossip 协议其名一样，这是一种随机且带有传染性的方式将信息传播到整个网络中，并在一定时间内，使得系统内的所有节点数据一致。</p>\n<p>在 Gossip 协议下，没有所谓的中心节点，每个节点周期性地随机找一个节点互相同步彼此的信息，理论上来说，各个节点的状态最终会保持一致。</p>\n<p>下面我们来对 Gossip 协议的定义做一个总结： <strong>Gossip 协议是一种允许在分布式系统中共享状态的去中心化通信协议，通过这种通信协议，我们可以将信息传播给网络或集群中的所有成员。</strong></p>\n<h2> Gossip 协议应用</h2>\n<p>1、我们经常使用的分布式缓存 Redis 的官方集群解决方案（3.0 版本引入） Redis Cluster 就是基于 Gossip 协议来实现集群中各个节点数据的最终一致性。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/85fbed524d8342adb054961525c6e257.png\" alt=\"\"></p>\n<p>Redis Cluster 中的每个 Redis 节点都维护了一份集群的状态信息，各个节点利用 Gossip 协议传递的信息就是集群的状态信息。</p>\n<p>下图就是主从架构的 Redis Cluster 的示意图，图中的虚线代表的就是各个节点之间使用 Gossip 进行通信 ，实线表示主从复制。</p>\n<p></p>\n<p>2、NoSQL 数据库 Apache Cassandra 集群通过 Gossip 协议来进行动态管理集群节点状态（节点故障检测和恢复）。</p>\n<p>3、服务网格解决方案 Consul 使用 Gossip 协议网络内可靠有效地传输新服务和事件的信息。</p>\n<p>4、Bitcoin 使用 Gossip 协议来传播交易和区块信息。不过，为了提供更好的隐私保护，CMU 的研究人员提出 <strong>蒲公英协议</strong>。</p>\n<p>5、......</p>\n<p>还有非常多使用 Gossip 协议的应用，学习 Gossip 协议有助于我们搞清很多技术的底层原理。</p>\n<h2> Gossip 协议消息传播模式</h2>\n<p>Gossip 设计了两种可能的消息传播模式：<strong>反熵（Anti-Entropy）</strong> 和 <strong>传谣（Rumor-Mongering）</strong>。</p>\n<h3> 反熵(Anti-entropy)</h3>\n<p>根据维基百科：</p>\n<blockquote>\n<p>熵的概念最早起源于<a href=\"https://zh.wikipedia.org/wiki/%E7%89%A9%E7%90%86%E5%AD%A6\" target=\"_blank\" rel=\"noopener noreferrer\">物理学</a>，用于度量一个热力学系统的混乱程度。熵最好理解为不确定性的量度而不是确定性的量度，因为越随机的信源的熵越大。</p>\n</blockquote>\n<p>在这里，你可以把反熵中的熵了解为节点之间数据的混乱程度/差异性，反熵就是指消除不同节点中数据的差异，提升节点间数据的相似度，从而降低熵值。</p>\n<p>具体是如何反熵的呢？集群中的节点，每隔段时间就随机选择某个其他节点，然后通过互相交换自己的所有数据来消除两者之间的差异，实现数据的最终一致性。</p>\n<p>在实现反熵的时候，主要有推、拉和推拉三种方式：</p>\n<ul>\n<li>推方式，就是将自己的所有副本数据，推给对方，修复对方副本中的熵。</li>\n<li>拉方式，就是拉取对方的所有副本数据，修复自己副本中的熵。</li>\n<li>推拉就是同时修复自己副本和对方副本中的熵。</li>\n</ul>\n<p>伪代码如下：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20210605165106728.png\" alt=\"\"></p>\n<p>在我们实际应用场景中，一般不会采用随机的节点进行反熵，而是需要可以的设计一个闭环。这样的话，我们能够在一个确定的时间范围内实现各个节点数据的最终一致性，而不是基于随机的概率。像 InfluxDB 就是这样来实现反熵的。</p>\n<p></p>\n<ol>\n<li>节点 A 推送数据给节点 B，节点 B 获取到节点 A 中的最新数据。</li>\n<li>节点 B 推送数据给 C，节点 C 获取到节点 A，B 中的最新数据。</li>\n<li>节点 C 推送数据给 A，节点 A 获取到节点 B，C 中的最新数据。</li>\n<li>节点 A 再推送数据给 B 形成闭环，这样节点 B 就获取到节点 C 中的最新数据。</li>\n</ol>\n<p>虽然反熵很简单实用，但是，节点过多或者节点动态变化的话，反熵就不太适用了。这个时候，我们想要实现最终一致性就要靠 **谣言传播(Rumor mongering) ** 。</p>\n<h3> 谣言传播(Rumor mongering)</h3>\n<p>谣言传播指的是分布式系统中的一个节点一旦有了新数据之后，就会变为活跃节点，活跃节点会周期性地联系其他节点向其发送新数据，直到所有的节点都存储了该新数据。</p>\n<p>如下图所示（下图来自于<a href=\"https://managementfromscratch.wordpress.com/2016/04/01/introduction-to-gossip/\" target=\"_blank\" rel=\"noopener noreferrer\">INTRODUCTION TO GOSSIP</a> 这篇文章）：</p>\n<p>![Gossip 传播示意图](./images/gossip/gossip-rumor- mongering.gif)</p>\n<p>伪代码如下：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20210605170707933.png\" alt=\"\"></p>\n<p>谣言传播比较适合节点数量比较多的情况，不过，这种模式下要尽量避免传播的信息包不能太大，避免网络消耗太大。</p>\n<h3> 总结</h3>\n<ul>\n<li>反熵（Anti-Entropy）会传播节点的所有数据，而谣言传播（Rumor-Mongering）只会传播节点新增的数据。</li>\n<li>我们一般会给反熵设计一个闭环。</li>\n<li>谣言传播（Rumor-Mongering）比较适合节点数量比较多或者节点动态变化的场景。</li>\n</ul>\n<h2> Gossip 协议优势和缺陷</h2>\n<p><strong>优势：</strong></p>\n<p>1、相比于其他分布式协议/算法来说，Gossip 协议理解起来非常简单。</p>\n<p>2、能够容忍网络上节点的随意地增加或者减少，宕机或者重启，因为 Gossip 协议下这些节点都是平等的，去中心化的。新增加或者重启的节点在理想情况下最终是一定会和其他节点的状态达到一致。</p>\n<p>3、速度相对较快。节点数量比较多的情况下，扩散速度比一个主节点向其他节点传播信息要更快（多播）。</p>\n<p><strong>缺陷</strong> :</p>\n<p>1、消息需要通过多个传播的轮次才能传播到整个网络中，因此，必然会出现各节点状态不一致的情况。毕竟，Gossip 协议强调的是最终一致，至于达到各个节点的状态一致需要多长时间，谁也无从得知。</p>\n<p>2、由于拜占庭将军问题，不允许存在恶意节点。</p>\n<p>3、可能会出现消息冗余的问题。由于消息传播的随机性，同一个节点可能会重复收到相同的消息。</p>\n<h2> 总结</h2>\n<ul>\n<li>Gossip 协议是一种允许在分布式系统中共享状态的通信协议，通过这种通信协议，我们可以将信息传播给网络或集群中的所有成员。</li>\n<li>Gossip 协议被 Redis 、Apache Cassandra、Consul 等项目应用。</li>\n<li>谣言传播（Rumor-Mongering）比较适合节点数量比较多或者节点动态变化的场景。</li>\n</ul>\n<h2> 参考</h2>\n<ul>\n<li>一万字详解 Redis Cluster Gossip 协议：https://segmentfault.com/a/1190000038373546</li>\n<li>《分布式协议与算法实战》</li>\n<li>《Redis 设计与实现》</li>\n</ul>\n",
      "date_published": "2022-03-18T08:28:37.000Z",
      "date_modified": "2022-03-20T10:59:37.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": []
    },
    {
      "title": "Java 优质开源大数据项目",
      "url": "https://javaguide.cn/open-source-project/big-data.html",
      "id": "https://javaguide.cn/open-source-project/big-data.html",
      "summary": "Spark :Spark 是用于大规模数据处理的统一分析引擎。 Flink ：Apache Flink 是一个框架和分布式处理引擎，用于在无边界和有边界数据流上进行有状态的计算。Flink 能在所有常见集群环境中运行，并能以内存速度和任意规模进行计算。 HBase： HBase – Hadoop Database，是一个高可靠性、高性能、面向列、可伸缩的分布式存储系统，利用 HBase 技术可在廉价 PC Server 上搭建起大规模结构化存储集群。 Flume :Apache Flume 是一个分布式的、可靠的、可用的，从多种不同的源收集、聚集、移动大量日志数据到集中数据存储的系统。 Storm : 一个分布式，高容错的实时计算系统。",
      "content_html": "<ul>\n<li><strong><a href=\"https://github.com/apache/spark\" target=\"_blank\" rel=\"noopener noreferrer\">Spark</a></strong> :Spark 是用于大规模数据处理的统一分析引擎。</li>\n<li><strong><a href=\"https://github.com/apache/flink\" title=\"flink\" target=\"_blank\" rel=\"noopener noreferrer\">Flink</a></strong> ：Apache Flink 是一个框架和分布式处理引擎，用于在<em>无边界和有边界</em>数据流上进行有状态的计算。Flink 能在所有常见集群环境中运行，并能以内存速度和任意规模进行计算。</li>\n<li><strong><a href=\"https://hbase.apache.org/\" target=\"_blank\" rel=\"noopener noreferrer\">HBase</a></strong>： HBase – Hadoop Database，是一个高可靠性、高性能、面向列、可伸缩的分布式存储系统，利用 HBase 技术可在廉价 PC Server 上搭建起大规模结构化存储集群。</li>\n<li><strong><a href=\"https://flume.apache.org/\" target=\"_blank\" rel=\"noopener noreferrer\">Flume</a></strong> :Apache Flume 是一个分布式的、可靠的、可用的，从多种不同的源收集、聚集、移动大量日志数据到集中数据存储的系统。</li>\n<li><strong><a href=\"https://storm.apache.org/\" target=\"_blank\" rel=\"noopener noreferrer\">Storm</a></strong> : 一个分布式，高容错的实时计算系统。</li>\n</ul>\n",
      "date_published": "2022-03-13T10:57:39.000Z",
      "date_modified": "2022-07-14T02:57:46.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "开源项目"
      ]
    },
    {
      "title": "Java 优质开源机器学习项目",
      "url": "https://javaguide.cn/open-source-project/machine-learning.html",
      "id": "https://javaguide.cn/open-source-project/machine-learning.html",
      "summary": "Deeplearning4j ： Deeplearning4j 是第一个为 Java 和 Scala 编写的商业级，开源，分布式深度学习库。 Smile ：基于 Java 和 Scala 的机器学习库。",
      "content_html": "<ul>\n<li><strong><a href=\"https://github.com/eclipse/deeplearning4j\" target=\"_blank\" rel=\"noopener noreferrer\">Deeplearning4j</a></strong> ： Deeplearning4j 是第一个为 Java 和 Scala 编写的商业级，开源，分布式深度学习库。</li>\n<li><strong><a href=\"https://github.com/haifengl/smile\" target=\"_blank\" rel=\"noopener noreferrer\">Smile</a></strong> ：基于 Java 和 Scala 的机器学习库。</li>\n</ul>\n<p>相关阅读：<a href=\"https://www.infoq.cn/article/GA9UeYlv8ohBzBso9eph\" target=\"_blank\" rel=\"noopener noreferrer\">Java 能用于机器学习和数据科学吗？-InfoQ</a></p>\n",
      "date_published": "2022-03-13T10:57:39.000Z",
      "date_modified": "2022-07-14T02:57:46.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "开源项目"
      ]
    },
    {
      "title": "Java 优质开源实战项目",
      "url": "https://javaguide.cn/open-source-project/practical-project.html",
      "id": "https://javaguide.cn/open-source-project/practical-project.html",
      "summary": "博客/论坛系统 下面这几个项目都是非常适合 Spring Boot 初学者学习的，下面的大部分项目的总体代码架构我都看过，个人觉得还算不错，不会误导没有实际做过项目的朋友。 forest ：下一代的知识社区系统，可以自定义专题和作品集。后端基于 SpringBoot + Shrio + MyBatis + JWT + Redis，前端基于 Vue + NuxtJS + Element-UI。 vhr ：微人事是一个前后端分离的人力资源管理系统，项目采用 SpringBoot+Vue 开发。 favorites-web :云收藏 Spring Boot 2.X 开源项目。云收藏是一个使用 Spring Boot 构建的开源网站，可以让用户在线随时随地收藏的一个网站，在网站上分类整理收藏的网站或者文章。 community ：开源论坛、问答系统，现有功能提问、回复、通知、最新、最热、消除零回复功能。功能持续更新中…… 技术栈 Spring、Spring Boot、MyBatis、MySQL/H2、Bootstrap。 VBlog ：V 部落，Vue+SpringBoot 实现的多用户博客管理平台! My-Blog ： My Blog 是由 SpringBoot + Mybatis + Thymeleaf 等技术实现的 Java 博客系统，页面美观、功能齐全、部署简单及完善的代码，一定会给使用者无与伦比的体验。",
      "content_html": "<h2> 博客/论坛系统</h2>\n<p>下面这几个项目都是非常适合 Spring Boot 初学者学习的，下面的大部分项目的总体代码架构我都看过，个人觉得还算不错，不会误导没有实际做过项目的朋友。</p>\n<ul>\n<li><strong><a href=\"https://github.com/rymcu\" target=\"_blank\" rel=\"noopener noreferrer\">forest</a></strong> ：下一代的知识社区系统，可以自定义专题和作品集。后端基于 SpringBoot + Shrio + MyBatis + JWT + Redis，前端基于 Vue + NuxtJS + Element-UI。</li>\n<li><strong><a href=\"https://github.com/lenve/vhr\" title=\"vhr\" target=\"_blank\" rel=\"noopener noreferrer\">vhr</a></strong> ：微人事是一个前后端分离的人力资源管理系统，项目采用 SpringBoot+Vue 开发。</li>\n<li><strong><a href=\"https://github.com/cloudfavorites/favorites-web\" target=\"_blank\" rel=\"noopener noreferrer\">favorites-web</a></strong> :云收藏 Spring Boot 2.X 开源项目。云收藏是一个使用 Spring Boot 构建的开源网站，可以让用户在线随时随地收藏的一个网站，在网站上分类整理收藏的网站或者文章。</li>\n<li><strong><a href=\"https://github.com/codedrinker/community\" target=\"_blank\" rel=\"noopener noreferrer\">community</a></strong> ：开源论坛、问答系统，现有功能提问、回复、通知、最新、最热、消除零回复功能。功能持续更新中…… 技术栈 Spring、Spring Boot、MyBatis、MySQL/H2、Bootstrap。</li>\n<li><strong><a href=\"https://github.com/lenve/VBlog\" target=\"_blank\" rel=\"noopener noreferrer\">VBlog</a></strong> ：V 部落，Vue+SpringBoot 实现的多用户博客管理平台!</li>\n<li><strong><a href=\"https://github.com/ZHENFENG13/My-Blog\" target=\"_blank\" rel=\"noopener noreferrer\">My-Blog</a></strong> ： My Blog 是由 SpringBoot + Mybatis + Thymeleaf 等技术实现的 Java 博客系统，页面美观、功能齐全、部署简单及完善的代码，一定会给使用者无与伦比的体验。</li>\n</ul>\n<h2> 考试/刷题系统</h2>\n<ul>\n<li><strong><a href=\"https://gitee.com/mindskip/uexam\" target=\"_blank\" rel=\"noopener noreferrer\">uexam</a></strong> ：一个非常不错的考试系统！考试系统应用场景还挺多的，不论是对于在校大学生还是已经工作的小伙伴，并且，类似的私活也有很多。相关阅读：<a href=\"http://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s%3F__biz%3DMzg2OTA0Njk0OA%3D%3D%26mid%3D2247491585%26idx%3D1%26sn%3D8d3c6768c22e72d6bfcbeee9624886a7%26chksm%3Dcea1afcaf9d626dc918760289c37025ad526f6255786bc198d2402203df64c873ad7934f58df%26scene%3D178%26cur_album_id%3D1345382825083895808%23rd\" target=\"_blank\" rel=\"noopener noreferrer\">《好一个 Spring Boot 开源在线考试系统！解决了我的燃眉之急》</a> 。</li>\n<li><strong><a href=\"https://github.com/Jackson0714/PassJava-Platform\" target=\"_blank\" rel=\"noopener noreferrer\">PassJava-Platform</a></strong> ：一个基于微服务(SpringBoot、Spring Cloud)的面试刷题系统！相关阅读：<a href=\"http://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s%3F__biz%3DMzg2OTA0Njk0OA%3D%3D%26mid%3D2247497045%26idx%3D1%26sn%3D577175bfd6c040a0df5a494fce6f9758%26chksm%3Dcea1ba9ef9d633883a2e213c0fb9a88bdc87051347d4b3fad2c2befb65d8b16e1ea81d8146dd%26scene%3D178%26cur_album_id%3D1345382825083895808%23rd\" target=\"_blank\" rel=\"noopener noreferrer\">《一个基于 Spring Cloud 的面试刷题系统。面试、毕设、项目经验一网打尽》</a>。</li>\n</ul>\n<p>相关文章：<a href=\"https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247491191&amp;idx=1&amp;sn=fd5efa645c2f2e09f088f6a018cea028&amp;chksm=cea251bcf9d5d8aac8653c686b7a331ffe4e13aa9ffc9beab2c378ea2497a9bd3295ff8d2c51&amp;token=747074901&amp;lang=zh_CN#rd\" target=\"_blank\" rel=\"noopener noreferrer\">想要搭建个人博客？我调研了 100 来个 Java 开源博客系统，发现这 5 个最好用！</a></p>\n<h2> 商城系统</h2>\n<p>下面的商城系统大多比较复杂比如 mall ,如果没有 Java 基础和 Spring Boot 都还没有摸熟的话不推荐过度研究下面几个项目或者使用这些项目当作毕业设计。</p>\n<ul>\n<li><strong><a href=\"https://github.com/macrozheng/mall\" title=\"mall\" target=\"_blank\" rel=\"noopener noreferrer\">mall</a></strong> ：mall 项目是一套电商系统，包括前台商城系统及后台管理系统，基于 SpringBoot+MyBatis 实现。</li>\n<li><strong><a href=\"https://github.com/macrozheng/mall-swarm\" title=\"mall-swarm\" target=\"_blank\" rel=\"noopener noreferrer\">mall-swarm</a></strong> : mall-swarm 是一套微服务商城系统，采用了 Spring Cloud Greenwich、Spring Boot 2、MyBatis、Docker、Elasticsearch 等核心技术，同时提供了基于 Vue 的管理后台方便快速搭建系统。</li>\n<li><strong><a href=\"https://github.com/YunaiV/onemall\" target=\"_blank\" rel=\"noopener noreferrer\">onemall</a></strong> ：mall 商城，基于微服务的思想，构建在 B2C 电商场景下的项目实战。核心技术栈，是 Spring Boot + Dubbo 。未来，会重构成 Spring Cloud Alibaba 。</li>\n<li><strong><a href=\"https://github.com/linlinjava/litemall\" title=\"litemall\" target=\"_blank\" rel=\"noopener noreferrer\">litemall</a></strong> ： 又一个小商城。litemall = Spring Boot 后端 + Vue 管理员前端 + 微信小程序用户前端 + Vue 用户移动端。</li>\n<li><strong><a href=\"https://github.com/Exrick/xmall\" target=\"_blank\" rel=\"noopener noreferrer\">xmall</a></strong> :基于 SOA 架构的分布式电商购物商城 前后端分离 前台商城:Vue 全家桶 后台管理系统:Spring/Dubbo/SSM/Elasticsearch/Redis/MySQL/ActiveMQ/Shiro/Zookeeper 等</li>\n<li><strong><a href=\"https://github.com/newbee-ltd/newbee-mall\" target=\"_blank\" rel=\"noopener noreferrer\">newbee-mall</a></strong> :newbee-mall 项目（新蜂商城）是一套电商系统，包括 newbee-mall 商城系统及 newbee-mall-admin 商城后台管理系统，基于 Spring Boot 2.X 及相关技术栈开发。</li>\n</ul>\n<h2> 权限管理系统</h2>\n<p>权限管理系统在企业级的项目中一般都是非常重要的，如果你需求去实际了解一个不错的权限系统是如何设计的话，推荐你可以参考下面这些开源项目。</p>\n<ul>\n<li><strong><a href=\"https://github.com/wxiaoqi/Spring-Cloud-Admin\" title=\"Spring-Cloud-Admin\" target=\"_blank\" rel=\"noopener noreferrer\">Spring-Cloud-Admin</a></strong> ：Cloud-Admin 是国内首个基于 Spring Cloud 微服务化开发平台，具有统一授权、认证后台管理系统，其中包含具备用户管理、资源权限管理、网关 API 管理等多个模块，支持多业务系统并行开发，可以作为后端服务的开发脚手架。代码简洁，架构清晰，适合学习和直接项目中使用。核心技术采用 Spring Boot2 以及 Spring Cloud Gateway 相关核心组件，前端采用 vue-element-admin 组件。</li>\n<li><strong><a href=\"https://gitee.com/log4j/pig\" title=\"pig\" target=\"_blank\" rel=\"noopener noreferrer\">pig</a></strong>：（gitee）基于 Spring Boot 2.2、 Spring Cloud Hoxton &amp; Alibaba、 OAuth2 的 RBAC 权限管理系统。</li>\n<li><strong><a href=\"https://github.com/wuyouzhuguli/FEBS-Shiro\" title=\"FEBS-Shiro\" target=\"_blank\" rel=\"noopener noreferrer\">FEBS-Shiro</a></strong> ：Spring Boot 2.1.3，Shiro1.4.0 &amp; Layui 2.5.4 权限管理系统。</li>\n<li><strong><a href=\"https://github.com/elunez/eladmin\" target=\"_blank\" rel=\"noopener noreferrer\">eladmin</a></strong> : 项目基于 Spring Boot 2.1.0 、 Jpa、 Spring Security、redis、Vue 的前后端分离的后台管理系统，项目采用分模块开发方式， 权限控制采用 RBAC，支持数据字典与数据权限管理，支持一键生成前后端代码，支持动态路由。</li>\n<li><strong><a href=\"https://github.com/Heeexy/SpringBoot-Shiro-Vue\" target=\"_blank\" rel=\"noopener noreferrer\">SpringBoot-Shiro-Vue</a></strong> ：提供一套基于 Spring Boot-Shiro-Vue 的权限管理思路.前后端都加以控制,做到按钮/接口级别的权限。</li>\n</ul>\n<h2> 快速开发脚手架</h2>\n<ul>\n<li><strong><a href=\"https://gitee.com/y_project/RuoYi\" target=\"_blank\" rel=\"noopener noreferrer\">RuoYi</a></strong> ：RuoYi 一款基于基于 SpringBoot 的权限管理系统 易读易懂、界面简洁美观，直接运行即可用 。</li>\n<li><strong><a href=\"https://github.com/valarchie/AgileBoot-Back-End\" target=\"_blank\" rel=\"noopener noreferrer\">AgileBoot-Back-End</a></strong> ：基于Ruoyi做了大量重构优化的基础快速开发框架。采用Springboot + Vue 3 + Mybatis Plus + 更面向对象的业务建模 + 面向生产的项目。（非玩具项目）</li>\n<li><strong><a href=\"https://github.com/YunaiV/ruoyi-vue-pro\" target=\"_blank\" rel=\"noopener noreferrer\">RuoYi-Vue-Pro</a></strong> ： 基于 SpringBoot，Spring Security，JWT，Vue &amp; Element 的前后端分离权限管理系统。</li>\n<li><strong><a href=\"https://gitee.com/stylefeng/guns\" target=\"_blank\" rel=\"noopener noreferrer\">Guns</a></strong> ： 我在上大学的时候就了解和接触过了这个项目，当时我还是一个 Spring 入门不太久的小菜鸟。一晃，不经意间已经过去快 3 年了。Guns 功能齐全 ，采用主流框架 Spring Boot2.0+开发，并且支持 Spring Cloud Alibaba 微服务）。 适合企业后台管理网站的快速开发场景，不论是对于单体和微服务都有支持。</li>\n<li><strong><a href=\"https://github.com/jhipster/generator-jhipster\" target=\"_blank\" rel=\"noopener noreferrer\">JHipster</a></strong> :开源应用程序平台，可在几秒钟内创建 Spring Boot + Angular / React 项目！</li>\n<li><strong><a href=\"https://github.com/zhangdaiscott/jeecg-boot\" target=\"_blank\" rel=\"noopener noreferrer\">JeecgBoot</a></strong>：一款基于代码生成器的 J2EE 低代码快速开发平台，支持生成前后端分离架构的项目。</li>\n<li><strong><a href=\"https://github.com/zuihou/zuihou-admin-cloud\" target=\"_blank\" rel=\"noopener noreferrer\">zuihou-admin-cloud</a></strong> :基于<code>SpringCloud(Hoxton.SR7)</code> + <code>SpringBoot(2.2.9.RELEASE)</code> 的 SaaS 型微服务快速开发平台，具备用户管理、资源权限管理、网关统一鉴权、Xss 防跨站攻击、自动代码生成、多存储系统、分布式事务、分布式定时任务等多个模块，支持多业务系统并行开发， 支持多服务并行开发，可以作为后端服务的开发脚手架。</li>\n<li><strong><a href=\"https://gitee.com/erupt/erupt\" target=\"_blank\" rel=\"noopener noreferrer\">Erupt</a></strong> : 使用 Java 注解，快速开发 Admin 管理后台。零前端代码、零 CURD、不生成任何代码、自动建表、注解式 API，支持所有主流数据库，支持自定义页面，支持多数据源，提供二十几类业务组件，十几种展示形式，支持逻辑删除，动态定时任务，前端后端分离等。 核心技术：Spring Boot、JPA、Reflect、TypeScript、NG-ZORRO 等。</li>\n<li><strong><a href=\"https://gitee.com/lab1024/smart-admin\" target=\"_blank\" rel=\"noopener noreferrer\">SmartAdmin</a></strong> : 互联网企业级的通用型中后台解决方案！使用最前沿的前后台技术栈 SpringBoot 和 Vue，前后端分离!代码质量非常高！</li>\n<li><strong><a href=\"https://github.com/ballcat-projects/ballcat\" target=\"_blank\" rel=\"noopener noreferrer\">BallCat</a></strong> ：一个功能完善的快速开发脚手架！除了最基本的权限管理，定时任务功能之外，还额外支持 XSS 过滤，SQL 防注入、数据脱敏等多种功能</li>\n</ul>\n<p><strong>相关阅读</strong> ：</p>\n<ul>\n<li><a href=\"https://sourl.cn/cFyLTR\" target=\"_blank\" rel=\"noopener noreferrer\">听说你要接私活？Guide 连夜整理了 5 个开源免费的 Java 项目快速开发脚手架。</a></li>\n<li><a href=\"https://sourl.cn/StkiAv\" target=\"_blank\" rel=\"noopener noreferrer\">解放双手，再来推荐 5 个 Java 项目开发快速开发脚手架！项目经验和私活都不愁了！</a></li>\n</ul>\n<h2> 造轮子</h2>\n<ul>\n<li><strong><a href=\"https://github.com/Snailclimb/guide-rpc-framework\" target=\"_blank\" rel=\"noopener noreferrer\">guide-rpc-framework</a></strong> ：一款基于 Netty+Kyro+Zookeeper 实现的自定义 RPC 框架-附详细实现过程和相关教程。</li>\n<li><strong><a href=\"https://github.com/DerekYRC/mini-spring\" target=\"_blank\" rel=\"noopener noreferrer\">mini-spring</a></strong> ：简化版的 Spring 框架，能帮助你快速熟悉 Spring 源码和掌握 Spring 的核心原理。代码极度简化，保留了 Spring 的核心功能，如 IoC 和 AOP、资源加载器等核心功能。</li>\n<li><strong><a href=\"https://github.com/DerekYRC/mini-spring-cloud\" target=\"_blank\" rel=\"noopener noreferrer\">mini-spring-cloud</a></strong> ：一个手写的简化版的 Spring Cloud，旨在帮助你快速熟悉 Spring Cloud 源码及掌握其核心原理。相关阅读：<a href=\"https://mp.weixin.qq.com/s/v3FUp-keswE2EhcTaLpSMQ\" target=\"_blank\" rel=\"noopener noreferrer\">手写一个简化版的 Spring Cloud！</a> 。</li>\n<li><strong><a href=\"https://github.com/fuzhengwei/itstack-demo-jvm\" target=\"_blank\" rel=\"noopener noreferrer\">itstack-demo-jvm</a></strong> ：通过 Java 代码来实现 JVM 的基础功能（搜索解析 class 文件、字节码命令、运行时数据区等。相关阅读：<a href=\"https://zachaxy.github.io/tags/JVM/\" target=\"_blank\" rel=\"noopener noreferrer\">《zachaxy 的手写 JVM 系列》</a></li>\n<li><strong><a href=\"https://github.com/alchemystar/Freedom\" target=\"_blank\" rel=\"noopener noreferrer\">Freedom</a></strong> ：自己 DIY 一个具有 ACID 的数据库。相关项目：<a href=\"https://github.com/CN-GuoZiyang/MYDB\" target=\"_blank\" rel=\"noopener noreferrer\">MYDB</a>（一个简单的数据库实现）、<a href=\"https://github.com/erikgrinaker/toydb\" target=\"_blank\" rel=\"noopener noreferrer\">toyDB</a>（Rust 实现的分布式 SQL 数据库）。</li>\n<li><strong><a href=\"https://github.com/stateIs0/lu-raft-kv\" target=\"_blank\" rel=\"noopener noreferrer\">lu-raft-kv</a></strong> ：一个 Java 版本的 Raft(CP) KV 分布式存储实现，非常适合想要深入学习 Raft 协议的小伙伴研究。lu-raft-kv 已经实现了 Raft 协议其中的两个核心功能：leader 选举和日志复制。如果你想要学习这个项目的话，建议你提前看一下作者写的项目介绍，比较详细，地址：http://thinkinjava.cn/2019/01/12/2019/2019-01-12-lu-raft-kv/ 。</li>\n</ul>\n",
      "date_published": "2022-03-13T10:57:39.000Z",
      "date_modified": "2023-02-17T05:40:22.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "开源项目"
      ]
    },
    {
      "title": "Java 开源项目精选",
      "url": "https://javaguide.cn/open-source-project/",
      "id": "https://javaguide.cn/open-source-project/",
      "summary": "这是一则或许对你有用的小广告 👉 欢迎准备 Java 面试以及学习 Java 的同学加入我的知识星球，干货很多！收费虽然是白菜价，但星球里的内容或许比你参加上万的培训班质量还要高。 👉 《Java 面试指北》持续更新完善中！这是一份教你如何更高效地准备面试的小册，涵盖常见八股文（系统设计、常见框架、分布式、高并发 ......）、优质面经等内容。",
      "content_html": "<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">这是一则或许对你有用的小广告</p>\n<p>👉 欢迎准备 Java 面试以及学习 Java 的同学加入我的<a href=\"/about-the-author/zhishixingqiu-two-years.html\" target=\"blank\">知识星球</a>，干货很多！收费虽然是白菜价，但星球里的内容或许比你参加上万的培训班质量还要高。</p>\n<p>👉 <a href=\"/zhuanlan/java-mian-shi-zhi-bei.html\" target=\"blank\">《Java 面试指北》</a>持续更新完善中！这是一份教你如何更高效地准备面试的小册，涵盖常见八股文（系统设计、常见框架、分布式、高并发 ......）、优质面经等内容。</p>\n</div>\n<p>精选 Github 和 Gitee 上优质的 Java 开源项目.</p>\n<p>欢迎大家在项目 <a href=\"https://github.com/CodingDocs/awesome-java/issues\" target=\"_blank\" rel=\"noopener noreferrer\">issues 区</a>推荐自己认可的 Java 开源项目，让我们共同维护一个优质的 Java 开源项目精选集！</p>\n<ul>\n<li>Github 地址：<a href=\"https://github.com/CodingDocs/awesome-java\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/CodingDocs/awesome-java</a></li>\n<li>Gitee 地址：<a href=\"https://gitee.com/SnailClimb/awesome-java\" target=\"_blank\" rel=\"noopener noreferrer\">https://gitee.com/SnailClimb/awesome-java</a></li>\n</ul>\n<p>如果内容对你有帮助的话，欢迎给本项目点个 Star。我会用我的业余时间持续完善这份名单，感谢！</p>\n<p>另外，我的公众号还会定期分享优质开源项目，每一期我都会精选 5 个高质量的 Java 开源项目。</p>\n<p>目前已经更新到了第 16 期：</p>\n<ol>\n<li><a href=\"http://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247515383&amp;idx=1&amp;sn=ba7244020c05d966b483d8c302d54e85&amp;chksm=cea1f33cf9d67a2a111bcf6cadc3cc1c44828ba2302cd3e13bbd88349e43d4254808e6434133&amp;scene=21#wechat_redirect\" target=\"_blank\" rel=\"noopener noreferrer\">一款基于 Spring Boot + Vue 的一站式开源持续测试平台</a>。</li>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247515981&amp;idx=1&amp;sn=e4b9c06af65f739bdcdf76bdc35d59f6&amp;chksm=cea1f086f9d679908bd6604b1c42d67580160d9789951f3707ad2f5de4d97aa72121d8fe777e&amp;token=435278690&amp;lang=zh_CN&amp;scene=21#wechat_redirect\" target=\"_blank\" rel=\"noopener noreferrer\">用 Java 写个沙盒塔防游戏！已上架 Steam,Apple Store</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247516459&amp;idx=1&amp;sn=a86fefe083fa91c83638243d75500a04&amp;chksm=cea1cee0f9d647f69237357e869f52e0903afad62f365e18b04ff1851aeb4c80c8d31a488fee&amp;scene=21&amp;cur_album_id=1345382825083895808#wechat_redirect\" target=\"_blank\" rel=\"noopener noreferrer\">一款基于 Java 的可视化 HTTP API 接口开发神器</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247518215&amp;idx=1&amp;sn=91e467f39322d2e7979b85fe235822d2&amp;chksm=cea1c7ccf9d64edaf966c95923d72d337bf5e655a773a3d295d65fc92e4535ae5d8b0e6d9d86&amp;token=660789642&amp;lang=zh_CN#rd\" target=\"_blank\" rel=\"noopener noreferrer\">一款对业务代码无侵入的可视化 Java 进程管理平台</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247519466&amp;idx=1&amp;sn=0dd412d5220444b37a1101f77ccdc65d&amp;chksm=cea1c321f9d64a376ef7de329b5c91e593a32c7a8e5c179b7ab3619296feea35939deb1f6a3f&amp;scene=178&amp;cur_album_id=1345382825083895808#rd\" target=\"_blank\" rel=\"noopener noreferrer\">一个比 Spring 更轻量级的 Web 框架！！！微软、红帽都在用</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247519972&amp;idx=1&amp;sn=f03c67e6e24eda2ccf703c8a9bc8c8f8&amp;chksm=cea1c12ff9d6483943f409e5ab50b773b5750b63d00950805fa340a67ad7b52ee74ff6651043&amp;scene=178&amp;cur_album_id=1345382825083895808#rd\" target=\"_blank\" rel=\"noopener noreferrer\">轻量！Google 开源了一个简易版 Spring ！</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247520633&amp;idx=1&amp;sn=aec35af40e3ed3b1e844addd04e31af5&amp;chksm=cea1deb2f9d657a46a0684bbcbcb2900cebff39a2b2746a4a809b6b5306bce08d4382efd5ca8&amp;scene=178&amp;cur_album_id=1345382825083895808#rd\" target=\"_blank\" rel=\"noopener noreferrer\">一款跨时代的高性能 Java 框架！启动速度快到飞起</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/kRgqHt73ZJGFQ2XmKG4PXw\" target=\"_blank\" rel=\"noopener noreferrer\">Spring Boot+MyBatis Plus+JWT 问卷系统！开源！</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/v3FUp-keswE2EhcTaLpSMQ\" target=\"_blank\" rel=\"noopener noreferrer\">手写一个简化版的 Spring Cloud！</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/CCzsX3Sn2Q3vhuBDEmRTlw\" target=\"_blank\" rel=\"noopener noreferrer\">这个 SpringBoot+ Vue 开源博客系统太酷炫了！</a></li>\n<li><a href=\"https://mp.weixin.qq.com/mp/appmsgalbum?__biz=Mzg2OTA0Njk0OA==&amp;action=getalbum&amp;album_id=1345382825083895808&amp;scene=173&amp;from_msgid=2247530323&amp;from_itemidx=1&amp;count=3&amp;nolastread=1#wechat_redirect\" target=\"_blank\" rel=\"noopener noreferrer\">手写一个简易版数据库！项目经验稳了</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/Ecjm801RpS34Mhj02bIOsQ\" target=\"_blank\" rel=\"noopener noreferrer\">一款强大的快速开发脚手架，前后端分离，干掉 70% 重复工作！</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247530783&amp;idx=1&amp;sn=c9fdc0c71e2fc95d88ba954291b07e29&amp;chksm=cea136d4f9d6bfc2931a18a42f7bd9903503963e8a85a318adcce579614c0831b1881be3267d&amp;token=1811572747&amp;lang=zh_CN#rd\" target=\"_blank\" rel=\"noopener noreferrer\">手写一个入门级编译器！YYDS！</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/vfPSXtOgefwonbnP53KlOQ\" target=\"_blank\" rel=\"noopener noreferrer\">8.8k star，这可能是我见过最强的开源支付系统！！</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/esaivn2z_66CcrRJlDYLEA\" target=\"_blank\" rel=\"noopener noreferrer\">31.2k！这是我见过最强的后台管理系统 ！！</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/6-TnCHUMEIFWQVl-pIWBOA\" target=\"_blank\" rel=\"noopener noreferrer\">14.3k star，这是我见过最强的第三方登录工具库！！</a></li>\n</ol>\n<p>推荐你在我的公众号“<strong>JavaGuide</strong>”回复“<strong>开源</strong>”在线阅读<a href=\"https://mp.weixin.qq.com/mp/appmsgalbum?__biz=Mzg2OTA0Njk0OA==&amp;action=getalbum&amp;album_id=1345382825083895808&amp;scene=173&amp;from_msgid=2247516459&amp;from_itemidx=1&amp;count=3&amp;nolastread=1#wechat_redirect\" target=\"_blank\" rel=\"noopener noreferrer\">「优质开源项目推荐」</a>系列。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/open-source-project/image-20220512211235432.png\" alt=\"“JavaGuide”公众号回复“开源”\"></p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/books167598cd2e17b8ec.png\" alt=\"我的公众号\"></p>\n",
      "image": "https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/open-source-project/image-20220512211235432.png",
      "date_published": "2022-03-13T10:57:39.000Z",
      "date_modified": "2023-02-27T01:50:14.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "开源项目"
      ]
    },
    {
      "title": "Java 优质开源系统设计项目",
      "url": "https://javaguide.cn/open-source-project/system-design.html",
      "id": "https://javaguide.cn/open-source-project/system-design.html",
      "summary": "基础框架 Spring Boot ：Spring Boot 可以轻松创建独立的生产级基于 Spring 的应用程序,内置 web 服务器让你可以像运行普通 Java 程序一样运行项 目。另外，大部分 Spring Boot 项目只需要少量的配置即可，这有别于 Spring 的重配置。 Javalin ：一个轻量级的 Web 框架，同时支持 Java 和 Kotlin，被微软、红帽、Uber等公司使用。 Quarkus : 用于编写 Java 应用程序的云原生和容器优先的框架。 Guice ：Google 开源的一个轻量级依赖注入框架，相当于一个功能极简化的轻量级 Spring Boot。在某些情况下非常实用，就比如说我们的项目只需要使用依赖注入，不需要 AOP 等功能特性。 SOFABoot ：SOFABoot 基于 Spring Boot ，不过在其基础上增加了 Readiness Check，类隔离，日志空间隔离等等能力。 配套提供的还有：SOFARPC（RPC 框架）、SOFABolt（基于 Netty 的远程通信框架）、SOFARegistry（注册中心）...详情请参考：SOFAStack 。 Spring Batch : Spring Batch 是一个轻量级但功能又十分全面的批处理框架，主要用于批处理场景比如从数据库、文件或队列中读取大量记录。不过，需要注意的是：Spring Batch 不是调度框架。商业和开源领域都有许多优秀的企业调度框架比如 Quartz、XXL-JOB、Elastic-Job。它旨在与调度程序一起工作，而不是取代调度程序。更多介绍请参考 Spring Batch 官方文档，入门教程可以参考 Spring Batch 从入门到实战。",
      "content_html": "<h2> 基础框架</h2>\n<ul>\n<li><strong><a href=\"https://github.com/spring-projects/spring-boot\" title=\"spring-boot\" target=\"_blank\" rel=\"noopener noreferrer\">Spring Boot </a></strong> ：Spring Boot 可以轻松创建独立的生产级基于 Spring 的应用程序,内置 web 服务器让你可以像运行普通 Java 程序一样运行项 目。另外，大部分 Spring Boot 项目只需要少量的配置即可，这有别于 Spring 的重配置。</li>\n<li><strong><a href=\"https://github.com/tipsy/javalin\" target=\"_blank\" rel=\"noopener noreferrer\">Javalin</a></strong> ：一个轻量级的 Web 框架，同时支持 Java 和 Kotlin，被微软、红帽、Uber等公司使用。</li>\n<li><strong><a href=\"https://github.com/quarkusio/quarkus\" target=\"_blank\" rel=\"noopener noreferrer\">Quarkus</a></strong> : 用于编写 Java 应用程序的云原生和容器优先的框架。</li>\n<li><strong><a href=\"https://github.com/google/guice\" target=\"_blank\" rel=\"noopener noreferrer\">Guice</a></strong> ：Google 开源的一个轻量级依赖注入框架，相当于一个功能极简化的轻量级 Spring Boot。在某些情况下非常实用，就比如说我们的项目只需要使用依赖注入，不需要 AOP 等功能特性。</li>\n<li><strong><a href=\"https://github.com/sofastack/sofa-boot\" target=\"_blank\" rel=\"noopener noreferrer\">SOFABoot</a></strong> ：SOFABoot 基于 Spring Boot ，不过在其基础上增加了 Readiness Check，类隔离，日志空间隔离等等能力。 配套提供的还有：SOFARPC（RPC 框架）、SOFABolt（基于 Netty 的远程通信框架）、SOFARegistry（注册中心）...详情请参考：<a href=\"https://github.com/sofastack\" target=\"_blank\" rel=\"noopener noreferrer\">SOFAStack </a> 。</li>\n<li><a href=\"https://github.com/spring-projects/spring-batch\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Spring Batch</strong></a> : Spring Batch 是一个轻量级但功能又十分全面的批处理框架，主要用于批处理场景比如从数据库、文件或队列中读取大量记录。不过，需要注意的是：<strong>Spring Batch 不是调度框架</strong>。商业和开源领域都有许多优秀的企业调度框架比如 Quartz、XXL-JOB、Elastic-Job。它旨在与调度程序一起工作，而不是取代调度程序。更多介绍请参考 <a href=\"https://docs.spring.io/spring-batch/docs/4.3.x/reference/html/spring-batch-intro.html#spring-batch-intro\" target=\"_blank\" rel=\"noopener noreferrer\">Spring Batch 官方文档</a>，入门教程可以参考 <a href=\"https://mrbird.cc/Spring-Batch%E5%85%A5%E9%97%A8.html\" target=\"_blank\" rel=\"noopener noreferrer\">Spring Batch 从入门到实战</a>。</li>\n</ul>\n<h2> 数据库</h2>\n<h3> 数据库连接池</h3>\n<ul>\n<li><strong><a href=\"https://github.com/alibaba/druid\" target=\"_blank\" rel=\"noopener noreferrer\">Druid</a></strong> : 阿里巴巴数据库事业部出品，为监控而生的数据库连接池。</li>\n<li><strong><a href=\"https://github.com/brettwooldridge/HikariCP\" target=\"_blank\" rel=\"noopener noreferrer\">HikariCP</a></strong> : 一个可靠的高性能 JDBC 连接池。Springboot 2.0 选择 HikariCP 作为默认数据库连接池。</li>\n</ul>\n<h3> 数据库框架</h3>\n<ul>\n<li><strong><a href=\"https://github.com/baomidou/mybatis-plus\" target=\"_blank\" rel=\"noopener noreferrer\">MyBatis-Plus</a></strong> : <a href=\"https://github.com/baomidou/mybatis-plus\" target=\"_blank\" rel=\"noopener noreferrer\">MyBatis-Plus</a>（简称 MP）是一个 <a href=\"http://www.mybatis.org/mybatis-3/\" target=\"_blank\" rel=\"noopener noreferrer\">MyBatis</a> 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。</li>\n<li><strong><a href=\"https://github.com/redisson/redisson\" title=\"redisson\" target=\"_blank\" rel=\"noopener noreferrer\">Redisson</a></strong> ： Redis 基础上的一个 Java 驻内存数据网格（In-Memory Data Grid）,支持超过 30 个对象和服务:<code>Set</code>,<code>SortedSet</code>, <code>Map</code>, <code>List</code>, <code>Queue</code>, <code>Deque</code> ......，并且提供了多种分布式锁的实现。更多介绍请看：<a href=\"https://github.com/redisson/redisson/wiki/Redisson%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D\" title=\"Redisson项目介绍\" target=\"_blank\" rel=\"noopener noreferrer\">《Redisson 项目介绍》</a>。</li>\n</ul>\n<h3> 数据同步</h3>\n<ul>\n<li><strong><a href=\"https://github.com/alibaba/canal\" title=\"canal\" target=\"_blank\" rel=\"noopener noreferrer\">Canal</a></strong> [kə'næl] : Canal 译意为水道/管道/沟渠，主要用途是基于 MySQL 数据库增量日志解析，提供增量数据订阅和消费。</li>\n<li><strong><a href=\"https://github.com/alibaba/DataX\" title=\"DataX\" target=\"_blank\" rel=\"noopener noreferrer\">DataX</a></strong> ：DataX 是阿里巴巴集团内被广泛使用的离线数据同步工具/平台，实现包括 MySQL、Oracle、SqlServer、Postgre、HDFS、Hive、ADS、HBase、TableStore(OTS)、MaxCompute(ODPS)、DRDS 等各种异构数据源之间高效的数据同步功能。相关项目：<strong><a href=\"https://github.com/WeiYe-Jing/datax-web\" target=\"_blank\" rel=\"noopener noreferrer\">DataX-Web</a></strong> （DataX 集成可视化页面，选择数据源即可一键生成数据同步任务）。</li>\n</ul>\n<p>其他：<strong><a href=\"https://github.com/DTStack/flinkx\" target=\"_blank\" rel=\"noopener noreferrer\">Flinkx</a></strong> （基于 Flink 的分布式数据同步工具）。</p>\n<h3> 时序数据库</h3>\n<ul>\n<li><strong><a href=\"https://github.com/apache/iotdb\" target=\"_blank\" rel=\"noopener noreferrer\">IoTDB</a></strong> ：一款 Java 语言编写的国产时序数据库，为用户提供数据收集、存储和分析等服务。与 Hadoop、Spark 和可视化工具(如 Grafana)无缝集成，满足了工业 IoT 领域中海量数据存储、高吞吐量数据写入和复杂数据查询分析的需求。</li>\n<li><strong><a href=\"https://github.com/kairosdb/kairosdb\" target=\"_blank\" rel=\"noopener noreferrer\">KairosDB</a></strong> ：一个基于 Cassandra 的快速分布式可扩展时间序列数据库。</li>\n</ul>\n<h2> 搜索引擎</h2>\n<ul>\n<li><strong><a href=\"https://github.com/elastic/elasticsearch\" title=\"elasticsearch\" target=\"_blank\" rel=\"noopener noreferrer\">Elasticsearch</a></strong> （推荐）：开源，分布式，RESTful 搜索引擎。</li>\n<li><strong><a href=\"https://lucene.apache.org/solr/\" target=\"_blank\" rel=\"noopener noreferrer\">Solr</a></strong> : Solr（读作“solar”）是 Apache Lucene 项目的开源企业搜索平台。</li>\n</ul>\n<h2> 认证授权</h2>\n<ul>\n<li><strong><a href=\"https://github.com/Wechat-Group/WxJava\" target=\"_blank\" rel=\"noopener noreferrer\">WxJava</a></strong> : WxJava （微信开发 Java SDK），支持包括微信支付、开放平台、小程序、企业微信/企业号和公众号等的后端开发。</li>\n<li><strong><a href=\"https://github.com/dromara/sa-token\" target=\"_blank\" rel=\"noopener noreferrer\">Sa-Token</a></strong> ：轻量级 Java 权限认证框架。支持认证授权、单点登录、踢人下线、自动续签等功能。</li>\n<li><strong><a href=\"https://github.com/justauth/JustAuth\" target=\"_blank\" rel=\"noopener noreferrer\">JustAuth</a></strong> ：小而全而美的第三方登录开源组件。目前已经集成了诸如：Github、Gitee、支付宝、新浪微博、微信、Google、Facebook、Twitter、StackOverflow 等国内外数十家第三方平台。</li>\n</ul>\n<h2> 网络通讯</h2>\n<ul>\n<li><strong><a href=\"https://github.com/netty/netty\" target=\"_blank\" rel=\"noopener noreferrer\">Netty</a></strong> : 一个基于 NIO 的 client-server(客户端服务器)框架，使用它可以快速简单地开发网络应用程序。</li>\n<li><strong><a href=\"https://github.com/square/retrofit\" target=\"_blank\" rel=\"noopener noreferrer\">Retrofit</a></strong> ：适用于 Android 和 Java 的类型安全的 HTTP 客户端。Retrofit 的 HTTP 请求使用的是 <a href=\"https://square.github.io/okhttp/\" target=\"_blank\" rel=\"noopener noreferrer\">OkHttp</a> 库（一款被广泛使用网络框架）。</li>\n<li><strong><a href=\"https://gitee.com/dromara/forest\" target=\"_blank\" rel=\"noopener noreferrer\">Forest</a></strong> ：轻量级 HTTP 客户端 API 框架，让 Java 发送 HTTP/HTTPS 请求不再难。它比 OkHttp 和 HttpClient 更高层，是封装调用第三方 restful api client 接口的好帮手，是 retrofit 和 feign 之外另一个选择。</li>\n<li><strong><a href=\"https://github.com/YeautyYE/netty-websocket-spring-boot-starter\" target=\"_blank\" rel=\"noopener noreferrer\">netty-websocket-spring-boot-starter</a></strong> :帮助你在 Spring Boot 中使用 Netty 来开发 WebSocket 服务器，并像 spring-websocket 的注解开发一样简单。</li>\n</ul>\n<h2> 测试</h2>\n<p>为了能让我们编写的系统更加健壮，必要的测试（UI 测试、单元测试...）是必须的。</p>\n<h3> 测试框架</h3>\n<ul>\n<li><strong><a href=\"http://junit.org/\" target=\"_blank\" rel=\"noopener noreferrer\">JUnit</a></strong> : Java 测试框架。</li>\n<li><strong><a href=\"https://github.com/mockito/mockito\" target=\"_blank\" rel=\"noopener noreferrer\">Mockito</a></strong> ：Mockito 是一个模拟测试框架，可以让你用优雅，简洁的接口写出漂亮的单元测试。（对那些不容易构建的对象用一个虚拟对象来代替，使其在调试期间用来作为真实对象的替代品）</li>\n<li><strong><a href=\"https://github.com/powermock/powermock\" target=\"_blank\" rel=\"noopener noreferrer\">PowerMock</a></strong> ： 编写单元测试仅靠 Mockito 是不够。因为 Mockito 无法 mock 私有方法、final 方法及静态方法等。PowerMock 这个 framework，主要是为了扩展其他 mock 框架，如 Mockito、EasyMock。它使用一个自定义的类加载器，纂改字节码，突破 Mockito 无法 mock 静态方法、构造方法、final 类、final 方法以及私有方法的限制。</li>\n<li><strong><a href=\"https://github.com/tomakehurst/wiremock\" target=\"_blank\" rel=\"noopener noreferrer\">WireMock</a></strong> ：模拟 HTTP 服务的工具（Mock your APIs）。</li>\n<li><strong><a href=\"https://github.com/testcontainers/testcontainers-java\" target=\"_blank\" rel=\"noopener noreferrer\">Testcontainers</a></strong> ：一个支持 JUnit 的测试工具库，提供轻量级的且一次性的常见数据库测试支持、Selenium Web 浏览器或者其他任何可以在 Docker 容器中运行的实例支持。</li>\n</ul>\n<p>相关阅读：</p>\n<ul>\n<li><a href=\"https://martinfowler.com/articles/practical-test-pyramid.html\" target=\"_blank\" rel=\"noopener noreferrer\">The Practical Test Pyramid- Martin Fowler</a> (很赞的一篇文章，不过是英文的)</li>\n<li><a href=\"https://juejin.im/post/6844903982058618894\" target=\"_blank\" rel=\"noopener noreferrer\">浅谈测试之 PowerMock</a></li>\n</ul>\n<h3> 测试平台</h3>\n<ul>\n<li><strong><a href=\"https://github.com/metersphere/metersphere\" target=\"_blank\" rel=\"noopener noreferrer\">MeterSphere</a></strong> : 一站式开源持续测试平台，涵盖测试跟踪、接口测试、性能测试、团队协作等功能，全面兼容 JMeter、Postman、Swagger 等开源、主流标准。</li>\n<li><strong><a href=\"https://www.apifox.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">Apifox</a></strong> ：API 文档、API 调试、API Mock、API 自动化测试。</li>\n</ul>\n<h3> API 调试</h3>\n<ul>\n<li><strong><a href=\"https://insomnia.rest/\" target=\"_blank\" rel=\"noopener noreferrer\">Insomnia</a></strong> :像人类而不是机器人一样调试 API。我平时经常用的，界面美观且轻量，总之很喜欢。</li>\n<li><strong><a href=\"https://www.getpostman.com/\" target=\"_blank\" rel=\"noopener noreferrer\">Postman</a></strong> ：API 请求生成器。</li>\n<li><strong><a href=\"https://github.com/liyasthomas/postwoman\" title=\"postwoman\" target=\"_blank\" rel=\"noopener noreferrer\">Postwoman</a></strong> ：API 请求生成器-一个免费、快速、漂亮的 Postma 替代品。</li>\n</ul>\n<h2> 任务调度</h2>\n<ul>\n<li><strong><a href=\"https://github.com/quartz-scheduler/quartz\" target=\"_blank\" rel=\"noopener noreferrer\">Quartz</a></strong> ：一个很火的开源任务调度框架，Java 定时任务领域的老大哥或者说参考标准， 很多其他任务调度框架都是基于 <code>quartz</code> 开发的，比如当当网的<code>elastic-job</code>就是基于<code>quartz</code>二次开发之后的分布式调度解决方案</li>\n<li><strong><a href=\"https://github.com/xuxueli/xxl-job\" target=\"_blank\" rel=\"noopener noreferrer\">XXL-JOB</a></strong> :XXL-JOB 是一个分布式任务调度平台，其核心设计目标是开发迅速、学习简单、轻量级、易扩展。现已开放源代码并接入多家公司线上产品线，开箱即用。</li>\n<li><strong><a href=\"http://elasticjob.io/index_zh.html\" target=\"_blank\" rel=\"noopener noreferrer\">Elastic-Job</a></strong> ：Elastic-Job 是当当网开源的一个基于 Quartz 和 Zookeeper 的分布式调度解决方案，由两个相互独立的子项目 Elastic-Job-Lite 和 Elastic-Job-Cloud 组成，一般我们只要使用 Elastic-Job-Lite 就好。</li>\n<li><strong><a href=\"https://github.com/analysys/EasyScheduler\" title=\"EasyScheduler\" target=\"_blank\" rel=\"noopener noreferrer\">EasyScheduler</a></strong> （已经更名为 DolphinScheduler，已经成为 Apache 孵化器项目）： Easy Scheduler 是一个分布式工作流任务调度系统，主要解决“复杂任务依赖但无法直接监控任务健康状态”的问题。Easy Scheduler 以 DAG 方式组装任务，可以实时监控任务的运行状态。同时，它支持重试，重新运行等操作... 。</li>\n<li><strong><a href=\"https://gitee.com/KFCFans/PowerJob\" target=\"_blank\" rel=\"noopener noreferrer\">PowerJob</a></strong> ：新一代分布式任务调度与计算框架，支持 CRON、API、固定频率、固定延迟等调度策略，提供工作流来编排任务解决依赖关系，使用简单，功能强大，文档齐全，欢迎各位接入使用！http://www.powerjob.tech/ 。</li>\n<li><strong><a href=\"https://github.com/apache/dolphinscheduler\" target=\"_blank\" rel=\"noopener noreferrer\">DolphinScheduler</a></strong> ：分布式易扩展的可视化工作流任务调度平台。</li>\n</ul>\n<p>相关阅读：</p>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/jqN4noo5NazckPCehWFgpA\" target=\"_blank\" rel=\"noopener noreferrer\">Spring Job、Quartz、XXL-Job 对比+全解析</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247518215&amp;idx=1&amp;sn=91e467f39322d2e7979b85fe235822d2&amp;chksm=cea1c7ccf9d64edaf966c95923d72d337bf5e655a773a3d295d65fc92e4535ae5d8b0e6d9d86&amp;token=2063686030&amp;lang=zh_CN#rd\" target=\"_blank\" rel=\"noopener noreferrer\">推荐 5 个 YYDS 的 Java 项目</a></li>\n</ul>\n<h2> 分布式</h2>\n<h3> API 网关</h3>\n<p>微服务下一个系统被拆分为多个服务，但是像 安全认证，流量控制，日志，监控等功能是每个服务都需要的，没有网关的话，我们就需要在每个服务中单独实现，这使得我们做了很多重复的事情并且没有一个全局的视图来统一管理这些功能。</p>\n<p>综上：<strong>一般情况下，网关一般都会提供请求转发、安全认证（身份/权限认证）、流量控制、负载均衡、容灾、日志、监控这些功能。</strong></p>\n<p>上面介绍了这么多功能实际上网关主要做了一件事情：<strong>请求过滤</strong> 。权限校验、流量控制这些都可以通过过滤器实现，请求转也是通过过滤器实现的。</p>\n<ol>\n<li><strong><a href=\"https://github.com/Kong/kong\" title=\"kong\" target=\"_blank\" rel=\"noopener noreferrer\">Kong</a></strong> ：Kong 是一个云原生、快速的、可伸缩的分布式微服务抽象层(也称为 API 网关、API 中间件或在某些情况下称为服务网格)。2015 年作为开源项目发布，其核心价值是高性能和可扩展性。</li>\n<li><strong><a href=\"https://github.com/Dromara/soul\" title=\"soul\" target=\"_blank\" rel=\"noopener noreferrer\">Soul</a></strong> ：高性能、基于 webflux 的反应式 Java API 网关</li>\n<li><strong><a href=\"https://github.com/spring-cloud/spring-cloud-gateway\" target=\"_blank\" rel=\"noopener noreferrer\">Spring Cloud Gateway</a></strong> : 基于 Spring Framework 5.x 和 Spring Boot 2.x 构建的高性能网关。</li>\n<li><strong><a href=\"https://github.com/Netflix/zuul\" target=\"_blank\" rel=\"noopener noreferrer\">Zuul</a></strong> : Zuul 是一个 L7 应用程序网关，它提供了动态路由，监视，弹性，安全性等功能。</li>\n</ol>\n<h3> 配置中心</h3>\n<ul>\n<li><strong><a href=\"https://github.com/ctripcorp/apollo\" title=\"apollo\" target=\"_blank\" rel=\"noopener noreferrer\">Apollo</a></strong>（推荐） ：Apollo（阿波罗）是携程框架部门研发的分布式配置中心，能够集中化管理应用不同环境、不同集群的配置，配置修改后能够实时推送到应用端，并且具备规范的权限、流程治理等特性，适用于微服务配置管理场景。</li>\n<li><strong><a href=\"https://github.com/alibaba/nacos\" target=\"_blank\" rel=\"noopener noreferrer\">Nacos</a></strong>（推荐）：Nacos 是 Spring Cloud Alibaba 提供的服务注册发现组件，类似于 Consul、Eureka。并且，提供了分布式配置管理功能。</li>\n<li><strong><a href=\"https://github.com/spring-cloud/spring-cloud-config\" target=\"_blank\" rel=\"noopener noreferrer\">Spring Cloud Config</a></strong> ： Spring Cloud Config 是 Spring Cloud 家族中最早的配置中心，虽然后来又发布了 Consul 可以代替配置中心功能，但是 Config 依然适用于 Spring Cloud 项目，通过简单的配置即可实现功能。</li>\n<li><strong><a href=\"https://github.com/hashicorp/consul\" target=\"_blank\" rel=\"noopener noreferrer\">Consul</a></strong> ：Consul 是 HashiCorp 公司推出的开源软件，提供了微服务系统中的服务治理、配置中心、控制总线等功能。这些功能中的每一个都可以根据需要单独使用，也可以一起使用以构建全方位的服务网格，总之 Consul 提供了一种完整的服务网格解决方案。</li>\n</ul>\n<h3> 链路追踪</h3>\n<p>目前分布式链路追踪系统基本都是根据谷歌的《Dapper 大规模分布式系统的跟踪系统》这篇论文发展而来，主流的有 Pinpoint，Skywalking ，CAT（当然也有其他的例如 Zipkin，Jaeger 等产品，不过总体来说不如前面选取的 3 个完成度高）等。</p>\n<ol>\n<li><strong><a href=\"https://github.com/apache/skywalking\" title=\"skywalking\" target=\"_blank\" rel=\"noopener noreferrer\">Skywalking</a></strong> : 针对分布式系统的应用性能监控，尤其是针对微服务、云原生和面向容器的分布式系统架构。</li>\n<li><strong><a href=\"https://github.com/openzipkin/zipkin\" title=\"zipkin\" target=\"_blank\" rel=\"noopener noreferrer\">Zipkin</a></strong> ：Zipkin 是一个分布式跟踪系统。它有助于收集解决服务体系结构中的延迟问题所需的时序数据。功能包括该数据的收集和查找。</li>\n<li><strong><a href=\"https://github.com/dianping/cat\" title=\"cat\" target=\"_blank\" rel=\"noopener noreferrer\">CAT</a></strong> ： CAT 作为服务端项目基础组件，提供了 Java, C/C++, Node.js, Python, Go 等多语言客户端，已经在美团点评的基础架构中间件框架（MVC 框架，RPC 框架，数据库框架，缓存框架等，消息队列，配置系统等）深度集成，为美团点评各业务线提供系统丰富的性能指标、健康状况、实时告警等。</li>\n</ol>\n<p>相关阅读： <a href=\"https://skywalking.apache.org/zh/blog/2019-03-29-introduction-of-skywalking-and-simple-practice.html\" target=\"_blank\" rel=\"noopener noreferrer\">Skywalking 官网对于主流开源链路追踪系统的对比</a></p>\n<h2> 高性能</h2>\n<h3> 多线程</h3>\n<ul>\n<li><strong><a href=\"https://github.com/opengoofy/hippo4j\" target=\"_blank\" rel=\"noopener noreferrer\">Hippo-4J</a></strong> ：一款强大的动态线程池框架，解决了传统线程池使用存在的一些痛点比如线程池参数没办法动态修改、不支持运行时变量的传递、无法执行优雅关闭。除了支持动态修改线程池参数、线程池任务传递上下文，还支持通知报警、运行监控等开箱即用的功能。</li>\n<li><strong><a href=\"https://github.com/dromara/dynamic-tp\" target=\"_blank\" rel=\"noopener noreferrer\">Dynamic Tp</a></strong> ：轻量级动态线程池，内置监控告警功能，集成三方中间件线程池管理，基于主流配置中心（已支持Nacos、Apollo，Zookeeper、Consul、Etcd，可通过SPI自定义实现）。</li>\n<li><strong><a href=\"https://gitee.com/jd-platform-opensource/asyncTool\" target=\"_blank\" rel=\"noopener noreferrer\">asyncTool</a></strong> : 京东的一位大佬开源的多线程工具库，里面大量使用到了 <code>CompletableFuture</code> ，可以解决任意的多线程并行、串行、阻塞、依赖、回调的并行框架，可以任意组合各线程的执行顺序，带全链路执行结果回调。</li>\n</ul>\n<h3> 缓存</h3>\n<ul>\n<li><strong><a href=\"https://github.com/ben-manes/caffeine\" target=\"_blank\" rel=\"noopener noreferrer\">Caffeine</a></strong> : 一款强大的本地缓存解决方案，性能非常 🐂。</li>\n<li><strong><a href=\"https://github.com/redis/redis\" target=\"_blank\" rel=\"noopener noreferrer\">Redis</a></strong> ：一个使用 C 语言开发的内存数据库，分布式缓存首选。</li>\n</ul>\n<h3> 消息队列</h3>\n<p><strong>分布式队列</strong> ：</p>\n<ol>\n<li><strong><a href=\"https://github.com/apache/rocketmq\" title=\"RocketMQ\" target=\"_blank\" rel=\"noopener noreferrer\">RocketMQ</a></strong> ：阿里巴巴开源的一款高性能、高吞吐量的分布式消息中间件。</li>\n<li><strong><a href=\"https://github.com/apache/kafka\" title=\"Kafaka\" target=\"_blank\" rel=\"noopener noreferrer\">Kafaka</a></strong>: Kafka 是一种分布式的，基于发布 / 订阅的消息系统。关于它的入门可以查看：<a href=\"https://github.com/Snailclimb/JavaGuide/blob/master/docs/system-design/data-communication/Kafka%E5%85%A5%E9%97%A8%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86.md\" title=\"Kafka入门看这一篇就够了\" target=\"_blank\" rel=\"noopener noreferrer\">Kafka 入门看这一篇就够了</a></li>\n<li><strong><a href=\"https://github.com/rabbitmq\" title=\"RabbitMQ\" target=\"_blank\" rel=\"noopener noreferrer\">RabbitMQ</a></strong> :由 erlang 开发的基于 AMQP（Advanced Message Queue 高级消息队列协议）协议实现的消息队列。</li>\n</ol>\n<p><strong>内存队列</strong> ：</p>\n<ul>\n<li><strong><a href=\"https://github.com/LMAX-Exchange/disruptor\" target=\"_blank\" rel=\"noopener noreferrer\">Disruptor</a></strong> ： Disruptor 是英国外汇交易公司 LMAX 开发的一个高性能队列，研发的初衷是解决内存队列的延迟问题（在性能测试中发现竟然与 I/O 操作处于同样的数量级）。相关阅读 ：<a href=\"https://tech.meituan.com/2016/11/18/disruptor.html\" target=\"_blank\" rel=\"noopener noreferrer\">《高性能内存队列——Disruptor》</a> 。</li>\n</ul>\n<p><strong>可视化管理工具</strong> ：</p>\n<ul>\n<li><strong><a href=\"https://github.com/obsidiandynamics/kafdrop\" target=\"_blank\" rel=\"noopener noreferrer\">Kafdrop</a></strong> : 一个用于查看 Kafka 主题和浏览消费者组的 Web UI。</li>\n<li><strong><a href=\"https://github.com/smartloli/EFAK\" target=\"_blank\" rel=\"noopener noreferrer\">EFAK</a></strong> （Eagle For Apache Kafka，以前叫做 Kafka Eagle） ：一个简单的高性能监控系统，用于对 Kafka 集群进行全面的监控和管理。</li>\n</ul>\n<h3> 数据库中间件</h3>\n<ul>\n<li><strong><a href=\"https://github.com/apache/shardingsphere\" target=\"_blank\" rel=\"noopener noreferrer\">ShardingSphere</a></strong> ：ShardingSphere 是一套开源的分布式数据库中间件解决方案组成的生态圈，它由 Sharding-JDBC、Sharding-Proxy 和 Sharding-Sidecar（计划中）这 3 款相互独立的产品组成。 他们均提供标准化的数据分片、分布式事务和数据库治理功能，可适用于如 Java 同构、异构语言、云原生等各种多样化的应用场景。中文文档：<a href=\"https://shardingsphere.apache.org/document/current/cn/overview/\" target=\"_blank\" rel=\"noopener noreferrer\">https://shardingsphere.apache.org/document/current/cn/overview/</a> 。</li>\n<li><strong><a href=\"https://github.com/MyCatApache/MyCat2\" target=\"_blank\" rel=\"noopener noreferrer\">MyCat</a></strong> : MyCat 是数据库分库分表的中间件，MyCat 使用最多的两个功能是：读写分离和分库分表。MyCat 是一些社区爱好者在阿里 Cobar 的基础上进行二次开发，解决了 Cobar 当时存 在的一些问题，并且加入了许多新的功能在其中。</li>\n<li><strong><a href=\"https://github.com/baomidou/dynamic-datasource-spring-boot-starter\" target=\"_blank\" rel=\"noopener noreferrer\">dynamic-datasource-spring-boot-starter</a></strong> ：dynamic-datasource-spring-boot-starter 是一个基于 springboot 的快速集成多数据源的启动器。如果说你有配置多数据源、读写分离等需求的话，可以了解一下这个项目。</li>\n</ul>\n<p>相关阅读：<a href=\"https://zhuanlan.zhihu.com/p/87144535\" target=\"_blank\" rel=\"noopener noreferrer\">数据库中间件详解（精品长文）</a></p>\n<h2> 高可用</h2>\n<h3> 限流</h3>\n<p><strong>分布式限流</strong> ：</p>\n<ul>\n<li><strong><a href=\"https://github.com/alibaba/Sentinel\" target=\"_blank\" rel=\"noopener noreferrer\"> Sentinel</a></strong>（推荐）：面向分布式服务架构的高可用防护组件，主要以流量为切入点，从流量控制、熔断降级、系统自适应保护等多个维度来帮助用户保障微服务的稳定性。</li>\n<li><strong><a href=\"https://github.com/Netflix/Hystrix\" target=\"_blank\" rel=\"noopener noreferrer\">Hystrix</a></strong> ：类似于 Sentinel 。</li>\n</ul>\n<p>相关阅读：<a href=\"https://sentinelguard.io/zh-cn/blog/sentinel-vs-hystrix.html\" target=\"_blank\" rel=\"noopener noreferrer\">Sentinel 与 Hystrix 的对比</a></p>\n<p><strong>单机限流</strong> ：</p>\n<ul>\n<li><strong><a href=\"https://github.com/vladimir-bukhtoyarov/bucket4j\" target=\"_blank\" rel=\"noopener noreferrer\">Bucket4j</a></strong> ：一个非常不错的基于令牌/漏桶算法的限流库。</li>\n<li><strong><a href=\"https://github.com/resilience4j/resilience4j\" target=\"_blank\" rel=\"noopener noreferrer\">Resilience4j</a></strong> ：一个轻量级的容错组件，其灵感来自于 Hystrix。</li>\n</ul>\n<h3> 监控</h3>\n<ul>\n<li><strong><a href=\"https://github.com/codecentric/spring-boot-admin\" target=\"_blank\" rel=\"noopener noreferrer\">Spring Boot Admin</a></strong> ：管理和监控 Spring Boot 应用程序。</li>\n<li><strong><a href=\"https://github.com/dropwizard/metrics\" target=\"_blank\" rel=\"noopener noreferrer\">Metrics</a></strong> ：捕获<strong>JVM</strong>和应用程序级别的指标。所以你知道发生了什么事。</li>\n</ul>\n<h3> 日志</h3>\n<ul>\n<li><strong>EKL 老三件套</strong> : 最原始的时候，ELK 是由 3 个开源项目的首字母构成，分别是 <strong>E</strong>lasticsearch 、<strong>L</strong>ogstash、<strong>K</strong>ibana。</li>\n<li><strong>新一代 ELK 架构</strong> : Elasticsearch+Logstash+Kibana+Beats。</li>\n<li><strong>EFK</strong> : EFK 中的 F 代表的是 <a href=\"https://github.com/fluent/fluentd\" target=\"_blank\" rel=\"noopener noreferrer\">Fluentd</a>。</li>\n<li><strong><a href=\"https://gitee.com/dromara/TLog\" target=\"_blank\" rel=\"noopener noreferrer\">TLog</a></strong> ：一个轻量级的分布式日志标记追踪神器，10 分钟即可接入，自动对日志打标签完成微服务的链路追踪。</li>\n</ul>\n",
      "date_published": "2022-03-13T10:57:39.000Z",
      "date_modified": "2023-02-07T03:03:15.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "开源项目"
      ]
    },
    {
      "title": "Java 优质开源工具类库",
      "url": "https://javaguide.cn/open-source-project/tool-library.html",
      "id": "https://javaguide.cn/open-source-project/tool-library.html",
      "summary": "代码质量 lombok :使用 Lombok 我们可以简化我们的 Java 代码，比如使用它之后我们通过注释就可以实现 getter/setter、equals 等方法。 guava ：Guava 是一组核心库，其中包括新的集合类型（例如 multimap 和 multiset），不可变集合，图形库以及用于并发、I / O、哈希、原始类型、字符串等的实用程序！ p3c ：Alibaba Java Coding Guidelines pmd implements and IDE plugin。Eclipse 和 IDEA 上都有该插件，推荐使用！ arthas ： Arthas 是 Alibaba 开源的 Java 诊断工具。 sonarqube ：SonarQube 支持所有开发人员编写更干净，更安全的代码。 checkstyle :Checkstyle 是一种开发工具，可帮助程序员编写符合编码标准的 Java 代码。它使检查 Java 代码的过程自动化，从而使人们不必执行这项无聊（但很重要）的任务。这使其成为想要实施编码标准的项目的理想选择。 pmd : 可扩展的多语言静态代码分析器。 spotbugs :SpotBugs 是 FindBugs 的继任者。静态分析工具，用于查找 Java 代码中的错误。 hutool : Hutool 是一个 Java 工具包，也只是一个工具包，它帮助我们简化每一行代码，减少每一个方法，让 Java 语言也可以“甜甜的”。",
      "content_html": "<h2> 代码质量</h2>\n<ul>\n<li><strong><a href=\"https://github.com/rzwitserloot/lombok\" target=\"_blank\" rel=\"noopener noreferrer\">lombok</a></strong> :使用 Lombok 我们可以简化我们的 Java 代码，比如使用它之后我们通过注释就可以实现 getter/setter、equals 等方法。</li>\n<li><strong><a href=\"https://github.com/google/guava\" title=\"guava\" target=\"_blank\" rel=\"noopener noreferrer\">guava</a></strong> ：Guava 是一组核心库，其中包括新的集合类型（例如 multimap 和 multiset），不可变集合，图形库以及用于并发、I / O、哈希、原始类型、字符串等的实用程序！</li>\n<li><strong><a href=\"https://github.com/alibaba/p3c\" title=\"p3c\" target=\"_blank\" rel=\"noopener noreferrer\">p3c</a></strong> ：Alibaba Java Coding Guidelines pmd implements and IDE plugin。Eclipse 和 IDEA 上都有该插件，推荐使用！</li>\n<li><strong><a href=\"https://github.com/alibaba/arthas\" title=\"arthas\" target=\"_blank\" rel=\"noopener noreferrer\">arthas</a></strong> ： Arthas 是 Alibaba 开源的 Java 诊断工具。</li>\n<li><strong><a href=\"https://github.com/SonarSource/sonarqube\" title=\"sonarqube\" target=\"_blank\" rel=\"noopener noreferrer\">sonarqube</a></strong> ：SonarQube 支持所有开发人员编写更干净，更安全的代码。</li>\n<li><strong><a href=\"https://github.com/checkstyle/checkstyle\" title=\"checkstyle\" target=\"_blank\" rel=\"noopener noreferrer\">checkstyle</a></strong> :Checkstyle 是一种开发工具，可帮助程序员编写符合编码标准的 Java 代码。它使检查 Java 代码的过程自动化，从而使人们不必执行这项无聊（但很重要）的任务。这使其成为想要实施编码标准的项目的理想选择。</li>\n<li><strong><a href=\"https://github.com/pmd/pmd\" title=\"pmd\" target=\"_blank\" rel=\"noopener noreferrer\">pmd</a></strong> : 可扩展的多语言静态代码分析器。</li>\n<li><strong><a href=\"https://github.com/spotbugs/spotbugs\" title=\"spotbugs\" target=\"_blank\" rel=\"noopener noreferrer\">spotbugs</a></strong> :SpotBugs 是 FindBugs 的继任者。静态分析工具，用于查找 Java 代码中的错误。</li>\n<li><strong><a href=\"https://github.com/looly/hutool\" title=\"hutool\" target=\"_blank\" rel=\"noopener noreferrer\">hutool</a></strong> : Hutool 是一个 Java 工具包，也只是一个工具包，它帮助我们简化每一行代码，减少每一个方法，让 Java 语言也可以“甜甜的”。</li>\n</ul>\n<h2> 文档处理</h2>\n<h3> Excel</h3>\n<ul>\n<li><strong><a href=\"https://github.com/alibaba/easyexcel\" target=\"_blank\" rel=\"noopener noreferrer\">easyexcel</a></strong> :快速、简单避免 OOM 的 java 处理 Excel 工具。</li>\n</ul>\n<h3> JSON</h3>\n<ul>\n<li><strong><a href=\"https://github.com/json-path/JsonPath\" target=\"_blank\" rel=\"noopener noreferrer\">JsonPath</a></strong> ：处理 JSON 数据的工具库。</li>\n</ul>\n<h3> PDF</h3>\n<ul>\n<li><strong><a href=\"https://github.com/apache/pdfbox\" target=\"_blank\" rel=\"noopener noreferrer\">pdfbox</a></strong> :用于处理 PDF 文档的开放源码 Java 工具。该项目允许创建新的 PDF 文档、对现有文档进行操作以及从文档中提取内容。PDFBox 还包括几个命令行实用程序。PDFBox 是在 Apache 2.0 版许可下发布的。</li>\n<li><strong><a href=\"https://github.com/LibrePDF/OpenPDF\" target=\"_blank\" rel=\"noopener noreferrer\">OpenPDF</a></strong> ：OpenPDF 是一个免费的 Java 库，用于使用 LGPL 和 MPL 开源许可创建和编辑 PDF 文件。OpenPDF 基于 iText 的一个分支。</li>\n<li><strong><a href=\"https://github.com/itext/itext7\" target=\"_blank\" rel=\"noopener noreferrer\">itext7</a></strong> ：iText 7 代表了想要利用利用好 PDF 的开发人员的更高级别的 sdk。iText 7 配备了更好的文档引擎、高级和低级编程功能以及创建、编辑和增强 PDF 文档的能力，几乎对每个工作流都有好处。</li>\n<li><strong><a href=\"https://xmlgraphics.apache.org/fop/\" target=\"_blank\" rel=\"noopener noreferrer\">FOP</a></strong> :Apache FOP 项目的主要的输出目标是 PDF。</li>\n</ul>\n<h2> 验证码</h2>\n<ul>\n<li><strong><a href=\"https://gitee.com/whvse/EasyCaptcha\" target=\"_blank\" rel=\"noopener noreferrer\">EasyCaptcha</a></strong> ：Java 图形验证码，支持 gif、中文、算术等类型，可用于 Java Web、JavaSE 等项目。</li>\n<li><strong><a href=\"https://gitee.com/anji-plus/captcha\" target=\"_blank\" rel=\"noopener noreferrer\">AJ-Captcha</a></strong> ：行为验证码(滑动拼图、点选文字)，前后端(java)交互。</li>\n<li><strong><a href=\"https://gitee.com/tianai/tianai-captcha\" target=\"_blank\" rel=\"noopener noreferrer\">tianai-captcha</a></strong> ：好看又好用的滑块验证码。</li>\n</ul>\n<h2> 在线支付</h2>\n<ul>\n<li><strong><a href=\"https://gitee.com/jeequan/jeepay\" target=\"_blank\" rel=\"noopener noreferrer\">jeepay</a></strong> ：一套适合互联网企业使用的开源支付系统，已实现交易、退款、转账、分账等接口，支持服务商特约商户和普通商户接口。已对接微信，支付宝，云闪付官方接口，支持聚合码支付。</li>\n<li><strong><a href=\"https://gitee.com/YunGouOS/YunGouOS-PAY-SDK\" target=\"_blank\" rel=\"noopener noreferrer\">YunGouOS-PAY-SDK</a></strong> ：YunGouOS 微信支付接口、微信官方个人支付接口、非二维码收款，非第四方清算。个人用户可提交资料开通微信支付商户，完成对接。</li>\n<li><strong><a href=\"https://gitee.com/javen205/IJPay\" target=\"_blank\" rel=\"noopener noreferrer\">IJPay</a></strong> ：聚合支付，IJPay 让支付触手可及，封装了微信支付、QQ 支付、支付宝支付、京东支付、银联支付、PayPal 支付等常用的支付方式以及各种常用的接口。</li>\n</ul>\n<h2> 其他</h2>\n<ul>\n<li><strong><a href=\"https://github.com/oshi/oshi\" title=\"oshi\" target=\"_blank\" rel=\"noopener noreferrer\">oshi</a></strong> ：一款为 Java 语言提供的基于 JNA 的（本机）操作系统和硬件信息库。</li>\n<li><strong><a href=\"https://github.com/lionsoul2014/ip2region\" target=\"_blank\" rel=\"noopener noreferrer\">ip2region</a></strong> :最自由的 ip 地址查询库，ip 到地区的映射库，提供 Binary,B 树和纯内存三种查询算法，妈妈再也不用担心我的 ip 地址定位。</li>\n<li><strong><a href=\"https://github.com/real-logic/agrona\" target=\"_blank\" rel=\"noopener noreferrer\">agrona</a></strong> ：Java 高性能数据结构（<code>Buffers</code>、<code>Lists</code>、<code>Maps</code>、<code>Scalable Timer Wheel</code>......）和实用方法。</li>\n</ul>\n",
      "date_published": "2022-03-13T10:57:39.000Z",
      "date_modified": "2022-07-14T02:57:46.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "开源项目"
      ]
    },
    {
      "title": "Java 优质开源开发工具",
      "url": "https://javaguide.cn/open-source-project/tools.html",
      "id": "https://javaguide.cn/open-source-project/tools.html",
      "summary": "Java JADX ：一款功能强大的反编译工具。 Recaf ： Java 字节码编辑器，基于 ASM（Java 字节码操作框架） 来修改字节码，可简化编辑已编译 Java 应用程序的过程。",
      "content_html": "<h2> Java</h2>\n<ul>\n<li><strong><a href=\"https://github.com/skylot/jadx\" target=\"_blank\" rel=\"noopener noreferrer\">JADX</a></strong> ：一款功能强大的反编译工具。</li>\n<li><strong><a href=\"https://github.com/Col-E/Recaf\" target=\"_blank\" rel=\"noopener noreferrer\">Recaf</a></strong> ： Java 字节码编辑器，基于 ASM（Java 字节码操作框架） 来修改字节码，可简化编辑已编译 Java 应用程序的过程。</li>\n</ul>\n<h2> 数据库</h2>\n<h3> 数据库建模</h3>\n<ul>\n<li><strong><a href=\"https://gitee.com/robergroup/chiner\" target=\"_blank\" rel=\"noopener noreferrer\">CHINER</a></strong> ：开源免费的国产数据库建模工具。目标是做一款丰富数据库生态，独立于具体数据库之外的，数据库关系模型设计平台。前生是 <a href=\"https://gitee.com/robergroup/pdman\" target=\"_blank\" rel=\"noopener noreferrer\">PDMan</a>，定位为 PowerDesigner 的免费替代方案。</li>\n</ul>\n<p>开源的数据库建模工具比较少，以下是一些非开源的数据库建模工具（部分需要付费才能使用） :</p>\n<ul>\n<li><strong><a href=\"https://www.mysql.com/products/workbench/\" target=\"_blank\" rel=\"noopener noreferrer\">MySQL Workbench</a></strong> : MySQL 官方为数据库架构师、开发人员和 DBA 提供的一个可视化工具。 MySQL Workbench 支持数据建模，SQL 开发以及服务器配置、用户管理、性能优化、数据库备份以及迁移等功能，支持 Windows、Linux 和 Mac OS X 平台。</li>\n<li><strong><a href=\"https://www.navicat.com.cn/products/navicat-data-modeler\" target=\"_blank\" rel=\"noopener noreferrer\">Navicat Data Modeler</a></strong> : 一款强大的和符合成本效益的数据库设计工具，它能帮助用户创建高质素的概念、逻辑和物理数据模型。让你可视化地设计数据库结构、执行逆向或正向工程程序、从 ODBC 数据源导入模型、生成复杂的 SQL/DDL 和打印模型到文件等。付费。</li>\n<li><strong><a href=\"https://dbschema.com/\" target=\"_blank\" rel=\"noopener noreferrer\">DbSchema</a></strong> : 一款功能强大的数据库设计和管理的可视化工具，支持几乎所有的关系型和 NoSQL 数据库。付费。</li>\n<li><strong><a href=\"https://dbdiagram.io/home\" target=\"_blank\" rel=\"noopener noreferrer\">dbdiagram.io</a></strong> : 是一款简单免费的在线 ER 图绘制工具，通过编写代码创建模型，专为开发人员和数据分析师而设计。它通过一个简单的自定义语言来生成数据模型，支持 MySQL、PostgreSQL、SQL Server 数据库 DDL 文件的正向工程和逆向工程、版本历史、在线共享、导出图片或者 PDF 等功能。dbdiagram.io 提供了免费版。</li>\n</ul>\n<h3> 数据库管理</h3>\n<ul>\n<li><strong><a href=\"https://github.com/beekeeper-studio/beekeeper-studio\" target=\"_blank\" rel=\"noopener noreferrer\">Beekeeper Studio</a></strong> ：跨平台数据库管理工具，颜值高，支持 SQLite、MySQL、MariaDB、Postgres、CockroachDB、SQL Server、Amazon Redshift。</li>\n<li><strong><a href=\"https://github.com/sequelpro/sequelpro\" target=\"_blank\" rel=\"noopener noreferrer\">Sequel Pro</a></strong> ：适用于 macOS 的 MySQL/MariaDB 数据库管理工具。</li>\n<li><strong><a href=\"https://github.com/dbeaver/dbeaver\" target=\"_blank\" rel=\"noopener noreferrer\">DBeaver</a></strong> ：一个基于 Java 开发 ，并且支持几乎所有的数据库产品的开源数据库管理工具。DBeaver 社区版不光支持关系型数据库比如 MySQL、PostgreSQL、MariaDB、SQLite、Oracle、Db2、SQL Server，还比如 SQLite、H2 这些内嵌数据库。还支持常见的全文搜索引擎比如 Elasticsearch 和 Solr、大数据相关的工具比如 Hive 和 Spark。</li>\n<li><strong><a href=\"https://gitee.com/dbkangaroo/kangaroo\" target=\"_blank\" rel=\"noopener noreferrer\">Kangaroo</a></strong> ：袋鼠是一款为热门数据库系统打造的管理客户端(SQLite / MySQL / PostgreSQL / ...) ，支持建表、查询、模型、同步、导入导出等功能，支持 Windows / Mac / Linux 等操作系统，力求打造成好用、好玩、开发友好的 SQL 工具。</li>\n<li><strong><a href=\"https://arctype.com/\" target=\"_blank\" rel=\"noopener noreferrer\">Arctype</a></strong> ：一个桌面的数据库查询工具，可以连接各种数据库，在其中执行 SQL 语句，以可视化形式展示数据。</li>\n<li><strong><a href=\"https://github.com/RenzHoly/Mongood\" target=\"_blank\" rel=\"noopener noreferrer\">Mongood</a></strong> : MongoDB 图形化的管理工具。基于微软 Fluent UI，支持自动黑暗模式。</li>\n</ul>\n<h3> Redis</h3>\n<ul>\n<li><strong><a href=\"https://github.com/qishibo/AnotherRedisDesktopManager/blob/master/README.zh-CN.md\" target=\"_blank\" rel=\"noopener noreferrer\">Another Redis Desktop Manager</a></strong> ：更快、更好、更稳定的 Redis 桌面(GUI)管理客户端。</li>\n<li><strong><a href=\"https://github.com/ngbdf/redis-manager\" target=\"_blank\" rel=\"noopener noreferrer\">Redis Manager</a></strong> ：Redis 一站式管理平台，支持集群（cluster、master-replica、sentinel）的监控、安装（除 sentinel）、管理、告警以及基本的数据操作功能。</li>\n</ul>\n<h2> Devops</h2>\n<ul>\n<li><strong><a href=\"https://github.com/portainer/portainer\" target=\"_blank\" rel=\"noopener noreferrer\">Portainer</a></strong> ：可视化管理 Docker 和 Kubernetes。相关阅读：<a href=\"https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247504221&amp;idx=1&amp;sn=85a3c69d64fba1b0d6d8485ab28ab4c4&amp;chksm=cea19e96f9d617802920d5769bafc824b3b80afdfb6166a00532f0caa3b6f5bdac930e4e89de&amp;token=693114125&amp;lang=zh_CN#rd\" target=\"_blank\" rel=\"noopener noreferrer\">《吊炸天的 Docker 图形化工具 Portainer，必须推荐给你！》</a>。</li>\n</ul>\n<h2> ZooKeeper</h2>\n<ul>\n<li><strong><a href=\"https://github.com/vran-dev/PrettyZoo\" target=\"_blank\" rel=\"noopener noreferrer\">PrettyZoo</a></strong> ： 一个基于 Apache Curator 和 JavaFX 实现的 ZooKeeper 图形化管理客户端，颜值非常高，支持 Mac / Windows / Linux 。你可以使用 PrettyZoo 来实现对 ZooKeeper 的可视化增删改查。</li>\n<li><strong><a href=\"https://zktools.readthedocs.io/en/latest/#installing\" target=\"_blank\" rel=\"noopener noreferrer\">zktools</a></strong> ： 一个低延迟的 ZooKeeper 图形化管理客户端，颜值非常高，支持 Mac / Windows / Linux 。你可以使用 zktools 来实现对 ZooKeeper 的可视化增删改查。</li>\n</ul>\n<h2> Markdown</h2>\n<ul>\n<li><strong><a href=\"https://github.com/marktext/marktext\" target=\"_blank\" rel=\"noopener noreferrer\">MarkText</a></strong> ：一个简单而优雅的开源 Markdown 编辑器，专注于速度和可用性。Linux、macOS 和 Windows 均适用。</li>\n<li><strong><a href=\"https://www.typora.io/\" target=\"_blank\" rel=\"noopener noreferrer\">Typora</a></strong> :我一直用的一款 Markdown 工具，直接文件夹视图和目录视图，支持 Markdown 格式直接导出成 PDF、HTML 等格式。</li>\n<li><strong><a href=\"https://github.com/adam-p/markdown-here\" target=\"_blank\" rel=\"noopener noreferrer\">Markdown Here</a></strong> ：使用 Markdown 语法发邮件，并且提供多种主题，快来拯救你的邮件格式吧！</li>\n</ul>\n",
      "date_published": "2022-03-13T10:57:39.000Z",
      "date_modified": "2022-08-08T01:38:15.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "开源项目"
      ]
    },
    {
      "title": "Java 优质开源技术教程",
      "url": "https://javaguide.cn/open-source-project/tutorial.html",
      "id": "https://javaguide.cn/open-source-project/tutorial.html",
      "summary": "Java JavaGuide :【Java 学习+面试指南】 一份涵盖大部分 Java 程序员所需要掌握的核心知识。 toBeBetterJavaer ：一份通俗易懂、风趣幽默的 Java 学习指南，内容涵盖 Java 基础、Java 集合框架、Java 并发编程、JVM、Java 企业级开发（Git、SSM、Spring Boot）等知识点。 interview-guide ：总结了后端面试八股文中的重点，希望能帮助各位准备互联网开发岗校招面试的同学。 advanced-java :互联网 Java 工程师进阶知识完全扫盲：涵盖高并发、分布式、高可用、微服务、海量数据处理等领域知识。 toBeTopJavaer ：Java 工程师成神之路 。 technology-talk : 汇总 java 生态圈常用技术框架、开源中间件，系统架构、数据库、大公司架构案例、常用三方类库、项目管理、线上问题排查、个人成长、思考等知识 JCSprout :处于萌芽阶段的 Java 核心知识库。 bestJavaer : 这是一个成为更好的 Java 程序员的系列教程。 java-design-patterns ： 用 Java 实现的设计模式。",
      "content_html": "<h2> Java</h2>\n<ul>\n<li><strong><a href=\"https://github.com/Snailclimb/JavaGuide\" title=\"JavaGuide\" target=\"_blank\" rel=\"noopener noreferrer\">JavaGuide</a></strong> :【Java 学习+面试指南】 一份涵盖大部分 Java 程序员所需要掌握的核心知识。</li>\n<li><strong><a href=\"https://github.com/itwanger/toBeBetterJavaer\" target=\"_blank\" rel=\"noopener noreferrer\">toBeBetterJavaer</a></strong> ：一份通俗易懂、风趣幽默的 Java 学习指南，内容涵盖 Java 基础、Java 集合框架、Java 并发编程、JVM、Java 企业级开发（Git、SSM、Spring Boot）等知识点。</li>\n<li><strong><a href=\"https://github.com/csguide-dabai/interview-guide\" target=\"_blank\" rel=\"noopener noreferrer\">interview-guide</a></strong> ：总结了后端面试八股文中的重点，希望能帮助各位准备互联网开发岗校招面试的同学。</li>\n<li><strong><a href=\"https://github.com/doocs/advanced-java\" title=\"advanced-java\" target=\"_blank\" rel=\"noopener noreferrer\">advanced-java</a></strong> :互联网 Java 工程师进阶知识完全扫盲：涵盖高并发、分布式、高可用、微服务、海量数据处理等领域知识。</li>\n<li><strong><a href=\"https://github.com/hollischuang/toBeTopJavaer\" title=\"toBeTopJavaer\" target=\"_blank\" rel=\"noopener noreferrer\">toBeTopJavaer</a></strong> ：Java 工程师成神之路 。</li>\n<li><strong><a href=\"https://github.com/aalansehaiyang/technology-talk\" target=\"_blank\" rel=\"noopener noreferrer\">technology-talk</a></strong> : 汇总 java 生态圈常用技术框架、开源中间件，系统架构、数据库、大公司架构案例、常用三方类库、项目管理、线上问题排查、个人成长、思考等知识</li>\n<li><strong><a href=\"https://github.com/crossoverJie/JCSprout\" title=\"JCSprout\" target=\"_blank\" rel=\"noopener noreferrer\">JCSprout</a></strong> :处于萌芽阶段的 Java 核心知识库。</li>\n<li><strong><a href=\"https://github.com/crisxuan/bestJavaer\" target=\"_blank\" rel=\"noopener noreferrer\">bestJavaer</a></strong> : 这是一个成为更好的 Java 程序员的系列教程。</li>\n<li><strong><a href=\"https://github.com/iluwatar/java-design-patterns\" title=\"java-design-patterns\" target=\"_blank\" rel=\"noopener noreferrer\">java-design-patterns</a></strong> ： 用 Java 实现的设计模式。</li>\n</ul>\n<h2> 计算机基础</h2>\n<ul>\n<li><strong><a href=\"https://github.com/PKUFlyingPig/cs-self-learning\" target=\"_blank\" rel=\"noopener noreferrer\">cs-self-learning </a></strong> ：计算机自学指南，汇总欧美众多名校高质量计算机课程。</li>\n<li><strong><a href=\"https://github.com/CyC2018/CS-Notes\" title=\"CS-Notes\" target=\"_blank\" rel=\"noopener noreferrer\">CS-Notes</a></strong> ：技术面试必备基础知识、Leetcode 题解、后端面试、Java 面试、春招、秋招、操作系统、计算机网络、系统设计。</li>\n<li><strong><a href=\"https://github.com/wolverinn/Waking-Up\" target=\"_blank\" rel=\"noopener noreferrer\">Waking-Up</a></strong> ：计算机基础（计算机网络/操作系统/数据库/Git...）面试问题全面总结。</li>\n</ul>\n<h2> 系统设计</h2>\n<h3> SpringBoot</h3>\n<ul>\n<li><strong><a href=\"https://github.com/Snailclimb/springboot-guide\" target=\"_blank\" rel=\"noopener noreferrer\">springboot-guide</a></strong> ：SpringBoot 核心知识点总结。 基于 Spring Boot 2.19+。</li>\n<li><strong><a href=\"https://github.com/wuyouzhuguli/SpringAll\" title=\"SpringAll\" target=\"_blank\" rel=\"noopener noreferrer\">SpringAll</a></strong> ：循序渐进，学习 Spring Boot、Spring Boot &amp; Shiro、Spring Cloud、Spring Security &amp; Spring Security OAuth2，博客 Spring 系列源码。</li>\n<li><strong><a href=\"https://github.com/chengxy-nds/Springboot-Notebook\" target=\"_blank\" rel=\"noopener noreferrer\">Springboot-Notebook</a></strong> :一系列以 Spring Boot 为基础开发框架，整合 Redis 、 Rabbitmq 、ES 、MongoDB 、Spring Cloud、Kafka、Skywalking 等互联网主流技术，实现各种常见功能点的综合性案例。</li>\n<li><strong><a href=\"https://github.com/JeffLi1993/springboot-learning-example\" title=\"springboot-learning-example\" target=\"_blank\" rel=\"noopener noreferrer\">springboot-learning-example</a></strong> ：Spring Boot 实践学习案例，是 Spring Boot 初学者及核心技术巩固的最佳实践。</li>\n<li><strong><a href=\"https://github.com/xkcoding/spring-boot-demo\" title=\"spring-boot-demo\" target=\"_blank\" rel=\"noopener noreferrer\">spring-boot-demo</a></strong> ：spring boot demo 是一个用来深度学习并实战 spring boot 的项目，目前总共包含 63 个集成 demo，已经完成 52 个。</li>\n<li><strong><a href=\"https://github.com/YunaiV/SpringBoot-Labs\" target=\"_blank\" rel=\"noopener noreferrer\">SpringBoot-Labs</a></strong> ：Spring Boot 系列教程。</li>\n</ul>\n<p>相关文章：<a href=\"https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247488298&amp;idx=3&amp;sn=0a8fd88ec5a050de131c2a3305482ac4&amp;chksm=cea25ce1f9d5d5f7f53a0237d27489326bce4546353b038085c03b086d91ef396bf824d3a155&amp;token=496868067&amp;lang=zh_CN#rd\" target=\"_blank\" rel=\"noopener noreferrer\">Github 点赞接近 100k 的 SpringBoot 学习教程+实战推荐！牛批！</a></p>\n<h3> SpringCloud</h3>\n<ul>\n<li><strong><a href=\"https://github.com/forezp/SpringCloudLearning\" title=\"SpringCloudLearning\" target=\"_blank\" rel=\"noopener noreferrer\">SpringCloudLearning</a></strong> : 方志朋的《史上最简单的 Spring Cloud 教程源码》。</li>\n<li><strong><a href=\"https://github.com/macrozheng/springcloud-learning\" target=\"_blank\" rel=\"noopener noreferrer\">springcloud-learning</a></strong> : 一套涵盖大部分核心组件使用的 Spring Cloud 教程。</li>\n<li><strong><a href=\"https://github.com/zhoutaoo/SpringCloud\" title=\"SpringCloud\" target=\"_blank\" rel=\"noopener noreferrer\">SpringCloud</a></strong> ：基于 SpringCloud2.1 的微服务开发脚手架，整合了 spring-security-oauth2、nacos、feign、sentinel、springcloud-gateway 等。</li>\n</ul>\n<p>相关文章：<a href=\"https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247488377&amp;idx=1&amp;sn=0fb33ef330159db5a9c8bc0f029cd739&amp;chksm=cea25cb2f9d5d5a4c7bacc9dcfc90ed86e89f4262e32b40c7aa47af84c747cb6c0429f753e1d&amp;token=496868067&amp;lang=zh_CN#rd\" target=\"_blank\" rel=\"noopener noreferrer\">Github 点赞接近 70k 的 Spring Cloud 学习教程+实战项目推荐！牛批！</a></p>\n<h3> Nginx</h3>\n<ul>\n<li><strong><a href=\"https://github.com/dunwu/nginx-tutorial\" target=\"_blank\" rel=\"noopener noreferrer\">nginx-tutorial</a></strong> ：一系列 Nginx 极简教程，包含HTTP 反向代理、HTTPS 反向代理、负载均衡、静态站点、文件服务器搭建等实战内容。</li>\n</ul>\n<h2> 大数据</h2>\n<ul>\n<li><strong><a href=\"https://github.com/heibaiying/BigData-Notes\" title=\"BigData-Notes\" target=\"_blank\" rel=\"noopener noreferrer\">BigData-Notes</a></strong> :大数据入门指南 ⭐️。</li>\n<li><strong><a href=\"https://github.com/zhisheng17/flink-learning\" title=\"flink-learning\" target=\"_blank\" rel=\"noopener noreferrer\">flink-learning</a></strong> ：含 Flink 入门、概念、原理、实战、性能调优、源码解析等内容。</li>\n</ul>\n<h2> 开源书籍</h2>\n<ul>\n<li><strong><a href=\"https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual\" target=\"_blank\" rel=\"noopener noreferrer\">《Effective Java（第 3 版）》中英对照版</a></strong> ：《Effective Java（第 3 版）各章节的中英文学习参考。</li>\n<li><strong><a href=\"https://github.com/Vonng/ddia\" target=\"_blank\" rel=\"noopener noreferrer\">《DDIA（设计数据密集型应用）》中文版</a></strong> ：《Designing Data-Intensive Application》DDIA 中文翻译。</li>\n<li><strong><a href=\"https://github.com/fenixsoft/awesome-fenix\" target=\"_blank\" rel=\"noopener noreferrer\">《凤凰架构》</a></strong> ：讨论如何构建一套可靠的大型分布式系统。</li>\n<li><strong><a href=\"https://github.com/dreamhead/patterns-of-distributed-systems\" target=\"_blank\" rel=\"noopener noreferrer\">《分布式系统模式》中文版</a></strong> ：《Patterns of Distributed Systems》中文翻译。</li>\n</ul>\n",
      "date_published": "2022-03-13T10:57:39.000Z",
      "date_modified": "2022-11-03T05:02:22.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "开源项目"
      ]
    },
    {
      "title": "代码重构指南",
      "url": "https://javaguide.cn/system-design/basis/refactoring.html",
      "id": "https://javaguide.cn/system-design/basis/refactoring.html",
      "summary": "前段时间重读了《重构：改善代码既有设计》，收货颇多。于是，简单写了一篇文章来聊聊我对重构的看法。 何谓重构？ 学习重构必看的一本神书《重构：改善代码既有设计》从两个角度给出了重构的定义：",
      "content_html": "<p>前段时间重读了<a href=\"https://book.douban.com/subject/30468597/\" target=\"_blank\" rel=\"noopener noreferrer\">《重构：改善代码既有设计》</a>，收货颇多。于是，简单写了一篇文章来聊聊我对重构的看法。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/image-20220311155746549.png\" alt=\"\"></p>\n<h2> 何谓重构？</h2>\n<p>学习重构必看的一本神书《重构：改善代码既有设计》从两个角度给出了重构的定义：</p>\n<blockquote>\n<ul>\n<li>重构（名词）：对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。</li>\n<li>重构（动词）：使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构。</li>\n</ul>\n</blockquote>\n<p>用更贴近工程师的语言来说： <strong>重构就是利用设计模式(如组合模式、策略模式、责任链模式)、软件设计原则（如 SOLID 原则、YAGNI 原则、KISS 原则）和重构手段（如封装、继承、构建测试体系）来让代码更容易理解，更易于修改。</strong></p>\n<p>软件设计原则指导着我们组织和规范代码，同时，重构也是为了能够尽量设计出尽量满足软件设计原则的软件。</p>\n<p>正确重构的核心在于 <strong>步子一定要小，每一步的重构都不会影响软件的正常运行，可以随时停止重构。</strong></p>\n<p><strong>常见的设计模式如下</strong> ：</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/system-design/basis/common-design-patterns.png\" alt=\"常见的设计模式\"></p>\n<p>更全面的设计模式总结，可以看 <strong><a href=\"https://github.com/iluwatar/java-design-patterns\" target=\"_blank\" rel=\"noopener noreferrer\">java-design-patterns</a></strong> 这个开源项目。</p>\n<p><strong>常见的软件设计原则如下</strong> ：</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/system-design/basis/programming-principles .png\" alt=\"常见的软件设计原则\"></p>\n<p>更全面的设计原则总结，可以看 <strong><a href=\"https://github.com/iluwatar/java-design-patterns\" target=\"_blank\" rel=\"noopener noreferrer\">java-design-patterns</a></strong> 和 <strong><a href=\"https://github.com/nusr/hacker-laws-zh\" target=\"_blank\" rel=\"noopener noreferrer\">hacker-laws-zh</a></strong> 这两个开源项目。</p>\n<h2> 为什么要重构？</h2>\n<p>在上面介绍重构定义的时候，我从比较抽象的角度介绍了重构的好处：重构的主要目的主要是提升代码&amp;架构的灵活性/可扩展性以及复用性。</p>\n<p>如果对应到一个真实的项目，重构具体能为我们带来什么好处呢？</p>\n<ol>\n<li><strong>让代码更容易理解</strong> ： 通过添加注释、命名规范、逻辑优化等手段可以让我们的代码更容易被理解；</li>\n<li><strong>避免代码腐化</strong> ：通过重构干掉坏味道代码；</li>\n<li><strong>加深对代码的理解</strong> ：重构代码的过程会加深你对某部分代码的理解；</li>\n<li><strong>发现潜在 bug</strong> ：是这样的，很多潜在的 bug ，都是我们在重构的过程中发现的；</li>\n<li>......</li>\n</ol>\n<p>看了上面介绍的关于重构带来的好处之后，你会发现重构的最终目标是 <strong>提高软件开发速度和质量</strong> 。</p>\n<p>重构并不会减慢软件开发速度，相反，如果代码质量和软件设计较差，当我们想要添加新功能的话，开发速度会越来越慢。到了最后，甚至都有想要重写整个系统的冲动。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/bad&amp;good-design.png\" alt=\"\"></p>\n<p>《重构：改善代码既有设计》这本书中这样说：</p>\n<blockquote>\n<p>重构的唯一目的就是让我们开发更快，用更少的工作量创造更大的价值。</p>\n</blockquote>\n<h2> 何时进行重构？</h2>\n<p>重构在是开发过程中随时可以进行的，见机行事即可，并不需要单独分配一两天的时间专门用来重构。</p>\n<h3> 提交代码之前</h3>\n<p>《重构：改善代码既有设计》这本书介绍了一个 <strong>营地法则</strong> 的概念:</p>\n<blockquote>\n<p>编程时，需要遵循营地法则：保证你离开时的代码库一定比来时更健康。</p>\n</blockquote>\n<p>这个概念表达的核心思想其实很简单：在你提交代码的之前，花一会时间想一想，我这次的提交是让项目代码变得更健康了，还是更腐化了，或者说没什么变化？</p>\n<p>项目团队的每一个人只有保证自己的提交没有让项目代码变得更腐化，项目代码才会朝着健康的方向发展。</p>\n<p><strong>当我们离开营地（项目代码）的时候，请不要留下垃圾（代码坏味道）！尽量确保营地变得更干净了！</strong></p>\n<h3> 开发一个新功能之后&amp;之前</h3>\n<p>在开发一个新功能之后，我们应该回过头看看是不是有可以改进的地方。在添加一个新功能之前，我们可以思考一下自己是否可以重构代码以让新功能的开发更容易。</p>\n<p>一个新功能的开发不应该仅仅只有功能验证通过那么简单，我们还应该尽量保证代码质量。</p>\n<p>有一个两顶帽子的比喻：在我开发新功能之前，我发现重构可以让新功能的开发更容易，于是我戴上了重构的帽子。重构之后，我换回原来的帽子，继续开发新能功能。新功能开发完成之后，我又发现自己的代码难以理解，于是我又戴上了重构帽子。比较好的开发状态就是就是这样在重构和开发新功能之间来回切换。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/refractor-two-hats.png\" alt=\"refractor-two-hats\"></p>\n<h3> Code Review 之后</h3>\n<p>Code Review 可以非常有效提高代码的整体质量，它会帮助我们发现代码中的坏味道以及可能存在问题的地方。并且， Code Review 可以帮助项目团队其他程序员理解你负责的业务模块，有效避免人员方面的单点风险。</p>\n<p>经历一次 Code Review ，你的代码可能会收到很多改进建议。</p>\n<h3> 捡垃圾式重构</h3>\n<p>当我们发现坏味道代码（垃圾）的时候，如果我们不想停下手头自己正在做的工作，但又不想放着垃圾不管，我们可以这样做：</p>\n<ul>\n<li>如果这个垃圾很容易重构的话，我们可以立即重构它。</li>\n<li>如果这个垃圾不太容易重构的话，我们可以先记录下来，当完成当下的任务再回来重构它。</li>\n</ul>\n<h3> 阅读理解代码的时候</h3>\n<p>搞开发的小伙伴应该非常有体会：我们经常需要阅读项目团队中其他人写的代码，也经常需要阅读自己过去写的代码。阅读代码的时候，通常要比我们写代码的时间还要多很多。</p>\n<p>我们在阅读理解代码的时候，如果发现一些坏味道的话，我们就可以对其进行重构。</p>\n<p>就比如说你在阅读张三写的某段代码的时候，你发现这段代码逻辑过于复杂难以理解，你有更好的写法，那你就可以对张三的这段代码逻辑进行重构。</p>\n<h2> 重构有哪些注意事项？</h2>\n<h3> 单元测试是重构的保护网</h3>\n<p><strong>单元测试可以为重构提供信心，降低重构的成本。我们要像重视生产代码那样，重视单元测试。</strong></p>\n<p>另外，多提一句：持续集成也要依赖单元测试，当持续集成服务自动构建新代码之后，会自动运行单元测试来发现代码错误。</p>\n<p><strong>怎样才能算单元测试呢？</strong> 网上的定义很多，很抽象，很容易把人给看迷糊了。我觉得对于单元测试的定义主要取决于你的项目，一个函数甚至是一个类都可以看作是一个单元。就比如说我们写了一个计算个人股票收益率的方法，我们为了验证它的正确性专门为它写了一个单元测试。再比如说我们代码有一个类专门负责数据脱敏，我们为了验证脱敏是否符合预期专门为这个类写了一个单元测试。</p>\n<p><strong>单元测试也是需要重构或者修改的。</strong> <a href=\"https://book.douban.com/subject/4199741/\" target=\"_blank\" rel=\"noopener noreferrer\">《代码整洁之道:敏捷软件开发手册》</a>这本书这样写到：</p>\n<blockquote>\n<p>测试代码需要随着生产代码的演进而修改，如果测试不能保持整洁，只会越来越难修改。</p>\n</blockquote>\n<h3> 不要为了重构而重构</h3>\n<p><strong>重构一定是要为项目带来价值的！</strong> 某些情况下我们不应该进行重构：</p>\n<ul>\n<li>学习了某个设计模式/工程实践之后，不顾项目实际情况，刻意使用在项目上（避免货物崇拜编程）；</li>\n<li>项目进展比较急的时候，重构项目调用的某个 API 的底层代码（重构之后对项目调用这个 API 并没有带来什么价值）；</li>\n<li>重写比重构更容易更省事；</li>\n<li>......</li>\n</ul>\n<h3> 遵循方法</h3>\n<p>《重构：改善代码既有设计》这本书中列举除了代码常见的一些坏味道（比如重复代码、过长函数）和重构手段（如提炼函数、提炼变量、提炼类）。我们应该花时间去学习这些重构相关的理论知识，并在代码中去实践这些重构理论。</p>\n<h2> 如何练习重构？</h2>\n<p>除了可以在重构项目代码的过程中练习精进重构之外，你还可以有下面这些手段：</p>\n<ul>\n<li><a href=\"https://linesh.gitbook.io/refactoring/\" target=\"_blank\" rel=\"noopener noreferrer\">重构实战练习</a> ：通过几个小案例一步一步带你学习重构！</li>\n<li><a href=\"https://refactoringguru.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">设计模式+重构学习网站</a> ：免费在线学习代码重构、 设计模式、 SOLID 原则 （单一职责、 开闭原则、 里氏替换、 接口隔离以及依赖反转） 。</li>\n<li><a href=\"https://www.jetbrains.com/help/idea/refactoring-source-code.html#popular-refactorings\" target=\"_blank\" rel=\"noopener noreferrer\">IDEA 官方文档的代码重构教程</a> ： 教你如何使用 IDEA 进行重构。</li>\n</ul>\n<h2> 参考</h2>\n<ul>\n<li><a href=\"https://insights.thoughtworks.cn/reread-refactoring/\" target=\"_blank\" rel=\"noopener noreferrer\">再读《重构》- ThoughtWorks 洞见 - 2020</a> ：详细介绍了重构的要点比如小步重构、捡垃圾式的重构，主要是重构概念相关的介绍。</li>\n<li><a href=\"https://juejin.cn/post/6954378167947624484\" target=\"_blank\" rel=\"noopener noreferrer\">常见代码重构技巧 - VectorJin - 2021</a> ：从软件设计原则、设计模式、代码分层、命名规范等角度介绍了如何进行重构，比较偏实战。</li>\n</ul>\n",
      "image": "https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/image-20220311155746549.png",
      "date_published": "2022-03-11T08:36:59.000Z",
      "date_modified": "2023-01-26T12:18:56.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "代码质量"
      ]
    },
    {
      "title": "我的知识星球快 3 岁了！",
      "url": "https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html",
      "id": "https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html",
      "summary": "时间过的真快，知识星球我已经平稳运行了 3 年有余了！ 在 2019 年 12 月 29 号，经过了大概一年左右的犹豫期，我正式确定要开始做一个自己的星球。 截止到今天，星球已经有 1.3w+的同学加入。虽然比不上很多大佬，但这于我来说也算是小有成就了，真的很满足了！我确信自己是一个普通人，能做成这些，也不过是在兴趣和运气的加持下赶上了时代而已。",
      "content_html": "<p>时间过的真快，知识星球我已经平稳运行了 3 年有余了！</p>\n<p>在 2019 年 12 月 29 号，经过了大概一年左右的犹豫期，我正式确定要开始做一个自己的星球。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2021-1/知识新球一周年-0293.jpg\" alt=\"\"></p>\n<p>截止到今天，星球已经有 1.3w+的同学加入。虽然比不上很多大佬，但这于我来说也算是小有成就了，真的很满足了！我确信自己是一个普通人，能做成这些，也不过是在兴趣和运气的加持下赶上了时代而已。</p>\n<p><strong>我有自己的原则，不割韭菜，用心做内容，真心希望帮助到他人！</strong></p>\n<h2> 什么是知识星球？</h2>\n<p>简单来说，知识星球就是一个私密交流圈子，主要用途是知识创作者连接铁杆读者/粉丝。相比于微信群，知识星球内容沉淀、信息管理更高效。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220211223754566.png\" alt=\"\"></p>\n<h2> 我的知识星球能为你提供什么？</h2>\n<p>努力做一个最优质的 Java 面试交流星球！加入到我的星球之后，你将获得：</p>\n<ol>\n<li>6 个高质量的专栏永久阅读，内容涵盖面试，源码解析，项目实战等内容！价值远超门票！</li>\n<li>多本原创 PDF 版本面试手册。</li>\n<li>免费的简历修改服务（已经累计帮助 4000+ 位球友修改简历）。</li>\n<li>一对一免费提问交流（专属建议，走心回答）。</li>\n<li>专属求职指南和建议，帮助你逆袭大厂！</li>\n<li>海量 Java 优质面试资源分享！价值远超门票！</li>\n<li>读书交流，学习交流，让我们一起努力创造一个纯粹的学习交流社区。</li>\n<li>不定期福利：节日抽奖、送书送课、球友线下聚会等等。</li>\n<li>......</li>\n</ol>\n<p>其中的任何一项服务单独拎出来价值都远超星球门票了。</p>\n<h3> 专属专栏</h3>\n<p>星球更新了 <strong>《Java 面试指北》</strong>、<strong>《Java 必读源码系列》</strong>（目前已经整理了 Dubbo 2.6.x 、Netty 4.x、SpringBoot2.1 的源码）、 <strong>《从零开始写一个 RPC 框架》</strong>（已更新完） 、<strong>《Kafka 常见面试题/知识点总结》</strong> 等多个优质专栏。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220211231206733.png\" alt=\"\"></p>\n<p>《Java 面试指北》内容概览：</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220304102536445.png\" alt=\"\"></p>\n<h3> PDF 面试手册</h3>\n<p>免费赠送多本优质 PDF 面试手册。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220723120918434.png\" alt=\"\"></p>\n<h3> 简历修改</h3>\n<p>一到面试季，我平均一天晚上至少要看 15 ~30 份简历。过了面试季的话，找我看简历的话会稍微少一些。要不然的话，是真心顶不住！</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220304123156348.png\" alt=\"\"></p>\n<p>简单统计了一下，到目前为止，我至少帮助 <strong>4000+</strong> 位球友提供了免费的简历修改服务。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/简历修改2.jpg\" alt=\"\"></p>\n<p>我会针对每一份简历给出详细的修改完善建议，用心修改，深受好评！</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220725093504807.png\" alt=\"\"></p>\n<h3> 一对一提问</h3>\n<p>你可以和我进行一对一免费提问交流，我会很走心地回答你的问题。到目前为止，已经累计回答了 <strong>1000+</strong> 个读者的提问。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220211223559179.png\" alt=\"\"></p>\n<h3> 学习打卡</h3>\n<p>星球的学习打卡活动可以督促自己和其他球友们一起学习交流。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220308143815840.png\" alt=\"\"></p>\n<p>看球友们的打卡也能有收货，最重要的是这个学习氛围对于自己自律非常有帮助！</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/球友每日打卡也能学到很多东西.jpg\" alt=\"\"></p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/确实是学习交流的好地方.jpg\" alt=\"\"></p>\n<h3> 读书活动</h3>\n<p>定期会举办读书活动（奖励丰厚），我会带着大家一起读一些优秀的技术书籍！</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220211233642079.png\" alt=\"\"></p>\n<p>每一期读书活动的获奖率都非常非常非常高！直接超过门票价！！！</p>\n<h2> 是否收费？</h2>\n<p>星球是需要付费才能进入的。 <strong>为什么要收费呢？</strong></p>\n<ol>\n<li>维护好星球是一件费时费力的事情，每到面试季，我经常凌晨还在看简历和回答球友问题。市面上单单一次简历修改服务也至少需要 200+，而简历修改也只是我的星球提供的服务的冰山一角。除此之外，我还要抽时间写星球专属的一些专栏，单单是这些专栏的价值就远超星球门票了。</li>\n<li>星球提供的服务比较多，如果我是免费提供这些服务的话，是肯定忙不过来的。付费这个门槛可以帮我筛选出真正需要帮助的那批人。</li>\n<li>免费的东西才是最贵的，加入星球之后无任何其他需要付费的项目，统统免费！</li>\n<li>合理的收费是对我付出劳动的一种正向激励，促进我继续输出！同时，这份收入还可以让我们家人过上更好的生活。虽然累点，但也是值得的！</li>\n</ol>\n<h2> 如何加入？</h2>\n<p>两年前，星球的定价是 <strong>50/年</strong> ，这是星球的最低定价，我还附送了 33 元优惠券。扣除了星球手续费，发了各种福利之后，几乎就是纯粹做公益。</p>\n<p>感兴趣的小伙伴可以看看我在 2020-01-03 发的头条：<a href=\"https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247486049&amp;idx=1&amp;sn=e0161b409e8f164251bdaa0c83a476bc&amp;chksm=cea245aaf9d5ccbcafdb95a546d959508814085620aabdbb4385c4b8cea6e50bf157c3697041&amp;token=1614894361&amp;lang=zh_CN#rd\" target=\"_blank\" rel=\"noopener noreferrer\">做了一个很久没敢做的事情</a>，去考古一下。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220311203414600.png\" alt=\"\"></p>\n<p>随着时间推移，星球积累的干货资源越来越多，我花在星球上的时间也越来越多。于是，我将星球的定价慢慢调整为了 <strong>159/年</strong>！后续会将星球的价格调整为 <strong>199/年</strong>，想要加入的小伙伴一定要尽早。</p>\n<p><strong>这里再送一个 30 元的新人优惠券，数量有限（续费半价）。</strong></p>\n<div align=\"center\">\n    <a href=\"https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html\">\n      <img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/xingqiuyouhuijuanheyi.png\" style=\"margin: 0 auto; \">\n    </a>\n</div>\n<p><strong>进入星球之后，记得添加微信，我会发你详细的星球使用指南。</strong></p>\n<div align=\"center\">\n      <a href=\"https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html\">\n        <img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/IMG_3007.jpg\" style=\"margin: 0 auto; \">\n      </a>\n</div>\n<p><strong>真诚欢迎准备面试的小伙伴加入星球一起交流！真心希望能够帮助到更多小伙伴！</strong></p>\n",
      "image": "https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2021-1/%E7%9F%A5%E8%AF%86%E6%96%B0%E7%90%83%E4%B8%80%E5%91%A8%E5%B9%B4-0293.jpg",
      "date_published": "2022-03-08T06:04:22.000Z",
      "date_modified": "2023-03-01T06:30:18.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "知识星球"
      ]
    },
    {
      "title": "优质面经汇总(付费)",
      "url": "https://javaguide.cn/interview-preparation/interview-experience.html",
      "id": "https://javaguide.cn/interview-preparation/interview-experience.html",
      "summary": "古人云:“他山之石，可以攻玉” 。善于学习借鉴别人的面试的成功经验或者失败的教训，可以让自己少走许多弯路。 在 《Java 面试指北》 的 「面经篇」 ，我分享了 15+ 篇高质量的 Java 后端面经，有校招的，也有社招的，有大厂的，也有中小厂的。 如果你是非科班的同学，也能在这些文章中找到对应的非科班的同学写的面经。",
      "content_html": "<p>古人云:“<strong>他山之石，可以攻玉</strong>” 。善于学习借鉴别人的面试的成功经验或者失败的教训，可以让自己少走许多弯路。</p>\n<p>在 <strong><a href=\"/zhuanlan/java-mian-shi-zhi-bei.html\" target=\"blank\">《Java 面试指北》</a></strong> 的 <strong>「面经篇」</strong> ，我分享了 15+ 篇高质量的 Java 后端面经，有校招的，也有社招的，有大厂的，也有中小厂的。</p>\n<p>如果你是非科班的同学，也能在这些文章中找到对应的非科班的同学写的面经。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/githubjuejinjihua/thinkimage-20220612185810480.png\" alt=\"\"></p>\n<p>并且，<a href=\"https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html\" target=\"_blank\" rel=\"noopener noreferrer\">知识星球</a>还有专门分享面经和面试题的专题，里面会分享很多优质的面经和面试题。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220304120018731.png\" alt=\"\"></p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220628101743381.png\" alt=\"\"></p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220628101805897.png\" alt=\"\"></p>\n<p>欢迎准备 Java 面试以及学习 Java 的同学加入我的<a href=\"https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html\" target=\"_blank\" rel=\"noopener noreferrer\">知识星球</a>，干货非常多，学习氛围也很不错！收费虽然是白菜价，但星球里的内容或许比你参加上万的培训班质量还要高。</p>\n<div align=\"center\">\n  <a href=\"https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html\">\n    <img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220311203414600.png\" style=\"margin: 0 auto; \">\n  </a>\n</div>\n<p>下面是星球提供的部分服务（点击下方图片即可获取知识星球的详细介绍）：</p>\n<div align=\"center\">\n  <a href=\"https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html\">\n    <img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/xingqiufuwu.png\" style=\"margin: 0 auto; \">\n  </a>\n</div>\n<p><strong>我有自己的原则，不割韭菜，用心做内容，真心希望帮助到你！</strong></p>\n<p>如果你感兴趣的话，不妨花 3 分钟左右看看星球的详细介绍： <a href=\"https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html\" target=\"_blank\" rel=\"noopener noreferrer\">JavaGuide 知识星球详细介绍</a>。</p>\n<p>这里再送一个 30 元的新人优惠券（续费半价）。</p>\n<div align=\"center\">\n  <a href=\"https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html\">\n    <img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/xingqiuyouhuijuanheyi.png\" style=\"margin: 0 auto; \">\n  </a>\n</div>\n<p>进入星球之后，记得添加微信，我会发你详细的星球使用指南。</p>\n<div align=\"center\">\n  <a href=\"https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html\">\n    <img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/IMG_3007.jpg\" style=\"margin: 0 auto; \">\n  </a>\n</div>\n",
      "image": "https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/githubjuejinjihua/thinkimage-20220612185810480.png",
      "date_published": "2022-03-08T06:04:22.000Z",
      "date_modified": "2023-01-29T03:31:13.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "知识星球"
      ]
    },
    {
      "title": "手把手教你如何准备面试",
      "url": "https://javaguide.cn/interview-preparation/teach-you-how-to-prepare-for-the-interview-hand-in-hand.html",
      "id": "https://javaguide.cn/interview-preparation/teach-you-how-to-prepare-for-the-interview-hand-in-hand.html",
      "summary": "友情提示 本文节选自 《Java 面试指北》。这是一份教你如何更高效地准备面试的小册，涵盖常见八股文（系统设计、常见框架、分布式、高并发 ......）、优质面经等内容。 你的身边一定有很多编程比你厉害但是找的工作并没有你好的朋友！技术面试不同于编程，编程厉害不代表技术面试就一定能过。",
      "content_html": "<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">友情提示</p>\n<p>本文节选自 <strong><a href=\"/zhuanlan/java-mian-shi-zhi-bei.html\" target=\"blank\">《Java 面试指北》</a></strong>。这是一份教你如何更高效地准备面试的小册，涵盖常见八股文（系统设计、常见框架、分布式、高并发 ......）、优质面经等内容。</p>\n</div>\n<p>你的身边一定有很多编程比你厉害但是找的工作并没有你好的朋友！<strong>技术面试不同于编程，编程厉害不代表技术面试就一定能过。</strong></p>\n<p>现在你去面个试，不认真准备一下，那简直就是往枪口上撞。我们大部分都只是普通人，没有发过顶级周刊或者获得过顶级大赛奖项。在这样一个技术面试氛围下，我们需要花费很多精力来准备面试，来提高自己的技术能力。“<a href=\"https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247491596&amp;idx=1&amp;sn=36fbf80922f71c200990de11514955f7&amp;chksm=cea1afc7f9d626d1c70d5e54505495ac499ce6eb5e05ba4f4bb079a8563a84e27f17ceff38af&amp;token=353590436&amp;lang=zh_CN&amp;scene=21#wechat_redirect\" target=\"_blank\" rel=\"noopener noreferrer\">面试造火箭，工作拧螺丝钉</a>” 就是目前的一个常态，预计未来很长很长一段时间也还是会是这样。</p>\n<p>准备面试不等于耍小聪明或者死记硬背面试题。 <strong>一定不要对面试抱有侥幸心理。打铁还需自身硬！</strong> 千万不要觉得自己看几篇面经，看几篇面试题解析就能通过面试了。一定要静下心来深入学习！</p>\n<p>这篇我会从宏观面出发简单聊聊如何准备 Java 面试，让你少走弯路！</p>\n<h2> 尽早以求职为导向来学习</h2>\n<p>我是比较建议还在学校的同学尽可能早一点以求职为导向来学习的。</p>\n<p><strong>这样更有针对性，并且可以大概率减少自己处在迷茫的时间，很大程度上还可以让自己少走很多弯路。</strong></p>\n<p>但是！不要把“以求职为导向学习”理解为“我就不用学课堂上那些计算机基础课程了”！</p>\n<p>我在之前的很多次分享中都强调过：<strong>一定要用心学习计算机基础知识！操作系统、计算机组成原理、计算机网络真的不是没有实际用处的学科！！！</strong></p>\n<p>你会发现大厂面试你会用到，以后工作之后你也会用到。我分别列举 2 个例子吧！</p>\n<ul>\n<li><strong>面试中</strong> ：像字节、腾讯这些大厂的技术面试以及几乎所有公司的笔试都会考操作系统相关的问题。</li>\n<li><strong>工作中</strong> ：在实际使用缓存的时候，你会发现在操作系统中可以找到很多缓存思想的影子。比如 CPU Cache 缓存的是内存数据用于解决 CPU 处理速度和内存不匹配的问题，内存缓存的是硬盘数据用于解决硬盘访问速度过慢的问题。再比如操作系统在页表方案基础之上引入了快表来加速虚拟地址到物理地址的转换。我们可以把快表理解为一种特殊的高速缓冲存储器（Cache）。</li>\n</ul>\n<p><strong>如何求职为导向学习呢？</strong> 简答来说就是：根据招聘要求整理一份目标岗位的技能清单，然后按照技能清单去学习和提升。</p>\n<ol>\n<li>你首先搞清楚自己要找什么工作</li>\n<li>然后根据招聘岗位的要求梳理一份技能清单</li>\n<li>根据技能清单写好最终的简历</li>\n<li>最后再按照建立的要求去学习和提升。</li>\n</ol>\n<p>这其实也是 <strong>以终为始</strong> 思想的运用。</p>\n<p><strong>何为以终为始？</strong> 简单来说，以终为始就是我们可以站在结果来考虑问题，从结果出发，根据结果来确定自己要做的事情。</p>\n<p>你会发现，其实几乎任何领域都可以用到 <strong>以终为始</strong> 的思想。</p>\n<h2> 了解投递简历的黄金时间</h2>\n<p>面试之前，你肯定是先要搞清楚春招和秋招的具体时间的。</p>\n<p>正所谓金三银四，金九银十，错过了这个时间，很多公司都没有 HC 了。</p>\n<p><strong>秋招一般 7 月份就开始了，大概一直持续到 9 月底。</strong></p>\n<p><strong>春招一般 3 月份就开始了，大概一直持续到 4 月底。</strong></p>\n<p>很多公司（尤其大厂）到了 9 月中旬(秋招)/3 月中旬（春招），很可能就会没有 HC 了。面试的话一般都是至少是 3 轮起步，一些大厂比如阿里、字节可能会有 5 轮面试。<strong>面试失败话的不要紧，某一面表现差的话也不要紧，调整好心态。又不是单一选择对吧？你能投这么多企业呢! 调整心态。</strong> 今年面试的话，因为疫情原因，有些公司还是可能会还是集中在线上进行面试。然后，还是因为疫情的影响，可能会比往年更难找工作（对大厂影响较小）。</p>\n<h2> 知道如何获取招聘信息</h2>\n<p><strong>1、目标企业的官网/公众号</strong></p>\n<p>最及时最权威的获取秋招信息的途径。</p>\n<p><strong>2、招聘网站</strong></p>\n<p><a href=\"https://www.zhipin.com/\" target=\"_blank\" rel=\"noopener noreferrer\">BOSS 直聘</a>、<a href=\"https://www.zhaopin.com/\" target=\"_blank\" rel=\"noopener noreferrer\">智联招聘</a>、<a href=\"https://www.lagou.com/\" target=\"_blank\" rel=\"noopener noreferrer\">拉勾招聘</a>......。</p>\n<p><strong>3、牛客网</strong></p>\n<p>每年秋招/春招，都会有大批量的公司会到牛客网发布招聘信息，并且还会有大量的公司员工来到这里发内推的帖子。</p>\n<p>地址：https://www.nowcoder.com/jobs/recommend/campus 。</p>\n<p><strong>4、超级简历</strong></p>\n<p>超级简历目前整合了各大企业的校园招聘入口，地址：https://www.wondercv.com/jobs/。</p>\n<p>如果你是校招的话，点击“校招网申”就可以直接跳转到各大企业的校园招聘入口的整合页面了。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20210412110352612.png\" alt=\"\"></p>\n<p><strong>5、认识的朋友</strong></p>\n<p>如果你有认识的朋友在目标企业工作的话，你也可以找他们了解秋招信息，并且可以让他们帮你内推。</p>\n<p><strong>6、宣讲会现场</strong></p>\n<p>Guide 当时也参加了几场宣讲会。不过，我是在荆州上学，那边没什么比较好的学校，一般没有公司去开宣讲会。所以，我当时是直接跑到武汉来了，参加了武汉理工大学以及华中科技大学的几场宣讲会。总体感觉还是很不错的！</p>\n<p><strong>7、其他</strong></p>\n<p>校园就业信息网、学校论坛、班级 or 年级 QQ 群</p>\n<h2> 多花点时间完善简历</h2>\n<p>一定一定一定要重视简历啊！朋友们！至少要花 2~3 天时间来专门完善自己的简历。</p>\n<p>最近看了很多份简历，满意的很少，我简单拿出一份来说分析一下（欢迎在评论区补充）。</p>\n<p><strong>1.个人介绍没太多实用的信息。</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/0f02df1ce7f54aa0a8e0c5b2d23da6e9.webp?x-oss-process=image/format,png\" alt=\"\"></p>\n<p>技术博客、Github 以及在校获奖经历的话，能写就尽量写在这里。 你可以参考下面 👇 的模板进行修改：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/b9ca9f520865006ae984301f77256f12.webp?x-oss-process=image/format,png\" alt=\"\"></p>\n<p><strong>2.项目经历过于简单，完全没有质量可言</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/0bc891e84c8229c498a1f2b870639196.webp?x-oss-process=image/format,png\" alt=\"\"></p>\n<p>每一个项目经历真的就一两句话可以描述了么？还是自己不想写？还是说不是自己做的，不敢多写。</p>\n<p>如果有项目的话，技术面试第一步，面试官一般都是让你自己介绍一下你的项目。你可以从下面几个方向来考虑：</p>\n<ol>\n<li>你对项目整体设计的一个感受（面试官可能会让你画系统的架构图）</li>\n<li>你在这个项目中你负责了什么、做了什么、担任了什么角色。</li>\n<li>从这个项目中你学会了那些东西，使用到了那些技术，学会了那些新技术的使用。</li>\n<li>你在这个项目中是否解决过什么问题？怎么解决的？收获了什么？</li>\n<li>你的项目用到了哪些技术？这些技术你吃透了没有？举个例子，你的项目经历使用了 Seata 来做分布式事务，那 Seata 相关的问题你要提前准备一下吧，比如说 Seata 支持哪些配置中心、Seata 的事务分组是怎么做的、Seata 支持哪些事务模式，怎么选择？</li>\n<li>你在这个项目中犯过的错误，最后是怎么弥补的？</li>\n</ol>\n<p><strong>3.计算机二级这个证书对于计算机专业完全不用写了，没有含金量的。</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/ddd2eaea3ae16c94491ae203f579c72b.webp?x-oss-process=image/format,png\" alt=\"\"></p>\n<p><strong>4.技能介绍问题太大。</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/93da1096fb02e19071ba13b4f6a7471c.png\" alt=\"\"></p>\n<ul>\n<li>技术名词最好规范大小写比较好，比如 java-&gt;Java ，spring boot -&gt; Spring Boot 。这个虽然有些面试官不会介意，但是很多面试官都会在意这个细节的。</li>\n<li>技能介绍太杂，没有亮点。不需要全才，某个领域做得好就行了！</li>\n<li>对 Java 后台开发的部分技能比如 Spring Boot 的熟悉度仅仅为了解，无法满足企业的要求。</li>\n</ul>\n<h2> 岗位匹配度很重要</h2>\n<p>校招通常会对你的项目经历的研究方向比较宽容，即使你的项目经历和对应公司的具体业务没有关系，影响其实也并不大。</p>\n<p>社招的话就不一样了，毕竟公司是要招聘可以直接来干活的人，你有相关的经验，公司会比较省事。社招通常会比较重视你的过往工作经历以及项目经历，HR 在筛选简历的时候会根据这两方面信息来判断你是否满足他们的招聘要求。就比如说你投递电商公司，而你之前的并没有和电商相关的工作经历以及项目经历，那 HR 在筛简历的时候很可能会直接把你 Pass 掉。</p>\n<p>不过，这个也并不绝对，也有一些公司在招聘的时候更看重的是你的过往经历，较少地关注岗位匹配度，优秀公司的工作经历以及有亮点的项目经验都是加分项。这类公司相信你既然在某个领域（比如电商、支付）已经做的不错了，那应该也可以在另外一个领域（比如流媒体平台、社交软件）很快成为专家。这个领域指的不是技术领域，更多的是业务方向。横跨技术领域（比如后端转算法、后端转大数据）找工作，你又没有相关的经验，几乎是没办法找到的。即使找到了，也大概率会面临 HR 压薪资的问题。</p>\n<h2> 提前准备技术面试和手撕算法</h2>\n<p>面试之前一定要提前准备一下常见的面试题：</p>\n<ul>\n<li>自己面试中可能涉及哪些知识点、那些知识点是重点。</li>\n<li>面试中哪些问题会被经常问到、面试中自己改如何回答。(强烈不推荐死记硬背，第一：通过背这种方式你能记住多少？能记住多久？第二：背题的方式的学习很难坚持下去！)</li>\n</ul>\n<p>这块内容只会介绍面试大概会涉及到哪方面的知识点，具体这些知识点涵盖哪些问题，后面的文章有介绍到。</p>\n<p><strong>Java</strong> :</p>\n<ul>\n<li>Java 基础</li>\n<li>Java 集合</li>\n<li>Java 并发</li>\n<li>JVM</li>\n</ul>\n<p><strong>计算机基础</strong> ：</p>\n<ul>\n<li>算法</li>\n<li>数据结构</li>\n<li>计算机网络</li>\n<li>操作系统</li>\n</ul>\n<p><strong>数据库</strong> ：</p>\n<ul>\n<li>MySQL</li>\n<li>Redis</li>\n</ul>\n<p><strong>常用框架</strong> ：</p>\n<ul>\n<li>Spring</li>\n<li>SpringBoot</li>\n<li>MyBatis</li>\n<li>Netty</li>\n<li>Zookeeper</li>\n<li>Dubbo</li>\n</ul>\n<p><strong>分布式</strong> :</p>\n<ul>\n<li>CAP 理论 和 BASE 理论、Paxos 算法和 Raft 算法</li>\n<li>RPC</li>\n<li>分布式事务</li>\n<li>分布式 ID</li>\n</ul>\n<p><strong>高并发</strong> ：</p>\n<ul>\n<li>消息队列</li>\n<li>读写分离&amp;分库分表</li>\n<li>负载均衡</li>\n</ul>\n<p><strong>高可用</strong> ：</p>\n<ul>\n<li>限流</li>\n<li>降级</li>\n<li>熔断</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/20210414112925296.png\" alt=\"\"></p>\n<p>不同类型的公司对于技能的要求侧重点是不同的比如腾讯、字节可能更重视计算机基础比如网络、操作系统这方面的内容。阿里、美团这种可能更重视你的项目经历、实战能力。</p>\n<p>关于如何准备算法面试请看《Java 面试指北》的「面试准备篇」中对应的文章。</p>\n<h2> 提前准备自我介绍</h2>\n<p>自我介绍一般是你和面试官的第一次面对面正式交流，换位思考一下，假如你是面试官的话，你想听到被你面试的人如何介绍自己呢？一定不是客套地说说自己喜欢编程、平时花了很多时间来学习、自己的兴趣爱好是打球吧？</p>\n<p>我觉得一个好的自我介绍至少应该包含这几点要素：</p>\n<ul>\n<li>用简洁的话说清楚自己主要的技术栈于擅长的领域；</li>\n<li>把重点放在自己在行的地方以及自己的优势之处；</li>\n<li>重点突出自己的能力比如自己的定位的 bug 的能力特别厉害；</li>\n</ul>\n<p>简单来说就是用简洁的语言突出自己的亮点，也就是推销自己嘛！</p>\n<ul>\n<li>如果你去过大公司实习，那对应的实习经历就是你的亮点。</li>\n<li>如果你参加过技术竞赛，那竞赛经历就是你的亮点。</li>\n<li>如果你大学就接触过企业级项目的开发，实战经验比较多，那这些项目经历就是你的亮点。</li>\n<li>......</li>\n</ul>\n<p>从社招和校招两个角度来举例子吧！我下面的两个例子仅供参考，自我介绍并不需要死记硬背，记住要说的要点，面试的时候根据公司的情况临场发挥也是没问题的。另外，网上一般建议的是准备好两份自我介绍：一份对 hr 说的，主要讲能突出自己的经历，会的编程技术一语带过；另一份对技术面试官说的，主要讲自己会的技术细节和项目经验。</p>\n<p><strong>社招：</strong></p>\n<blockquote>\n<p>面试官，您好！我叫独秀儿。我目前有 1 年半的工作经验，熟练使用 Spring、MyBatis 等框架、了解 Java 底层原理比如 JVM 调优并且有着丰富的分布式开发经验。离开上一家公司是因为我想在技术上得到更多的锻炼。在上一个公司我参与了一个分布式电子交易系统的开发，负责搭建了整个项目的基础架构并且通过分库分表解决了原始数据库以及一些相关表过于庞大的问题，目前这个网站最高支持 10 万人同时访问。工作之余，我利用自己的业余时间写了一个简单的 RPC 框架，这个框架用到了 Netty 进行网络通信， 目前我已经将这个项目开源，在 Github 上收获了 2k 的 Star! 说到业余爱好的话，我比较喜欢通过博客整理分享自己所学知识，现在已经是多个博客平台的认证作者。 生活中我是一个比较积极乐观的人，一般会通过运动打球的方式来放松。我一直都非常想加入贵公司，我觉得贵公司的文化和技术氛围我都非常喜欢，期待能与你共事！</p>\n</blockquote>\n<p><strong>校招：</strong></p>\n<blockquote>\n<p>面试官，您好！我叫秀儿。大学时间我主要利用课外时间学习了 Java 以及 Spring、MyBatis 等框架 。在校期间参与过一个考试系统的开发，这个系统的主要用了 Spring、MyBatis 和 shiro 这三种框架。我在其中主要担任后端开发，主要负责了权限管理功能模块的搭建。另外，我在大学的时候参加过一次软件编程大赛，我和我的团队做的在线订餐系统成功获得了第二名的成绩。我还利用自己的业余时间写了一个简单的 RPC 框架，这个框架用到了 Netty 进行网络通信， 目前我已经将这个项目开源，在 Github 上收获了 2k 的 Star! 说到业余爱好的话，我比较喜欢通过博客整理分享自己所学知识，现在已经是多个博客平台的认证作者。 生活中我是一个比较积极乐观的人，一般会通过运动打球的方式来放松。我一直都非常想加入贵公司，我觉得贵公司的文化和技术氛围我都非常喜欢，期待能与你共事！</p>\n</blockquote>\n<h2> 减少抱怨</h2>\n<p>就像现在的技术面试一样，大家都说内卷了，抱怨现在的面试真特么难。然而，单纯抱怨有用么？你对其他求职者说：“大家都不要刷 Leetcode 了啊！都不要再准备高并发、高可用的面试题了啊！现在都这么卷了！”</p>\n<p>会有人听你的么？<strong>你不准备面试，但是其他人会准备面试啊！那你是不是傻啊？还是真的厉害到不需要准备面试呢？</strong></p>\n<p>因此，准备 Java 面试的第一步，我们一定要尽量减少抱怨。抱怨的声音多了之后，会十分影响自己，会让自己变得十分焦虑。</p>\n<h2> 面试之后及时复盘</h2>\n<p>如果失败，不要灰心；如果通过，切勿狂喜。面试和工作实际上是两回事，可能很多面试未通过的人，工作能力比你强的多，反之亦然。</p>\n<p>面试就像是一场全新的征程，失败和胜利都是平常之事。所以，劝各位不要因为面试失败而灰心、丧失斗志。也不要因为面试通过而沾沾自喜，等待你的将是更美好的未来，继续加油！</p>\n<h2> 总结</h2>\n<p>这篇文章内容有点多，如果这篇文章只能让你记住 4 句话，那请记住下面这 4 句：</p>\n<ol>\n<li>一定要提前准备面试！技术面试不同于编程，编程厉害不代表技术面试就一定能过。</li>\n<li>一定不要对面试抱有侥幸心理。打铁还需自身硬！千万不要觉得自己看几篇面经，看几篇面试题解析就能通过面试了。一定要静下心来深入学习！</li>\n<li>建议大学生尽可能早一点以求职为导向来学习的。这样更有针对性，并且可以大概率减少自己处在迷茫的时间，很大程度上还可以让自己少走很多弯路。 但是，不要把“以求职为导向学习”理解为“我就不用学课堂上那些计算机基础课程了”！</li>\n<li>手撕算法是当下技术面试的标配，尽早准备！</li>\n</ol>\n",
      "image": "https://img-blog.csdnimg.cn/20210412110352612.png",
      "date_published": "2022-03-08T06:04:22.000Z",
      "date_modified": "2022-11-13T08:46:36.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "知识星球"
      ]
    },
    {
      "title": "《手写 RPC 框架》(付费)",
      "url": "https://javaguide.cn/zhuanlan/handwritten-rpc-framework.html",
      "id": "https://javaguide.cn/zhuanlan/handwritten-rpc-framework.html",
      "summary": "介绍 《手写 RPC 框架》 是我的知识星球的一个内部小册，我写了 12 篇文章来讲解如何从零开始基于 Netty+Kyro+Zookeeper 实现一个简易的 RPC 框架。 麻雀虽小五脏俱全，项目代码注释详细，结构清晰，并且集成了 Check Style 规范代码结构，非常适合阅读和学习。 内容概览",
      "content_html": "<h2> 介绍</h2>\n<p><strong>《手写 RPC 框架》</strong> 是我的<a href=\"/about-the-author/zhishixingqiu-two-years.html\" target=\"blank\">知识星球</a>的一个内部小册，我写了 12 篇文章来讲解如何从零开始基于 Netty+Kyro+Zookeeper 实现一个简易的 RPC 框架。</p>\n<p>麻雀虽小五脏俱全，项目代码注释详细，结构清晰，并且集成了 Check Style 规范代码结构，非常适合阅读和学习。</p>\n<h2> 内容概览</h2>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/image-20220308100605485.png\" alt=\"\"></p>\n<p>通过这个简易的轮子，你可以学到 RPC 的底层原理和原理以及各种 Java 编码实践的运用。你甚至可以把它当做你的毕设/项目经验的选择，这是非常不错！对比其他求职者的项目经验都是各种系统，造轮子肯定是更加能赢得面试官的青睐。</p>\n<ul>\n<li>Github 地址：<a href=\"https://github.com/Snailclimb/guide-rpc-framework\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/Snailclimb/guide-rpc-framework</a> 。</li>\n<li>Gitee 地址：<a href=\"https://gitee.com/SnailClimb/guide-rpc-framework\" target=\"_blank\" rel=\"noopener noreferrer\">https://gitee.com/SnailClimb/guide-rpc-framework</a> 。</li>\n</ul>\n<h2> 星球其他资源</h2>\n<p>除了 <strong>《手写 RPC 框架》</strong> 之外，星球还有 <strong>《Java 必读源码系列》</strong>（目前已经整理了 Dubbo 2.6.x 、Netty 4.x、SpringBoot2.1 的源码）、 <strong>《Java 面试指北》</strong> 、<strong>《Kafka 常见面试题/知识点总结》</strong> 等多个专属小册。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220316200015412.png\" alt=\"\">\n另外，星球还会有读书活动、学习打卡、简历修改、免费提问、海量 Java 优质面试资源以及各种不定时的福利。\n<img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220304124333119.png\" alt=\"\"></p>\n<h2> 星球限时优惠</h2>\n<p>两年前，星球的定价是 <strong>50/年</strong> ，这是星球的最低定价，我还附送了 33 元优惠券。扣除了星球手续费，发了各种福利之后，几乎就是纯粹做公益。</p>\n<p>感兴趣的小伙伴可以看看我在 2020-01-03 发的头条：<a href=\"https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247486049&amp;idx=1&amp;sn=e0161b409e8f164251bdaa0c83a476bc&amp;chksm=cea245aaf9d5ccbcafdb95a546d959508814085620aabdbb4385c4b8cea6e50bf157c3697041&amp;token=1614894361&amp;lang=zh_CN#rd\" target=\"_blank\" rel=\"noopener noreferrer\">做了一个很久没敢做的事情</a>，去考古一下。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220311203414600.png\" alt=\"\"></p>\n<p>随着时间推移，星球积累的干货资源越来越多，我花在星球上的时间也越来越多。于是，我将星球的定价慢慢调整为了 <strong>159/年</strong>！后续会将星球的价格调整为 <strong>199/年</strong>，想要加入的小伙伴一定要尽早。</p>\n<p>这里再送一个 30 元的新人优惠券（续费半价）。</p>\n<div align=\"center\">\n  <a href=\"https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html\">\n    <img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/xingqiuyouhuijuanheyi.png\" style=\"margin: 0 auto; \">\n  </a>\n</div>\n<p>进入星球之后，记得添加微信，我会发你详细的星球使用指南。</p>\n<div align=\"center\">\n  <a href=\"https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html\">\n    <img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/IMG_3007.jpg\" style=\"margin: 0 auto; \">\n  </a>\n</div>\n<p><strong>真诚欢迎准备面试的小伙伴加入星球一起交流！真心希望能够帮助到更多小伙伴！</strong></p>\n",
      "image": "https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/image-20220308100605485.png",
      "date_published": "2022-03-08T06:04:22.000Z",
      "date_modified": "2023-01-29T03:31:13.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "知识星球"
      ]
    },
    {
      "title": "星球专属优质专栏概览",
      "url": "https://javaguide.cn/zhuanlan/",
      "id": "https://javaguide.cn/zhuanlan/",
      "summary": "这部分的内容为我的知识星球专属，目前已经更新了下面这些专栏： 《Java 面试指北》 : 与 JavaGuide 开源版的内容互补！ 《手写 RPC 框架》 : 从零开始基于 Netty+Kyro+Zookeeper 实现一个简易的 RPC 框架。 《Java 必读源码系列》 ：目前已经整理了 Dubbo 2.6.x 、Netty 4.x、SpringBoot 2.1 等框架/中间件的源码 ......",
      "content_html": "<p>这部分的内容为我的<a href=\"/about-the-author/zhishixingqiu-two-years.html\" target=\"blank\">知识星球</a>专属，目前已经更新了下面这些专栏：</p>\n<ul>\n<li><strong><a href=\"/zhuanlan/java-mian-shi-zhi-bei.html\" target=\"blank\">《Java 面试指北》</a></strong> : 与 JavaGuide 开源版的内容互补！</li>\n<li><strong><a href=\"/zhuanlan/java-mian-shi-zhi-bei.html\" target=\"blank\">《手写 RPC 框架》</a></strong> : 从零开始基于 Netty+Kyro+Zookeeper 实现一个简易的 RPC 框架。</li>\n<li><strong><a href=\"/zhuanlan/source-code-reading.html\" target=\"blank\">《Java 必读源码系列》</a></strong> ：目前已经整理了 Dubbo 2.6.x 、Netty 4.x、SpringBoot 2.1 等框架/中间件的源码</li>\n<li>......</li>\n</ul>\n<p>欢迎准备 Java 面试以及学习 Java 的同学加入我的<a href=\"/about-the-author/zhishixingqiu-two-years.html\" target=\"blank\">知识星球</a>，干货非常多！收费虽然是白菜价，但星球里的内容比你参加几万的培训班质量还要高。</p>\n<p>我有自己的原则，不割韭菜，用心做内容，真心希望帮助到你！</p>\n<h2> 更多专栏</h2>\n<p>除了上面介绍的之外，我的<a href=\"/about-the-author/zhishixingqiu-two-years.html\" target=\"blank\">知识星球</a>还有  <strong>《Kafka 常见面试题/知识点总结》</strong> 、**《程序员副业赚钱之路》**等多个专栏。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220211231206733.png\" alt=\"\"></p>\n<p>另外，星球还会有读书活动、学习打卡、简历修改、免费提问、海量 Java 优质面试资源以及各种不定时的福利。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220304124333119.png\" alt=\"\"></p>\n<h2> 星球限时优惠</h2>\n<p>两年前，星球的定价是 <strong>50/年</strong> ，这是星球的最低定价，我还附送了 33 元优惠券。扣除了星球手续费，发了各种福利之后，几乎就是纯粹做公益。</p>\n<p>感兴趣的小伙伴可以看看我在 2020-01-03 发的头条：<a href=\"https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247486049&amp;idx=1&amp;sn=e0161b409e8f164251bdaa0c83a476bc&amp;chksm=cea245aaf9d5ccbcafdb95a546d959508814085620aabdbb4385c4b8cea6e50bf157c3697041&amp;token=1614894361&amp;lang=zh_CN#rd\" target=\"_blank\" rel=\"noopener noreferrer\">做了一个很久没敢做的事情</a>，去考古一下。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220311203414600.png\" alt=\"\"></p>\n<p>随着时间推移，星球积累的干货资源越来越多，我花在星球上的时间也越来越多。于是，我将星球的定价慢慢调整为了 <strong>159/年</strong>！后续会将星球的价格调整为 <strong>199/年</strong>，想要加入的小伙伴一定要尽早。</p>\n<p>你可以添加我的微信（没有手机号再申请微信，故使用企业微信。不过，请放心，这个号的消息也是我本人处理，平时最常看这个微信）领取星球专属优惠券，限时 <strong>130/年</strong> 加入！</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/IMG_3007.jpg\" alt=\"\"></p>\n<p>或者你也可以直接使用下面这张 <strong>20</strong> 元的优惠券，<strong>139/年</strong> 加入。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/xingqiuyouhuijuan-20.png\" alt=\"\"></p>\n<p>进入星球之后，你可以为自己制定一个目标，比如自己想要进入某某还不错的公司或者达成什么成就（一定要是还算有点挑战的目标）。待你完成目标在星球分享之后，我会将星球的门票费退还给你。</p>\n<p><strong>真诚欢迎准备面试的小伙伴加入星球一起交流！真心希望能够帮助到更多小伙伴！</strong></p>\n<p><strong>加入星球之后记得看<a href=\"https://t.zsxq.com/04iiiAqf6\" target=\"_blank\" rel=\"noopener noreferrer\">置顶主题</a>，你会发现物超所值！</strong></p>\n",
      "image": "https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220211231206733.png",
      "date_published": "2022-03-08T06:04:22.000Z",
      "date_modified": "2022-08-07T23:16:26.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "知识星球"
      ]
    },
    {
      "title": "《Java 面试指北》(付费)",
      "url": "https://javaguide.cn/zhuanlan/java-mian-shi-zhi-bei.html",
      "id": "https://javaguide.cn/zhuanlan/java-mian-shi-zhi-bei.html",
      "summary": "介绍 《Java 面试指北》 是我的知识星球的一个内部小册，和 JavaGuide 开源版的内容互补。相比于开源版本来说，《Java 面试指北》添加了下面这些内容（不仅仅是这些内容）： 10+ 篇文章手把手教你如何准备面试。 更全面的八股文面试题（系统设计、常见框架、分布式、高并发 ......）。 优质面经精选。 技术面试题自测。 练级攻略（有助于个人成长的经验）。",
      "content_html": "<h2> 介绍</h2>\n<p><strong>《Java 面试指北》</strong> 是我的<a href=\"/about-the-author/zhishixingqiu-two-years.html\" target=\"blank\">知识星球</a>的一个内部小册，和 <a href=\"https://javaguide.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">JavaGuide 开源版</a>的内容互补。相比于开源版本来说，《Java 面试指北》添加了下面这些内容（不仅仅是这些内容）：</p>\n<ul>\n<li>10+ 篇文章手把手教你如何准备面试。</li>\n<li>更全面的八股文面试题（系统设计、常见框架、分布式、高并发 ......）。</li>\n<li>优质面经精选。</li>\n<li>技术面试题自测。</li>\n<li>练级攻略（有助于个人成长的经验）。</li>\n</ul>\n<h2> 内容概览</h2>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javamianshizhibei/javamianshizhibei-content-overview.png\" alt=\"《Java 面试指北》内容概览\"></p>\n<h3> 面试准备篇</h3>\n<p>在 <strong>「面试准备篇」</strong> ，我写了 10+ 篇文章手把手教你如何准备面试，涵盖项目经验、简历编写、源码学习、算法准备、面试资源等内容。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javamianshizhibei/preparation-for-interview.png\" alt=\"《Java 面试指北》面试准备篇\"></p>\n<p>另外，考虑到很多小伙伴缺少项目经历，我还推荐了很多小众但优质的实战项目，有视频也有开源项目，有业务系统，也有各种含金量比较高的轮子类项目。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javamianshizhibei/practical-project-recommendation.png\" alt=\"实战项目推荐\"></p>\n<h3> 技术面试题篇</h3>\n<p><strong>「技术面试题篇」</strong> 的内容和 JavaGuide 开源版本互补，不仅仅包括最基本的 Java、常见框架等八股文，还包括系统设计、分布式、高并发等进阶内容。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javamianshizhibei/technical-interview-questions.png\" alt=\"《Java 面试指北》技术面试题篇\"></p>\n<h3> 面经篇</h3>\n<p>古人云:“<strong>他山之石，可以攻玉</strong>” 。善于学习借鉴别人的面试的成功经验或者失败的教训，可以让自己少走许多弯路。</p>\n<p><strong>「面经篇」</strong> 主要会分享一些高质量的 Java 后端面经，有校招的，也有社招的，有大厂的，也有中小厂的。</p>\n<p>如果你是非科班的同学，也能在这些文章中找到对应的非科班的同学写的面经。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/githubjuejinjihua/thinkimage-20220612185810480.png\" alt=\"《Java 面试指北》面经篇\"></p>\n<p>并且，<a href=\"https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html\" target=\"_blank\" rel=\"noopener noreferrer\">知识星球</a>还有专门分享面经和面试题的专题，里面会分享很多优质的面经和面试题。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220304120018731.png\" alt=\"\"></p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220628101743381.png\" alt=\"\"></p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220628101805897.png\" alt=\"\"></p>\n<h3> 技术面试题自测篇</h3>\n<p>为了让小伙伴们自测以检查自己的掌握情况，我还推出了 <strong>「技术面试题自测」</strong> 系列。不过，目前只更新了 Java 和数据库的自测，正在持续更新中。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220621095641897.png\" alt=\"《Java 面试指北》技术面试题自测篇\"></p>\n<h3> 练级攻略篇</h3>\n<p><strong>「练级攻略篇」</strong> 这个系列主要内容一些有助于个人成长的经验分享。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javamianshizhibei/training-strategy-articles.png\" alt=\"《Java 面试指北》练级攻略篇\"></p>\n<p>每一篇内容都非常干货，不少球友看了之后表示收获漫漫。不过，最重要的还是知行合一。</p>\n<h2> 星球其他资源</h2>\n<p>除了 <strong>《Java 面试指北》</strong> 之外，星球还有 <strong>《Java 必读源码系列》</strong>（目前已经整理了 Dubbo 2.6.x 、Netty 4.x、SpringBoot2.1 的源码）、 <strong>《从零开始写一个 RPC 框架》</strong>（已更新完） 、<strong>《Kafka 常见面试题/知识点总结》</strong> 等多个专属小册。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220316200015412.png\" alt=\"\">\n另外，星球还会有读书活动、学习打卡、简历修改、免费提问、海量 Java 优质面试资源以及各种不定时的福利。\n<img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220304124333119.png\" alt=\"\"></p>\n<h2> 星球限时优惠</h2>\n<p>两年前，星球的定价是 <strong>50/年</strong> ，这是星球的最低定价，我还附送了 33 元优惠券。扣除了星球手续费，发了各种福利之后，几乎就是纯粹做公益。</p>\n<p>感兴趣的小伙伴可以看看我在 2020-01-03 发的头条：<a href=\"https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247486049&amp;idx=1&amp;sn=e0161b409e8f164251bdaa0c83a476bc&amp;chksm=cea245aaf9d5ccbcafdb95a546d959508814085620aabdbb4385c4b8cea6e50bf157c3697041&amp;token=1614894361&amp;lang=zh_CN#rd\" target=\"_blank\" rel=\"noopener noreferrer\">做了一个很久没敢做的事情</a>，去考古一下。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220311203414600.png\" alt=\"\"></p>\n<p>随着时间推移，星球积累的干货资源越来越多，我花在星球上的时间也越来越多。于是，我将星球的定价慢慢调整为了 <strong>159/年</strong>！后续会将星球的价格调整为 <strong>199/年</strong>，想要加入的小伙伴一定要尽早。</p>\n<p><strong>这里再送一个 30 元的新人优惠券（续费半价）。</strong></p>\n<div align=\"center\">\n  <a href=\"https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html\">\n    <img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/xingqiuyouhuijuanheyi.png\" style=\"margin: 0 auto; \">\n  </a>\n</div>\n**进入星球之后，记得添加微信，我会发你详细的星球使用指南。**\n<div align=\"center\">\n  <a href=\"https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html\">\n    <img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/IMG_3007.jpg\" style=\"margin: 0 auto; \">\n  </a>\n</div>\n<p><strong>真诚欢迎准备面试的小伙伴加入星球一起交流！真心希望能够帮助到更多小伙伴！</strong></p>\n",
      "image": "https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javamianshizhibei/javamianshizhibei-content-overview.png",
      "date_published": "2022-03-04T09:38:55.000Z",
      "date_modified": "2023-01-30T15:07:18.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "知识星球"
      ]
    },
    {
      "title": "数据库基础知识总结",
      "url": "https://javaguide.cn/database/basis.html",
      "id": "https://javaguide.cn/database/basis.html",
      "summary": "数据库知识基础，这部分内容一定要理解记忆。虽然这部分内容只是理论知识，但是非常重要，这是后面学习 MySQL 数据库的基础。PS: 这部分内容由于涉及太多概念性内容，所以参考了维基百科和百度百科相应的介绍。 什么是数据库, 数据库管理系统, 数据库系统, 数据库管理员? 数据库 : 数据库(DataBase 简称 DB)就是信息的集合或者说数据库是由数据库管理系统管理的数据的集合。 数据库管理系统 : 数据库管理系统(Database Management System 简称 DBMS)是一种操纵和管理数据库的大型软件，通常用于建立、使用和维护数据库。 数据库系统 : 数据库系统(Data Base System，简称 DBS)通常由软件、数据库和数据管理员(DBA)组成。 数据库管理员 : 数据库管理员(Database Administrator, 简称 DBA)负责全面管理和控制数据库系统。",
      "content_html": "<p>数据库知识基础，这部分内容一定要理解记忆。虽然这部分内容只是理论知识，但是非常重要，这是后面学习 MySQL 数据库的基础。PS: 这部分内容由于涉及太多概念性内容，所以参考了维基百科和百度百科相应的介绍。</p>\n<h2> 什么是数据库, 数据库管理系统, 数据库系统, 数据库管理员?</h2>\n<ul>\n<li><strong>数据库</strong> : 数据库(DataBase 简称 DB)就是信息的集合或者说数据库是由数据库管理系统管理的数据的集合。</li>\n<li><strong>数据库管理系统</strong> : 数据库管理系统(Database Management System 简称 DBMS)是一种操纵和管理数据库的大型软件，通常用于建立、使用和维护数据库。</li>\n<li><strong>数据库系统</strong> : 数据库系统(Data Base System，简称 DBS)通常由软件、数据库和数据管理员(DBA)组成。</li>\n<li><strong>数据库管理员</strong> : 数据库管理员(Database Administrator, 简称 DBA)负责全面管理和控制数据库系统。</li>\n</ul>\n<h2> 什么是元组, 码, 候选码, 主码, 外码, 主属性, 非主属性？</h2>\n<ul>\n<li><strong>元组</strong> ： 元组（tuple）是关系数据库中的基本概念，关系是一张表，表中的每行（即数据库中的每条记录）就是一个元组，每列就是一个属性。 在二维表里，元组也称为行。</li>\n<li><strong>码</strong> ：码就是能唯一标识实体的属性，对应表中的列。</li>\n<li><strong>候选码</strong> ： 若关系中的某一属性或属性组的值能唯一的标识一个元组，而其任何、子集都不能再标识，则称该属性组为候选码。例如：在学生实体中，“学号”是能唯一的区分学生实体的，同时又假设“姓名”、“班级”的属性组合足以区分学生实体，那么{学号}和{姓名，班级}都是候选码。</li>\n<li><strong>主码</strong> : 主码也叫主键。主码是从候选码中选出来的。 一个实体集中只能有一个主码，但可以有多个候选码。</li>\n<li><strong>外码</strong> : 外码也叫外键。如果一个关系中的一个属性是另外一个关系中的主码则这个属性为外码。</li>\n<li><strong>主属性</strong> ： 候选码中出现过的属性称为主属性。比如关系 工人（工号，身份证号，姓名，性别，部门）. 显然工号和身份证号都能够唯一标示这个关系，所以都是候选码。工号、身份证号这两个属性就是主属性。如果主码是一个属性组，那么属性组中的属性都是主属性。</li>\n<li><strong>非主属性：</strong> 不包含在任何一个候选码中的属性称为非主属性。比如在关系——学生（学号，姓名，年龄，性别，班级）中，主码是“学号”，那么其他的“姓名”、“年龄”、“性别”、“班级”就都可以称为非主属性。</li>\n</ul>\n<h2> 什么是 ER 图？</h2>\n<p>我们做一个项目的时候一定要试着画 ER 图来捋清数据库设计，这个也是面试官问你项目的时候经常会被问到的。</p>\n<p><strong>ER 图</strong> 全称是 Entity Relationship Diagram（实体联系图），提供了表示实体类型、属性和联系的方法。</p>\n<p>ER 图由下面 3 个要素组成：</p>\n<ul>\n<li><strong>实体</strong> ：通常是现实世界的业务对象，当然使用一些逻辑对象也可以。比如对于一个校园管理系统，会涉及学生、教师、课程、班级等等实体。在 ER 图中，实体使用矩形框表示。</li>\n<li><strong>属性</strong> ：即某个实体拥有的属性，属性用来描述组成实体的要素，对于产品设计来说可以理解为字段。在 ER 图中，属性使用椭圆形表示。</li>\n<li><strong>联系</strong> ：即实体与实体之间的关系，这个关系不仅有业务关联关系，还能通过数字表示实体之间的数量对照关系。例如，一个班级会有多个学生就是一种实体间的联系。</li>\n</ul>\n<p>下图是一个学生选课的 ER 图，每个学生可以选若干门课程，同一门课程也可以被若干人选择，所以它们之间的关系是多对多（M: N）。另外，还有其他两种实体之间的关系是：1 对 1（1:1）、1 对多（1: N）。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/c745c87f6eda9a439e0eea52012c7f4a.png\" alt=\"学生与课程之间联系的E-R图\"></p>\n<h2> 数据库范式了解吗?</h2>\n<p>数据库范式有 3 种：</p>\n<ul>\n<li>1NF(第一范式)：属性不可再分。</li>\n<li>2NF(第二范式)：1NF 的基础之上，消除了非主属性对于码的部分函数依赖。</li>\n<li>3NF(第三范式)：3NF 在 2NF 的基础之上，消除了非主属性对于码的传递函数依赖 。</li>\n</ul>\n<h3> 1NF(第一范式)</h3>\n<p>属性（对应于表中的字段）不能再被分割，也就是这个字段只能是一个值，不能再分为多个其他的字段了。<strong>1NF 是所有关系型数据库的最基本要求</strong> ，也就是说关系型数据库中创建的表一定满足第一范式。</p>\n<h3> 2NF(第二范式)</h3>\n<p>2NF 在 1NF 的基础之上，消除了非主属性对于码的部分函数依赖。如下图所示，展示了第一范式到第二范式的过渡。第二范式在第一范式的基础上增加了一个列，这个列称为主键，非主属性都依赖于主键。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/bd1d31be3779342427fc9e462bf7f05c.png\" alt=\"第二范式\"></p>\n<p>一些重要的概念：</p>\n<ul>\n<li><strong>函数依赖（functional dependency）</strong> ：若在一张表中，在属性（或属性组）X 的值确定的情况下，必定能确定属性 Y 的值，那么就可以说 Y 函数依赖于 X，写作 X → Y。</li>\n<li><strong>部分函数依赖（partial functional dependency）</strong> ：如果 X→Y，并且存在 X 的一个真子集 X0，使得 X0→Y，则称 Y 对 X 部分函数依赖。比如学生基本信息表 R 中（学号，身份证号，姓名）当然学号属性取值是唯一的，在 R 关系中，（学号，身份证号）-&gt;（姓名），（学号）-&gt;（姓名），（身份证号）-&gt;（姓名）；所以姓名部分函数依赖与（学号，身份证号）；</li>\n<li><strong>完全函数依赖(Full functional dependency)</strong> ：在一个关系中，若某个非主属性数据项依赖于全部关键字称之为完全函数依赖。比如学生基本信息表 R（学号，班级，姓名）假设不同的班级学号有相同的，班级内学号不能相同，在 R 关系中，（学号，班级）-&gt;（姓名），但是（学号）-&gt;(姓名)不成立，（班级）-&gt;(姓名)不成立，所以姓名完全函数依赖与（学号，班级）；</li>\n<li><strong>传递函数依赖</strong> ： 在关系模式 R(U)中，设 X，Y，Z 是 U 的不同的属性子集，如果 X 确定 Y、Y 确定 Z，且有 X 不包含 Y，Y 不确定 X，（X∪Y）∩Z=空集合，则称 Z 传递函数依赖(transitive functional dependency) 于 X。传递函数依赖会导致数据冗余和异常。传递函数依赖的 Y 和 Z 子集往往同属于某一个事物，因此可将其合并放到一个表中。比如在关系 R(学号 , 姓名, 系名，系主任)中，学号 → 系名，系名 → 系主任，所以存在非主属性系主任对于学号的传递函数依赖。。</li>\n</ul>\n<h3> 3NF(第三范式)</h3>\n<p>3NF 在 2NF 的基础之上，消除了非主属性对于码的传递函数依赖 。符合 3NF 要求的数据库设计，<strong>基本</strong>上解决了数据冗余过大，插入异常，修改异常，删除异常的问题。比如在关系 R(学号 , 姓名, 系名，系主任)中，学号 → 系名，系名 → 系主任，所以存在非主属性系主任对于学号的传递函数依赖，所以该表的设计，不符合 3NF 的要求。</p>\n<h2> 主键和外键有什么区别?</h2>\n<ul>\n<li><strong>主键(主码)</strong> ：主键用于唯一标识一个元组，不能有重复，不允许为空。一个表只能有一个主键。</li>\n<li><strong>外键(外码)</strong> ：外键用来和其他表建立联系用，外键是另一表的主键，外键是可以有重复的，可以是空值。一个表可以有多个外键。</li>\n</ul>\n<h2> 为什么不推荐使用外键与级联？</h2>\n<p>对于外键和级联，阿里巴巴开发手册这样说到：</p>\n<blockquote>\n<p>【强制】不得使用外键与级联，一切外键概念必须在应用层解决。</p>\n<p>说明: 以学生和成绩的关系为例，学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新，即为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群; 级联更新是强阻塞，存在数据库更新风暴的风 险; 外键影响数据库的插入速度</p>\n</blockquote>\n<p>为什么不要用外键呢？大部分人可能会这样回答：</p>\n<ol>\n<li><strong>增加了复杂性：</strong> a. 每次做 DELETE 或者 UPDATE 都必须考虑外键约束，会导致开发的时候很痛苦, 测试数据极为不方便; b. 外键的主从关系是定的，假如那天需求有变化，数据库中的这个字段根本不需要和其他表有关联的话就会增加很多麻烦。</li>\n<li><strong>增加了额外工作</strong>： 数据库需要增加维护外键的工作，比如当我们做一些涉及外键字段的增，删，更新操作之后，需要触发相关操作去检查，保证数据的的一致性和正确性，这样会不得不消耗资源；（个人觉得这个不是不用外键的原因，因为即使你不使用外键，你在应用层面也还是要保证的。所以，我觉得这个影响可以忽略不计。）</li>\n<li><strong>对分库分表不友好</strong> ：因为分库分表下外键是无法生效的。</li>\n<li>......</li>\n</ol>\n<p>我个人觉得上面这种回答不是特别的全面，只是说了外键存在的一个常见的问题。实际上，我们知道外键也是有很多好处的，比如：</p>\n<ol>\n<li>保证了数据库数据的一致性和完整性；</li>\n<li>级联操作方便，减轻了程序代码量；</li>\n<li>......</li>\n</ol>\n<p>所以说，不要一股脑的就抛弃了外键这个概念，既然它存在就有它存在的道理，如果系统不涉及分库分表，并发量不是很高的情况还是可以考虑使用外键的。</p>\n<h2> 什么是存储过程?</h2>\n<p>我们可以把存储过程看成是一些 SQL 语句的集合，中间加了点逻辑控制语句。存储过程在业务比较复杂的时候是非常实用的，比如很多时候我们完成一个操作可能需要写一大串 SQL 语句，这时候我们就可以写有一个存储过程，这样也方便了我们下一次的调用。存储过程一旦调试完成通过后就能稳定运行，另外，使用存储过程比单纯 SQL 语句执行要快，因为存储过程是预编译过的。</p>\n<p>存储过程在互联网公司应用不多，因为存储过程难以调试和扩展，而且没有移植性，还会消耗数据库资源。</p>\n<p>阿里巴巴 Java 开发手册里要求禁止使用存储过程。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/0fa082bc4d4f919065767476a41b2156.png\" alt=\"阿里巴巴Java开发手册: 禁止存储过程\"></p>\n<h2> drop、delete 与 truncate 区别？</h2>\n<h3> 用法不同</h3>\n<ul>\n<li><code>drop</code>(丢弃数据): <code>drop table 表名</code> ，直接将表都删除掉，在删除表的时候使用。</li>\n<li><code>truncate</code> (清空数据) : <code>truncate table 表名</code> ，只删除表中的数据，再插入数据的时候自增长 id 又从 1 开始，在清空表中数据的时候使用。</li>\n<li><code>delete</code>（删除数据） : <code>delete from 表名 where 列名=值</code>，删除某一行的数据，如果不加 <code>where</code> 子句和<code>truncate table 表名</code>作用类似。</li>\n</ul>\n<p><code>truncate</code> 和不带 where``子句的 <code>delete</code>、以及 <code>drop</code> 都会删除表内的数据，但是 <strong><code>truncate</code> 和 <code>delete</code> 只删除数据不删除表的结构(定义)，执行 <code>drop</code> 语句，此表的结构也会删除，也就是执行 <code>drop</code> 之后对应的表不复存在。</strong></p>\n<h3> 属于不同的数据库语言</h3>\n<p><code>truncate</code> 和 <code>drop</code> 属于 DDL(数据定义语言)语句，操作立即生效，原数据不放到 rollback segment 中，不能回滚，操作不触发 trigger。而 <code>delete</code> 语句是 DML (数据库操作语言)语句，这个操作会放到 rollback segement 中，事务提交之后才生效。</p>\n<p><strong>DML 语句和 DDL 语句区别：</strong></p>\n<ul>\n<li>DML 是数据库操作语言（Data Manipulation Language）的缩写，是指对数据库中表记录的操作，主要包括表记录的插入、更新、删除和查询，是开发人员日常使用最频繁的操作。</li>\n<li>DDL （Data Definition Language）是数据定义语言的缩写，简单来说，就是对数据库内部的对象进行创建、删除、修改的操作语言。它和 DML 语言的最大区别是 DML 只是对表内部数据的操作，而不涉及到表的定义、结构的修改，更不会涉及到其他对象。DDL 语句更多的被数据库管理员（DBA）所使用，一般的开发人员很少使用。</li>\n</ul>\n<p>另外，由于<code>select</code>不会对表进行破坏，所以有的地方也会把<code>select</code>单独区分开叫做数据库查询语言 DQL（Data Query Language）。</p>\n<h3> 执行速度不同</h3>\n<p>一般来说：<code>drop</code> &gt; <code>truncate</code> &gt; <code>delete</code>（这个我没有设计测试过）。</p>\n<ul>\n<li><code>delete</code>命令执行的时候会产生数据库的<code>binlog</code>日志，而日志记录是需要消耗时间的，但是也有个好处方便数据回滚恢复。</li>\n<li><code>truncate</code>命令执行的时候不会产生数据库日志，因此比<code>delete</code>要快。除此之外，还会把表的自增值重置和索引恢复到初始大小等。</li>\n<li><code>drop</code>命令会把表占用的空间全部释放掉。</li>\n</ul>\n<p>Tips：你应该更多地关注在使用场景上，而不是执行效率。</p>\n<h2> 数据库设计通常分为哪几步?</h2>\n<ol>\n<li><strong>需求分析</strong> : 分析用户的需求，包括数据、功能和性能需求。</li>\n<li><strong>概念结构设计</strong> : 主要采用 E-R 模型进行设计，包括画 E-R 图。</li>\n<li><strong>逻辑结构设计</strong> : 通过将 E-R 图转换成表，实现从 E-R 模型到关系模型的转换。</li>\n<li><strong>物理结构设计</strong> : 主要是为所设计的数据库选择合适的存储结构和存取路径。</li>\n<li><strong>数据库实施</strong> : 包括编程、测试和试运行</li>\n<li><strong>数据库的运行和维护</strong> : 系统的运行与数据库的日常维护。</li>\n</ol>\n<h2> 参考</h2>\n<ul>\n<li><a href=\"https://blog.csdn.net/rl529014/article/details/48391465\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.csdn.net/rl529014/article/details/48391465</a></li>\n<li><a href=\"https://www.zhihu.com/question/24696366/answer/29189700\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.zhihu.com/question/24696366/answer/29189700</a></li>\n<li><a href=\"https://blog.csdn.net/bieleyang/article/details/77149954\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.csdn.net/bieleyang/article/details/77149954</a></li>\n</ul>\n",
      "image": "https://img-blog.csdnimg.cn/img_convert/c745c87f6eda9a439e0eea52012c7f4a.png",
      "date_published": "2022-03-03T01:14:56.000Z",
      "date_modified": "2023-02-02T09:54:04.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "数据库"
      ]
    },
    {
      "title": "字符集详解",
      "url": "https://javaguide.cn/database/character-set.html",
      "id": "https://javaguide.cn/database/character-set.html",
      "summary": "MySQL 字符编码集中有两套 UTF-8 编码实现：utf8 和 utf8mb4。 如果使用 utf8 的话，存储emoji 符号和一些比较复杂的汉字、繁体字就会出错。 为什么会这样呢？这篇文章可以从源头给你解答。 何为字符集？ 字符是各种文字和符号的统称，包括各个国家文字、标点符号、表情、数字等等。 字符集 就是一系列字符的集合。字符集的种类较多，每个字符集可以表示的字符范围通常不同，就比如说有些字符集是无法表示汉字的。",
      "content_html": "<p>MySQL 字符编码集中有两套 UTF-8 编码实现：<strong><code>utf8</code></strong> 和 <strong><code>utf8mb4</code></strong>。</p>\n<p>如果使用 <strong><code>utf8</code></strong>  的话，存储emoji 符号和一些比较复杂的汉字、繁体字就会出错。</p>\n<p>为什么会这样呢？这篇文章可以从源头给你解答。</p>\n<h2> 何为字符集？</h2>\n<p>字符是各种文字和符号的统称，包括各个国家文字、标点符号、表情、数字等等。 <strong>字符集</strong> 就是一系列字符的集合。字符集的种类较多，每个字符集可以表示的字符范围通常不同，就比如说有些字符集是无法表示汉字的。</p>\n<p><strong>计算机只能存储二进制的数据，那英文、汉字、表情等字符应该如何存储呢？</strong></p>\n<p>我们要将这些字符和二进制的数据一一对应起来，比如说字符“a”对应“01100001”，反之，“01100001”对应 “a”。我们将字符对应二进制数据的过程称为\"<strong>字符编码</strong>\"，反之，二进制数据解析成字符的过程称为“<strong>字符解码</strong>”。</p>\n<h2> 有哪些常见的字符集？</h2>\n<p>常见的字符集有 ASCII、GB2312、GBK、UTF-8......。</p>\n<p>不同的字符集的主要区别在于：</p>\n<ul>\n<li>可以表示的字符范围</li>\n<li>编码方式</li>\n</ul>\n<h3> ASCII</h3>\n<p><strong>ASCII</strong> (<strong>A</strong>merican <strong>S</strong>tandard <strong>C</strong>ode for <strong>I</strong>nformation <strong>I</strong>nterchange，美国信息交换标准代码) 是一套主要用于现代美国英语的字符集（这也是 ASCII 字符集的局限性所在）。</p>\n<p><strong>为什么 ASCII 字符集没有考虑到中文等其他字符呢？</strong> 因为计算机是美国人发明的，当时，计算机的发展还处于比较雏形的时代，还未在其他国家大规模使用。因此，美国发布 ASCII 字符集的时候没有考虑兼容其他国家的语言。</p>\n<p>ASCII 字符集至今为止共定义了 128 个字符，其中有 33 个控制字符（比如回车、删除）无法显示。</p>\n<p>一个 ASCII 码长度是一个字节也就是 8 个 bit，比如“a”对应的 ASCII 码是“01100001”。不过，最高位是 0 仅仅作为校验位，其余 7 位使用 0 和 1 进行组合，所以，ASCII 字符集可以定义 128（2^7）个字符。</p>\n<p>由于，ASCII 码可以表示的字符实在是太少了。后来，人们对其进行了扩展得到了 <strong>ASCII 扩展字符集</strong> 。ASCII 扩展字符集使用 8 位（bits）表示一个字符，所以，ASCII 扩展字符集可以定义 256（2^8）个字符。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/c1c6375d08ca268690cef2b13591a5b4.png\" alt=\"ASCII字符编码\"></p>\n<h3> GB2312</h3>\n<p>我们上面说了，ASCII 字符集是一种现代美国英语适用的字符集。因此，很多国家都捣鼓了一个适合自己国家语言的字符集。</p>\n<p>GB2312 字符集是一种对汉字比较友好的字符集，共收录 6700 多个汉字，基本涵盖了绝大部分常用汉字。不过，GB2312 字符集不支持绝大部分的生僻字和繁体字。</p>\n<p>对于英语字符，GB2312 编码和 ASCII 码是相同的，1 字节编码即可。对于非英字符，需要 2 字节编码。</p>\n<h3> GBK</h3>\n<p>GBK 字符集可以看作是 GB2312 字符集的扩展，兼容 GB2312 字符集，共收录了 20000 多个汉字。</p>\n<p>GBK 中 K 是汉语拼音 Kuo Zhan（扩展）中的“Kuo”的首字母。</p>\n<h3> GB18030</h3>\n<p>GB18030 完全兼容 GB2312 和 GBK 字符集，纳入中国国内少数民族的文字，且收录了日韩汉字，是目前为止最全面的汉字字符集，共收录汉字 70000 多个。</p>\n<h3> BIG5</h3>\n<p>BIG5 主要针对的是繁体中文，收录了 13000 多个汉字。</p>\n<h3> Unicode &amp; UTF-8编码</h3>\n<p>为了更加适合本国语言，诞生了很多种字符集。</p>\n<p>我们上面也说了不同的字符集可以表示的字符范围以及编码规则存在差异。这就导致了一个非常严重的问题：<strong>使用错误的编码方式查看一个包含字符的文件就会产生乱码现象。</strong></p>\n<p>就比如说你使用 UTF-8 编码方式打开 GB2312 编码格式的文件就会出现乱码。示例：“牛”这个汉字 GB2312 编码后的十六进制数值为 “C5A3”，而 “C5A3” 用 UTF-8 解码之后得到的却是 “ţ”。</p>\n<p>你可以通过这个网站在线进行编码和解码：https://www.haomeili.net/HanZi/ZiFuBianMaZhuanHuan</p>\n<p><img src=\"https://img-blog.csdnimg.cn/836c49b117ee4408871b0020b74c991d.png\" alt=\"\"></p>\n<p>这样我们就搞懂了乱码的本质： <strong>编码和解码时用了不同或者不兼容的字符集</strong> 。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/a8808cbabeea49caa3af27d314fa3c02-1.jpg\" alt=\"\"></p>\n<p>为了解决这个问题，人们就想：“如果我们能够有一种字符集将世界上所有的字符都纳入其中就好了！”。</p>\n<p>然后，<strong>Unicode</strong> 带着这个使命诞生了。</p>\n<p>Unicode 字符集中包含了世界上几乎所有已知的字符。不过，Unicode 字符集并没有规定如何存储这些字符（也就是如何使用二进制数据表示这些字符）。</p>\n<p>然后，就有了 <strong>UTF-8</strong>（<strong>8</strong>-bit <strong>U</strong>nicode <strong>T</strong>ransformation <strong>F</strong>ormat）。类似的还有 UTF-16、 UTF-32。</p>\n<p>UTF-8 使用 1 到 4 个字节为每个字符编码， UTF-16 使用 2 或 4 个字节为每个字符编码，UTF-32 固定位 4 个字节为每个字符编码。</p>\n<p>UTF-8 可以根据不同的符号自动选择编码的长短，像英文字符只需要 1 个字节就够了，这一点 ASCII 字符集一样 。因此，对于英语字符，UTF-8 编码和 ASCII 码是相同的。</p>\n<p>UTF-32 的规则最简单，不过缺陷也比较明显，对于英文字母这类字符消耗的空间是 UTF-8 的 4 倍之多。</p>\n<p><strong>UTF-8</strong> 是目前使用最广的一种字符编码，。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/1280px-Utf8webgrowth.svg.png\" alt=\"\"></p>\n<h2> MySQL 字符集</h2>\n<p>MySQL 支持很多种字符编码的方式，比如 UTF-8、GB2312、GBK、BIG5。</p>\n<p>你可以通过 <code>SHOW CHARSET</code> 命令来查看。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/image-20211008164229671.png\" alt=\"\"></p>\n<p>通常情况下，我们建议使用 UTF-8 作为默认的字符编码方式。</p>\n<p>不过，这里有一个小坑。</p>\n<p>MySQL 字符编码集中有两套 UTF-8 编码实现：</p>\n<ul>\n<li><strong><code>utf8</code></strong> ： <code>utf8</code>编码只支持<code>1-3</code>个字节 。 在 <code>utf8</code> 编码中，中文是占 3 个字节，其他数字、英文、符号占一个字节。但 emoji 符号占 4 个字节，一些较复杂的文字、繁体字也是 4 个字节。</li>\n<li><strong><code>utf8mb4</code></strong> ： UTF-8 的完整实现，正版！最多支持使用 4 个字节表示字符，因此，可以用来存储 emoji 符号。</li>\n</ul>\n<p><strong>为什么有两套 UTF-8 编码实现呢？</strong> 原因如下：</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/image-20211008164542347.png\" alt=\"\"></p>\n<p>因此，如果你需要存储<code>emoji</code>类型的数据或者一些比较复杂的文字、繁体字到 MySQL 数据库的话，数据库的编码一定要指定为<code>utf8mb4</code> 而不是<code>utf8</code> ，要不然存储的时候就会报错了。</p>\n<p>演示一下吧！（环境：MySQL 5.7+）</p>\n<p>建表语句如下，我们指定数据库 CHARSET 为 <code>utf8</code> 。</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>当我们执行下面的 insert 语句插入数据到数据库时，果然报错！</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>报错信息如下：</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 参考</h2>\n<ul>\n<li>字符集和字符编码（Charset &amp; Encoding）： https://www.cnblogs.com/skynet/archive/2011/05/03/2035105.html</li>\n<li>十分钟搞清字符集和字符编码：http://cenalulu.github.io/linux/character-encoding/</li>\n<li>Unicode-维基百科：https://zh.wikipedia.org/wiki/Unicode</li>\n<li>GB2312-维基百科：https://zh.wikipedia.org/wiki/GB_2312</li>\n<li>UTF-8-维基百科：https://zh.wikipedia.org/wiki/UTF-8</li>\n<li>GB18030-维基百科: https://zh.wikipedia.org/wiki/GB_18030</li>\n</ul>\n",
      "image": "https://img-blog.csdnimg.cn/img_convert/c1c6375d08ca268690cef2b13591a5b4.png",
      "date_published": "2022-03-03T01:14:56.000Z",
      "date_modified": "2022-11-05T10:24:11.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "数据库"
      ]
    },
    {
      "title": "降级&熔断详解(付费)",
      "url": "https://javaguide.cn/high-availability/fallback_circuit-breaker.html",
      "id": "https://javaguide.cn/high-availability/fallback_circuit-breaker.html",
      "summary": "降级&amp;熔断 相关的面试题为我的知识星球（点击链接即可查看详细介绍以及加入方法）专属内容，已经整理到了《Java 面试指北》中。",
      "content_html": "<p><strong>降级&amp;熔断</strong> 相关的面试题为我的<a href=\"https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html\" target=\"_blank\" rel=\"noopener noreferrer\">知识星球</a>（点击链接即可查看详细介绍以及加入方法）专属内容，已经整理到了<a href=\"https://javaguide.cn/zhuanlan/java-mian-shi-zhi-bei.html\" target=\"_blank\" rel=\"noopener noreferrer\">《Java 面试指北》</a>中。</p>\n<p><a href=\"https://javaguide.cn/zhuanlan/java-mian-shi-zhi-bei.html\" target=\"_blank\" rel=\"noopener noreferrer\">《Java 面试指北》</a>（点击链接即可查看详细介绍）的部分内容展示如下，你可以将其看作是 <a href=\"https://javaguide.cn/#/\" target=\"_blank\" rel=\"noopener noreferrer\">JavaGuide</a> 的补充完善，两者可以配合使用。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220304102536445.png\" alt=\"\"></p>\n<p>最近几年，市面上有越来越多的“技术大佬”开始办培训班/训练营，动辄成千上万的学费，却并没有什么干货，单纯的就是割韭菜。</p>\n<p>为了帮助更多同学准备 Java 面试以及学习 Java ，我创建了一个纯粹的知识星球。虽然收费只有培训班/训练营的百分之一，但是知识星球里的内容质量更高，提供的服务也更全面。</p>\n<p>欢迎准备 Java 面试以及学习 Java 的同学加入我的<a href=\"https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html\" target=\"_blank\" rel=\"noopener noreferrer\">知识星球</a>，干货非常多，学习氛围也很不错！收费虽然是白菜价，但星球里的内容或许比你参加上万的培训班质量还要高。</p>\n<div align=\"center\">\n  <a href=\"https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html\">\n    <img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220311203414600.png\" style=\"margin: 0 auto; \">\n  </a>\n</div>\n<p>下面是星球提供的部分服务（点击下方图片即可获取知识星球的详细介绍）：</p>\n<div align=\"center\">\n  <a href=\"https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html\">\n    <img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/xingqiufuwu.png\" style=\"margin: 0 auto; \">\n  </a>\n</div>\n<p><strong>我有自己的原则，不割韭菜，用心做内容，真心希望帮助到你！</strong></p>\n<p>如果你感兴趣的话，不妨花 3 分钟左右看看星球的详细介绍： <a href=\"https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html\" target=\"_blank\" rel=\"noopener noreferrer\">JavaGuide 知识星球详细介绍</a>。</p>\n<p>这里再送一个 30 元的新人优惠券（续费半价）。</p>\n<div align=\"center\">\n  <a href=\"https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html\">\n    <img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/xingqiuyouhuijuanheyi.png\" style=\"margin: 0 auto; \">\n  </a>\n</div>\n<p>进入星球之后，记得添加微信，我会发你详细的星球使用指南。</p>\n<div align=\"center\">\n  <a href=\"https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html\">\n    <img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/IMG_3007.jpg\" style=\"margin: 0 auto; \">\n  </a>\n</div>\n",
      "image": "https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220304102536445.png",
      "date_published": "2022-03-03T01:14:56.000Z",
      "date_modified": "2023-01-30T02:46:56.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "高可用"
      ]
    },
    {
      "title": "高可用系统设计指南",
      "url": "https://javaguide.cn/high-availability/high-availability-system-design.html",
      "id": "https://javaguide.cn/high-availability/high-availability-system-design.html",
      "summary": "什么是高可用？可用性的判断标准是啥？ 高可用描述的是一个系统在大部分时间都是可用的，可以为我们提供服务的。高可用代表系统即使在发生硬件故障或者系统升级的时候，服务仍然是可用的。 一般情况下，我们使用多少个 9 来评判一个系统的可用性，比如 99.9999% 就是代表该系统在所有的运行时间中只有 0.0001% 的时间是不可用的，这样的系统就是非常非常高可用的了！当然，也会有系统如果可用性不太好的话，可能连 9 都上不了。 除此之外，系统的可用性还可以用某功能的失败次数与总的请求次数之比来衡量，比如对网站请求 1000 次，其中有 10 次请求失败，那么可用性就是 99%。",
      "content_html": "<h2> 什么是高可用？可用性的判断标准是啥？</h2>\n<p>高可用描述的是一个系统在大部分时间都是可用的，可以为我们提供服务的。高可用代表系统即使在发生硬件故障或者系统升级的时候，服务仍然是可用的。</p>\n<p>一般情况下，我们使用多少个 9 来评判一个系统的可用性，比如 99.9999% 就是代表该系统在所有的运行时间中只有 0.0001% 的时间是不可用的，这样的系统就是非常非常高可用的了！当然，也会有系统如果可用性不太好的话，可能连 9 都上不了。</p>\n<p>除此之外，系统的可用性还可以用某功能的失败次数与总的请求次数之比来衡量，比如对网站请求 1000 次，其中有 10 次请求失败，那么可用性就是 99%。</p>\n<h2> 哪些情况会导致系统不可用？</h2>\n<ol>\n<li>黑客攻击；</li>\n<li>硬件故障，比如服务器坏掉。</li>\n<li>并发量/用户请求量激增导致整个服务宕掉或者部分服务不可用。</li>\n<li>代码中的坏味道导致内存泄漏或者其他问题导致程序挂掉。</li>\n<li>网站架构某个重要的角色比如 Nginx 或者数据库突然不可用。</li>\n<li>自然灾害或者人为破坏。</li>\n<li>......</li>\n</ol>\n<h2> 有哪些提高系统可用性的方法？</h2>\n<h3> 注重代码质量，测试严格把关</h3>\n<p>我觉得这个是最最最重要的，代码质量有问题比如比较常见的内存泄漏、循环依赖都是对系统可用性极大的损害。大家都喜欢谈限流、降级、熔断，但是我觉得从代码质量这个源头把关是首先要做好的一件很重要的事情。如何提高代码质量？比较实际可用的就是 CodeReview，不要在乎每天多花的那 1 个小时左右的时间，作用可大着呢！</p>\n<p>另外，安利几个对提高代码质量有实际效果的神器：</p>\n<ul>\n<li><a href=\"https://www.sonarqube.org/\" target=\"_blank\" rel=\"noopener noreferrer\">Sonarqube</a>；</li>\n<li>Alibaba 开源的 Java 诊断工具 <a href=\"https://arthas.aliyun.com/doc/\" target=\"_blank\" rel=\"noopener noreferrer\">Arthas</a>；</li>\n<li><a href=\"https://github.com/alibaba/p3c\" target=\"_blank\" rel=\"noopener noreferrer\">阿里巴巴 Java 代码规范</a>（Alibaba Java Code Guidelines）；</li>\n<li>IDEA 自带的代码分析等工具。</li>\n</ul>\n<h3> 使用集群，减少单点故障</h3>\n<p>先拿常用的 Redis 举个例子！我们如何保证我们的 Redis 缓存高可用呢？答案就是使用集群，避免单点故障。当我们使用一个 Redis 实例作为缓存的时候，这个 Redis 实例挂了之后，整个缓存服务可能就挂了。使用了集群之后，即使一台 Redis 实例挂了，不到一秒就会有另外一台 Redis 实例顶上。</p>\n<h3> 限流</h3>\n<p>流量控制（flow control），其原理是监控应用流量的 QPS 或并发线程数等指标，当达到指定的阈值时对流量进行控制，以避免被瞬时的流量高峰冲垮，从而保障应用的高可用性。——来自 <a href=\"https://github.com/alibaba/Sentinel\" title=\"Sentinel\" target=\"_blank\" rel=\"noopener noreferrer\">alibaba-Sentinel</a> 的 wiki。</p>\n<h3> 超时和重试机制设置</h3>\n<p>一旦用户请求超过某个时间的得不到响应，就抛出异常。这个是非常重要的，很多线上系统故障都是因为没有进行超时设置或者超时设置的方式不对导致的。我们在读取第三方服务的时候，尤其适合设置超时和重试机制。一般我们使用一些 RPC 框架的时候，这些框架都自带的超时重试的配置。如果不进行超时设置可能会导致请求响应速度慢，甚至导致请求堆积进而让系统无法再处理请求。重试的次数一般设为 3 次，再多次的重试没有好处，反而会加重服务器压力（部分场景使用失败重试机制会不太适合）。</p>\n<h3> 熔断机制</h3>\n<p>超时和重试机制设置之外，熔断机制也是很重要的。 熔断机制说的是系统自动收集所依赖服务的资源使用情况和性能指标，当所依赖的服务恶化或者调用失败次数达到某个阈值的时候就迅速失败，让当前系统立即切换依赖其他备用服务。 比较常用的流量控制和熔断降级框架是 Netflix 的 Hystrix 和 alibaba 的 Sentinel。</p>\n<h3> 异步调用</h3>\n<p>异步调用的话我们不需要关心最后的结果，这样我们就可以用户请求完成之后就立即返回结果，具体处理我们可以后续再做，秒杀场景用这个还是蛮多的。但是，使用异步之后我们可能需要 <strong>适当修改业务流程进行配合</strong>，比如<strong>用户在提交订单之后，不能立即返回用户订单提交成功，需要在消息队列的订单消费者进程真正处理完该订单之后，甚至出库后，再通过电子邮件或短信通知用户订单成功</strong>。除了可以在程序中实现异步之外，我们常常还使用消息队列，消息队列可以通过异步处理提高系统性能（削峰、减少响应所需时间）并且可以降低系统耦合性。</p>\n<h3> 使用缓存</h3>\n<p>如果我们的系统属于并发量比较高的话，如果我们单纯使用数据库的话，当大量请求直接落到数据库可能数据库就会直接挂掉。使用缓存缓存热点数据，因为缓存存储在内存中，所以速度相当地快！</p>\n<h3> 其他</h3>\n<ul>\n<li><strong>核心应用和服务优先使用更好的硬件</strong></li>\n<li><strong>监控系统资源使用情况增加报警设置。</strong></li>\n<li><strong>注意备份，必要时候回滚。</strong></li>\n<li><strong>灰度发布：</strong> 将服务器集群分成若干部分，每天只发布一部分机器，观察运行稳定没有故障，第二天继续发布一部分机器，持续几天才把整个集群全部发布完毕，期间如果发现问题，只需要回滚已发布的一部分服务器即可</li>\n<li><strong>定期检查/更换硬件：</strong> 如果不是购买的云服务的话，定期还是需要对硬件进行一波检查的，对于一些需要更换或者升级的硬件，要及时更换或者升级。</li>\n<li>.....</li>\n</ul>\n",
      "date_published": "2022-03-03T01:14:56.000Z",
      "date_modified": "2022-08-25T08:08:46.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "高可用"
      ]
    },
    {
      "title": "性能测试入门",
      "url": "https://javaguide.cn/high-availability/performance-test.html",
      "id": "https://javaguide.cn/high-availability/performance-test.html",
      "summary": "性能测试入门 性能测试一般情况下都是由测试这个职位去做的，那还需要我们开发学这个干嘛呢？了解性能测试的指标、分类以及工具等知识有助于我们更好地去写出性能更好的程序，另外作为开发这个角色，如果你会性能测试的话，相信也会为你的履历加分不少。 这篇文章是我会结合自己的实际经历以及在测试这里取的经所得，除此之外，我还借鉴了一些优秀书籍，希望对你有帮助。 本文思维导图：",
      "content_html": "<h1> 性能测试入门</h1>\n<p>性能测试一般情况下都是由测试这个职位去做的，那还需要我们开发学这个干嘛呢？了解性能测试的指标、分类以及工具等知识有助于我们更好地去写出性能更好的程序，另外作为开发这个角色，如果你会性能测试的话，相信也会为你的履历加分不少。</p>\n<p>这篇文章是我会结合自己的实际经历以及在测试这里取的经所得，除此之外，我还借鉴了一些优秀书籍，希望对你有帮助。</p>\n<p>本文思维导图：</p>\n<img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/网站性能测试.png\" style=\"zoom:50%;\">\n<h2> 一 不同角色看网站性能</h2>\n<h3> 1.1 用户</h3>\n<p>当用户打开一个网站的时候，最关注的是什么？当然是网站响应速度的快慢。比如我们点击了淘宝的主页，淘宝需要多久将首页的内容呈现在我的面前，我点击了提交订单按钮需要多久返回结果等等。</p>\n<p>所以，用户在体验我们系统的时候往往根据你的响应速度的快慢来评判你的网站的性能。</p>\n<h3> 1.2 开发人员</h3>\n<p>用户与开发人员都关注速度，这个速度实际上就是我们的系统<strong>处理用户请求的速度</strong>。</p>\n<p>开发人员一般情况下很难直观的去评判自己网站的性能，我们往往会根据网站当前的架构以及基础设施情况给一个大概的值,比如：</p>\n<ol>\n<li>项目架构是分布式的吗？</li>\n<li>用到了缓存和消息队列没有？</li>\n<li>高并发的业务有没有特殊处理？</li>\n<li>数据库设计是否合理？</li>\n<li>系统用到的算法是否还需要优化？</li>\n<li>系统是否存在内存泄露的问题？</li>\n<li>项目使用的 Redis 缓存多大？服务器性能如何？用的是机械硬盘还是固态硬盘？</li>\n<li>......</li>\n</ol>\n<h3> 1.3 测试人员</h3>\n<p>测试人员一般会根据性能测试工具来测试，然后一般会做出一个表格。这个表格可能会涵盖下面这些重要的内容：</p>\n<ol>\n<li>响应时间；</li>\n<li>请求成功率；</li>\n<li>吞吐量；</li>\n<li>......</li>\n</ol>\n<h3> 1.4 运维人员</h3>\n<p>运维人员会倾向于根据基础设施和资源的利用率来判断网站的性能，比如我们的服务器资源使用是否合理、数据库资源是否存在滥用的情况、当然，这是传统的运维人员，现在 Devpos 火起来后，单纯干运维的很少了。我们这里暂且还保留有这个角色。</p>\n<h2> 二 性能测试需要注意的点</h2>\n<p>几乎没有文章在讲性能测试的时候提到这个问题，大家都会讲如何去性能测试，有哪些性能测试指标这些东西。</p>\n<h3> 2.1 了解系统的业务场景</h3>\n<p><strong>性能测试之前更需要你了解当前的系统的业务场景。</strong> 对系统业务了解的不够深刻，我们很容易犯测试方向偏执的错误，从而导致我们忽略了对系统某些更需要性能测试的地方进行测试。比如我们的系统可以为用户提供发送邮件的功能，用户配置成功邮箱后只需输入相应的邮箱之后就能发送，系统每天大概能处理上万次发邮件的请求。很多人看到这个可能就直接开始使用相关工具测试邮箱发送接口，但是，发送邮件这个场景可能不是当前系统的性能瓶颈，这么多人用我们的系统发邮件， 还可能有很多人一起发邮件，单单这个场景就这么人用，那用户管理可能才是性能瓶颈吧！</p>\n<h3> 2.2 历史数据非常有用</h3>\n<p>当前系统所留下的历史数据非常重要，一般情况下，我们可以通过相应的些历史数据初步判定这个系统哪些接口调用的比较多、哪些 service 承受的压力最大，这样的话，我们就可以针对这些地方进行更细致的性能测试与分析。</p>\n<p>另外，这些地方也就像这个系统的一个短板一样，优化好了这些地方会为我们的系统带来质的提升。</p>\n<h3> 三 性能测试的指标</h3>\n<h3> 3.1 响应时间</h3>\n<p><strong>响应时间就是用户发出请求到用户收到系统处理结果所需要的时间。</strong> 重要吗？实在太重要！</p>\n<p>比较出名的 2-5-8 原则是这样描述的：通常来说，2到5秒，页面体验会比较好，5到8秒还可以接受，8秒以上基本就很难接受了。另外，据统计当网站慢一秒就会流失十分之一的客户。</p>\n<p>但是，在某些场景下我们也并不需要太看重 2-5-8 原则 ，比如我觉得系统导出导入大数据量这种就不需要，系统生成系统报告这种也不需要。</p>\n<h3> 3.2 并发数</h3>\n<p><strong>并发数是系统能同时处理请求的数目即同时提交请求的用户数目。</strong></p>\n<p>不得不说，高并发是现在后端架构中非常非常火热的一个词了，这个与当前的互联网环境以及中国整体的互联网用户量都有很大关系。一般情况下，你的系统并发量越大，说明你的产品做的就越大。但是，并不是每个系统都需要达到像淘宝、12306 这种亿级并发量的。</p>\n<h3> 3.3 吞吐量</h3>\n<p>吞吐量指的是系统单位时间内系统处理的请求数量。衡量吞吐量有几个重要的参数：QPS（TPS）、并发数、响应时间。</p>\n<ol>\n<li>QPS（Query Per Second）：服务器每秒可以执行的查询次数；</li>\n<li>TPS（Transaction Per Second）：服务器每秒处理的事务数（这里的一个事务可以理解为客户发出请求到收到服务器的过程）；</li>\n<li>并发数；系统能同时处理请求的数目即同时提交请求的用户数目。</li>\n<li>响应时间： 一般取多次请求的平均响应时间</li>\n</ol>\n<p>理清他们的概念，就很容易搞清楚他们之间的关系了。</p>\n<ul>\n<li><strong>QPS（TPS）</strong> = 并发数/平均响应时间</li>\n<li><strong>并发数</strong> = QPS*平均响应时间</li>\n</ul>\n<p>书中是这样描述 QPS 和 TPS 的区别的。</p>\n<blockquote>\n<p>QPS vs TPS：QPS 基本类似于 TPS，但是不同的是，对于一个页面的一次访问，形成一个TPS；但一次页面请求，可能产生多次对服务器的请求，服务器对这些请求，就可计入“QPS”之中。如，访问一个页面会请求服务器2次，一次访问，产生一个“T”，产生2个“Q”。</p>\n</blockquote>\n<h3> 3.4 性能计数器</h3>\n<p><strong>性能计数器是描述服务器或者操作系统的一些数据指标如内存使用、CPU使用、磁盘与网络I/O等情况。</strong></p>\n<h3> 四 几种常见的性能测试</h3>\n<h3> 性能测试</h3>\n<p>性能测试方法是通过测试工具模拟用户请求系统，目的主要是为了测试系统的性能是否满足要求。通俗地说，这种方法就是要在特定的运行条件下验证系统的能力状态。</p>\n<p>性能测试是你在对系统性能已经有了解的前提之后进行的，并且有明确的性能指标。</p>\n<h3> 负载测试</h3>\n<p>对被测试的系统继续加大请求压力，直到服务器的某个资源已经达到饱和了，比如系统的缓存已经不够用了或者系统的响应时间已经不满足要求了。</p>\n<p>负载测试说白点就是测试系统的上限。</p>\n<h3> 压力测试</h3>\n<p>不去管系统资源的使用情况，对系统继续加大请求压力，直到服务器崩溃无法再继续提供服务。</p>\n<h3> 稳定性测试</h3>\n<p>模拟真实场景，给系统一定压力，看看业务是否能稳定运行。</p>\n<h2> 五 常用性能测试工具</h2>\n<p>这里就不多扩展了，有时间的话会单独拎一个熟悉的说一下。</p>\n<h3> 5.1 后端常用</h3>\n<p>没记错的话，除了 LoadRunner 其他几款性能测试工具都是开源免费的。</p>\n<ol>\n<li>Jmeter ：Apache JMeter 是 JAVA 开发的性能测试工具。</li>\n<li>LoadRunner：一款商业的性能测试工具。</li>\n<li>Galtling ：一款基于Scala 开发的高性能服务器性能测试工具。</li>\n<li>ab ：全称为 Apache Bench 。Apache 旗下的一款测试工具，非常实用。</li>\n</ol>\n<h3> 5.2 前端常用</h3>\n<ol>\n<li>Fiddler：抓包工具，它可以修改请求的数据，甚至可以修改服务器返回的数据，功能非常强大，是Web 调试的利器。</li>\n<li>HttpWatch: 可用于录制HTTP请求信息的工具。</li>\n</ol>\n<h2> 六 常见的性能优化策略</h2>\n<p>性能优化之前我们需要对请求经历的各个环节进行分析，排查出可能出现性能瓶颈的地方，定位问题。</p>\n<p>下面是一些性能优化时，我经常拿来自问的一些问题：</p>\n<ol>\n<li>系统是否需要缓存？</li>\n<li>系统架构本身是不是就有问题？</li>\n<li>系统是否存在死锁的地方？</li>\n<li>系统是否存在内存泄漏？（Java 的自动回收内存虽然很方便，但是，有时候代码写的不好真的会造成内存泄漏）</li>\n<li>数据库索引使用是否合理？</li>\n<li>......</li>\n</ol>\n",
      "date_published": "2022-03-03T01:14:56.000Z",
      "date_modified": "2022-08-17T00:36:59.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "高可用"
      ]
    },
    {
      "title": "超时&重试详解",
      "url": "https://javaguide.cn/high-availability/timeout-and-retry.html",
      "id": "https://javaguide.cn/high-availability/timeout-and-retry.html",
      "summary": "由于网络问题、系统或者服务内部的 Bug、服务器宕机、操作系统崩溃等问题的不确定性，我们的系统或者服务永远不可能保证时刻都是可用的状态。 为了最大限度的减小系统或者服务出现故障之后带来的影响，我们需要用到的 超时（Timeout） 和 重试（Retry） 机制。 想要把超时和重试机制讲清楚其实很简单，因为它俩本身就不是什么高深的概念。 虽然超时和重试机制的思想很简单，但是它俩是真的非常实用。你平时接触到的绝大部分涉及到远程调用的系统或者服务都会应用超时和重试机制。尤其是对于微服务系统来说，正确设置超时和重试非常重要。单体服务通常只涉及数据库、缓存、第三方 API、中间件等的网络调用，而微服务系统内部各个服务之间还存在着网络调用。",
      "content_html": "<p>由于网络问题、系统或者服务内部的 Bug、服务器宕机、操作系统崩溃等问题的不确定性，我们的系统或者服务永远不可能保证时刻都是可用的状态。</p>\n<p>为了最大限度的减小系统或者服务出现故障之后带来的影响，我们需要用到的 <strong>超时（Timeout）</strong> 和 <strong>重试（Retry）</strong> 机制。</p>\n<p>想要把超时和重试机制讲清楚其实很简单，因为它俩本身就不是什么高深的概念。</p>\n<p>虽然超时和重试机制的思想很简单，但是它俩是真的非常实用。你平时接触到的绝大部分涉及到远程调用的系统或者服务都会应用超时和重试机制。尤其是对于微服务系统来说，正确设置超时和重试非常重要。单体服务通常只涉及数据库、缓存、第三方 API、中间件等的网络调用，而微服务系统内部各个服务之间还存在着网络调用。</p>\n<h2> 超时机制</h2>\n<h3> 什么是超时机制？</h3>\n<p>超时机制说的是当一个请求超过指定的时间（比如 1s）还没有被处理的话，这个请求就会直接被取消并抛出指定的异常或者错误（比如 <code>504 Gateway Timeout</code>）。</p>\n<p>我们平时接触到的超时可以简单分为下面 2 种：</p>\n<ul>\n<li><strong>连接超时（ConnectTimeout）</strong> ：客户端与服务端建立连接的最长等待时间。</li>\n<li><strong>读取超时（ReadTimeout）</strong> ：客户端和服务端已经建立连接，客户端等待服务端处理完请求的最长时间。实际项目中，我们关注比较多的还是读取超时。</li>\n</ul>\n<p>一些连接池客户端框架中可能还会有获取连接超时和空闲连接清理超时。</p>\n<p>如果没有设置超时的话，就可能会导致服务端连接数爆炸和大量请求堆积的问题。</p>\n<p>这些堆积的连接和请求会消耗系统资源，影响新收到的请求的处理。严重的情况下，甚至会拖垮整个系统或者服务。</p>\n<p>我之前在实际项目就遇到过类似的问题，整个网站无法正常处理请求，服务器负载直接快被拉满。后面发现原因是项目超时设置错误加上客户端请求处理异常，导致服务端连接数直接接近 40w+，这么多堆积的连接直接把系统干趴了。</p>\n<h3> 超时时间应该如何设置？</h3>\n<p>超时到底设置多长时间是一个难题！超时值设置太高或者太低都有风险。如果设置太高的话，会降低超时机制的有效性，比如你设置超时为 10s 的话，那设置超时就没啥意义了，系统依然可能会出现大量慢请求堆积的问题。如果设置太低的话，就可能会导致在系统或者服务在某些处理请求速度变慢的情况下（比如请求突然增多），大量请求重试（超时通常会结合重试）继续加重系统或者服务的压力，进而导致整个系统或者服务被拖垮的问题。</p>\n<p>通常情况下，我们建议读取超时设置为 <strong>1500ms</strong> ,这是一个比较普适的值。如果你的系统或者服务对于延迟比较敏感的话，那读取超时值可以适当在 <strong>1500ms</strong> 的基础上进行缩短。反之，读取超时值也可以在 <strong>1500ms</strong> 的基础上进行加长，不过，尽量还是不要超过 <strong>1500ms</strong> 。连接超时可以适当设置长一些，建议在 <strong>1000ms ~ 5000ms</strong> 之内。</p>\n<p>没有银弹！超时值具体该设置多大，还是要根据实际项目的需求和情况慢慢调整优化得到。</p>\n<p>更上一层，参考<a href=\"https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html\" target=\"_blank\" rel=\"noopener noreferrer\">美团的Java线程池参数动态配置</a>思想，我们也可以将超时弄成可配置化的参数而不是固定的，比较简单的一种办法就是将超时的值放在配置中心中。这样的话，我们就可以根据系统或者服务的状态动态调整超时值了。</p>\n<h2> 重试机制</h2>\n<h3> 什么是重试机制？</h3>\n<p>重试机制一般配合超时机制一起使用，指的是多次发送相同的请求来避免瞬态故障和偶然性故障。</p>\n<p>瞬态故障可以简单理解为某一瞬间系统偶然出现的故障，并不会持久。偶然性故障可以理解为哪些在某些情况下偶尔出现的故障，频率通常较低。</p>\n<p>重试的核心思想是通过消耗服务器的资源来尽可能获得请求更大概率被成功处理。由于瞬态故障和偶然性故障是很少发生的，因此，重试对于服务器的资源消耗几乎是可以被忽略的。</p>\n<h3> 重试的次数如何设置？</h3>\n<p>重试的次数不宜过多，否则依然会对系统负载造成比较大的压力。</p>\n<p>重试的次数通常建议设为 3 次。并且，我们通常还会设置重试的间隔，比如说我们要重试 3 次的话，第 1 次请求失败后，等待 1 秒再进行重试，第 2 次请求失败后，等待 2 秒再进行重试，第 3 次请求失败后，等待 3 秒再进行重试。</p>\n<h3> 重试幂等</h3>\n<p>超时和重试机制在实际项目中使用的话，需要注意保证同一个请求没有被多次执行。</p>\n<p>什么情况下会出现一个请求被多次执行呢？客户端等待服务端完成请求完成超时但此时服务端已经执行了请求，只是由于短暂的网络波动导致响应在发送给客户端的过程中延迟了。</p>\n<p>举个例子：用户支付购买某个课程，结果用户支付的请求由于重试的问题导致用户购买同一门课程支付了两次。对于这种情况，我们在执行用户购买课程的请求的时候需要判断一下用户是否已经购买过。这样的话，就不会因为重试的问题导致重复购买了。</p>\n<h2> 参考</h2>\n<ul>\n<li>微服务之间调用超时的设置治理：https://www.infoq.cn/article/eyrslar53l6hjm5yjgyx</li>\n<li>超时、重试和抖动回退：https://aws.amazon.com/cn/builders-library/timeouts-retries-and-backoff-with-jitter/</li>\n</ul>\n",
      "date_published": "2022-03-03T01:14:56.000Z",
      "date_modified": "2022-11-03T15:33:32.000Z",
      "authors": [
        {
          "name": "Guide",
          "url": "https://javaguide.cn/article/"
        }
      ],
      "tags": [
        "高可用"
      ]
    }
  ]
}